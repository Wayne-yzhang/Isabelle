theory Aexp
imports Main
begin








type_synonym 'v symvar = "'v \<times> nat"


lemma
  "\<not> finite (UNIV::'v symvar set)"
by (simp add : finite_prod)







type_synonym ('v,'d) state = "'v \<Rightarrow> 'd"




type_synonym ('v,'d) aexp =  "('v,'d) state \<Rightarrow> 'd"







definition vars :: 
  "('v,'d) aexp \<Rightarrow> 'v set" 
where
  "vars e = {v. \<exists> \<sigma> val. e (\<sigma>(v := val)) \<noteq> e \<sigma>}"


lemma vars_example_1 :
  fixes e::"('v,integer) aexp"
  assumes "e = (\<lambda> \<sigma>. \<sigma> x - \<sigma> y)"
  assumes "x \<noteq> y"
  shows   "vars e = {x,y}"
unfolding set_eq_iff
proof (intro allI iffI)
  fix v assume "v \<in> vars e"

  then obtain \<sigma> val 
  where "e (\<sigma>(v := val)) \<noteq> e \<sigma>"
  unfolding vars_def by blast

  thus "v \<in> {x, y}" 
  using assms by (case_tac "v = x", simp, (case_tac "v = y", simp+))
next
  fix v assume "v \<in> {x,y}"

  thus "v \<in> vars e"
  using assms
  by (auto simp add : vars_def) 
     (rule_tac ?x="\<lambda> v. 0" in exI, rule_tac ?x="1" in exI, simp)+
qed


lemma vars_example_2 :
  fixes e::"('v,integer) aexp"
  assumes "e = (\<lambda> \<sigma>. \<sigma> x - \<sigma> y)"
  assumes "x = y"
  shows   "vars e = {}"
using assms by (auto simp add : vars_def)






abbreviation fresh ::
  "'v \<Rightarrow> ('v,'d) aexp \<Rightarrow> bool" 
where
  "fresh v e \<equiv> v \<notin> vars e"
 
end
