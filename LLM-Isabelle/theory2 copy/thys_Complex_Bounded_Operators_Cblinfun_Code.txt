
theory Cblinfun_Code
  imports
    Cblinfun_Matrix Containers.Set_Impl Jordan_Normal_Form.Matrix_Kernel
begin

no_notation "Lattice.meet" (infixl "\<sqinter>\<index>" 70)
no_notation "Lattice.join" (infixl "\<squnion>\<index>" 65)
hide_const (open) Coset.kernel
hide_const (open) Matrix_Kernel.kernel
hide_const (open) Order.bottom Order.top

unbundle lattice_syntax
unbundle jnf_notation
unbundle cblinfun_notation






  "(bot::'a::onb_enum ccsubspace) = SPAN []"
  unfolding SPAN_def by (auto simp: Set.filter_def)


lemma sup_spans[code]:
  "SPAN A \<squnion> SPAN B = SPAN (A @ B)"
  unfolding SPAN_def 
  by (auto simp: ccspan_union image_Un filter_Un Let_def)


definition [code del,code_abbrev]: "Span_code (S::'a::enum ell2 set) = (ccspan S)"

lemma span_Set_Monad[code]: "Span_code (Set_Monad l) = (SPAN (map vec_of_ell2 l))"
     constructor that represents sets as lists in the computation.)\<close>
text \<open>This instantiation defines a code equation for equality tests for \<^type>\<open>ccsubspace\<close>.
      The actual code for equality tests is given below (lemma \<open>equal_ccsubspace_code\<close>).\<close>
  \<comment> \<open>Code equation for deciding inclusion of one space in another.
     computation by checking for each generator of A whether it is in the
     span of B (by orthogonal projection onto an orthonormal basis of B
     which is computed using Gram-Schmidt).\<close>
  \<comment> \<open>Code equation for equality test. By checking mutual inclusion
      (for which we have code by the preceding code equation).\<close>
  \<comment> \<open>Code equation for applying an operator \<^term>\<open>A\<close> to a subspace. 
      Simply by multiplying each generator with \<^term>\<open>A\<close>\<close>
  \<comment> \<open>A new constant for the special case of applying an operator to the subspace \<^term>\<open>top\<close>
