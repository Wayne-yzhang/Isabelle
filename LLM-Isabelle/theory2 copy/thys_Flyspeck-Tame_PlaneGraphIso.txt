theory PlaneGraphIso
imports Main Quasi_Order
begin

lemma image_image_id_if[simp]: "(\<And>x. f(f x) = x) \<Longrightarrow> f ` f ` M = M"
by (auto simp: image_iff)


declare not_None_eq [iff] not_Some_eq [iff]


denote congruence and isomorphism on arbitrary types. On lists
all faces.\<close>
text\<open>A plane graph is a set or list (for executability) of faces
nodes:\<close>
subsection\<open>Equivalence of faces\<close>
text\<open>Two faces are equivalent modulo rotation:\<close>
subsection\<open>Homomorphism and isomorphism\<close>
text\<open>Homomorphisms preserve the set of nodes.\<close>
    with \<open>x \<in> set F\<close> show "x \<in> \<phi> ` (\<Union>F\<in>Fs\<^sub>1. set F)"
text\<open>Therefore isomorphisms preserve cardinality of node set.\<close>
text\<open>Isomorphisms preserve the number of faces.\<close>
text\<open>A kind of recursion rule, a first step towards executability:\<close>
subsection\<open>Isomorphism tests\<close>
text\<open>Now we bound the number of rotations needed. We have to exclude
the empty face @{term"[]"} to be able to restrict the search to
@{prop"n < length xs"} (which would otherwise be vacuous).\<close>
text\<open>Thus correctness carries over to \<open>pr_iso_test1\<close>:\<close>
subsubsection\<open>Implementing maps by lists\<close>
text\<open>The representation are lists of pairs with no repetition in the
first or second component.\<close>
text\<open>A simple implementation\<close>
text\<open>Implementing merge as a recursive function:\<close>
subsubsection\<open>`Improper' Isomorphisms\<close>
subsection\<open>Elementhood and containment modulo\<close>
