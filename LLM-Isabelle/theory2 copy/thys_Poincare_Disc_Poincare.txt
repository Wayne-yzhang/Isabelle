theory Poincare
imports Poincare_Lines Poincare_Between Poincare_Distance Poincare_Circles
begin


typedef p_point = "{z. z \<in> unit_disc}"
  using zero_in_unit_disc
  by (rule_tac x="0\<^sub>h" in exI, simp)

setup_lifting type_definition_p_point

lift_definition p_zero :: "p_point" is "0\<^sub>h"
  by (rule zero_in_unit_disc)

lift_definition p_of_complex :: "complex \<Rightarrow> p_point" is "\<lambda> z. if cmod z < 1 then of_complex z else 0\<^sub>h"
  by auto


typedef p_line = "{H. is_poincare_line H}"
  by (rule_tac x="x_axis" in exI, simp)

setup_lifting type_definition_p_line

lift_definition p_incident :: "p_line \<Rightarrow> p_point \<Rightarrow> bool" is on_circline
  done

definition p_points :: "p_line \<Rightarrow> p_point set" where
  "p_points l = {p. p_incident l p}"

lift_definition p_x_axis :: "p_line" is x_axis
  by simp

lift_definition p_line :: "p_point \<Rightarrow> p_point \<Rightarrow> p_line" is poincare_line
proof-
  fix u v
  show "is_poincare_line (poincare_line u v)"
  proof (cases "u \<noteq> v")
    case True
    thus ?thesis
      by simp
  next
    case False
    thus ?thesis
      by (transfer, transfer, auto simp add: hermitean_def mat_adj_def mat_cnj_def split: if_split_asm)
  qed
qed


lemma p_on_line:
  assumes "z \<noteq> w"
  shows "p_incident (p_line z w) z"
        "p_incident (p_line z w) w"
  using assms
  by (transfer, simp)+

lemma
  assumes "u \<noteq> v"
  shows "\<exists>! l. {u, v} \<subseteq> p_points l"
  using assms
  apply (rule_tac a="p_line u v" in ex1I, auto simp add: p_points_def p_on_line)
  apply (transfer, simp add: unique_poincare_line)
  done

lemma
  assumes "p_zero \<in> p_points l" "u \<in> p_points l" "u \<noteq> p_zero" "u \<in> p_points p_x_axis"
  shows "l = p_x_axis"
  using assms
  unfolding p_points_def
  apply simp
  apply transfer
  using is_poincare_line_0_real_is_x_axis inf_notin_unit_disc
  unfolding circline_set_def
  by blast


lift_definition p_collinear :: "p_point set \<Rightarrow> bool" is poincare_collinear
  done


typedef p_isometry = "{f. unit_disc_fix_f f}"
  by (rule_tac x="id" in exI, simp add: unit_disc_fix_f_def, rule_tac x="id_moebius" in exI, simp)

setup_lifting type_definition_p_isometry

lift_definition p_isometry_pt :: "p_isometry \<Rightarrow> p_point \<Rightarrow> p_point" is "\<lambda> f p. f p"
  using unit_disc_fix_f_unit_disc
  by auto

lift_definition p_isometry_line :: "p_isometry \<Rightarrow> p_line \<Rightarrow> p_line" is "\<lambda> f l. unit_disc_fix_f_circline f l"
proof-
  fix f H
  assume "unit_disc_fix_f f" "is_poincare_line H"
  then obtain M where "unit_disc_fix M" and *: "f = moebius_pt M \<or> f = moebius_pt M \<circ> conjugate"
    unfolding unit_disc_fix_f_def
    by auto
  show "is_poincare_line (unit_disc_fix_f_circline f H)"
    using *
  proof
    assume "f = moebius_pt M"
    thus ?thesis
      using unit_disc_fix_f_circline_direct[of M f H]
      by auto
  next
    assume "f = moebius_pt M \<circ> conjugate"
    thus ?thesis
      using unit_disc_fix_f_circline_indirect[of M f H]
      by auto
  qed
qed


lemma p_collinear_p_isometry_pt [simp]: 
  shows "p_collinear (p_isometry_pt M ` A) \<longleftrightarrow> p_collinear A"
proof-
  have *: "\<forall> M A.  ((\<lambda>x. moebius_pt M (conjugate x)) ` A = moebius_pt M ` (conjugate ` A))"
    by auto
  show ?thesis
    by transfer (auto simp add: unit_disc_fix_f_def *)
(* ------------------------------------------------------------------ *)
(* ------------------------------------------------------------------ *)
(* ------------------------------------------------------------------ *)
(* ------------------------------------------------------------------ *)
