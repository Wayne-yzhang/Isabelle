theory Sim_Struct_Cong
  imports Simulation "HOL-Library.Multiset"
begin


lemma partitionListLeft:
  assumes "xs@ys=xs'@y#ys'"
    and   "y \<in> set xs"
    and   "distinct(xs@ys)"

obtains zs where "xs = xs'@y#zs" and "ys'=zs@ys"
  using assms
  by(force simp add: append_eq_append_conv2 append_eq_Cons_conv)

lemma partitionListRight:

assumes "xs@ys=xs'@y#ys'"
  and   "y \<in> set ys"
  and   "distinct(xs@ys)"

obtains zs where "xs' = xs@zs" and "ys=zs@y#ys'"
  using assms
  by(force simp add: append_eq_append_conv2 append_eq_Cons_conv)

context env begin

lemma resOutputCases''''[consumes 8, case_names cOpen cRes]:
  fixes \<Psi>    :: 'b
    and x    :: name
    and zvec :: "name list"
    and P    :: "('a, 'b, 'c) psi"
    and \<alpha>    :: "'a action"
    and P'   :: "('a, 'b, 'c) psi"
    and C    :: "'f::fs_name"

assumes Trans: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>P \<longmapsto>\<alpha> \<prec> P'"
  and   1: "x \<sharp> \<Psi>"
  and   2: "x \<sharp> \<alpha>"
  and   3: "x \<sharp> P'"
  and   4: "bn \<alpha> \<sharp>* \<Psi>"
  and   5: "bn \<alpha> \<sharp>* P"
  and   6: "bn \<alpha> \<sharp>* subject \<alpha>"
  and   "\<alpha> = M\<lparr>\<nu>*zvec\<rparr>\<langle>N\<rangle>"
  and   rOpen: "\<And>M xvec yvec y N P'. \<lbrakk>\<Psi> \<rhd> ([(x, y)] \<bullet> P) \<longmapsto>M\<lparr>\<nu>*(xvec@yvec)\<rparr>\<langle>N\<rangle> \<prec> P'; y \<in> supp N;
                                         x \<sharp> N; x \<sharp> P'; x \<noteq> y; y \<sharp> xvec; y \<sharp> yvec; y \<sharp> M; distinct xvec; distinct yvec;
                                         xvec \<sharp>* \<Psi>; y \<sharp> \<Psi>; yvec \<sharp>* \<Psi>; xvec \<sharp>* P; y \<sharp> P; yvec \<sharp>* P; xvec \<sharp>* M; y \<sharp> M;
                                         yvec \<sharp>* M; xvec \<sharp>* yvec\<rbrakk> \<Longrightarrow>
                                         Prop (M\<lparr>\<nu>*(xvec@y#yvec)\<rparr>\<langle>N\<rangle>) P'"
  and   rScope:  "\<And>P'. \<lbrakk>\<Psi> \<rhd> P \<longmapsto>\<alpha> \<prec> P'\<rbrakk> \<Longrightarrow> Prop \<alpha> (\<lparr>\<nu>x\<rparr>P')"

shows "Prop \<alpha> P'"
proof -
  from Trans have "distinct (bn \<alpha>)" by(auto dest: boundOutputDistinct)
  proof(induct rule: resCases'[where C="(zvec, C)"])
    case cBrOpen
    then show ?case
      by(auto simp add: residualInject boundOutputApp)
  next
    case cRes
    then show ?case
      by(auto simp add: residualInject boundOutputApp)
  next
    case cBrClose
    then show ?case
      by(auto simp add: residualInject boundOutputApp)
  next
    case(cOpen M' xvec yvec y N' P')
    show ?case
      by(rule cOpen(22))
  qed
qed

lemma resOutputCases'''''[consumes 7, case_names cOpen cRes]:
  fixes \<Psi>    :: 'b
    and x    :: name
    and zvec :: "name list"
    and P    :: "('a, 'b, 'c) psi"
    and P'   :: "('a, 'b, 'c) psi"
    and C    :: "'f::fs_name"

assumes Trans: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>P \<longmapsto>M\<lparr>\<nu>*zvec\<rparr>\<langle>N\<rangle> \<prec> P'"
  and   1: "x \<sharp> \<Psi>"
  and   "x \<sharp> M\<lparr>\<nu>*zvec\<rparr>\<langle>N\<rangle>"
  and   3: "x \<sharp> P'"
  and   "zvec \<sharp>* \<Psi>"
  and   "zvec \<sharp>* P"
  and   "zvec \<sharp>* M"
  and   rOpen: "\<And>M' xvec yvec y N' P'. \<lbrakk>\<Psi> \<rhd> ([(x, y)] \<bullet> P) \<longmapsto>M'\<lparr>\<nu>*(xvec@yvec)\<rparr>\<langle>N'\<rangle> \<prec> P'; y \<in> supp N';
                                         x \<sharp> N'; x \<sharp> P'; x \<noteq> y; y \<sharp> xvec; y \<sharp> yvec; y \<sharp> M'; distinct xvec; distinct yvec;
                                         xvec \<sharp>* \<Psi>; y \<sharp> \<Psi>; yvec \<sharp>* \<Psi>; xvec \<sharp>* P; y \<sharp> P; yvec \<sharp>* P; xvec \<sharp>* M'; y \<sharp> M';
                                         yvec \<sharp>* M'; xvec \<sharp>* yvec; M'\<lparr>\<nu>*(xvec@y#yvec)\<rparr>\<langle>N'\<rangle> = M\<lparr>\<nu>*zvec\<rparr>\<langle>N\<rangle>\<rbrakk> \<Longrightarrow>
                                         Prop P'"
  and   rScope:  "\<And>P'. \<lbrakk>\<Psi> \<rhd> P \<longmapsto>M\<lparr>\<nu>*zvec\<rparr>\<langle>N\<rangle> \<prec> P'\<rbrakk> \<Longrightarrow> Prop (\<lparr>\<nu>x\<rparr>P')"

shows "Prop P'"
proof -
  from Trans have "distinct zvec" by(auto dest: boundOutputDistinct)
  obtain al where "al=M\<lparr>\<nu>*zvec\<rparr>\<langle>N\<rangle>" by simp
  have \<alpha>Trans: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>P \<longmapsto>al \<prec> P'" and 4: "bn al \<sharp>* \<Psi>" and 5: "bn al \<sharp>* P" and 6: "bn al \<sharp>* subject al"
    by simp+
  proof(induct rule: resCases'[where C="(zvec, C)"])
    case cBrOpen
    then show ?case
      by(auto simp add: residualInject boundOutputApp)
  next
    case cBrClose
    then show ?case
      by(auto simp add: residualInject boundOutputApp)
  next
    case(cOpen M' xvec yvec y N' P')
    show ?case
      by(rule cOpen(22))
  next
    case (cRes P')
    show ?case
      by (simp add: cRes(4))
  qed
qed

lemma resBrOutputCases'[consumes 7, case_names cBrOpen cRes]:
  fixes \<Psi>    :: 'b
    and x    :: name
    and zvec :: "name list"
    and P    :: "('a, 'b, 'c) psi"
    and P'   :: "('a, 'b, 'c) psi"
    and C    :: "'f::fs_name"

assumes Trans: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>P \<longmapsto>\<exclamdown>M\<lparr>\<nu>*zvec\<rparr>\<langle>N\<rangle> \<prec> P'"
  and   1: "x \<sharp> \<Psi>"
  and   "x \<sharp> \<exclamdown>M\<lparr>\<nu>*zvec\<rparr>\<langle>N\<rangle>"
  and   3: "x \<sharp> P'"
  and   "zvec \<sharp>* \<Psi>"
  and   "zvec \<sharp>* P"
  and   "zvec \<sharp>* M"
  and   rBrOpen: "\<And>M' xvec yvec y N' P'. \<lbrakk>\<Psi> \<rhd> ([(x, y)] \<bullet> P) \<longmapsto>\<exclamdown>M'\<lparr>\<nu>*(xvec@yvec)\<rparr>\<langle>N'\<rangle> \<prec> P'; y \<in> supp N';
                                         x \<sharp> N'; x \<sharp> P'; x \<noteq> y; y \<sharp> xvec; y \<sharp> yvec; y \<sharp> M'; distinct xvec; distinct yvec;
                                         xvec \<sharp>* \<Psi>; y \<sharp> \<Psi>; yvec \<sharp>* \<Psi>; xvec \<sharp>* P; y \<sharp> P; yvec \<sharp>* P; xvec \<sharp>* M'; y \<sharp> M';
                                         yvec \<sharp>* M'; xvec \<sharp>* yvec; \<exclamdown>M'\<lparr>\<nu>*(xvec@y#yvec)\<rparr>\<langle>N'\<rangle> = \<exclamdown>M\<lparr>\<nu>*zvec\<rparr>\<langle>N\<rangle>\<rbrakk> \<Longrightarrow>
                                         Prop P'"
  and   rScope:  "\<And>P'. \<lbrakk>\<Psi> \<rhd> P \<longmapsto>\<exclamdown>M\<lparr>\<nu>*zvec\<rparr>\<langle>N\<rangle> \<prec> P'\<rbrakk> \<Longrightarrow> Prop (\<lparr>\<nu>x\<rparr>P')"

shows "Prop P'"
proof -
  from Trans have "distinct zvec" by(auto dest: boundOutputDistinct)
  obtain al where "al=\<exclamdown>M\<lparr>\<nu>*zvec\<rparr>\<langle>N\<rangle>" by simp
  have \<alpha>Trans: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>P \<longmapsto>al \<prec> P'" and 4: "bn al \<sharp>* \<Psi>" and 5: "bn al \<sharp>* P" and 6: "bn al \<sharp>* subject al"
    by simp+
  proof(induct rule: resCases'[where C="(zvec, C)"])
    case cBrOpen
    then show ?case
      by(auto simp add: residualInject boundOutputApp)
  next
    case cBrClose
    then show ?case
      by(auto simp add: residualInject boundOutputApp)
  next
    case(cOpen M' xvec yvec y N' P')
    then show ?case
      by(auto simp add: residualInject boundOutputApp)
  next
    case (cRes P')
    show ?case
      by (simp add: cRes(4))
  qed
qed

lemma brOutputFreshSubject:
  fixes x::name
  assumes "\<Psi> \<rhd> P \<longmapsto> \<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'"
    and   "xvec \<sharp>* M"
    and   "x \<sharp> P"
  shows "x \<sharp> M"
  using assms
proof(nominal_induct avoiding: x rule: brOutputInduct')
  case(cAlpha \<Psi> P M xvec N P' p)
  then show ?case by simp
next
  case(cBrOutput \<Psi> M K N P)
  then show ?case
    by(auto simp add: fresh_def psi.supp dest: chanOutConSupp)
next
  case(cCase \<Psi> P M xvec N P' \<phi> Cs) then show ?case
    by(induct Cs) auto
next
  case(cPar1 \<Psi> \<Psi>\<^sub>Q P M xvec N P' A\<^sub>Q Q) then show ?case
    by simp
next
  case cPar2 then show ?case by simp
next
  case cBrComm1 then show ?case by simp
next
  case cBrComm2 then show ?case by simp
next
  case cBrOpen then show ?case by(simp add: fresh_abs_fun_iff[OF pt_name_inst, OF at_name_inst, OF fin_supp])
next
  case cScope then show ?case by(simp add: fresh_abs_fun_iff[OF pt_name_inst, OF at_name_inst, OF fin_supp])
next
  case cBang then show ?case by simp
qed

lemma brInputFreshSubject:
  fixes x::name
  assumes "\<Psi> \<rhd> P \<longmapsto> \<questiondown>M\<lparr>N\<rparr> \<prec> P'"
    and   "x \<sharp> P"
  shows "x \<sharp> M"
  using assms
proof(nominal_induct avoiding: x rule: brInputInduct)
  case(cBrInput \<Psi> K M xvec N Tvec P y)
  then show ?case
    by(auto simp add: fresh_def psi.supp dest: chanInConSupp)
next
  case(cCase \<Psi> P M N P' \<phi> Cs y) then show ?case
    by(induct Cs) auto
next
  case(cPar1 \<Psi> \<Psi>\<^sub>Q P M N P' A\<^sub>Q Q y) then show ?case
    by simp
next
  case cPar2 then show ?case by simp
next
  case cBrMerge then show ?case by simp
next
  case cScope then show ?case by(simp add: fresh_abs_fun_iff[OF pt_name_inst, OF at_name_inst, OF fin_supp])
next
  case cBang then show ?case by simp
qed

lemma resComm:
  fixes \<Psi>   :: 'b
    and x   :: name
    and y   :: name
    and Rel :: "('b \<times> ('a, 'b, 'c) psi \<times> ('a, 'b, 'c) psi) set"
    and P   :: "('a, 'b, 'c) psi"

assumes "x \<sharp> \<Psi>"
  and   "y \<sharp> \<Psi>"
  and   "eqvt Rel"
  and   R1: "\<And>\<Psi>' Q. (\<Psi>', Q, Q) \<in> Rel"
  and   R2: "\<And>\<Psi>' a b Q. \<lbrakk>a \<sharp> \<Psi>'; b \<sharp> \<Psi>'\<rbrakk> \<Longrightarrow> (\<Psi>', \<lparr>\<nu>a\<rparr>(\<lparr>\<nu>b\<rparr>Q), \<lparr>\<nu>b\<rparr>(\<lparr>\<nu>a\<rparr>Q)) \<in> Rel"
  and   R3: "\<And>\<Psi>' xvec yvec Q. \<lbrakk>xvec \<sharp>* \<Psi>'; mset xvec = mset yvec\<rbrakk> \<Longrightarrow> (\<Psi>', \<lparr>\<nu>*xvec\<rparr>Q, \<lparr>\<nu>*yvec\<rparr>Q) \<in> Rel"

shows "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>y\<rparr>P) \<leadsto>[Rel] \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>x\<rparr>P)"
proof(cases "x=y")
  assume "x = y"
  then show ?thesis using R1
    by(force intro: reflexive)
next
  assume "x \<noteq> y"
  moreover have "[x, y] \<sharp>* \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>y\<rparr>P)" by(simp add: abs_fresh)
  moreover have "[x, y] \<sharp>* \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>x\<rparr>P)" by(simp add: abs_fresh)
  ultimately show ?thesis
  proof(induct rule: simIChainFresh[where C="(x, y)"])
    case(cSim \<alpha> P')
    proof(induct rule: resCases'[where C=x])
      case(cOpen M yvec1 yvec2 y' N P')
        by simp+
        by simp+
      have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>([(y, y')] \<bullet> P) \<longmapsto>M\<lparr>\<nu>*(yvec1@yvec2)\<rparr>\<langle>N\<rangle> \<prec> P'" by(simp add: eqvts)
      have "(yvec1@yvec2) \<sharp>* ([(y, y')] \<bullet> P)" by simp
        by simp
      ultimately show ?case
      proof(induct rule: resOutputCases''''')
        case(cOpen M' xvec1 xvec2 x' N' P')
        have "x \<sharp> (yvec1@yvec2)" and "y \<sharp> (yvec1@yvec2)" and "y' \<sharp> (yvec1@yvec2)" by simp+
        have "x \<sharp> xvec1" and "x \<noteq> x'" and "x \<sharp> xvec2" and "y \<sharp> xvec1" and "y \<noteq> x'" and "y \<sharp> xvec2"
          and "y' \<sharp> xvec1" and "x' \<noteq> y'" and "y' \<sharp> xvec2"
          by auto

        show ?case
        proof(cases "x' \<in> set yvec1")
          assume "x' \<in> set yvec1"

          obtain xvec2' where Eq1: "yvec1=xvec1@x'#xvec2'"
            and Eq: "xvec2=xvec2'@yvec2"
            by(metis partitionListLeft)
          have "\<Psi> \<rhd> \<lparr>\<nu>y'\<rparr>([(x, x')] \<bullet> [(y, y')] \<bullet> P) \<longmapsto>M'\<lparr>\<nu>*((xvec1@xvec2')@y'#yvec2)\<rparr>\<langle>N'\<rangle> \<prec> P'"
            by(intro Open) auto
          then have "\<Psi> \<rhd> \<lparr>\<nu>x'\<rparr>(\<lparr>\<nu>y'\<rparr>([(x, x')] \<bullet> [(y, y')] \<bullet> P)) \<longmapsto>M\<lparr>\<nu>*(xvec1@x'#xvec2'@y'#yvec2)\<rparr>\<langle>N\<rangle> \<prec> P'"
            by(intro Open) auto
          have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>y'\<rparr>([(y, y')] \<bullet> P)) \<longmapsto>M\<lparr>\<nu>*(xvec1@x'#xvec2'@y'#yvec2)\<rparr>\<langle>N\<rangle> \<prec> P'"
            by(subst alphaRes[where y=x']) (simp add: calc_atm eqvts abs_fresh)+
            by(auto simp add: alphaRes abs_fresh)
        next
          assume "\<not>x' \<in> set yvec1"
          then have "x' \<sharp> yvec1" by(simp add: fresh_def)
          have "x' \<in> set yvec2"
            by(auto simp add: append_eq_append_conv2 append_eq_Cons_conv)
          obtain xvec2' where Eq: "xvec1=yvec1@xvec2'"
            and Eq1: "yvec2=xvec2'@x'#xvec2"
            by(metis partitionListRight)
          have "\<Psi> \<rhd> \<lparr>\<nu>y'\<rparr>([(x, x')] \<bullet> [(y, y')] \<bullet> P) \<longmapsto>M'\<lparr>\<nu>*(yvec1@y'#xvec2'@xvec2)\<rparr>\<langle>N'\<rangle> \<prec> P'"
            by(intro Open) (assumption | simp)+
          then have "\<Psi> \<rhd> \<lparr>\<nu>x'\<rparr>(\<lparr>\<nu>y'\<rparr>([(x, x')] \<bullet> [(y, y')] \<bullet> P)) \<longmapsto>M\<lparr>\<nu>*((yvec1@y'#xvec2')@x'#xvec2)\<rparr>\<langle>N\<rangle> \<prec> P'"
            by(intro Open) auto
          have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>y'\<rparr>([(y, y')] \<bullet> P)) \<longmapsto>M\<lparr>\<nu>*((yvec1@y'#xvec2')@x'#xvec2)\<rparr>\<langle>N\<rangle> \<prec> P'"
            by(subst alphaRes[where y=x']) (simp add: calc_atm eqvts abs_fresh)+
            by(auto simp add: alphaRes abs_fresh)
        qed
      next
        case(cRes P')
        have "\<Psi> \<rhd> \<lparr>\<nu>y'\<rparr>([(y, y')] \<bullet> P) \<longmapsto>M\<lparr>\<nu>*(yvec1@y'#yvec2)\<rparr>\<langle>N\<rangle> \<prec> P'" by(rule Open)
          by(intro Scope) auto
        moreover have "(\<Psi>, \<lparr>\<nu>x\<rparr>P', \<lparr>\<nu>x\<rparr>P') \<in> Rel" by(rule R1)
        ultimately show ?case by blast
      qed
    next
      case(cBrOpen M yvec1 yvec2 y' N P')
        by simp+
        by simp+
      have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>([(y, y')] \<bullet> P) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(yvec1@yvec2)\<rparr>\<langle>N\<rangle> \<prec> P'" by(simp add: eqvts)
      have "(yvec1@yvec2) \<sharp>* ([(y, y')] \<bullet> P)" by simp
        by simp
      ultimately show ?case
      proof(induct rule: resBrOutputCases')
        case(cBrOpen M' xvec1 xvec2 x' N' P')
        have "x \<sharp> (yvec1@yvec2)" and "y \<sharp> (yvec1@yvec2)" and "y' \<sharp> (yvec1@yvec2)" by simp+
        have "x \<sharp> xvec1" and "x \<noteq> x'" and "x \<sharp> xvec2" and "y \<sharp> xvec1" and "y \<noteq> x'" and "y \<sharp> xvec2"
          and "y' \<sharp> xvec1" and "x' \<noteq> y'" and "y' \<sharp> xvec2"
          by auto

        show ?case
        proof(cases "x' \<in> set yvec1")
          assume "x' \<in> set yvec1"

          obtain xvec2' where Eq1: "yvec1=xvec1@x'#xvec2'"
            and Eq: "xvec2=xvec2'@yvec2"
            by(metis partitionListLeft)
          have "\<Psi> \<rhd> \<lparr>\<nu>y'\<rparr>([(x, x')] \<bullet> [(y, y')] \<bullet> P) \<longmapsto>\<exclamdown>M'\<lparr>\<nu>*((xvec1@xvec2')@y'#yvec2)\<rparr>\<langle>N'\<rangle> \<prec> P'"
            by(intro BrOpen) auto
          then have "\<Psi> \<rhd> \<lparr>\<nu>x'\<rparr>(\<lparr>\<nu>y'\<rparr>([(x, x')] \<bullet> [(y, y')] \<bullet> P)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@x'#xvec2'@y'#yvec2)\<rparr>\<langle>N\<rangle> \<prec> P'"
            by(intro BrOpen) auto
          have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>y'\<rparr>([(y, y')] \<bullet> P)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@x'#xvec2'@y'#yvec2)\<rparr>\<langle>N\<rangle> \<prec> P'"
            by(subst alphaRes[where y=x']) (simp add: calc_atm eqvts abs_fresh)+
            by(auto simp add: alphaRes abs_fresh)
        next
          assume "\<not>x' \<in> set yvec1"
          then have "x' \<sharp> yvec1" by(simp add: fresh_def)
          have "x' \<in> set yvec2"
            by(auto simp add: append_eq_append_conv2 append_eq_Cons_conv)
          obtain xvec2' where Eq: "xvec1=yvec1@xvec2'"
            and Eq1: "yvec2=xvec2'@x'#xvec2"
            by(metis partitionListRight)
          have "\<Psi> \<rhd> \<lparr>\<nu>y'\<rparr>([(x, x')] \<bullet> [(y, y')] \<bullet> P) \<longmapsto>\<exclamdown>M'\<lparr>\<nu>*(yvec1@y'#xvec2'@xvec2)\<rparr>\<langle>N'\<rangle> \<prec> P'"
            by(intro BrOpen) (assumption | simp)+
          then have "\<Psi> \<rhd> \<lparr>\<nu>x'\<rparr>(\<lparr>\<nu>y'\<rparr>([(x, x')] \<bullet> [(y, y')] \<bullet> P)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*((yvec1@y'#xvec2')@x'#xvec2)\<rparr>\<langle>N\<rangle> \<prec> P'"
            by(intro BrOpen) auto
          have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>y'\<rparr>([(y, y')] \<bullet> P)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*((yvec1@y'#xvec2')@x'#xvec2)\<rparr>\<langle>N\<rangle> \<prec> P'"
            by(subst alphaRes[where y=x']) (simp add: calc_atm eqvts abs_fresh)+
            by(auto simp add: alphaRes abs_fresh)
        qed
      next
        case(cRes P')
        have "\<Psi> \<rhd> \<lparr>\<nu>y'\<rparr>([(y, y')] \<bullet> P) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(yvec1@y'#yvec2)\<rparr>\<langle>N\<rangle> \<prec> P'" by(rule BrOpen)
          by(intro Scope) auto
        moreover have "(\<Psi>, \<lparr>\<nu>x\<rparr>P', \<lparr>\<nu>x\<rparr>P') \<in> Rel" by(rule R1)
        ultimately show ?case by blast
      qed
    next
      case(cRes P')
      proof(induct rule: resCases'[where C="(x, y)"])
        case(cOpen M xvec1 xvec2 x' N P')
        have "\<Psi> \<rhd> \<lparr>\<nu>y\<rparr>([(x, x')] \<bullet> P) \<longmapsto>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>N\<rangle> \<prec> \<lparr>\<nu>y\<rparr>P'"
          by(rule Scope)
        then have "\<Psi> \<rhd> \<lparr>\<nu>x'\<rparr>(\<lparr>\<nu>y\<rparr>([(x, x')] \<bullet> P)) \<longmapsto>M\<lparr>\<nu>*(xvec1@x'#xvec2)\<rparr>\<langle>N\<rangle> \<prec> \<lparr>\<nu>y\<rparr>P'"
          by(rule Open)
          by(subst alphaRes[where y=x']) (simp add: abs_fresh eqvts calc_atm)+
        moreover have "(\<Psi>, \<lparr>\<nu>y\<rparr>P', \<lparr>\<nu>y\<rparr>P') \<in> Rel" by(rule R1)
        ultimately show ?case by blast
      next
        case(cBrOpen M xvec1 xvec2 x' N P')
        have "\<Psi> \<rhd> \<lparr>\<nu>y\<rparr>([(x, x')] \<bullet> P) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>N\<rangle> \<prec> \<lparr>\<nu>y\<rparr>P'"
          by(rule Scope)
        then have "\<Psi> \<rhd> \<lparr>\<nu>x'\<rparr>(\<lparr>\<nu>y\<rparr>([(x, x')] \<bullet> P)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@x'#xvec2)\<rparr>\<langle>N\<rangle> \<prec> \<lparr>\<nu>y\<rparr>P'"
          by(rule BrOpen)
          by(subst alphaRes[where y=x']) (simp add: abs_fresh eqvts calc_atm)+
        moreover have "(\<Psi>, \<lparr>\<nu>y\<rparr>P', \<lparr>\<nu>y\<rparr>P') \<in> Rel" by(rule R1)
        ultimately show ?case by blast
      next
        case(cRes P')
        have "\<Psi> \<rhd> \<lparr>\<nu>y\<rparr>P \<longmapsto>\<alpha> \<prec> \<lparr>\<nu>y\<rparr>P'" by(rule Scope)
          by(rule Scope)
          by(rule R2)
        ultimately show ?case by blast
      next
        case(cBrClose M xvec N P')
        then show ?case
        proof(cases "y \<sharp> \<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle>")
          case True
            by(intro Scope)
            by(rule BrClose)
          moreover have "(\<Psi>, (\<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>\<lparr>\<nu>y\<rparr>P')), \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>P'))) \<in> Rel"
          proof -
            have "mset (x#xvec@[y]) = mset (y#x#xvec)"
              by simp
              by simp
            ultimately have "(\<Psi>, \<lparr>\<nu>*(x#xvec@[y])\<rparr>P', \<lparr>\<nu>*(y#x#xvec)\<rparr>P') \<in> Rel"
              by(metis R3)
            then show ?thesis
              by(auto simp add: resChainAppend)
          qed
          ultimately show ?thesis
            by blast
        next
          case False
          then have "y \<in> supp(\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle>)" unfolding fresh_def by simp
          show ?thesis
          proof(cases "y \<in> supp(M)")
            case True
              by(rule BrClose)
              by(rule Scope) simp
              by(metis R2)
            ultimately show ?thesis
              by blast
          next
            case False
            then have "y \<sharp> M" by(simp add: fresh_def)
            have "y \<in> supp N"
              by(simp add: fresh_def action.supp)
              by simp
              by(intro BrOpen) (assumption|simp)+
            then have "\<Psi> \<rhd> \<lparr>\<nu>y\<rparr>P \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(y#xvec)\<rparr>\<langle>N\<rangle> \<prec> P'"
              by simp
              by(auto dest: BrClose)
              by(rule R2)
            ultimately show ?thesis by blast
          qed
        qed
      qed
    next
      case(cBrClose M xvec N P')
      have "x \<sharp> \<lparr>\<nu>x\<rparr>P" by(simp add: fresh_abs_fun_iff[OF pt_name_inst, OF at_name_inst, OF fin_supp])
      have "x \<sharp> P'"
        by(rule broutputFreshDerivativeP) fact+
      have "x \<sharp> N"
        by(rule broutputFreshDerivativeN) fact+
        by(rule brOutputFreshSubject)
      ultimately have "x \<sharp> \<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle>"
        by simp
        by(simp add: supp_some)
      obtain M' xvec' N' where "\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> = \<exclamdown>M'\<lparr>\<nu>*xvec'\<rparr>\<langle>N'\<rangle>"
        by auto
      have "\<exists>Q'. \<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>y\<rparr>P) \<longmapsto> \<tau> \<prec> Q' \<and> (\<Psi>, Q', \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*(bn (\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle>))\<rparr>P')) \<in> Rel"
      proof(induct rule: resCases'[where C=y])
        case cOpen then show ?case by(simp add: residualInject)
      next
        case(cBrOpen M xvec yvec z N P')
          by(simp add: supp_some)
        have "\<Psi> \<rhd> \<lparr>\<nu>y\<rparr>([(x, z)] \<bullet> P) \<longmapsto> \<tau> \<prec> \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*(xvec@yvec)\<rparr>P')"
          by(rule BrClose)
          by(rule Scope) simp
          apply(subst alphaRes[where x=x and y=z])
           apply(simp add: fresh_abs_fun_iff[OF pt_name_inst, OF at_name_inst, OF fin_supp])
          apply(simp add: eqvts swap_simps)
          done
        moreover have "(\<Psi>, \<lparr>\<nu>z\<rparr>(\<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*(xvec @ yvec)\<rparr>P')), \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*bn (\<exclamdown>M\<lparr>\<nu>*(xvec @ z # yvec)\<rparr>\<langle>N\<rangle>)\<rparr>P')) \<in> Rel"
        proof -
          have "mset(z#y#xvec@yvec) = mset(y#xvec@z#yvec)"
            by simp
            by simp
          ultimately have "(\<Psi>, \<lparr>\<nu>*(z#y#xvec@yvec)\<rparr>P', \<lparr>\<nu>*(y#xvec@z#yvec)\<rparr>P') \<in> Rel"
            by(metis R3)
          then show ?thesis
            by(simp add: resChainAppend)
        qed
        ultimately show ?case
          by blast
      next
        case(cRes P')
        have "\<Psi> \<rhd> \<lparr>\<nu>y\<rparr>P \<longmapsto> \<tau> \<prec> \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*xvec\<rparr>P')"
          by(rule BrClose)
          by(rule Scope) simp
        moreover have "(\<Psi>, \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*xvec\<rparr>P')), \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*bn (\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle>)\<rparr>\<lparr>\<nu>x\<rparr>P')) \<in> Rel"
        proof -
          have "mset(x#y#xvec) = mset(y#xvec@[x])"
            by simp
            by simp
          ultimately have "(\<Psi>, \<lparr>\<nu>*(x#y#xvec)\<rparr>P', \<lparr>\<nu>*(y#xvec@[x])\<rparr>P') \<in> Rel"
            by(metis R3)
          then show ?thesis by(simp add: resChainAppend)
        qed
        ultimately show ?case
          by blast
      next
        case cBrClose then show ?case by simp
      qed
      then show ?case by simp
    qed
  qed
qed

lemma parAssocLeft:
  fixes \<Psi>   :: 'b
    and P   :: "('a, 'b, 'c) psi"
    and Q   :: "('a, 'b, 'c) psi"
    and R   :: "('a, 'b, 'c) psi"
    and Rel :: "('b \<times> ('a, 'b, 'c) psi \<times> ('a, 'b, 'c) psi) set"

assumes "eqvt Rel"
  and   C1: "\<And>\<Psi>' S T U. (\<Psi>, (S \<parallel> T) \<parallel> U, S \<parallel> (T \<parallel> U)) \<in> Rel"
  and   C2: "\<And>xvec \<Psi>' S T U. \<lbrakk>xvec \<sharp>* \<Psi>'; xvec \<sharp>* S\<rbrakk> \<Longrightarrow> (\<Psi>', \<lparr>\<nu>*xvec\<rparr>((S \<parallel> T) \<parallel> U), S \<parallel> (\<lparr>\<nu>*xvec\<rparr>(T \<parallel> U))) \<in> Rel"
  and   C3: "\<And>xvec \<Psi>' S T U. \<lbrakk>xvec \<sharp>* \<Psi>'; xvec \<sharp>* U\<rbrakk> \<Longrightarrow> (\<Psi>', (\<lparr>\<nu>*xvec\<rparr>(S \<parallel> T)) \<parallel> U, \<lparr>\<nu>*xvec\<rparr>(S \<parallel> (T \<parallel> U))) \<in> Rel"
  and   C4: "\<And>\<Psi>' S T xvec. \<lbrakk>(\<Psi>', S, T) \<in> Rel; xvec \<sharp>* \<Psi>'\<rbrakk> \<Longrightarrow> (\<Psi>', \<lparr>\<nu>*xvec\<rparr>S, \<lparr>\<nu>*xvec\<rparr>T) \<in> Rel"

shows "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<leadsto>[Rel] P \<parallel> (Q \<parallel> R)"
proof(induct rule: simI[of _ _ _ _ "()"])
  case(cSim \<alpha> PQR)
  then have "bn \<alpha> \<sharp>* (Q \<parallel> R)" by simp
  proof(induct rule: parCases[where C = "(\<Psi>, P, Q, R, \<alpha>)"])
    case(cPar1 P' A\<^sub>Q\<^sub>R \<Psi>\<^sub>Q\<^sub>R)
      by simp+
    obtain A\<^sub>Q \<Psi>\<^sub>Q A\<^sub>R \<Psi>\<^sub>R where "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" and FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" and  FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>"
      and "A\<^sub>Q \<sharp>* \<Psi>\<^sub>R" and "A\<^sub>R \<sharp>* \<Psi>\<^sub>Q"
      by(auto intro: mergeFrameE dest: extractFrameFreshChain)

    have "A\<^sub>Q \<sharp>* \<Psi>" and "A\<^sub>R \<sharp>* \<Psi>" and "A\<^sub>Q \<sharp>* P" and "A\<^sub>R \<sharp>* P" and "A\<^sub>Q \<sharp>* Q" and "A\<^sub>R \<sharp>* Q" and "A\<^sub>Q \<sharp>* \<alpha>" and "A\<^sub>R \<sharp>* \<alpha>"
      by simp+

      by(metis statEqTransition Associativity Commutativity Composition)
      by(intro Par1) auto
      by(auto intro: Par1)
    moreover have "(\<Psi>, (P' \<parallel> Q) \<parallel> R, P' \<parallel> (Q \<parallel> R)) \<in> Rel" by(rule C1)
    ultimately show ?case by blast
  next
    case(cPar2 QR A\<^sub>P \<Psi>\<^sub>P)
      by simp+
    have FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact
    proof(induct rule: parCasesSubject[where C = "(A\<^sub>P, \<Psi>\<^sub>P, P, Q, R, \<Psi>)"])
      case(cPar1 Q' A\<^sub>R \<Psi>\<^sub>R)
        by simp+
        by(auto dest: extractFrameFreshChain)
        by(metis statEqTransition Associativity Commutativity Composition)
      then have "\<Psi> \<otimes> \<Psi>\<^sub>R \<rhd> P \<parallel> Q \<longmapsto>\<alpha> \<prec> (P \<parallel> Q')"
        by(intro Par2) (assumption | force)+
      then have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<alpha> \<prec> ((P \<parallel> Q') \<parallel> R)"
        by(intro Par1) (assumption | simp)+
      moreover have "(\<Psi>, (P \<parallel> Q') \<parallel> R, P \<parallel> (Q' \<parallel> R)) \<in> Rel" by(rule C1)
      ultimately show ?case by blast
    next
      case(cPar2 R' A\<^sub>Q \<Psi>\<^sub>Q)
        by simp+
      have FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact
        by(auto dest: extractFrameFreshChain)
      have "\<Psi> \<otimes> (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q) \<rhd> R \<longmapsto>\<alpha> \<prec> R'"
        by(blast intro: statEqTransition Associativity)
      have "extractFrame(P \<parallel> Q) = \<langle>(A\<^sub>P@A\<^sub>Q), \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q\<rangle> " by simp
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<alpha> \<prec> ((P \<parallel> Q) \<parallel> R')"
        by(rule Par2)
      moreover have "(\<Psi>, (P \<parallel> Q) \<parallel> R', P \<parallel> (Q \<parallel> R')) \<in> Rel" by(rule C1)
      ultimately show ?case by blast
    next
      case(cComm1 \<Psi>\<^sub>R M N Q' A\<^sub>Q \<Psi>\<^sub>Q K xvec R' A\<^sub>R)
      have "A\<^sub>Q \<sharp>* P" and "A\<^sub>Q \<sharp>* Q" and "A\<^sub>Q \<sharp>* R" and "A\<^sub>Q \<sharp>* A\<^sub>P" and "A\<^sub>Q \<sharp>* \<Psi>\<^sub>P"  and "A\<^sub>Q \<sharp>* \<Psi>" by simp+

      have FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact
        by(auto dest: extractFrameFreshChain)
      have FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact
        by(auto dest: extractFrameFreshChain)
        by(auto intro: outputFreshChainDerivative)

        by(metis statEqTransition Associativity Commutativity Composition)
        by(intro Par2) auto
        by simp
        by(metis statEqTransition Associativity)
        by(metis statEqEnt Associativity Commutativity Composition)
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<tau> \<prec> \<lparr>\<nu>*xvec\<rparr>((P \<parallel> Q') \<parallel> R')"
        by(intro Comm1) (assumption | simp)+
        by(rule C2)
      ultimately show ?case by blast
    next
      case(cComm2 \<Psi>\<^sub>R M xvec N Q' A\<^sub>Q \<Psi>\<^sub>Q K R' A\<^sub>R)
      have "A\<^sub>Q \<sharp>* P" and "A\<^sub>Q \<sharp>* Q" and "A\<^sub>Q \<sharp>* R" and "A\<^sub>Q \<sharp>* A\<^sub>P" and "A\<^sub>Q \<sharp>* \<Psi>" and "A\<^sub>Q \<sharp>* \<Psi>\<^sub>P" by simp+

      have FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact
        by(auto dest: extractFrameFreshChain)
      have FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact
        by(auto dest: extractFrameFreshChain)

        by(auto intro: outputFreshChainDerivative)

        by(metis statEqTransition Associativity Commutativity Composition)
        by(intro Par2) auto
        by simp+
        by(metis statEqTransition Associativity)
        by(metis statEqEnt Associativity Commutativity Composition)
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<tau> \<prec> \<lparr>\<nu>*xvec\<rparr>((P \<parallel> Q') \<parallel> R')"
        by(intro Comm2) (assumption | simp)+
        by(rule C2)
      ultimately show ?case by blast
    next
      case(cBrMerge \<Psi>\<^sub>R M N Q' A\<^sub>Q \<Psi>\<^sub>Q R' A\<^sub>R)
      have "A\<^sub>Q \<sharp>* P" and "A\<^sub>Q \<sharp>* Q" and "A\<^sub>Q \<sharp>* R" and "A\<^sub>Q \<sharp>* A\<^sub>P" and "A\<^sub>Q \<sharp>* \<Psi>\<^sub>P"  and "A\<^sub>Q \<sharp>* \<Psi>" by simp+

      have FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact
        by(auto dest: extractFrameFreshChain)
      have FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact
        by(auto dest: extractFrameFreshChain)

        by(metis statEqTransition Associativity Commutativity Composition)
        by(intro Par2) auto
        by simp
        by(metis statEqTransition Associativity)
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> (P \<parallel> Q') \<parallel> R'"
        by(auto intro: BrMerge)
      moreover have "(\<Psi>, (P \<parallel> Q') \<parallel> R', P \<parallel> (Q' \<parallel> R')) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    next
      case(cBrComm1 \<Psi>\<^sub>R M N Q' A\<^sub>Q \<Psi>\<^sub>Q xvec R' A\<^sub>R)
        by(auto simp add: action.inject)
      have "A\<^sub>P \<sharp>* xvec" and "A\<^sub>P \<sharp>* M" and "A\<^sub>P \<sharp>* N" by auto
        by simp+
      have "A\<^sub>Q \<sharp>* P" and "A\<^sub>Q \<sharp>* Q" and "A\<^sub>Q \<sharp>* R" and "A\<^sub>Q \<sharp>* A\<^sub>P" and "A\<^sub>Q \<sharp>* \<Psi>\<^sub>P"  and "A\<^sub>Q \<sharp>* \<Psi>" by simp+

      have FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact
        by(auto dest: extractFrameFreshChain)
      have FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact
        by(auto dest: extractFrameFreshChain)

        by(metis statEqTransition Associativity Commutativity Composition)
        by(intro Par2) auto
        by simp
        by(metis statEqTransition Associativity)
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> ((P \<parallel> Q') \<parallel> R')"
        by(intro BrComm1) (assumption | simp)+
      moreover have "(\<Psi>, ((P \<parallel> Q') \<parallel> R'), (P \<parallel> (Q' \<parallel> R'))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    next
      case(cBrComm2 \<Psi>\<^sub>R M xvec N Q' A\<^sub>Q \<Psi>\<^sub>Q R' A\<^sub>R)
        by(auto simp add: action.inject)
      have "A\<^sub>P \<sharp>* xvec" and "A\<^sub>P \<sharp>* M" and "A\<^sub>P \<sharp>* N" by auto
        by simp+
      have "A\<^sub>Q \<sharp>* P" and "A\<^sub>Q \<sharp>* Q" and "A\<^sub>Q \<sharp>* R" and "A\<^sub>Q \<sharp>* A\<^sub>P" and "A\<^sub>Q \<sharp>* \<Psi>" and "A\<^sub>Q \<sharp>* \<Psi>\<^sub>P" by simp+

      have FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact
        by(auto dest: extractFrameFreshChain)
      have FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact
        by(auto dest: extractFrameFreshChain)

        by(metis statEqTransition Associativity Commutativity Composition)
        by(intro Par2) auto
        by simp+
        by(metis statEqTransition Associativity)
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> ((P \<parallel> Q') \<parallel> R')"
        by(auto intro: BrComm2)
      moreover have "(\<Psi>, ((P \<parallel> Q') \<parallel> R'), (P \<parallel> (Q' \<parallel> R'))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    qed
  next
    case(cComm1 \<Psi>\<^sub>Q\<^sub>R M N P' A\<^sub>P \<Psi>\<^sub>P K xvec QR' A\<^sub>Q\<^sub>R)
    have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q\<^sub>R \<rhd> P \<longmapsto>M\<lparr>N\<rparr> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" and MeqK: "\<Psi> \<otimes> \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q\<^sub>R \<turnstile> M \<leftrightarrow> K" by fact+
    proof(induct rule: parCasesOutputFrame)
      case(cPar1 Q' A\<^sub>Q \<Psi>\<^sub>Q A\<^sub>R \<Psi>\<^sub>R)
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>N\<rparr> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover note FrP
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover from MeqK \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q \<turnstile> M \<leftrightarrow> K"
        by(metis statEqEnt Associativity Commutativity Composition)
        by(auto dest:  extractFrameFreshChain)
      ultimately have "\<Psi> \<otimes> \<Psi>\<^sub>R \<rhd> P \<parallel> Q \<longmapsto>\<tau> \<prec> \<lparr>\<nu>*xvec\<rparr>(P' \<parallel> Q')"
        by(intro Comm1) (assumption | force)+
        by(intro Par1) (assumption | simp)+
        by(rule C3)
      ultimately show ?case by blast
    next
      case(cPar2 R' A\<^sub>Q \<Psi>\<^sub>Q A\<^sub>R \<Psi>\<^sub>R)
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
      have RTrans: "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<rhd> R \<longmapsto>K\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> R'" and FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact+
      then have "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<rhd> R \<longmapsto> ROut K (\<lparr>\<nu>*xvec\<rparr>N \<prec>' R')" by(simp add: residualInject)
      then obtain K' where KeqK': "((\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q) \<otimes> \<Psi>\<^sub>R \<turnstile> K \<leftrightarrow> K'" and "A\<^sub>P \<sharp>* K'" and "A\<^sub>Q \<sharp>* K'"
        using outputObtainPrefix[where B="A\<^sub>P@A\<^sub>Q"]
        by (smt (verit, ccfv_threshold) freshChainAppend freshChainSym freshCompChain(1))
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>N\<rparr> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover from MeqK KeqK' \<Psi>eq have MeqK': "((\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q) \<otimes> \<Psi>\<^sub>P \<turnstile> M \<leftrightarrow> K'"
        by(metis statEqEnt Associativity Commutativity Composition chanEqTrans)
        by(auto intro: inputRenameSubject)
        by(intro Par1) (assumption | force)+
      have "extractFrame(P \<parallel> Q) = \<langle>(A\<^sub>P@A\<^sub>Q), \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q\<rangle>" by simp+
      moreover from RTrans have "\<Psi> \<otimes> (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q) \<rhd> R \<longmapsto>K\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> R'" by(metis Associativity statEqTransition)
      moreover note FrR
      moreover from MeqK' KeqK' have "\<Psi> \<otimes> (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q) \<otimes> \<Psi>\<^sub>R \<turnstile> K' \<leftrightarrow> K"
        by(metis statEqEnt Associativity Commutativity Composition chanEqTrans chanEqSym)
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<tau> \<prec> \<lparr>\<nu>*xvec\<rparr>((P' \<parallel> Q) \<parallel> R')"
        by(intro Comm1) (assumption | simp)+
        by(metis C1 C4)
      ultimately show ?case by blast
    qed
  next
    case(cComm2 \<Psi>\<^sub>Q\<^sub>R M xvec N P' A\<^sub>P \<Psi>\<^sub>P K QR' A\<^sub>Q\<^sub>R)
    have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q\<^sub>R \<rhd> P \<longmapsto>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" and MeqK: "\<Psi> \<otimes> \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q\<^sub>R \<turnstile> M \<leftrightarrow> K" by fact+
    proof(induct rule: parCasesInputFrame)
      case(cPar1 Q' A\<^sub>Q \<Psi>\<^sub>Q A\<^sub>R \<Psi>\<^sub>R)
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover note FrP
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover from MeqK \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q \<turnstile> M \<leftrightarrow> K"
        by(metis statEqEnt Associativity Commutativity Composition)
      have "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>P \<sharp>* \<Psi>\<^sub>R" by(auto dest: extractFrameFreshChain)
      ultimately have "\<Psi> \<otimes> \<Psi>\<^sub>R \<rhd> P \<parallel> Q \<longmapsto>\<tau> \<prec> \<lparr>\<nu>*xvec\<rparr>(P' \<parallel> Q')"
        by(intro Comm2) (assumption | force)+
        by(intro Par1) (assumption | simp)+
        by(rule C3)
      ultimately show ?case by blast
    next
      case(cPar2 R' A\<^sub>Q \<Psi>\<^sub>Q A\<^sub>R \<Psi>\<^sub>R)
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
      have "A\<^sub>R \<sharp>* \<Psi>" and "A\<^sub>R \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>P \<sharp>* A\<^sub>R" and "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>R \<sharp>* P" and "A\<^sub>Q \<sharp>* \<Psi>" and "A\<^sub>Q \<sharp>* \<Psi>\<^sub>P" by simp+
      have RTrans: "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<rhd> R \<longmapsto>K\<lparr>N\<rparr> \<prec> R'" and FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact+
      then obtain K' where KeqK': "((\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q) \<otimes> \<Psi>\<^sub>R \<turnstile> K \<leftrightarrow> K'" and "A\<^sub>P \<sharp>* K'" and "A\<^sub>Q \<sharp>* K'"
        using inputObtainPrefix[where B="A\<^sub>P@A\<^sub>Q"]
        by (smt (verit, ccfv_threshold) freshChainAppend freshChainSym freshCompChain(1))
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover from MeqK KeqK' \<Psi>eq have MeqK': "((\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q) \<otimes> \<Psi>\<^sub>P \<turnstile> M \<leftrightarrow> K'"
        by(metis statEqEnt Associativity Commutativity Composition chanEqTrans)
        by(auto dest: extractFrameFreshChain)
        by(auto intro: outputRenameSubject)
        by(intro Par1) (assumption | force)+
      have "extractFrame(P \<parallel> Q) = \<langle>(A\<^sub>P@A\<^sub>Q), \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q\<rangle>" by simp+
      moreover from RTrans have "\<Psi> \<otimes> (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q) \<rhd> R \<longmapsto>K\<lparr>N\<rparr> \<prec> R'" by(metis Associativity statEqTransition)
      moreover note FrR
      moreover from MeqK' KeqK' have "\<Psi> \<otimes> (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q) \<otimes> \<Psi>\<^sub>R \<turnstile> K' \<leftrightarrow> K"
        by(metis statEqEnt Associativity Commutativity Composition chanEqTrans chanEqSym)
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<tau> \<prec> \<lparr>\<nu>*xvec\<rparr>((P' \<parallel> Q) \<parallel> R')"
        by(intro Comm2) (assumption | simp)+
        by(metis C1 C4)
      ultimately show ?case by blast
    qed
  next
    case(cBrMerge \<Psi>\<^sub>Q\<^sub>R M N P' A\<^sub>P \<Psi>\<^sub>P QR' A\<^sub>Q\<^sub>R)
    have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q\<^sub>R \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
    proof(induct rule: parCasesBrInputFrame)
      case(cPar1 Q' A\<^sub>Q \<Psi>\<^sub>Q A\<^sub>R \<Psi>\<^sub>R)
        by simp+
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover note FrP
        by(metis statEqTransition Associativity Commutativity Composition)
      have "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>P \<sharp>* \<Psi>\<^sub>R" by(auto dest: extractFrameFreshChain)
      ultimately have "\<Psi> \<otimes> \<Psi>\<^sub>R \<rhd> P \<parallel> Q \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> (P' \<parallel> Q')"
        by(intro BrMerge) (assumption | force)+
        by(intro Par1) (assumption | simp)+
      moreover have "(\<Psi>, (P' \<parallel> Q') \<parallel> R, (P' \<parallel> (Q' \<parallel> R))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    next
      case(cPar2 R' A\<^sub>Q \<Psi>\<^sub>Q A\<^sub>R \<Psi>\<^sub>R)
        by simp+
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
      have "A\<^sub>R \<sharp>* \<Psi>" and "A\<^sub>R \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>P \<sharp>* A\<^sub>R" and "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>R \<sharp>* P" and "A\<^sub>Q \<sharp>* \<Psi>" and "A\<^sub>Q \<sharp>* \<Psi>\<^sub>P" by simp+
      have RTrans: "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<rhd> R \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> R'" and FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact+
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
        by(auto dest: extractFrameFreshChain)
        by(intro Par1) (assumption | force)+
      have "extractFrame(P \<parallel> Q) = \<langle>(A\<^sub>P@A\<^sub>Q), \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q\<rangle>" by simp+
      moreover from RTrans have "\<Psi> \<otimes> (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q) \<rhd> R \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> R'" by(metis Associativity statEqTransition)
      moreover note FrR
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> ((P' \<parallel> Q) \<parallel> R')"
        by(auto intro: BrMerge)
      moreover have "(\<Psi>, ((P' \<parallel> Q) \<parallel> R'), (P' \<parallel> (Q \<parallel> R'))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    next
      case(cBrMerge \<Psi>\<^sub>R Q' A\<^sub>Q \<Psi>\<^sub>Q R' A\<^sub>R)
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
      have "A\<^sub>Q \<sharp>* N" and "A\<^sub>R \<sharp>* N" and "A\<^sub>Q \<sharp>* M" and "A\<^sub>R \<sharp>* M"
        and "A\<^sub>Q \<sharp>* \<Psi>" and "A\<^sub>R \<sharp>* \<Psi>" and "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>P \<sharp>* A\<^sub>R"
        and "A\<^sub>Q \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>R \<sharp>* \<Psi>\<^sub>P"
        and "A\<^sub>Q \<sharp>* P" and "A\<^sub>R \<sharp>* P"
        by simp+

      have "A\<^sub>P \<sharp>* \<Psi>\<^sub>Q"
        by (metis extractFrameFreshChain freshFrameDest)
      from Aeq \<Psi>eq PTrans have "\<Psi> \<otimes> (\<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R) \<rhd> P \<longmapsto> \<questiondown>M\<lparr>N\<rparr> \<prec> P'" by simp
      then have "\<Psi> \<otimes> (\<Psi>\<^sub>R \<otimes> \<Psi>\<^sub>Q) \<rhd> P \<longmapsto> \<questiondown>M\<lparr>N\<rparr> \<prec> P'"
        by (metis Commutativity \<Psi>eq compositionSym statEqTransition)
      then have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto> \<questiondown>M\<lparr>N\<rparr> \<prec> P'"
        by (metis AssertionStatEqSym Associativity statEqTransition)
      moreover note FrP
        by (metis associativitySym statEqTransition)
        by (metis extractFrameFreshChain freshFrameDest)
      ultimately have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<rhd> (P \<parallel> Q) \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> (P' \<parallel> Q')"
        by(intro BrMerge) (assumption | force)+

        by (metis Associativity statEqTransition)

      have "extractFrame(P \<parallel> Q) = \<langle>(A\<^sub>P@A\<^sub>Q), (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q)\<rangle>" by simp
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> (P' \<parallel> Q') \<parallel> R'"
        by(auto intro: BrMerge)
      moreover have "(\<Psi>, (P' \<parallel> Q') \<parallel> R', (P' \<parallel> (Q' \<parallel> R'))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    qed
  next
    case(cBrComm1 \<Psi>\<^sub>Q\<^sub>R M N P' A\<^sub>P \<Psi>\<^sub>P xvec QR' A\<^sub>Q\<^sub>R)
    have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q\<^sub>R \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
    proof(induct rule: parCasesBrOutputFrame)
      case(cPar1 Q' A\<^sub>Q \<Psi>\<^sub>Q A\<^sub>R \<Psi>\<^sub>R)
        by simp+
        by simp+
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover note FrP
        by(metis statEqTransition Associativity Commutativity Composition)
      have "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>P \<sharp>* \<Psi>\<^sub>R" by(auto dest: extractFrameFreshChain)
      ultimately have "\<Psi> \<otimes> \<Psi>\<^sub>R \<rhd> P \<parallel> Q \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> (P' \<parallel> Q')"
        by(intro BrComm1) (assumption | force)+
        by(intro Par1) (assumption | simp)+
      moreover have "(\<Psi>, (P' \<parallel> Q') \<parallel> R, (P' \<parallel> (Q' \<parallel> R))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    next
      case(cPar2 R' A\<^sub>Q \<Psi>\<^sub>Q A\<^sub>R \<Psi>\<^sub>R)
        by simp+
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
      have "A\<^sub>R \<sharp>* \<Psi>" and "A\<^sub>R \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>P \<sharp>* A\<^sub>R" and "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>R \<sharp>* P" and "A\<^sub>Q \<sharp>* \<Psi>" and "A\<^sub>Q \<sharp>* \<Psi>\<^sub>P" by simp+
      have RTrans: "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<rhd> R \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> R'" and FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact+
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
        by(auto dest: extractFrameFreshChain)
        by(intro Par1) (assumption | force)+
      have "extractFrame(P \<parallel> Q) = \<langle>(A\<^sub>P@A\<^sub>Q), \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q\<rangle>" by simp+
      moreover from RTrans have "\<Psi> \<otimes> (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q) \<rhd> R \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> R'" by(metis Associativity statEqTransition)
      moreover note FrR
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> ((P' \<parallel> Q) \<parallel> R')"
        by(intro BrComm1) (assumption | simp)+
      moreover have "(\<Psi>, ((P' \<parallel> Q) \<parallel> R'), (P' \<parallel> (Q \<parallel> R'))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    next
      case(cBrComm1 \<Psi>\<^sub>R Q' A\<^sub>Q \<Psi>\<^sub>Q R' A\<^sub>R)
        by simp+
        by simp+
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
        by (metis extractFrameFreshChain freshChainSym freshFrameDest)
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover note FrP
        by(metis statEqTransition Associativity Commutativity Composition)
      have "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>P \<sharp>* \<Psi>\<^sub>R" by(auto dest: extractFrameFreshChain)
      ultimately have PQTrans: "\<Psi> \<otimes> \<Psi>\<^sub>R \<rhd> P \<parallel> Q \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> (P' \<parallel> Q')"
        by(intro BrMerge) (assumption | force)+
      have RTrans: "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<rhd> R \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> R'" and FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact+
      note PQTrans
      have "extractFrame(P \<parallel> Q) = \<langle>(A\<^sub>P@A\<^sub>Q), \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q\<rangle>" by simp+
      moreover from RTrans have "\<Psi> \<otimes> (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q) \<rhd> R \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> R'"
        by (metis Associativity statEqTransition)
      moreover note FrR
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> (P' \<parallel> Q') \<parallel> R'"
        by(intro BrComm1) (assumption | force)+
      moreover have "(\<Psi>, (P' \<parallel> Q') \<parallel> R', (P' \<parallel> (Q' \<parallel> R'))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    next
      case(cBrComm2 \<Psi>\<^sub>R Q' A\<^sub>Q \<Psi>\<^sub>Q R' A\<^sub>R)
        by simp+
        by simp+
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
        by (metis extractFrameFreshChain freshChainSym freshFrameDest)
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover note FrP
        by(metis statEqTransition Associativity Commutativity Composition)
      have "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>P \<sharp>* \<Psi>\<^sub>R" by(auto dest: extractFrameFreshChain)
      ultimately have PQTrans: "\<Psi> \<otimes> \<Psi>\<^sub>R \<rhd> P \<parallel> Q \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> (P' \<parallel> Q')"
        by(intro BrComm1) (assumption | force)+
      have RTrans: "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<rhd> R \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> R'" and FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact+
      note PQTrans
      have "extractFrame(P \<parallel> Q) = \<langle>(A\<^sub>P@A\<^sub>Q), \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q\<rangle>" by simp+
      moreover from RTrans have "\<Psi> \<otimes> (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q) \<rhd> R \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> R'"
        by (metis Associativity statEqTransition)
      moreover note FrR
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> (P' \<parallel> Q') \<parallel> R'"
        by(auto intro: BrComm2)
      moreover have "(\<Psi>, (P' \<parallel> Q') \<parallel> R', (P' \<parallel> (Q' \<parallel> R'))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    qed
  next
    case(cBrComm2 \<Psi>\<^sub>Q\<^sub>R M xvec N P' A\<^sub>P \<Psi>\<^sub>P QR' A\<^sub>Q\<^sub>R)
    have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q\<^sub>R \<rhd> P \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
    proof(induct rule: parCasesBrInputFrame)
      case(cPar1 Q' A\<^sub>Q \<Psi>\<^sub>Q A\<^sub>R \<Psi>\<^sub>R)
        by simp+
        by simp+
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover note FrP
        by(metis statEqTransition Associativity Commutativity Composition)
      have "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>P \<sharp>* \<Psi>\<^sub>R" by(auto dest: extractFrameFreshChain)
      ultimately have "\<Psi> \<otimes> \<Psi>\<^sub>R \<rhd> P \<parallel> Q \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> (P' \<parallel> Q')"
        by(intro BrComm2) (assumption | force)+
        by(intro Par1) (assumption | simp)+
      moreover have "(\<Psi>, (P' \<parallel> Q') \<parallel> R, (P' \<parallel> (Q' \<parallel> R))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    next
      case(cPar2 R' A\<^sub>Q \<Psi>\<^sub>Q A\<^sub>R \<Psi>\<^sub>R)
        by simp+
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
      have "A\<^sub>R \<sharp>* \<Psi>" and "A\<^sub>R \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>P \<sharp>* A\<^sub>R" and "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>R \<sharp>* P" and "A\<^sub>Q \<sharp>* \<Psi>" and "A\<^sub>Q \<sharp>* \<Psi>\<^sub>P" by simp+
      have RTrans: "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<rhd> R \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> R'" and FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact+
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
        by(auto dest: extractFrameFreshChain)
        by(intro Par1) (assumption | force)+
      have "extractFrame(P \<parallel> Q) = \<langle>(A\<^sub>P@A\<^sub>Q), \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q\<rangle>" by simp+
      moreover from RTrans have "\<Psi> \<otimes> (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q) \<rhd> R \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> R'" by(metis Associativity statEqTransition)
      moreover note FrR
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> ((P' \<parallel> Q) \<parallel> R')"
        by(auto intro: BrComm2)
      moreover have "(\<Psi>, ((P' \<parallel> Q) \<parallel> R'), (P' \<parallel> (Q \<parallel> R'))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    next
      case(cBrMerge \<Psi>\<^sub>R Q' A\<^sub>Q \<Psi>\<^sub>Q R' A\<^sub>R)
        by simp+
        by simp+
      have Aeq: "A\<^sub>Q\<^sub>R = A\<^sub>Q@A\<^sub>R" and \<Psi>eq: "\<Psi>\<^sub>Q\<^sub>R = \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>R" by fact+
        by (metis extractFrameFreshChain freshChainSym freshFrameDest)
      from PTrans \<Psi>eq have "(\<Psi> \<otimes> \<Psi>\<^sub>R) \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'"
        by(metis statEqTransition Associativity Commutativity Composition)
      moreover note FrP
        by(metis statEqTransition Associativity Commutativity Composition)
      have "A\<^sub>P \<sharp>* A\<^sub>Q" and "A\<^sub>P \<sharp>* \<Psi>\<^sub>R" by(auto dest: extractFrameFreshChain)
      ultimately have PQTrans: "\<Psi> \<otimes> \<Psi>\<^sub>R \<rhd> P \<parallel> Q \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> (P' \<parallel> Q')"
        by(intro BrComm2) (assumption | force)+
      have RTrans: "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<rhd> R \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> R'" and FrR: "extractFrame R = \<langle>A\<^sub>R, \<Psi>\<^sub>R\<rangle>" by fact+
      note PQTrans
      have "extractFrame(P \<parallel> Q) = \<langle>(A\<^sub>P@A\<^sub>Q), \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q\<rangle>" by simp+
      moreover from RTrans have "\<Psi> \<otimes> (\<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q) \<rhd> R \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> R'"
        by (metis Associativity statEqTransition)
      moreover note FrR
      ultimately have "\<Psi> \<rhd> (P \<parallel> Q) \<parallel> R \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> (P' \<parallel> Q') \<parallel> R'"
        by(auto intro: BrComm2)
      moreover have "(\<Psi>, (P' \<parallel> Q') \<parallel> R', (P' \<parallel> (Q' \<parallel> R'))) \<in> Rel"
        by(rule C1)
      ultimately show ?case by blast
    qed
  qed
qed

lemma parNilLeft:
  fixes \<Psi> :: 'b
    and P   :: "('a, 'b, 'c) psi"
    and Rel :: "('b \<times> ('a, 'b, 'c) psi \<times> ('a, 'b, 'c) psi) set"

assumes "eqvt Rel"
  and   C1: "\<And>Q. (\<Psi>, Q \<parallel> \<zero>, Q) \<in> Rel"

shows "\<Psi> \<rhd> (P \<parallel> \<zero>) \<leadsto>[Rel] P"
proof(induct rule: simI[of _ _ _ _ "()"])
  case(cSim \<alpha> P')
    by(metis statEqTransition Identity AssertionStatEqSym)
  then have "\<Psi> \<rhd> (P \<parallel> \<zero>) \<longmapsto>\<alpha> \<prec> (P' \<parallel> \<zero>)"
    by(rule Par1) auto
  moreover have "(\<Psi>, P' \<parallel> \<zero>, P') \<in> Rel" by(rule C1)
  ultimately show ?case by blast
qed

lemma parNilRight:
  fixes \<Psi> :: 'b
    and P   :: "('a, 'b, 'c) psi"
    and Rel :: "('b \<times> ('a, 'b, 'c) psi \<times> ('a, 'b, 'c) psi) set"

assumes "eqvt Rel"
  and   C1: "\<And>Q. (\<Psi>, Q, (Q \<parallel> \<zero>)) \<in> Rel"

shows "\<Psi> \<rhd> P \<leadsto>[Rel] (P \<parallel> \<zero>)"
proof(induct rule: simI[of _ _ _ _ "()"])
  case(cSim \<alpha> P')
  moreover have "bn \<alpha> \<sharp>* \<zero>" by simp
  proof(induct rule: parCases[where C="()"])
    case(cPar1 P' A\<^sub>Q \<Psi>\<^sub>Q)
      by(metis statEqTransition Identity)
    moreover have "(\<Psi>, P', P' \<parallel> \<zero>) \<in> Rel" by(rule C1)
    ultimately show ?case by blast
  next
    case(cPar2 Q' A\<^sub>P \<Psi>\<^sub>P)
      by auto
    then show ?case by simp
  next
    case(cComm1 \<Psi>\<^sub>Q M N P' A\<^sub>P \<Psi>\<^sub>P K xvec Q' A\<^sub>Q)
    then show ?case by simp
  next
    case(cComm2 \<Psi>\<^sub>Q M xvec N P' A\<^sub>P \<Psi>\<^sub>P K Q' A\<^sub>Q)
      by auto
    then show ?case by simp
  next
    case(cBrMerge \<Psi>\<^sub>Q M N P' A\<^sub>P \<Psi>\<^sub>P Q' A\<^sub>Q)
      by auto
    then show ?case by simp
  next
    case(cBrComm1 \<Psi>\<^sub>Q M N P' A\<^sub>P \<Psi>\<^sub>P xvec Q' A\<^sub>Q)
      by auto
    then show ?case by simp
  next
    case(cBrComm2 \<Psi>\<^sub>Q M xvec N P' A\<^sub>P \<Psi>\<^sub>P Q' A\<^sub>Q)
      by auto
    then show ?case by simp
  qed
qed

lemma resNilLeft:
  fixes x   :: name
    and \<Psi>   :: 'b
    and Rel :: "('b \<times> ('a, 'b, 'c) psi \<times> ('a, 'b, 'c) psi) set"

shows "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>\<zero> \<leadsto>[Rel] \<zero>"
  by(auto simp add: simulation_def)

lemma resNilRight:
  fixes x   :: name
    and \<Psi>   :: 'b
    and Rel :: "('b \<times> ('a, 'b, 'c) psi \<times> ('a, 'b, 'c) psi) set"

shows "\<Psi> \<rhd> \<zero> \<leadsto>[Rel] \<lparr>\<nu>x\<rparr>\<zero>"
  apply(clarsimp simp add: simulation_def)
  by(cases rule: semantics.cases) (auto simp add: psi.inject alpha')

lemma inputPushResLeft:
  fixes \<Psi>   :: 'b
    and x    :: name
    and M    :: 'a
    and xvec :: "name list"
    and N    :: 'a
    and P    :: "('a, 'b, 'c) psi"

assumes "eqvt Rel"
  and   "x \<sharp> \<Psi>"
  and   "x \<sharp> M"
  and   "x \<sharp> xvec"
  and   "x \<sharp> N"
  and   C1: "\<And>Q. (\<Psi>, Q, Q) \<in> Rel"

shows "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(M\<lparr>\<lambda>*xvec N\<rparr>.P) \<leadsto>[Rel] M\<lparr>\<lambda>*xvec N\<rparr>.\<lparr>\<nu>x\<rparr>P"
proof -
  moreover have "x \<sharp> \<lparr>\<nu>x\<rparr>(M\<lparr>\<lambda>*xvec N\<rparr>.P)" by(simp add: abs_fresh)
    by(auto simp add: inputChainFresh abs_fresh)
  ultimately show ?thesis
  proof(induct rule: simIFresh[of _ _ _ _ _ "()"])
    case(cSim \<alpha> P')
    proof(induct rule: inputCases)
      case(cInput K Tvec)
      have "\<Psi> \<rhd> M\<lparr>\<lambda>*xvec N\<rparr>.P \<longmapsto>K\<lparr>(N[xvec::=Tvec])\<rparr> \<prec> P[xvec::=Tvec]"
        by(rule Input)
        by(intro Scope) auto
        by(rule substTerm.subst3)
        by(force intro: C1)
      ultimately show ?case by blast
    next
      case(cBrInput K Tvec)
      have "\<Psi> \<rhd> M\<lparr>\<lambda>*xvec N\<rparr>.P \<longmapsto>\<questiondown>K\<lparr>(N[xvec::=Tvec])\<rparr> \<prec> P[xvec::=Tvec]"
        by(rule BrInput)
        by(intro Scope) auto
        by(rule substTerm.subst3)
        by(force intro: C1)
      ultimately show ?case by blast
    qed
  qed
qed

lemma inputPushResRight:
  fixes \<Psi>   :: 'b
    and x    :: name
    and M    :: 'a
    and xvec :: "name list"
    and N    :: 'a
    and P    :: "('a, 'b, 'c) psi"

assumes "eqvt Rel"
  and   "x \<sharp> \<Psi>"
  and   "x \<sharp> M"
  and   "x \<sharp> xvec"
  and   "x \<sharp> N"
  and   C1: "\<And>Q. (\<Psi>, Q, Q) \<in> Rel"

shows "\<Psi> \<rhd> M\<lparr>\<lambda>*xvec N\<rparr>.\<lparr>\<nu>x\<rparr>P \<leadsto>[Rel] \<lparr>\<nu>x\<rparr>(M\<lparr>\<lambda>*xvec N\<rparr>.P)"
proof -
    by(auto simp add: inputChainFresh abs_fresh)
  moreover have "x \<sharp> \<lparr>\<nu>x\<rparr>(M\<lparr>\<lambda>*xvec N\<rparr>.P)" by(simp add: abs_fresh)
  ultimately show ?thesis
  proof(induct rule: simIFresh[of _ _ _ _ _ "()"])
    case(cSim \<alpha> P')
      by simp
    proof(induct rule: resCases[where C="()"])
      case(cRes P')
      proof(induct rule: inputCases)
        case(cInput K Tvec)
        have "\<Psi> \<rhd> M\<lparr>\<lambda>*xvec N\<rparr>.(\<lparr>\<nu>x\<rparr>P) \<longmapsto>K\<lparr>(N[xvec::=Tvec])\<rparr> \<prec> (\<lparr>\<nu>x\<rparr>P)[xvec::=Tvec]"
          by(rule Input)
          by(rule substTerm.subst3)
          by(force intro: C1)
        ultimately show ?case by blast
      next
        case(cBrInput K Tvec)
        have "\<Psi> \<rhd> M\<lparr>\<lambda>*xvec N\<rparr>.(\<lparr>\<nu>x\<rparr>P) \<longmapsto>\<questiondown>K\<lparr>(N[xvec::=Tvec])\<rparr> \<prec> (\<lparr>\<nu>x\<rparr>P)[xvec::=Tvec]"
          by(rule BrInput)
          by(rule substTerm.subst3)
          by(force intro: C1)
        ultimately show ?case by blast
      qed
    next
      case cOpen
      then have False by auto
      then show ?case by simp
    next
      case cBrOpen
      then have False by auto
      then show ?case by simp
    next
      case (cBrClose M xvec N P')
      then have False by auto
      then show ?case by simp
    qed
  qed
qed

lemma outputPushResLeft:
  fixes \<Psi>   :: 'b
    and x    :: name
    and M    :: 'a
    and N    :: 'a
    and P    :: "('a, 'b, 'c) psi"

assumes "eqvt Rel"
  and   "x \<sharp> \<Psi>"
  and   "x \<sharp> M"
  and   "x \<sharp> N"
  and   C1: "\<And>Q. (\<Psi>, Q, Q) \<in> Rel"

shows "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(M\<langle>N\<rangle>.P) \<leadsto>[Rel] M\<langle>N\<rangle>.\<lparr>\<nu>x\<rparr>P"
proof -
  moreover have "x \<sharp> \<lparr>\<nu>x\<rparr>(M\<langle>N\<rangle>.P)" by(simp add: abs_fresh)
    by(auto simp add: abs_fresh)
  ultimately show ?thesis
  proof(induct rule: simIFresh[of _ _ _ _ _ "()"])
    case(cSim \<alpha> P')
    show ?case
    proof(induct rule: outputCases)
      case(cOutput K)
        by(rule Output)
        by(rule Scope)
      moreover have "(\<Psi>, \<lparr>\<nu>x\<rparr>P, \<lparr>\<nu>x\<rparr>P) \<in> Rel" by(rule C1)
      ultimately show ?case by blast
    next
      case(cBrOutput K)
        by(rule BrOutput)
        by(rule Scope)
      moreover have "(\<Psi>, \<lparr>\<nu>x\<rparr>P, \<lparr>\<nu>x\<rparr>P) \<in> Rel" by(rule C1)
      ultimately show ?case by blast
    qed
  qed
qed

lemma broutputNoBind:
  fixes \<Psi> :: 'b
    and M  :: 'a
    and N  :: 'a
    and P  :: "('a, 'b, 'c) psi"
    and \<alpha>  :: "'a action"
    and P' :: "('a, 'b, 'c) psi"

assumes "\<Psi> \<rhd> M\<langle>N\<rangle>.P \<longmapsto>(\<exclamdown>K\<lparr>\<nu>*xvec\<rparr>\<langle>N'\<rangle>) \<prec> P'"
shows "xvec = []"
proof -
  from assms have "bn(\<exclamdown>K\<lparr>\<nu>*xvec\<rparr>\<langle>N'\<rangle>) = []"
    by(induct rule: outputCases) auto
  then show ?thesis by simp
qed

lemma broutputObjectEq:
  fixes \<Psi> :: 'b
    and M  :: 'a
    and N  :: 'a
    and P  :: "('a, 'b, 'c) psi"
    and \<alpha>  :: "'a action"
    and P' :: "('a, 'b, 'c) psi"

assumes "\<Psi> \<rhd> M\<langle>N\<rangle>.P \<longmapsto>(\<exclamdown>K\<lparr>\<nu>*xvec\<rparr>\<langle>N'\<rangle>) \<prec> P'"
shows "N = N'"
proof -
  from assms have "object(\<exclamdown>K\<lparr>\<nu>*xvec\<rparr>\<langle>N'\<rangle>) = Some N"
    by(induct rule: outputCases) auto
  then show ?thesis
    by simp
qed

lemma brOutputOutputCases[consumes 1, case_names cBrOutput]:
  fixes \<Psi> :: 'b
    and M  :: 'a
    and N  :: 'a
    and P  :: "('a, 'b, 'c) psi"
    and \<alpha>  :: "'a action"
    and P' :: "('a, 'b, 'c) psi"

assumes Trans: "\<Psi> \<rhd> M\<langle>N\<rangle>.P \<longmapsto>(\<exclamdown>K\<lparr>\<nu>*xvec\<rparr>\<langle>N'\<rangle>) \<prec> P'"
  and   rBrOutput: "\<And>K. \<Psi> \<turnstile> M \<preceq> K \<Longrightarrow> Prop (\<exclamdown>K\<langle>N\<rangle>) P"

shows "Prop (\<exclamdown>K\<lparr>\<nu>*xvec\<rparr>\<langle>N'\<rangle>) P'"
proof -
  have "xvec = []" using Trans by(rule broutputNoBind)
  then obtain K' N'' where eq: "(\<exclamdown>K\<lparr>\<nu>*xvec\<rparr>\<langle>N'\<rangle>)= \<exclamdown>K'\<langle>N''\<rangle>"
    by blast
  have "N = N'" using Trans by(rule broutputObjectEq)
  proof(induct rule: outputCases)
    case (cOutput K) then show ?case by simp
  next
    case (cBrOutput K) then show ?case
      by(intro rBrOutput)
  qed
qed

lemma outputPushResRight:
  fixes \<Psi>   :: 'b
    and x    :: name
    and M    :: 'a
    and N    :: 'a
    and P    :: "('a, 'b, 'c) psi"

assumes "eqvt Rel"
  and   "x \<sharp> \<Psi>"
  and   "x \<sharp> M"
  and   "x \<sharp> N"
  and   C1: "\<And>Q. (\<Psi>, Q, Q) \<in> Rel"

shows "\<Psi> \<rhd> M\<langle>N\<rangle>.\<lparr>\<nu>x\<rparr>P \<leadsto>[Rel] \<lparr>\<nu>x\<rparr>(M\<langle>N\<rangle>.P)"
proof -
    by(auto simp add: abs_fresh)
  moreover have "x \<sharp> \<lparr>\<nu>x\<rparr>(M\<langle>N\<rangle>.P)" by(simp add: abs_fresh)
  ultimately show ?thesis
  proof(induct rule: simIFresh[of _ _ _ _ _ "(M, N)"])
    case(cSim \<alpha> P')
    proof(induct rule: resCases[where C="()"])
      case(cOpen K xvec1 xvec2 y N' P')
      have "N = ([(x, y)] \<bullet> N')"
        apply -
        by(ind_cases "\<Psi> \<rhd> M\<langle>N\<rangle>.P \<longmapsto>K\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N')\<rangle> \<prec> ([(x, y)] \<bullet> P')")
          (auto simp add: residualInject psi.inject)
        by(subst pt_bij[OF pt_name_inst, OF at_name_inst, symmetric, where pi="[(x, y)]"])
          (simp add: fresh_left calc_atm)
      then show ?case by simp
    next
      case(cBrOpen K xvec1 xvec2 y N' P')
      have "N = ([(x, y)] \<bullet> N')"
        apply -
        by(ind_cases "\<Psi> \<rhd> M\<langle>N\<rangle>.P \<longmapsto>\<exclamdown>K\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N')\<rangle> \<prec> ([(x, y)] \<bullet> P')")
          (auto simp add: residualInject psi.inject)
        by(subst pt_bij[OF pt_name_inst, OF at_name_inst, symmetric, where pi="[(x, y)]"])
          (simp add: fresh_left calc_atm)
      then show ?case by simp
    next
      case(cRes P')
      proof(induct rule: outputCases)
        case(cOutput K)
          by(rule Output)
        moreover have "(\<Psi>, \<lparr>\<nu>x\<rparr>P, \<lparr>\<nu>x\<rparr>P) \<in> Rel" by(rule C1)
        ultimately show ?case by force
      next
        case(cBrOutput K)
          by(rule BrOutput)
        moreover have "(\<Psi>, \<lparr>\<nu>x\<rparr>P, \<lparr>\<nu>x\<rparr>P) \<in> Rel" by(rule C1)
        ultimately show ?case by force
      qed
    next
      case(cBrClose K xvec N' P')
      have "\<Psi> \<turnstile> M \<preceq> the(subject(\<exclamdown>K\<lparr>\<nu>*xvec\<rparr>\<langle>N'\<rangle>))"
        by(rule brOutputOutputCases) simp
      then have "\<Psi> \<turnstile> M \<preceq> K" by simp
      then have "supp K \<subseteq> (supp M:: name set)" by(rule chanOutConSupp)
        by blast
      then show ?case by(rule FalseE)
    qed
  qed
qed

lemma casePushResLeft:
  fixes \<Psi>  :: 'b
    and x  :: name
    and Cs :: "('c \<times> ('a, 'b, 'c) psi) list"

assumes "eqvt Rel"
  and   "x \<sharp> \<Psi>"
  and   "x \<sharp> map fst Cs"
  and   C1: "\<And>Q. (\<Psi>, Q, Q) \<in> Rel"

shows "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(Cases Cs) \<leadsto>[Rel] Cases (map (\<lambda>(\<phi>, P). (\<phi>, \<lparr>\<nu>x\<rparr>P)) Cs)"
proof -
  moreover have "x \<sharp> \<lparr>\<nu>x\<rparr>(Cases Cs)" by(simp add: abs_fresh)
    by(induct Cs) (auto simp add: abs_fresh)
  ultimately show ?thesis
  proof(induct rule: simIFresh[of _ _ _ _ _ Cs])
    case(cSim \<alpha> P'')
    show ?case
    proof(induct rule: caseCases)
      case(cCase \<phi> P')
      obtain P where "(\<phi>, P) \<in> set Cs" and "P' = \<lparr>\<nu>x\<rparr>P"
        by(induct Cs) auto
        by simp
      have "bn \<alpha> \<sharp>* P" by(auto dest: memFreshChain)
      proof(induct rule: resCases[where C="()"])
        case(cOpen M xvec1 xvec2 y N P')
        have "\<Psi> \<rhd> Cases Cs \<longmapsto>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> ([(x, y)] \<bullet> P')" by(rule Case)
        then have "([(x, y)] \<bullet> \<Psi>) \<rhd> ([(x, y)] \<bullet> (Cases Cs))  \<longmapsto>([(x, y)] \<bullet> (M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> ([(x, y)] \<bullet> P')))"
          by(rule semantics.eqvt)
        have "\<Psi> \<rhd> ([(x, y)] \<bullet> (Cases Cs))  \<longmapsto>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>N\<rangle> \<prec> P'" by(simp add: eqvts)
          by(rule Open)
          by(simp add: alphaRes)
        moreover have "(\<Psi>, P', P') \<in> Rel" by(rule C1)
        ultimately show ?case by blast
      next
        case(cBrOpen M xvec1 xvec2 y N P')
        have "\<Psi> \<rhd> Cases Cs \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> ([(x, y)] \<bullet> P')" by(rule Case)
        then have "([(x, y)] \<bullet> \<Psi>) \<rhd> ([(x, y)] \<bullet> (Cases Cs))  \<longmapsto>([(x, y)] \<bullet> (\<exclamdown>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> ([(x, y)] \<bullet> P')))"
          by(rule semantics.eqvt)
        have "\<Psi> \<rhd> ([(x, y)] \<bullet> (Cases Cs))  \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>N\<rangle> \<prec> P'" by(simp add: eqvts)
          by(rule BrOpen)
          by(simp add: alphaRes)
        moreover have "(\<Psi>, P', P') \<in> Rel" by(rule C1)
        ultimately show ?case by blast
      next
        case(cRes P')
        have "\<Psi> \<rhd> Cases Cs \<longmapsto>\<alpha> \<prec> P'" by(rule Case)
          by(rule Scope)
        moreover have "(\<Psi>, \<lparr>\<nu>x\<rparr>P', \<lparr>\<nu>x\<rparr>P') \<in> Rel" by(rule C1)
        ultimately show ?case by blast
      next
        case(cBrClose M xvec N P')
        have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>P \<longmapsto> \<tau> \<prec> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>P')"
          by(rule BrClose)
        have "\<Psi> \<rhd> Cases Cs \<longmapsto> \<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'"
          by(rule Case)
          by(rule BrClose)
        moreover have "(\<Psi>,\<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>P'),\<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>P')) \<in> Rel" by fact
        ultimately show ?case by blast
      qed
    qed
  qed
qed

lemma casePushResRight:
  fixes \<Psi>  :: 'b
    and x  :: name
    and Cs :: "('c \<times> ('a, 'b, 'c) psi) list"

assumes "eqvt Rel"
  and   "x \<sharp> \<Psi>"
  and   "x \<sharp> map fst Cs"
  and   C1: "\<And>Q. (\<Psi>, Q, Q) \<in> Rel"

shows "\<Psi> \<rhd> Cases (map (\<lambda>(\<phi>, P). (\<phi>, \<lparr>\<nu>x\<rparr>P)) Cs) \<leadsto>[Rel] \<lparr>\<nu>x\<rparr>(Cases Cs)"
proof -
    by(induct Cs) (auto simp add: abs_fresh)
  moreover have "x \<sharp> \<lparr>\<nu>x\<rparr>(Cases Cs)" by(simp add: abs_fresh)
  ultimately show ?thesis
  proof(induct rule: simIFresh[of _ _ _ _ _ Cs])
    case(cSim \<alpha> P'')
    proof(induct rule: resCases[where C="()"])
      case(cOpen M xvec1 xvec2 y N P')
      show ?case
      proof(induct rule: caseCases)
        case(cCase \<phi> P)
        have "([(x, y)] \<bullet> \<Psi>) \<rhd> ([(x, y)] \<bullet> P)  \<longmapsto>([(x, y)] \<bullet> (M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> ([(x, y)] \<bullet> P')))"
          by(rule semantics.eqvt)
        have "\<Psi> \<rhd> ([(x, y)] \<bullet> P)  \<longmapsto>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>N\<rangle> \<prec> P'" by(simp add: eqvts)
          by(rule Open)
          by(subst alphaRes, auto dest: memFresh)
          by(induct Cs) auto
        ultimately have "\<Psi> \<rhd> (Cases (map (\<lambda>(\<phi>, P). (\<phi>, \<lparr>\<nu>x\<rparr>P)) Cs)) \<longmapsto>M\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>\<langle>N\<rangle> \<prec> P'"
          by(rule Case)
        moreover have "(\<Psi>, P', P') \<in> Rel" by(rule C1)
        ultimately show ?case by blast
      qed
    next
      case(cBrOpen M xvec1 xvec2 y N P')
      show ?case
      proof(induct rule: caseCases)
        case(cCase \<phi> P)
        have "([(x, y)] \<bullet> \<Psi>) \<rhd> ([(x, y)] \<bullet> P) \<longmapsto>([(x, y)] \<bullet> (\<exclamdown>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> ([(x, y)] \<bullet> P')))"
          by(rule semantics.eqvt)
        have "\<Psi> \<rhd> ([(x, y)] \<bullet> P)  \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>N\<rangle> \<prec> P'" by(simp add: eqvts)
          by(rule BrOpen)
          by(subst alphaRes, auto dest: memFresh)
          by(induct Cs) auto
        ultimately have "\<Psi> \<rhd> (Cases (map (\<lambda>(\<phi>, P). (\<phi>, \<lparr>\<nu>x\<rparr>P)) Cs)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>\<langle>N\<rangle> \<prec> P'"
          by(rule Case)
        moreover have "(\<Psi>, P', P') \<in> Rel" by(rule C1)
        ultimately show ?case by blast
      qed
    next
      case(cRes P')
      show ?case
      proof(induct rule: caseCases)
        case(cCase \<phi> P)
        have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>P \<longmapsto>\<alpha> \<prec> \<lparr>\<nu>x\<rparr>P'" by(rule Scope)
          by(induct Cs) auto
        ultimately have "\<Psi> \<rhd> (Cases (map (\<lambda>(\<phi>, P). (\<phi>, \<lparr>\<nu>x\<rparr>P)) Cs)) \<longmapsto>\<alpha> \<prec> \<lparr>\<nu>x\<rparr>P'"
          by(rule Case)
        moreover have "(\<Psi>, \<lparr>\<nu>x\<rparr>P', \<lparr>\<nu>x\<rparr>P') \<in> Rel" by(rule C1)
        ultimately show ?case by blast
      qed
    next
      case(cBrClose M xvec N P')
      then show ?case
      proof(induct rule: caseCases)
        case(cCase \<phi> P)
        have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>P \<longmapsto> \<tau> \<prec> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>P')"
          by(intro BrClose)
          by(induct Cs) auto
        ultimately have "\<Psi> \<rhd> Cases map (\<lambda>(\<phi>, P). (\<phi>, \<lparr>\<nu>x\<rparr>P)) Cs \<longmapsto> \<tau> \<prec> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>P')"
          by(intro Case)
        moreover have "(\<Psi>,\<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>P'),\<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>P')) \<in> Rel"
          by fact
        ultimately show ?case
          by blast
      qed
    qed
  qed
qed

lemma resInputCases[consumes 5, case_names cRes]:
  fixes \<Psi>    :: 'b
    and x    :: name
    and P    :: "('a, 'b, 'c) psi"
    and M    :: 'a
    and N    :: 'a
    and P'   :: "('a, 'b, 'c) psi"
    and C    :: "'d::fs_name"

assumes Trans: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>P \<longmapsto>M\<lparr>N\<rparr> \<prec> P'"
  and   "x \<sharp> \<Psi>"
  and   "x \<sharp> M"
  and   "x \<sharp> N"
  and   "x \<sharp> P'"
  and   rScope:  "\<And>P'. \<lbrakk>\<Psi> \<rhd> P \<longmapsto>M\<lparr>N\<rparr> \<prec> P'\<rbrakk> \<Longrightarrow> Prop (\<lparr>\<nu>x\<rparr>P')"

shows "Prop P'"
proof -
  ultimately show ?thesis using assms
    by(induct rule: resInputCases') simp
qed

lemma resBrInputCases[consumes 5, case_names cRes]:
  fixes \<Psi>    :: 'b
    and x    :: name
    and P    :: "('a, 'b, 'c) psi"
    and M    :: 'a
    and N    :: 'a
    and P'   :: "('a, 'b, 'c) psi"
    and C    :: "'d::fs_name"

assumes Trans: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'"
  and   "x \<sharp> \<Psi>"
  and   "x \<sharp> M"
  and   "x \<sharp> N"
  and   "x \<sharp> P'"
  and   rScope:  "\<And>P'. \<lbrakk>\<Psi> \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'\<rbrakk> \<Longrightarrow> Prop (\<lparr>\<nu>x\<rparr>P')"

shows "Prop P'"
proof -
  ultimately show ?thesis using assms
    by(induct rule: resBrInputCases') simp
qed

lemma swap_supp:
  fixes x   :: name
    and y   :: name
    and N   :: 'a

assumes "y \<in> supp N"

shows "x \<in> supp ([(x, y)] \<bullet> N)"
  using assms
  by (metis fresh_bij fresh_def swap_simps(2))

lemma swap_supp':
  fixes x   :: name
    and y   :: name
    and N   :: 'a

assumes "x \<in> supp N"

shows "y \<in> supp ([(x, y)] \<bullet> N)"
  using assms
  by (metis fresh_bij fresh_def swap_simps(1))

lemma brOutputFreshSubjectChain:
  fixes \<Psi>   :: 'b
    and Q   :: "('a, 'b, 'c) psi"
    and M   :: 'a
    and xvec :: "name list"
    and N   :: 'a
    and Q'  :: "('a, 'b, 'c) psi"
    and yvec :: "name list"

assumes "\<Psi> \<rhd> Q \<longmapsto> \<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> Q'"
  and "xvec \<sharp>* M"
  and "yvec \<sharp>* Q"

shows "yvec \<sharp>* M"
  using assms
proof(induct yvec)
  case Nil
  then show ?case by simp
next
  case(Cons a yvec)
  then have "yvec \<sharp>* M" by simp
  have "a \<sharp> M"
    by(simp add: brOutputFreshSubject)
    by simp
qed

lemma scopeExtLeft:
  fixes x   :: name
    and P   :: "('a, 'b, 'c) psi"
    and \<Psi>   :: 'b
    and Q   :: "('a, 'b, 'c) psi"
    and Rel :: "('b \<times> ('a, 'b, 'c) psi \<times> ('a, 'b, 'c) psi) set"

assumes "x \<sharp> P"
  and   "x \<sharp> \<Psi>"
  and   "eqvt Rel"
  and   C1: "\<And>\<Psi>' R. (\<Psi>', R, R) \<in> Rel"
  and   C2: "\<And>y \<Psi>' R S zvec. \<lbrakk>y \<sharp> \<Psi>'; y \<sharp> R; zvec \<sharp>* \<Psi>'\<rbrakk> \<Longrightarrow> (\<Psi>', \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*zvec\<rparr>(R \<parallel> S)), \<lparr>\<nu>*zvec\<rparr>(R \<parallel> \<lparr>\<nu>y\<rparr>S)) \<in> Rel"
  and   C3: "\<And>\<Psi>' zvec R y. \<lbrakk>y \<sharp> \<Psi>'; zvec \<sharp>* \<Psi>'\<rbrakk> \<Longrightarrow> (\<Psi>', \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*zvec\<rparr>R), \<lparr>\<nu>*zvec\<rparr>(\<lparr>\<nu>y\<rparr>R)) \<in> Rel"
  and   C4: "\<And>\<Psi>' R S zvec. \<lbrakk>zvec \<sharp>* R; zvec \<sharp>* \<Psi>'\<rbrakk> \<Longrightarrow> (\<Psi>', (\<lparr>\<nu>*zvec\<rparr>(R \<parallel> S)), (R \<parallel> (\<lparr>\<nu>*zvec\<rparr>S))) \<in> Rel"

shows "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<leadsto>[Rel] P \<parallel> \<lparr>\<nu>x\<rparr>Q"
proof -
  moreover have "x \<sharp> \<lparr>\<nu>x\<rparr>(P \<parallel> Q)" by(simp add: abs_fresh)
  ultimately show ?thesis
  proof(induct rule: simIFresh[of _ _ _ _ _ x])
    case(cSim \<alpha> PQ)
    proof(induct rule: parCases[where C=x])
      case(cPar1 P' A\<^sub>Q \<Psi>\<^sub>Q)
      have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<alpha> \<prec> P'" by fact
      then obtain y A\<^sub>Q' where A: "A\<^sub>Q = y#A\<^sub>Q'" by(cases A\<^sub>Q) auto
      have "A\<^sub>Q' \<sharp>* \<Psi>" and "A\<^sub>Q' \<sharp>* P" and "A\<^sub>Q' \<sharp>* \<alpha>"
        and "y \<sharp> \<Psi>" and "y \<sharp> P" and "y \<sharp> \<alpha>"
        by simp+
        by(auto intro: freeFreshDerivative)
      note PTrans
        by(simp add: frame.inject alpha' fresh_list_cons eqvts)
        by(simp add: pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst])
      ultimately have "\<Psi> \<rhd> P \<parallel> ([(y, x)] \<bullet> Q) \<longmapsto>\<alpha> \<prec> (P' \<parallel> ([(y, x)] \<bullet> Q))"
        by(rule Par1)
      then have "\<Psi> \<rhd> \<lparr>\<nu>y\<rparr>(P \<parallel> ([(y, x)] \<bullet> Q)) \<longmapsto>\<alpha> \<prec> \<lparr>\<nu>y\<rparr>(P' \<parallel> ([(y, x)] \<bullet> Q))"
        by(rule Scope)
      then have "([(y, x)] \<bullet> \<Psi>) \<rhd> ([(y, x)] \<bullet> (\<lparr>\<nu>y\<rparr>(P \<parallel> ([(y, x)] \<bullet> Q)))) \<longmapsto>([(y, x)] \<bullet> (\<alpha> \<prec> \<lparr>\<nu>y\<rparr>(P' \<parallel> ([(y, x)] \<bullet> Q))))"
        by(rule semantics.eqvt)
      have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto>\<alpha> \<prec> \<lparr>\<nu>x\<rparr>(P' \<parallel> Q)"
        by(simp add: eqvts calc_atm)
        by(rule C2) auto
      ultimately show ?case
        by force
    next
      case(cPar2 xQ' A\<^sub>P \<Psi>\<^sub>P)
      moreover have FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact
        by(force dest: extractFrameFresh)+
        by(auto dest: extractFrameFreshChain)
      proof(induct rule: resCases'[where C="(P, A\<^sub>P, \<Psi>)"])
        case(cOpen M xvec1 xvec2 y N Q')
        ultimately have "\<Psi> \<rhd> P \<parallel> ([(x, y)] \<bullet> Q) \<longmapsto>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>N\<rangle> \<prec> (P \<parallel> Q')"
          by(intro Par2) (assumption | simp)+
        then have "\<Psi> \<rhd> \<lparr>\<nu>y\<rparr>(P \<parallel> ([(x, y)] \<bullet> Q)) \<longmapsto>M\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>\<langle>N\<rangle> \<prec> (P \<parallel> Q')"
          by(rule Open)
          by(subst alphaRes[where y=y]) (simp add: fresh_left calc_atm eqvts)+
        moreover have "(\<Psi>, P \<parallel> Q', P \<parallel> Q') \<in> Rel" by(rule C1)
        ultimately show ?case by blast
      next
        case(cBrOpen M xvec1 xvec2 y N Q')
        ultimately have "\<Psi> \<rhd> P \<parallel> ([(x, y)] \<bullet> Q) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>N\<rangle> \<prec> (P \<parallel> Q')"
          by(intro Par2) (assumption | simp)+
        then have "\<Psi> \<rhd> \<lparr>\<nu>y\<rparr>(P \<parallel> ([(x, y)] \<bullet> Q)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>\<langle>N\<rangle> \<prec> (P \<parallel> Q')"
          by(rule BrOpen)
          by(subst alphaRes[where y=y]) (simp add: fresh_left calc_atm eqvts)+
        moreover have "(\<Psi>, P \<parallel> Q', P \<parallel> Q') \<in> Rel" by(rule C1)
        ultimately show ?case by blast
      next
        case(cRes Q')
          by(rule Par2)
          by(rule Scope)
          by(rule C2) auto
        ultimately show ?case
          by force
      next
        case(cBrClose M xvec N Q')
        have "xvec \<sharp>* P" and "A\<^sub>P \<sharp>* xvec" and "xvec \<sharp>* \<Psi>"
          by simp+
        have "A\<^sub>P \<sharp>* M"
          by(simp add: brOutputFreshSubjectChain)

        have "A\<^sub>P \<sharp>* N" and "A\<^sub>P \<sharp>* Q'" by(simp add: broutputFreshChainDerivative)+
          by simp

        have "\<Psi> \<rhd> P \<parallel> Q \<longmapsto> \<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P \<parallel> Q'"
          by(simp add: Par2)

        have "(x#xvec) \<sharp>* P" and "(x#xvec) \<sharp>* \<Psi>" by simp+
        then have "(\<Psi>, (\<lparr>\<nu>*(x#xvec)\<rparr>(P \<parallel> Q')), P \<parallel> (\<lparr>\<nu>*(x#xvec)\<rparr>Q')) \<in> Rel"
          by(rule C4)
        then have "(\<Psi>, \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>(P \<parallel> Q')), P \<parallel> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>Q')) \<in> Rel"
          by simp

        have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto> \<tau> \<prec> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>(P \<parallel> Q'))"
          by(rule BrClose)

        ultimately show ?case
          by force
      qed
    next
      case(cComm1 \<Psi>\<^sub>Q M N P' A\<^sub>P \<Psi>\<^sub>P K xvec xQ' A\<^sub>Q)
      have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto>K\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> xQ'" and FrQ: "extractFrame(\<lparr>\<nu>x\<rparr>Q) = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact+
      have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>N\<rparr> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
      have "x \<sharp> \<lparr>\<nu>x\<rparr>Q" by(simp add: abs_fresh)
        by(force intro: outputFreshDerivative)+
        by(drule_tac extractFrameFresh) auto
        by(drule_tac extractFrameFresh) auto
      obtain M' where "(\<Psi> \<otimes> \<Psi>\<^sub>Q) \<otimes> \<Psi>\<^sub>P \<turnstile> M \<leftrightarrow> M'" and "x \<sharp> M'" and "A\<^sub>Q \<sharp>* M'" and "xvec \<sharp>* M'"
        by(elim inputObtainPrefix[where B="x#xvec@A\<^sub>Q"]) (assumption | force simp add: fresh_star_list_cons)+
      then have MeqM': "\<Psi> \<otimes> \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q \<turnstile> M \<leftrightarrow> M'" by(metis statEqEnt Associativity Commutativity Composition)
        by(blast intro: chanEqTrans chanEqSym)
      then have "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<turnstile> K \<leftrightarrow> M'" by(metis statEqEnt Associativity Commutativity Composition)
      have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto>M'\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> xQ'"
        by(force intro: outputRenameSubject)


      have "object(M'\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle>) = Some N" by simp
      have "bn(M'\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle>) = xvec" by simp
      have "subject(M'\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle>) = Some M'" by simp
      ultimately show ?case
      proof(induct rule: resOutputCases''''')
      	case(cOpen M'' xvec1 xvec2 y N' Q')
        then have Eq: "M'\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> = M''\<lparr>\<nu>*(xvec1 @ y # xvec2)\<rparr>\<langle>N'\<rangle>" by simp
          by simp+
        from Eq have "N = N'" and "xvec = xvec1@y#xvec2" and "M' = M''" by(simp add: action.inject)+
        have "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>([(y, x)] \<bullet> N)\<rparr> \<prec> ([(y, x)] \<bullet> P')"
          by(elim inputAlpha[where xvec="[y]"]) (auto simp add: calc_atm)
        then have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>([(x, y)] \<bullet> N)\<rparr> \<prec> ([(x, y)] \<bullet> P')"
          by(simp add: name_swap)

        have "[(x, y)] \<bullet> (\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> [(x, y)] \<bullet> Q \<longmapsto> M''\<lparr>\<nu>*(xvec1 @ xvec2)\<rparr>\<langle>N'\<rangle> \<prec> Q')"
          by simp
        then have "[(x, y)] \<bullet> (\<Psi> \<otimes> \<Psi>\<^sub>P) \<rhd> ([(x, y)] \<bullet> ([(x, y)] \<bullet> Q)) \<longmapsto> ([(x, y)] \<bullet> M'')\<lparr>\<nu>*([(x, y)] \<bullet> (xvec1 @ xvec2))\<rparr>\<langle>([(x, y)] \<bullet> N')\<rangle> \<prec> [(x, y)] \<bullet> Q'"
          by(simp add: eqvts)
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto> M''\<lparr>\<nu>*(xvec1 @ xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N')\<rangle> \<prec> [(x, y)] \<bullet> Q'"
          by simp
          by(elim outputFreshChainDerivative(2)) (assumption | simp)+

        then obtain z A\<^sub>Q' where A: "A\<^sub>Q = z#A\<^sub>Q'" by(cases A\<^sub>Q) auto
        have "A\<^sub>Q' \<sharp>* \<Psi>" and "A\<^sub>Q' \<sharp>* P" and "A\<^sub>Q' \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>Q' \<sharp>* Q"
          and "z \<sharp> \<Psi>" and "z \<sharp> P" and "z \<sharp> P'" and "z \<sharp> \<Psi>\<^sub>P" and "z \<sharp> Q" and "z \<sharp> xvec1" and "z \<sharp> xvec2"
          and "z \<sharp> M''" and "z \<sharp> ([(x, y)] \<bullet> Q')" and "A\<^sub>Q' \<sharp>* M''" and "z \<noteq> y" and "z \<sharp> (xvec1@xvec2)"
          by auto

          by(induct A\<^sub>Q') (auto simp add: fresh_list_nil fresh_list_cons)
          by(elim inputAlpha[where xvec="[x]"]) (auto simp add: calc_atm)
        moreover note FrP
        moreover from QTrans have "([(x, z)] \<bullet> (\<Psi> \<otimes> \<Psi>\<^sub>P)) \<rhd> ([(x, z)] \<bullet> Q) \<longmapsto>([(x, z)] \<bullet> (M''\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N')\<rangle> \<prec> ([(x, y)] \<bullet> Q')))"
          by(rule semantics.eqvt)
        have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> ([(x, z)] \<bullet> Q) \<longmapsto>M''\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, z)] \<bullet> [(x, y)] \<bullet> N')\<rangle> \<prec> ([(x, z)] \<bullet> [(x, y)] \<bullet> Q')"
          by(simp add: eqvts)
          by(clarsimp simp add: alpha' eqvts frame.inject fresh_list_cons name_swap)
          by(simp add: pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst])
          by(simp add: pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst])
        ultimately have "\<Psi> \<rhd> (P \<parallel> ([(x, z)] \<bullet> Q)) \<longmapsto>\<tau> \<prec> \<lparr>\<nu>*(xvec1@xvec2)\<rparr>(([(x, z)] \<bullet> [(x, y)] \<bullet> P') \<parallel> ([(x, z)] \<bullet> [(x, y)] \<bullet> Q'))"
          by(intro Comm1) (assumption | simp)+
          by(intro Scope) auto
          by(subst alphaRes[of x]) (auto simp add: calc_atm fresh_left name_swap)
          by(simp add: eqvts)
          by(subst alphaRes[of x]) (auto simp add: resChainFresh fresh_left calc_atm name_swap)
          by(simp add: eqvts)
        have "\<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*(xvec1@xvec2)\<rparr>(([(x, y)] \<bullet> P') \<parallel> ([(x, y)] \<bullet> Q'))) =  \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*(xvec1@xvec2)\<rparr>(P' \<parallel> Q'))"
          by(subst alphaRes[of y]) (auto simp add: resChainFresh calc_atm eqvts fresh_left name_swap)
        ultimately have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto>\<tau> \<prec> \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*(xvec1@xvec2)\<rparr>(P' \<parallel> Q'))"
          by simp
        have "(\<Psi>, \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*(xvec1@xvec2)\<rparr>(P' \<parallel> Q')), \<lparr>\<nu>*xvec\<rparr>(P' \<parallel> Q')) \<in> Rel"
          by(force intro: C3 simp add: resChainAppend)
        ultimately show ?case by blast
      next
        case(cRes Q')
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto>M'\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> Q'" by fact
          by(force dest: outputFreshChainDerivative)

        then obtain y A\<^sub>Q' where A: "A\<^sub>Q = y#A\<^sub>Q'" by(cases A\<^sub>Q) auto
        have "A\<^sub>Q' \<sharp>* \<Psi>" and "A\<^sub>Q' \<sharp>* P" and "A\<^sub>Q' \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>Q' \<sharp>* Q" and "A\<^sub>Q \<sharp>* xvec" and "A\<^sub>Q \<sharp>* Q'"
          and "y \<sharp> \<Psi>" and "y \<sharp> P" and "y \<sharp> P'" and "y \<sharp> \<Psi>\<^sub>P" and "y \<sharp> Q" and "y \<sharp> xvec" and "y \<sharp> M'" and "y \<sharp> Q'"
          and "A\<^sub>Q' \<sharp>* M'"
          by(simp)+

          by(induct A\<^sub>Q') (auto simp add: fresh_list_nil fresh_list_cons)

        have "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>([(y, x)] \<bullet> N)\<rparr> \<prec> [(y, x)] \<bullet> P'"
          by(intro inputAlpha[where xvec="[y]"]) (auto simp add: calc_atm)
        then have "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>([(x, y)] \<bullet> N)\<rparr> \<prec> [(x, y)] \<bullet> P'"
          by(simp add: name_swap)
        moreover note FrP
          by(rule semantics.eqvt)
        have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> ([(x, y)] \<bullet> Q) \<longmapsto>M'\<lparr>\<nu>*xvec\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> ([(x, y)] \<bullet> Q')"
          by(simp add: eqvts)
          by(clarsimp simp add: alpha' eqvts frame.inject fresh_list_cons name_swap)
        ultimately have "\<Psi> \<rhd> (P \<parallel> ([(x, y)] \<bullet> Q)) \<longmapsto>\<tau> \<prec> \<lparr>\<nu>*xvec\<rparr>([(x, y)] \<bullet> P') \<parallel> ([(x, y)] \<bullet> Q')"
          by(intro Comm1) (assumption | simp)+
          by(intro Scope) auto
          by(subst alphaRes[of x]) (auto simp add: calc_atm fresh_left name_swap)
          by(simp add: eqvts)
          by(subst alphaRes[of y]) (auto simp add: resChainFresh calc_atm eqvts fresh_left name_swap)
        ultimately have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto>\<tau> \<prec> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>(P' \<parallel> Q'))"
          by simp
          by(rule C2)
        ultimately show ?case by blast
      qed
    next
      case(cComm2 \<Psi>\<^sub>Q M xvec N P' A\<^sub>P \<Psi>\<^sub>P K xQ' A\<^sub>Q)
      have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto>K\<lparr>N\<rparr> \<prec> xQ'" and FrQ: "extractFrame(\<lparr>\<nu>x\<rparr>Q) = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact+
      have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
        by(force intro: outputFreshDerivative)+
      have "x \<sharp> \<lparr>\<nu>x\<rparr>Q" by(simp add: abs_fresh)
        by(drule_tac extractFrameFresh) auto
        by(drule_tac extractFrameFresh) auto

        by(simp add: residualInject)

      obtain M' where "(\<Psi> \<otimes> \<Psi>\<^sub>Q) \<otimes> \<Psi>\<^sub>P \<turnstile> M \<leftrightarrow> M'" and "x \<sharp> M'" and "A\<^sub>Q \<sharp>* M'"
        by(elim outputObtainPrefix[where B="x#A\<^sub>Q"]) (assumption | force simp add: fresh_star_list_cons)+
      then have MeqM': "\<Psi> \<otimes> \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q \<turnstile> M \<leftrightarrow> M'"
        by(metis statEqEnt Associativity Commutativity Composition)
        by(blast intro: chanEqTrans chanEqSym)
      then have "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<turnstile> K \<leftrightarrow> M'"
        by(metis statEqEnt Associativity Commutativity Composition)
      have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto>M'\<lparr>N\<rparr> \<prec> xQ'" by(force intro: inputRenameSubject)

      ultimately show ?case
      proof(induct rule: resInputCases)
        case(cRes Q')
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto>M'\<lparr>N\<rparr> \<prec> Q'" by fact
          by(elim inputFreshChainDerivative)

        then obtain y A\<^sub>Q' where A: "A\<^sub>Q = y#A\<^sub>Q'" by(cases A\<^sub>Q) auto
        have "A\<^sub>Q' \<sharp>* \<Psi>" and "A\<^sub>Q' \<sharp>* P" and "A\<^sub>Q' \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>Q' \<sharp>* Q" and "A\<^sub>Q \<sharp>* xvec" and "A\<^sub>Q \<sharp>* Q'"
          and "y \<sharp> \<Psi>" and "y \<sharp> P" and "y \<sharp> P'" and "y \<sharp> \<Psi>\<^sub>P" and "y \<sharp> Q" and "y \<sharp> xvec" and "y \<sharp> M'" and "y \<sharp> Q'" and "y \<sharp> N"
          and "A\<^sub>Q' \<sharp>* M'"
          by(simp)+

          by(induct A\<^sub>Q') (auto simp add: fresh_list_nil fresh_list_cons)

        note PTrans FrP
          by(rule semantics.eqvt)
        have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> ([(x, y)] \<bullet> Q) \<longmapsto>M'\<lparr>N\<rparr> \<prec> ([(x, y)] \<bullet> Q')"
          by(simp add: eqvts)
          by(clarsimp simp add: alpha' eqvts frame.inject fresh_list_cons name_swap)+
        ultimately have "\<Psi> \<rhd> (P \<parallel> ([(x, y)] \<bullet> Q)) \<longmapsto>\<tau> \<prec> \<lparr>\<nu>*xvec\<rparr>(P' \<parallel> ([(x, y)] \<bullet> Q'))"
          by(intro Comm2) (assumption | simp)+
          by(intro Scope) auto
          by(subst alphaRes[of x]) (auto simp add: calc_atm fresh_left name_swap)
          by(simp add: eqvts)
          by(subst alphaRes[of y]) (auto simp add: resChainFresh calc_atm eqvts fresh_left name_swap)
        ultimately have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto>\<tau> \<prec> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>(P' \<parallel> Q'))"
          by simp
          by(rule C2)
        ultimately show ?case by blast
      qed
    next
      case(cBrMerge \<Psi>\<^sub>Q M N P' A\<^sub>P \<Psi>\<^sub>P xQ' A\<^sub>Q)
      have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> xQ'" and FrQ: "extractFrame(\<lparr>\<nu>x\<rparr>Q) = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact+
      have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
        by(drule_tac extractFrameFresh) auto
        by(rule brinputFreshDerivative)
      have "x \<sharp> \<lparr>\<nu>x\<rparr>Q" by(simp add: abs_fresh)
        by(drule_tac extractFrameFresh) auto
      have "x \<sharp> (\<Psi> \<otimes> \<Psi>\<^sub>P)" by force
      show ?case
      proof(induct rule: resBrInputCases)
        case(cRes Q')
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> Q'" by fact
          by(elim brinputFreshChainDerivative)

        then obtain y A\<^sub>Q' where A: "A\<^sub>Q = y#A\<^sub>Q'" by(cases A\<^sub>Q) auto
        have "A\<^sub>Q' \<sharp>* \<Psi>" and "A\<^sub>Q' \<sharp>* P" and "A\<^sub>Q' \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>Q' \<sharp>* Q" and "A\<^sub>Q \<sharp>* Q'"
          and "y \<sharp> \<Psi>" and "y \<sharp> P" and "y \<sharp> P'" and "y \<sharp> \<Psi>\<^sub>P" and "y \<sharp> Q" and "y \<sharp> M" and "y \<sharp> Q'" and "y \<sharp> N"
          and "A\<^sub>Q' \<sharp>* M"
          by(simp)+

          by(induct A\<^sub>Q') (auto simp add: fresh_list_nil fresh_list_cons)

        note PTrans FrP
          by(rule semantics.eqvt)
        have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> ([(x, y)] \<bullet> Q) \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> ([(x, y)] \<bullet> Q')"
          by(simp add: eqvts)
          by(clarsimp simp add: alpha' eqvts frame.inject fresh_list_cons name_swap)+
        ultimately have "\<Psi> \<rhd> (P \<parallel> ([(x, y)] \<bullet> Q)) \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> (P' \<parallel> ([(x, y)] \<bullet> Q'))"
          by(intro BrMerge)
          by(intro Scope) auto
          by(subst alphaRes[of x]) (auto simp add: calc_atm fresh_left name_swap)
          by(simp add: eqvts)
          by(subst alphaRes[of y]) (auto simp add: resChainFresh calc_atm eqvts fresh_left name_swap)
        ultimately have finTrans: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> \<lparr>\<nu>x\<rparr>(P' \<parallel> Q')"
          by simp
        then have "(\<Psi>, \<lparr>\<nu>*[x]\<rparr>(P' \<parallel> Q'), (P' \<parallel> (\<lparr>\<nu>*[x]\<rparr>Q'))) \<in> Rel"
          by(rule C4)
        then have "(\<Psi>, \<lparr>\<nu>x\<rparr>(P' \<parallel> Q'), (P' \<parallel> \<lparr>\<nu>x\<rparr>Q')) \<in> Rel"
          by simp
        with finTrans show ?case by blast
      qed
    next
      case(cBrComm1 \<Psi>\<^sub>Q M N P' A\<^sub>P \<Psi>\<^sub>P xvec xQ' A\<^sub>Q)
      have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> xQ'" and FrQ: "extractFrame(\<lparr>\<nu>x\<rparr>Q) = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact+
      have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
      have "x \<sharp> \<lparr>\<nu>x\<rparr>Q" by(simp add: abs_fresh)
        by(force intro: broutputFreshDerivative)+
        by(drule_tac extractFrameFresh) auto
        by(drule_tac extractFrameFresh) auto
      note QTrans


      have "object(\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle>) = Some N" by simp
      have "bn(\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle>) = xvec" by simp
      have "subject(\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle>) = Some M" by simp
      ultimately show ?case
      proof(induct rule: resBrOutputCases')
      	case(cBrOpen M'' xvec1 xvec2 y N' Q')
        then have Eq: "\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> = \<exclamdown>M''\<lparr>\<nu>*(xvec1 @ y # xvec2)\<rparr>\<langle>N'\<rangle>" by simp
          by simp+
        from Eq have "N = N'" and "xvec = xvec1@y#xvec2" and "M = M''" by(simp add: action.inject)+
        have "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>([(y, x)] \<bullet> N)\<rparr> \<prec> ([(y, x)] \<bullet> P')"
          by(intro brinputAlpha[where xvec="[y]"]) (auto simp add: calc_atm)
        then have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>([(x, y)] \<bullet> N)\<rparr> \<prec> ([(x, y)] \<bullet> P')"
          by(simp add: name_swap)

        have "[(x, y)] \<bullet> (\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> [(x, y)] \<bullet> Q \<longmapsto> \<exclamdown>M''\<lparr>\<nu>*(xvec1 @ xvec2)\<rparr>\<langle>N'\<rangle> \<prec> Q')"
          by simp
        then have "[(x, y)] \<bullet> (\<Psi> \<otimes> \<Psi>\<^sub>P) \<rhd> ([(x, y)] \<bullet> ([(x, y)] \<bullet> Q)) \<longmapsto> \<exclamdown>([(x, y)] \<bullet> M'')\<lparr>\<nu>*([(x, y)] \<bullet> (xvec1 @ xvec2))\<rparr>\<langle>([(x, y)] \<bullet> N')\<rangle> \<prec> [(x, y)] \<bullet> Q'"
          by(simp add: eqvts)
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto> \<exclamdown>M''\<lparr>\<nu>*(xvec1 @ xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N')\<rangle> \<prec> [(x, y)] \<bullet> Q'"
          by simp
          by(elim broutputFreshChainDerivative(2)) (assumption | simp)+

        then obtain z A\<^sub>Q' where A: "A\<^sub>Q = z#A\<^sub>Q'" by(cases A\<^sub>Q) auto
        have "A\<^sub>Q' \<sharp>* \<Psi>" and "A\<^sub>Q' \<sharp>* P" and "A\<^sub>Q' \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>Q' \<sharp>* Q"
          and "z \<sharp> \<Psi>" and "z \<sharp> P" and "z \<sharp> P'" and "z \<sharp> \<Psi>\<^sub>P" and "z \<sharp> Q" and "z \<sharp> xvec1" and "z \<sharp> xvec2"
          and "z \<sharp> M''" and "z \<sharp> ([(x, y)] \<bullet> Q')" and "A\<^sub>Q' \<sharp>* M''" and "z \<noteq> y" and "z \<sharp> (xvec1@xvec2)"
          by auto


        then have "x \<in> supp ([(x, y)] \<bullet> N)"
          by (rule swap_supp)
        then have zsupp: "z \<in> supp ([(x, z)] \<bullet> [(x, y)] \<bullet> N)"
          by (rule swap_supp')

          by(induct A\<^sub>Q') (auto simp add: fresh_list_nil fresh_list_cons)
          by(elim brinputAlpha[where xvec="[x]"]) (auto simp add: calc_atm)
        moreover note FrP
        moreover from QTrans have "([(x, z)] \<bullet> (\<Psi> \<otimes> \<Psi>\<^sub>P)) \<rhd> ([(x, z)] \<bullet> Q) \<longmapsto>([(x, z)] \<bullet> (\<exclamdown>M''\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N')\<rangle> \<prec> ([(x, y)] \<bullet> Q')))"
          by(rule semantics.eqvt)
        have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> ([(x, z)] \<bullet> Q) \<longmapsto>\<exclamdown>M''\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, z)] \<bullet> [(x, y)] \<bullet> N')\<rangle> \<prec> ([(x, z)] \<bullet> [(x, y)] \<bullet> Q')"
          by(simp add: eqvts)
          by(clarsimp simp add: alpha' eqvts frame.inject fresh_list_cons name_swap)
          by(simp add: pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst])
          by(simp add: pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst])
        ultimately have "\<Psi> \<rhd> (P \<parallel> ([(x, z)] \<bullet> Q)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, z)] \<bullet> [(x, y)] \<bullet> N)\<rangle> \<prec> (([(x, z)] \<bullet> [(x, y)] \<bullet> P') \<parallel> ([(x, z)] \<bullet> [(x, y)] \<bullet> Q'))"
          by(intro BrComm1) (assumption | simp)+
        then have permTrans: "\<Psi> \<rhd> \<lparr>\<nu>z\<rparr>(P \<parallel> ([(x, z)] \<bullet> Q)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@z#xvec2)\<rparr>\<langle>([(x, z)] \<bullet> [(x, y)] \<bullet> N)\<rangle> \<prec> (([(x, z)] \<bullet> [(x, y)] \<bullet> P') \<parallel> ([(x, z)] \<bullet> [(x, y)] \<bullet> Q'))"
          by(rule BrOpen)

          by(subst alphaRes[of x]) (auto simp add: calc_atm fresh_left name_swap)
          by(simp add: eqvts)
        with permTrans have permTrans2: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@z#xvec2)\<rparr>\<langle>([(x, z)] \<bullet> [(x, y)] \<bullet> N)\<rangle> \<prec> (([(x, z)] \<bullet> [(x, y)] \<bullet> P') \<parallel> ([(x, z)] \<bullet> [(x, y)] \<bullet> Q'))"
          by simp
        then have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto> RBrOut M (\<lparr>\<nu>*(xvec1@z#xvec2)\<rparr>([(x, z)] \<bullet> [(x, y)] \<bullet> N) \<prec>' (([(x, z)] \<bullet> [(x, y)] \<bullet> P') \<parallel> ([(x, z)] \<bullet> [(x, y)] \<bullet> Q')))"
          by(simp add: residualInject)
        then have permTrans3: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto> RBrOut M (\<lparr>\<nu>*(xvec1@z#xvec2)\<rparr> (([(x, z)] \<bullet> [(x, y)] \<bullet> N) \<prec>' ([(x, z)] \<bullet> [(x, y)] \<bullet> (P' \<parallel> Q'))))"
          by simp
        have "z \<sharp> ([(x, y)] \<bullet> N)"
          by (metis calc_atm(2) calc_atm(3) fresh_right name_prm_name.simps(2) name_prm_name_def singleton_rev_conv swap_name_def)
        have "z \<sharp> ([(x, y)] \<bullet> P')"
          by (metis calc_atm(2) calc_atm(3) fresh_right name_prm_name.simps(2) name_prm_name_def singleton_rev_conv swap_name_def)
          by (metis calc_atm(2) calc_atm(3) fresh_right name_prm_name.simps(2) name_prm_name_def singleton_rev_conv swap_name_def)
          by (metis calc_atm(2) calc_atm(3) fresh_right name_prm_name.simps(2) name_prm_name_def singleton_rev_conv swap_name_def)
        have "x \<sharp> ([(x, z)] \<bullet> [(x, y)] \<bullet> Q')"
          by (metis calc_atm(2) calc_atm(3) fresh_right name_prm_name.simps(2) name_prm_name_def singleton_rev_conv swap_name_def)
        ultimately have "x \<sharp> ([(x, z)] \<bullet> [(x, y)] \<bullet> (P' \<parallel> Q'))"
          by simp
        have "z \<in> set ((xvec1@z#xvec2))"
          by simp
        have eq1: "(\<lparr>\<nu>*(xvec1@z#xvec2)\<rparr> (([(x, z)] \<bullet> [(x, y)] \<bullet> N) \<prec>' ([(x, z)] \<bullet> [(x, y)] \<bullet> (P' \<parallel> Q')))) = (\<lparr>\<nu>*([(z, x)] \<bullet> (xvec1@z#xvec2))\<rparr> (([(z, x)] \<bullet> [(x, z)] \<bullet> [(x, y)] \<bullet> N) \<prec>' ([(z, x)] \<bullet> [(x, z)] \<bullet> [(x, y)] \<bullet> (P' \<parallel> Q'))))"
          by(rule boundOutputChainSwap)
        have eq2: "(\<lparr>\<nu>*([(z, x)] \<bullet> (xvec1@z#xvec2))\<rparr> (([(z, x)] \<bullet> [(x, z)] \<bullet> [(x, y)] \<bullet> N) \<prec>' ([(z, x)] \<bullet> [(x, z)] \<bullet> [(x, y)] \<bullet> (P' \<parallel> Q')))) = (\<lparr>\<nu>*([(z, x)] \<bullet> (xvec1@z#xvec2))\<rparr> (([(x, y)] \<bullet> N) \<prec>' ([(x, y)] \<bullet> (P' \<parallel> Q'))))"
          by auto (metis perm_swap(2))+
        have "([(z, x)] \<bullet> (xvec1@z#xvec2)) = (xvec1@x#xvec2)"
          by(simp add: eqvts swap_simps)
        then have eq3: "(\<lparr>\<nu>*([(z, x)] \<bullet> (xvec1@z#xvec2))\<rparr> (([(x, y)] \<bullet> N) \<prec>' ([(x, y)] \<bullet> (P' \<parallel> Q')))) = (\<lparr>\<nu>*(xvec1@x#xvec2)\<rparr> (([(x, y)] \<bullet> N) \<prec>' ([(x, y)] \<bullet> (P' \<parallel> Q'))))"
          by simp

        from permTrans3 eq1 eq2 eq3 have noXZTrans: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto> RBrOut M (\<lparr>\<nu>*(xvec1@x#xvec2)\<rparr> (([(x, y)] \<bullet> N) \<prec>' ([(x, y)] \<bullet> (P' \<parallel> Q'))))"
          by simp

        have "y \<sharp> ([(x, y)] \<bullet> N)"
          by (metis calc_atm(2) fresh_right name_prm_name.simps(2) name_prm_name_def singleton_rev_conv swap_name_def swap_simps(2))
        have "y \<sharp> ([(x, y)] \<bullet> (P' \<parallel> Q'))"
          by (metis fresh_left psi.fresh(5) singleton_rev_conv swap_simps(2))
        moreover have "x \<in> set (xvec1@x#xvec2)"
          by simp
        ultimately have eq1: "\<lparr>\<nu>*(xvec1@x#xvec2)\<rparr>([(x, y)] \<bullet> N) \<prec>' ([(x, y)] \<bullet> (P' \<parallel> Q')) = \<lparr>\<nu>*([(x, y)] \<bullet> (xvec1@x#xvec2))\<rparr>([(x, y)] \<bullet> [(x, y)] \<bullet> N) \<prec>' ([(x, y)] \<bullet> [(x, y)] \<bullet> (P' \<parallel> Q'))"
          by(rule boundOutputChainSwap)
        have eq2: "\<lparr>\<nu>*([(x, y)] \<bullet> (xvec1@x#xvec2))\<rparr>([(x, y)] \<bullet> [(x, y)] \<bullet> N) \<prec>' ([(x, y)] \<bullet> [(x, y)] \<bullet> (P' \<parallel> Q')) = \<lparr>\<nu>*([(x, y)] \<bullet> (xvec1@x#xvec2))\<rparr>N \<prec>' (P' \<parallel> Q')"
          by simp
        have eq3: "([(x, y)] \<bullet> (xvec1@x#xvec2)) = (xvec1@y#xvec2)"
          by(simp add: eqvts swap_simps)

        from eq1 eq2 eq3 noXZTrans have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto> RBrOut M (\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>N \<prec>' (P' \<parallel> Q'))"
          by simp
        then have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>\<langle>N\<rangle> \<prec> (P' \<parallel> Q')"
          by(simp add: residualInject)

        have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> (P' \<parallel> Q')"
          by simp
        moreover have "(\<Psi>, P' \<parallel> Q', P' \<parallel> Q') \<in> Rel"
          by(rule C1)

        ultimately show ?case
          by force
      next
        case(cRes Q')
        have "x \<sharp> M" and "x \<sharp> xvec" and "x \<sharp> N"
          by simp+
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> Q'" by fact
          by(force dest: broutputFreshChainDerivative)

        then obtain y A\<^sub>Q' where A: "A\<^sub>Q = y#A\<^sub>Q'" by(cases A\<^sub>Q) auto
        have "A\<^sub>Q' \<sharp>* \<Psi>" and "A\<^sub>Q' \<sharp>* P" and "A\<^sub>Q' \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>Q' \<sharp>* Q" and "A\<^sub>Q \<sharp>* xvec" and "A\<^sub>Q \<sharp>* Q'"
          and "y \<sharp> \<Psi>" and "y \<sharp> P" and "y \<sharp> P'" and "y \<sharp> \<Psi>\<^sub>P" and "y \<sharp> Q" and "y \<sharp> xvec" and "y \<sharp> M" and "y \<sharp> Q'"
          and "A\<^sub>Q' \<sharp>* M" and "y \<sharp> N"
          by(simp)+

          by(induct A\<^sub>Q') (auto simp add: fresh_list_nil fresh_list_cons)

          by (metis calc_atm(2) fresh_right name_prm_name.simps(2) name_prm_name_def singleton_rev_conv swap_name_def swap_simps(2))

        have "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>([(y, x)] \<bullet> N)\<rparr> \<prec> [(y, x)] \<bullet> P'"
          by(elim brinputAlpha[where xvec="[y]"]) (auto simp add: calc_atm)
        then have "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>([(x, y)] \<bullet> N)\<rparr> \<prec> [(x, y)] \<bullet> P'"
          by(simp add: name_swap)
        moreover note FrP
          by(rule semantics.eqvt)
        have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> ([(x, y)] \<bullet> Q) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> ([(x, y)] \<bullet> Q')"
          by(simp add: eqvts)
          by(clarsimp simp add: alpha' eqvts frame.inject fresh_list_cons name_swap)
        ultimately have "\<Psi> \<rhd> (P \<parallel> ([(x, y)] \<bullet> Q)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> ([(x, y)] \<bullet> P') \<parallel> ([(x, y)] \<bullet> Q')"
          by(intro BrComm1) (assumption | simp)+
          by(intro Scope) auto
          by(subst alphaRes[of x]) (auto simp add: calc_atm fresh_left name_swap)
          by(simp add: eqvts)
          by(subst alphaRes[of y]) (auto simp add: resChainFresh calc_atm eqvts fresh_left name_swap)
        ultimately have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> \<lparr>\<nu>x\<rparr>(P' \<parallel> Q')"
          by simp
        have Trans: "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> \<lparr>\<nu>x\<rparr>(P' \<parallel> Q')"
          by simp
        have "(\<Psi>, \<lparr>\<nu>*[x]\<rparr>(P' \<parallel> Q'), (P' \<parallel> (\<lparr>\<nu>*[x]\<rparr>Q'))) \<in> Rel"
          by(intro C4) simp+
        then have Relation: "(\<Psi>, \<lparr>\<nu>x\<rparr>(P' \<parallel> Q'), (P' \<parallel> (\<lparr>\<nu>x\<rparr>Q'))) \<in> Rel"
          by simp
        from Trans Relation show ?case
          by blast
      qed
    next
      case(cBrComm2 \<Psi>\<^sub>Q M xvec N P' A\<^sub>P \<Psi>\<^sub>P xQ' A\<^sub>Q)
      have "x \<sharp> M" "x \<sharp> xvec" "x \<sharp> N"
        by force+
      have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> xQ'" and FrQ: "extractFrame(\<lparr>\<nu>x\<rparr>Q) = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact+
      have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
        by(force intro: broutputFreshDerivative)+
      have "x \<sharp> \<lparr>\<nu>x\<rparr>Q" by(simp add: abs_fresh)
        by(drule_tac extractFrameFresh) auto
        by(drule_tac extractFrameFresh) auto

        by(simp add: residualInject)

      note QTrans
      ultimately show ?case
      proof(induct rule: resBrInputCases)
        case(cRes Q')
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> Q'" by fact
          by(elim brinputFreshChainDerivative)

        then obtain y A\<^sub>Q' where A: "A\<^sub>Q = y#A\<^sub>Q'" by(cases A\<^sub>Q) auto
        have "A\<^sub>Q' \<sharp>* \<Psi>" and "A\<^sub>Q' \<sharp>* P" and "A\<^sub>Q' \<sharp>* \<Psi>\<^sub>P" and "A\<^sub>Q' \<sharp>* Q" and "A\<^sub>Q \<sharp>* xvec" and "A\<^sub>Q \<sharp>* Q'"
          and "y \<sharp> \<Psi>" and "y \<sharp> P" and "y \<sharp> P'" and "y \<sharp> \<Psi>\<^sub>P" and "y \<sharp> Q" and "y \<sharp> xvec" and "y \<sharp> M" and "y \<sharp> Q'" and "y \<sharp> N"
          and "A\<^sub>Q' \<sharp>* M"
          by(simp)+

          by(induct A\<^sub>Q') (auto simp add: fresh_list_nil fresh_list_cons)

        note PTrans FrP
          by(rule semantics.eqvt)
        have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> ([(x, y)] \<bullet> Q) \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> ([(x, y)] \<bullet> Q')"
          by(simp add: eqvts)
          by(clarsimp simp add: alpha' eqvts frame.inject fresh_list_cons name_swap)+
        ultimately have "\<Psi> \<rhd> (P \<parallel> ([(x, y)] \<bullet> Q)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> (P' \<parallel> ([(x, y)] \<bullet> Q'))"
          by(intro BrComm2) (assumption | simp)+
          by(intro Scope) auto
          by(subst alphaRes[of x]) (auto simp add: calc_atm fresh_left name_swap)
          by(simp add: eqvts)
          by(subst alphaRes[of y]) (auto simp add: resChainFresh calc_atm eqvts fresh_left name_swap)
        ultimately have "\<Psi> \<rhd> \<lparr>\<nu>x\<rparr>(P \<parallel> Q) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> \<lparr>\<nu>x\<rparr>(P' \<parallel> Q')"
          by simp
          by(intro C4) simp+
        moreover then have "(\<Psi>, \<lparr>\<nu>x\<rparr>(P' \<parallel> Q'), (P' \<parallel> (\<lparr>\<nu>x\<rparr>Q'))) \<in> Rel"
          by simp
        ultimately show ?case by blast
      qed
    qed
  qed
qed

lemma scopeExtRight:
  fixes x   :: name
    and P   :: "('a, 'b, 'c) psi"
    and \<Psi>   :: 'b
    and Q   :: "('a, 'b, 'c) psi"
    and Rel :: "('b \<times> ('a, 'b, 'c) psi \<times> ('a, 'b, 'c) psi) set"

assumes "x \<sharp> P"
  and   "x \<sharp> \<Psi>"
  and   "eqvt Rel"
  and   C1: "\<And>\<Psi>' R. (\<Psi>, R, R) \<in> Rel"
  and   C2: "\<And>y \<Psi>' R S zvec. \<lbrakk>y \<sharp> \<Psi>'; y \<sharp> R; zvec \<sharp>* \<Psi>'\<rbrakk> \<Longrightarrow> (\<Psi>', \<lparr>\<nu>*zvec\<rparr>(R \<parallel> \<lparr>\<nu>y\<rparr>S), \<lparr>\<nu>y\<rparr>(\<lparr>\<nu>*zvec\<rparr>(R \<parallel> S))) \<in> Rel"
  and   C3: "\<And>\<Psi>' R S zvec. \<lbrakk>zvec \<sharp>* R; zvec \<sharp>* \<Psi>'\<rbrakk> \<Longrightarrow> (\<Psi>', (R \<parallel> (\<lparr>\<nu>*zvec\<rparr>S)), (\<lparr>\<nu>*zvec\<rparr>(R \<parallel> S))) \<in> Rel"

shows "\<Psi> \<rhd> P \<parallel> \<lparr>\<nu>x\<rparr>Q \<leadsto>[Rel] \<lparr>\<nu>x\<rparr>(P \<parallel> Q)"
proof -
  ultimately show ?thesis
  proof(induct rule: simIFresh[of _ _ _ _ _ "()"])
    case(cSim \<alpha> xPQ)
    proof(induct rule: resCases[where C="()"])
      case(cOpen M xvec1 xvec2 y N PQ)
      have "(xvec1@xvec2) \<sharp>* P" and "(xvec1@xvec2) \<sharp>* Q" and "y \<sharp> P" and "y \<sharp> Q"
        by simp+
      have "([(x, y)] \<bullet> \<Psi>) \<rhd> ([(x, y)] \<bullet> (P \<parallel> Q)) \<longmapsto> ([(x, y)] \<bullet> (M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> ([(x, y)] \<bullet> PQ)))"
        by(rule semantics.eqvt)
      have "\<Psi> \<rhd> P \<parallel> ([(x, y)] \<bullet> Q) \<longmapsto> M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>N\<rangle> \<prec> PQ"
        by(simp add: eqvts)
        by(simp add: pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst])
        by(auto simp add: eqvts)
      ultimately show ?case
      proof(induct rule: parOutputCases[where C=y])
        case(cPar1 P' A\<^sub>Q \<Psi>\<^sub>Q)
        have "y \<sharp> N" by(force intro: outputFreshDerivative)
        then show ?case by simp
      next
        case(cPar2 Q' A\<^sub>P \<Psi>\<^sub>P)
        have FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact
          apply(drule_tac extractFrameFresh)
          by(simp add: frameResChainFresh) (simp add: fresh_def name_list_supp)
        have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>y\<rparr>(([(x, y)] \<bullet> Q)) \<longmapsto>M\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>\<langle>N\<rangle> \<prec> Q'" by(force intro: Open)
          by(simp add: alphaRes)
        ultimately have "\<Psi> \<rhd> P \<parallel> (\<lparr>\<nu>x\<rparr>Q) \<longmapsto>M\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>\<langle>N\<rangle> \<prec> (P \<parallel> Q')"
          by(intro Par2) auto
        moreover have "(\<Psi>, P \<parallel> Q', P \<parallel> Q') \<in> Rel" by(rule C1)
        ultimately show ?case by blast
      qed
    next
      case(cBrOpen M xvec1 xvec2 y N PQ)
      have "(xvec1@xvec2) \<sharp>* P" and "(xvec1@xvec2) \<sharp>* Q" and "y \<sharp> P" and "y \<sharp> Q"
        by simp+
      have "([(x, y)] \<bullet> \<Psi>) \<rhd> ([(x, y)] \<bullet> (P \<parallel> Q)) \<longmapsto> ([(x, y)] \<bullet> (\<exclamdown>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>([(x, y)] \<bullet> N)\<rangle> \<prec> ([(x, y)] \<bullet> PQ)))"
        by(rule semantics.eqvt)
      have "\<Psi> \<rhd> P \<parallel> ([(x, y)] \<bullet> Q) \<longmapsto> \<exclamdown>M\<lparr>\<nu>*(xvec1@xvec2)\<rparr>\<langle>N\<rangle> \<prec> PQ"
        by(simp add: eqvts)
        by(simp add: pt_fresh_star_bij[OF pt_name_inst, OF at_name_inst])
        by(auto simp add: eqvts)
      ultimately show ?case
      proof(induct rule: parBrOutputCases[where C=y])
        case(cPar1 P' A\<^sub>Q \<Psi>\<^sub>Q)
        have "y \<sharp> N" by(force intro: broutputFreshDerivative)
        then show ?case by simp
      next
        case(cPar2 Q' A\<^sub>P \<Psi>\<^sub>P)
        have FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact
          apply(drule_tac extractFrameFresh)
          by(simp add: frameResChainFresh) (simp add: fresh_def name_list_supp)
        have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>y\<rparr>(([(x, y)] \<bullet> Q)) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>\<langle>N\<rangle> \<prec> Q'" by(force intro: BrOpen)
          by(simp add: alphaRes)
        ultimately have "\<Psi> \<rhd> P \<parallel> (\<lparr>\<nu>x\<rparr>Q) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>\<langle>N\<rangle> \<prec> (P \<parallel> Q')"
          by(intro Par2) auto
        moreover have "(\<Psi>, P \<parallel> Q', P \<parallel> Q') \<in> Rel" by(rule C1)
        ultimately show ?case by blast
      next
        case(cBrComm1 \<Psi>\<^sub>Q P' A\<^sub>P \<Psi>\<^sub>P Q' A\<^sub>Q)
        have FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact
          apply(drule_tac extractFrameFresh)
          by(simp add: frameResChainFresh) (simp add: fresh_def name_list_supp)

        have "extractFrame (\<lparr>\<nu>y\<rparr>([(x, y)] \<bullet> Q)) = \<langle>(y#A\<^sub>Q), \<Psi>\<^sub>Q\<rangle>"
          by simp
        have FrQ: "extractFrame (\<lparr>\<nu>x\<rparr>Q) = \<langle>(y#A\<^sub>Q), \<Psi>\<^sub>Q\<rangle>"
          by(simp add: alphaRes)
        have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>y\<rparr>([(x, y)] \<bullet> Q) \<longmapsto> \<exclamdown>M\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>\<langle>N\<rangle> \<prec> Q'"
          by(force intro: BrOpen)
          by(simp add: alphaRes)
          by (metis resChain.base resChain.step resChainFresh)
        ultimately have "(y # A\<^sub>Q) \<sharp>* (\<lparr>\<nu>x\<rparr>Q)" by simp
        have "\<Psi> \<rhd> P \<parallel> (\<lparr>\<nu>x\<rparr>Q) \<longmapsto>\<exclamdown>M\<lparr>\<nu>*(xvec1@y#xvec2)\<rparr>\<langle>N\<rangle> \<prec> (P' \<parallel> Q')"
          by(intro BrComm1) (assumption | simp)+
        moreover have "(\<Psi>, P' \<parallel> Q', P' \<parallel> Q') \<in> Rel" by(rule C1)
        ultimately show ?case by blast
      next
        case(cBrComm2 \<Psi>\<^sub>Q P' A\<^sub>P \<Psi>\<^sub>P Q' A\<^sub>Q)
        have "y \<sharp> N" by(force intro: broutputFreshDerivative)
        then show ?case by simp
      qed
    next
      case(cRes PQ)
      show ?case
      proof(induct rule: parCases[where C=x])
        case(cPar1 P' A\<^sub>Q \<Psi>\<^sub>Q)
        have "x \<sharp> P'" by(force dest: freeFreshDerivative)
          by simp
        ultimately have "\<Psi> \<rhd> P \<parallel> \<lparr>\<nu>x\<rparr>Q \<longmapsto>\<alpha> \<prec> (P' \<parallel> \<lparr>\<nu>x\<rparr>Q)"
          by(rule Par1)
          by(intro C2) auto
        ultimately show ?case
          by force
      next
        case(cPar2 Q' A\<^sub>P \<Psi>\<^sub>P)
        have FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact
          apply(drule_tac extractFrameFresh)
          by(simp add: frameResChainFresh) (simp add: fresh_def name_list_supp)
        have "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto>\<alpha> \<prec> \<lparr>\<nu>x\<rparr>Q'"
          by(intro Scope) auto
          by(rule Par2)
          by(intro C2) auto
        ultimately show ?case
          by force
      next
        case(cComm1 \<Psi>\<^sub>Q M N P' A\<^sub>P \<Psi>\<^sub>P K xvec Q' A\<^sub>Q)
        have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>N\<rparr> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto>K\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> Q'" and FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact+
          by(auto dest: extractFrameFresh)
        obtain M' where MeqM': "(\<Psi> \<otimes> \<Psi>\<^sub>Q) \<otimes> \<Psi>\<^sub>P \<turnstile> M \<leftrightarrow> M'" and "x \<sharp> M'" and "A\<^sub>Q \<sharp>* M'"
          by(elim inputObtainPrefix[where B="x#A\<^sub>Q"]) (assumption | force simp add: fresh_star_list_cons)+
        from MeqM' have MeqM': "\<Psi> \<otimes> \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q \<turnstile> M \<leftrightarrow> M'"
          by(metis statEqEnt Associativity Composition Commutativity)
          by(blast intro: chanEqTrans chanEqSym)
        then have "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<turnstile> K \<leftrightarrow> M'"
          by(metis statEqEnt Associativity Composition Commutativity)
          by(elim outputRenameSubject) (assumption | force)+
        show ?case
        proof(cases "x \<in> supp N")
          note PTrans FrP
          moreover assume "x \<in> supp N"
            by(intro Open) (assumption | force simp add: fresh_list_nil)+
          then have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto>M'\<lparr>\<nu>*(x#xvec)\<rparr>\<langle>N\<rangle> \<prec> Q'" by simp
            by simp
            by(simp add: fresh_star_def fresh_list_cons) (auto simp add: fresh_def name_list_supp)
            by(intro Comm1) (assumption | simp)+
          moreover have "(\<Psi>, \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>(P' \<parallel> Q')), \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>(P' \<parallel> Q'))) \<in> Rel" by(rule C1)
          ultimately show ?case by force
        next
          note PTrans FrP
          moreover assume "x \<notin> supp N"
          then have "x \<sharp> N" by(simp add: fresh_def)
          have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto>M'\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> \<lparr>\<nu>x\<rparr>Q'"
            by(intro Scope) (assumption | force)+
            by simp
            by(simp add: fresh_star_def fresh_list_cons) (auto simp add: fresh_def name_list_supp)
            by(intro Comm1) (assumption | simp)+
          ultimately show ?case by blast
        qed
      next
        case(cComm2 \<Psi>\<^sub>Q M xvec N P' A\<^sub>P \<Psi>\<^sub>P K Q' A\<^sub>Q)
        have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto>K\<lparr>N\<rparr> \<prec> Q'" and FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact+
          by(auto dest: extractFrameFresh)
        from PTrans
        have "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto> ROut M (\<lparr>\<nu>*xvec\<rparr>N \<prec>' P')"
          by(simp add: residualInject)
        obtain M' where MeqM': "(\<Psi> \<otimes> \<Psi>\<^sub>Q) \<otimes> \<Psi>\<^sub>P \<turnstile> M \<leftrightarrow> M'" and "x \<sharp> M'" and "A\<^sub>Q \<sharp>* M'"
          by(elim outputObtainPrefix[where B="x#A\<^sub>Q"]) (assumption | force simp add: fresh_star_list_cons)+
        from MeqM' have MeqM': "\<Psi> \<otimes> \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q \<turnstile> M \<leftrightarrow> M'"
          by(metis statEqEnt Associativity Commutativity Composition)
          by(blast intro: chanEqTrans chanEqSym)
        then have "(\<Psi> \<otimes> \<Psi>\<^sub>P) \<otimes> \<Psi>\<^sub>Q \<turnstile> K \<leftrightarrow> M'"
          by(metis statEqEnt Associativity Commutativity Composition)
          by(auto intro: inputRenameSubject)

        have "x \<sharp> N" and "x \<sharp> P'" by(force intro: outputFreshDerivative)+
          by(intro Scope) (assumption | force)+

        note PTrans FrP QTrans
          by simp
          by(simp add: fresh_star_def fresh_list_cons) (auto simp add: fresh_def name_list_supp)
          by(intro Comm2) (assumption | simp)+
        ultimately show ?case by blast
      next
        case(cBrMerge \<Psi>\<^sub>Q M N P' A\<^sub>P \<Psi>\<^sub>P Q' A\<^sub>Q)
        have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> Q'" and FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact+
          by(auto dest: extractFrameFresh)
          by(simp add: frameResChainFresh) (simp add: fresh_def name_list_supp)
        have "x \<sharp> P'"
          by(rule brinputFreshDerivative)
          by(intro Scope) (assumption | force)+

        note PTrans FrP QTrans
          by simp
          by(simp add: fresh_star_def fresh_list_cons) (auto simp add: fresh_def name_list_supp)
          by(intro BrMerge) (assumption | simp)+
          by(intro C3) simp+
        then have Relation: "(\<Psi>, (P' \<parallel> (\<lparr>\<nu>x\<rparr>Q')), \<lparr>\<nu>x\<rparr>(P' \<parallel> Q')) \<in> Rel" by simp
        with Trans Relation show ?case by blast
      next
        case(cBrComm1 \<Psi>\<^sub>Q M N P' A\<^sub>P \<Psi>\<^sub>P xvec Q' A\<^sub>Q)
        have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> Q'" and FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact+
          by(auto dest: extractFrameFresh)
          by(simp add: frameResChainFresh) (simp add: fresh_def name_list_supp)
        show ?case
        proof(cases "x \<in> supp N")
          note PTrans FrP
          moreover assume "x \<in> supp N"
            by(simp add: fresh_def)
          then show ?case
            by simp
        next
          note PTrans FrP
          moreover assume "x \<notin> supp N"
          have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> \<lparr>\<nu>x\<rparr>Q'"
            by(intro Scope) (assumption | force)+
            by simp
            by(simp add: fresh_star_def fresh_list_cons) (auto simp add: fresh_def name_list_supp)
            by(intro BrComm1) (assumption | simp)+
            by(intro C3) simp+
          then have Relation: "(\<Psi>, (P' \<parallel> (\<lparr>\<nu>x\<rparr>Q')), \<lparr>\<nu>x\<rparr>(P' \<parallel> Q')) \<in> Rel" by simp
          from Trans Relation show ?case by blast
        qed
      next
        case(cBrComm2 \<Psi>\<^sub>Q M xvec N P' A\<^sub>P \<Psi>\<^sub>P Q' A\<^sub>Q)
        have PTrans: "\<Psi> \<otimes> \<Psi>\<^sub>Q \<rhd> P \<longmapsto>\<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P'" and FrP: "extractFrame P = \<langle>A\<^sub>P, \<Psi>\<^sub>P\<rangle>" by fact+
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> Q \<longmapsto>\<questiondown>M\<lparr>N\<rparr> \<prec> Q'" and FrQ: "extractFrame Q = \<langle>A\<^sub>Q, \<Psi>\<^sub>Q\<rangle>" by fact+
          by(auto dest: extractFrameFresh)
          by(simp add: frameResChainFresh) (simp add: fresh_def name_list_supp)
        have "x \<sharp> N" and "x \<sharp> P'" by(force intro: broutputFreshDerivative)+
          by(intro Scope) (assumption | force)+

        note PTrans FrP QTrans
          by simp
          by(simp add: fresh_star_def fresh_list_cons) (auto simp add: fresh_def name_list_supp)
          by(intro BrComm2) (assumption | simp)+
          by(intro C3) simp+
        then have Relation: "(\<Psi>, (P' \<parallel> \<lparr>\<nu>x\<rparr>Q'), \<lparr>\<nu>x\<rparr>(P' \<parallel> Q')) \<in> Rel" by simp
        from Trans Relation show ?case by blast
      qed
    next
      case(cBrClose M xvec N PQ)
      then show ?case
      proof(induct rule: parBrOutputCases[where C=x])
        case(cPar1 P' A\<^sub>Q \<Psi>\<^sub>Q)
        have "x \<sharp> M"
          by(rule brOutputFreshSubject)
          by(simp add: fresh_def)
        then show ?case
          by simp
      next
        case(cPar2 Q' A\<^sub>P \<Psi>\<^sub>P)
        have "x \<sharp> \<Psi>\<^sub>P"
          apply(drule_tac extractFrameFresh)
          by(simp add: frameResChainFresh) (simp add: fresh_def name_list_supp)
        have QTrans: "\<Psi> \<otimes> \<Psi>\<^sub>P \<rhd> \<lparr>\<nu>x\<rparr>Q \<longmapsto> \<tau> \<prec> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>Q')"
          by(rule BrClose)
        have Trans: "\<Psi> \<rhd> (P \<parallel> \<lparr>\<nu>x\<rparr>Q) \<longmapsto> \<tau> \<prec> (P \<parallel> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>Q'))"
          by(intro Par2) (assumption | simp)+
        ultimately have "(\<Psi>, (P \<parallel> (\<lparr>\<nu>*(x#xvec)\<rparr>Q')), (\<lparr>\<nu>*(x#xvec)\<rparr>P \<parallel> Q')) \<in> Rel"
          by(rule C3)
        then have Relation: "(\<Psi>, (P \<parallel> \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>Q')), \<lparr>\<nu>x\<rparr>(\<lparr>\<nu>*xvec\<rparr>P \<parallel> Q')) \<in> Rel"
          by simp
        from Trans Relation
        show ?case
          by blast
      next
        case(cBrComm1 \<Psi>\<^sub>Q P' A\<^sub>P \<Psi>\<^sub>P Q' A\<^sub>Q)
        have "x \<sharp> M"
          by(rule brInputFreshSubject)
          by(simp add: fresh_def)
        then show ?case
          by simp
      next
        case(cBrComm2 \<Psi>\<^sub>Q P' A\<^sub>P \<Psi>\<^sub>P Q' A\<^sub>Q)
        have "x \<sharp> M"
          by(rule brOutputFreshSubject)
          by(simp add: fresh_def)
        then show ?case
          by simp
      qed
    qed
  qed
qed

lemma simParComm:
  fixes \<Psi>   :: 'b
    and P   :: "('a, 'b, 'c) psi"
    and Q   :: "('a, 'b, 'c) psi"
    and Rel :: "('b \<times> ('a, 'b, 'c) psi \<times> ('a, 'b, 'c) psi) set"

assumes "eqvt Rel"
  and   C1: "\<And>\<Psi>' R S. (\<Psi>', R \<parallel> S, S \<parallel> R) \<in> Rel"
  and   C2: "\<And>\<Psi>' R S xvec. \<lbrakk>(\<Psi>', R, S) \<in> Rel; xvec \<sharp>* \<Psi>'\<rbrakk> \<Longrightarrow> (\<Psi>', \<lparr>\<nu>*xvec\<rparr>R, \<lparr>\<nu>*xvec\<rparr>S) \<in> Rel"

shows "\<Psi> \<rhd> P \<parallel> Q \<leadsto>[Rel] Q \<parallel> P"
proof(induct rule: simI[of _ _ _ _ "()"])
  case(cSim \<alpha> PQ)
  proof(induct rule: parCases[where C="()"])
    case(cPar1 Q' A\<^sub>P \<Psi>\<^sub>P)
    have "\<Psi> \<rhd> P \<parallel> Q \<longmapsto>\<alpha> \<prec> (P \<parallel> Q')" by(rule Par2)
    moreover have "(\<Psi>, P \<parallel> Q', Q' \<parallel> P) \<in> Rel" by(rule C1)
    ultimately show ?case by blast
  next
    case(cPar2 P' A\<^sub>Q \<Psi>\<^sub>Q)
    have "\<Psi> \<rhd> P \<parallel> Q \<longmapsto>\<alpha> \<prec> (P' \<parallel> Q)" by(rule Par1)
    moreover have "(\<Psi>, P' \<parallel> Q, Q \<parallel> P') \<in> Rel" by(rule C1)
    ultimately show ?case by blast
  next
    case(cComm1 \<Psi>\<^sub>P M N Q' A\<^sub>Q \<Psi>\<^sub>Q K xvec P' A\<^sub>P)
    have "\<Psi> \<otimes> \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>P \<turnstile> K \<leftrightarrow> M"
      by(rule chanEqSym)
    then have "\<Psi> \<otimes> \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q \<turnstile> K \<leftrightarrow> M"
      by(blast intro: statEqEnt compositionSym Commutativity)
    ultimately have "\<Psi> \<rhd> P \<parallel> Q \<longmapsto>\<tau> \<prec> \<lparr>\<nu>*xvec\<rparr>(P' \<parallel> Q')"
      by(intro Comm2) (assumption | simp)+
    moreover have "(\<Psi>, P' \<parallel> Q', Q' \<parallel> P') \<in> Rel" by(rule C1)
    ultimately show ?case by blast
  next
    case(cComm2 \<Psi>\<^sub>P M xvec N Q' A\<^sub>Q \<Psi>\<^sub>Q K P' A\<^sub>P)
    have "\<Psi> \<otimes> \<Psi>\<^sub>Q \<otimes> \<Psi>\<^sub>P \<turnstile> K \<leftrightarrow> M"
      by(rule chanEqSym)
    then have "\<Psi> \<otimes> \<Psi>\<^sub>P \<otimes> \<Psi>\<^sub>Q \<turnstile> K \<leftrightarrow> M"
      by(blast intro: statEqEnt compositionSym Commutativity)
    ultimately have "\<Psi> \<rhd> P \<parallel> Q \<longmapsto>\<tau> \<prec> \<lparr>\<nu>*xvec\<rparr>(P' \<parallel> Q')"
      by(intro Comm1) (assumption | simp add: freshChainSym)+
    moreover have "(\<Psi>, P' \<parallel> Q', Q' \<parallel> P') \<in> Rel" by(rule C1)
    ultimately show ?case by blast
  next
    case(cBrMerge \<Psi>\<^sub>P M N Q' A\<^sub>Q \<Psi>\<^sub>Q P' A\<^sub>P)
    then have "\<Psi> \<rhd> P \<parallel> Q \<longmapsto> \<questiondown>M\<lparr>N\<rparr> \<prec> P' \<parallel> Q'"
      by(intro BrMerge) (assumption|simp)+
    then show ?case by(blast intro: C1)
  next
    case(cBrComm1 \<Psi>\<^sub>P M N Q' A\<^sub>Q \<Psi>\<^sub>Q xvec P' A\<^sub>P)
    then have "\<Psi> \<rhd> P \<parallel> Q \<longmapsto> \<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P' \<parallel> Q'"
      by(intro BrComm2) (assumption|simp)+
    then show ?case by(blast intro: C1)
  next
    case(cBrComm2 \<Psi>\<^sub>P M xvec N Q' A\<^sub>Q \<Psi>\<^sub>Q P' A\<^sub>P)
    then have "\<Psi> \<rhd> P \<parallel> Q \<longmapsto> \<exclamdown>M\<lparr>\<nu>*xvec\<rparr>\<langle>N\<rangle> \<prec> P' \<parallel> Q'"
      by(intro BrComm1) (assumption|simp)+
    then show ?case by(blast intro: C1)
  qed
qed

lemma bangExtLeft:
  fixes \<Psi> :: 'b
    and P :: "('a, 'b, 'c) psi"

assumes "guarded P"
  and   "\<And>\<Psi>' Q. (\<Psi>', Q, Q) \<in> Rel"

shows "\<Psi> \<rhd> !P \<leadsto>[Rel] P \<parallel> !P"
  using assms
  by(auto simp add: simulation_def dest: Bang)

lemma bangExtRight:
  fixes \<Psi> :: 'b
    and P :: "('a, 'b, 'c) psi"

assumes C1: "\<And>\<Psi>' Q. (\<Psi>', Q, Q) \<in> Rel"

shows "\<Psi> \<rhd> P \<parallel> !P \<leadsto>[Rel] !P"
proof -
  {
    fix \<alpha> P'
    assume "\<Psi> \<rhd> !P \<longmapsto>\<alpha> \<prec> P'"
    then have "\<Psi> \<rhd> P \<parallel> !P \<longmapsto>\<alpha> \<prec> P'"
      apply -
      by(ind_cases "\<Psi> \<rhd> !P \<longmapsto>\<alpha> \<prec> P'") (auto simp add: psi.inject)
    moreover have "(\<Psi>, P', P') \<in> Rel" by(rule C1)
    ultimately have "\<exists>P''. \<Psi> \<rhd> P \<parallel> !P \<longmapsto>\<alpha> \<prec> P'' \<and> (\<Psi>, P'', P') \<in> Rel"
      by blast
  }
  then show ?thesis
    by(auto simp add: simulation_def)
qed

end

end
