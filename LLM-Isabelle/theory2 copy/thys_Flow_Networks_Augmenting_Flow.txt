theory Augmenting_Flow
imports Residual_Graph
begin


context NFlow
begin

definition augment :: "'capacity flow \<Rightarrow> 'capacity flow"
where "augment f' \<equiv> \<lambda>(u, v).
  if (u, v) \<in> E then
    f (u, v) + f' (u, v) - f' (v, u)
  else
    0"

abbreviation (input) augment_syntax (infix "\<up>" 55) 
  where "\<And>f f'. f\<up>f' \<equiv> NFlow.augment c f f'"


context 
  fixes f' :: "'capacity flow"
  assumes f'_flow: "Flow cf s t f'"
begin  

interpretation f': Flow cf s t f' by (rule f'_flow)

lemma augment_flow_presv_cap: 
  shows "0 \<le> (f\<up>f')(u,v) \<and> (f\<up>f')(u,v) \<le> c(u,v)"
proof (cases "(u,v)\<in>E"; rule conjI) 
  assume [simp]: "(u,v)\<in>E"
  hence "f(u,v) = cf(v,u)" 
    using no_parallel_edge by (auto simp: residualGraph_def)
  also have "cf(v,u) \<ge> f'(v,u)" using f'.capacity_const by auto

    note [trans] = xtrans

    by (auto simp: augment_def)
  also have "\<dots> \<ge> f(u,v) + f'(u,v) - f(u,v)"
  also have "\<dots> = f'(u,v)" by auto
  also have "\<dots> \<ge> 0" using f'.capacity_const by auto
  finally show "(f\<up>f')(u,v) \<ge> 0" .
    
  have "(f\<up>f')(u,v) = f(u,v) + f'(u,v) - f'(v,u)" 
    by (auto simp: augment_def)
  also have "\<dots> \<le> f(u,v) + f'(u,v)" using f'.capacity_const by auto
  also have "\<dots> \<le> f(u,v) + cf(u,v)" using f'.capacity_const by auto
  also have "\<dots> = f(u,v) + c(u,v) - f(u,v)" 
    by (auto simp: residualGraph_def)
  also have "\<dots> = c(u,v)" by auto
  finally show "(f\<up>f')(u, v) \<le> c(u, v)" .
qed (auto simp: augment_def cap_positive)

  

private lemma split_rflow_outgoing: 
  "(\<Sum>v\<in>cf.E``{u}. f' (u,v)) = (\<Sum>v\<in>E``{u}. f'(u,v)) + (\<Sum>v\<in>E\<inverse>``{u}. f'(u,v))"
  (is "?LHS = ?RHS")
proof -
  from no_parallel_edge have DJ: "E``{u} \<inter> E\<inverse>``{u} = {}" by auto

  have "?LHS = (\<Sum>v\<in>E``{u} \<union> E\<inverse>``{u}. f' (u,v))"
    apply (rule sum.mono_neutral_left)
    using cfE_ss_invE
    by (auto intro: finite_Image)
  also have "\<dots> = ?RHS"
    apply (subst sum.union_disjoint[OF _ _ DJ])
    by (auto intro: finite_Image)
  finally show "?LHS = ?RHS" .
qed  

private lemma split_rflow_incoming: 
  "(\<Sum>v\<in>cf.E\<inverse>``{u}. f' (v,u)) = (\<Sum>v\<in>E``{u}. f'(v,u)) + (\<Sum>v\<in>E\<inverse>``{u}. f'(v,u))"
  (is "?LHS = ?RHS")
proof -
  from no_parallel_edge have DJ: "E``{u} \<inter> E\<inverse>``{u} = {}" by auto

  have "?LHS = (\<Sum>v\<in>E``{u} \<union> E\<inverse>``{u}. f' (v,u))"
    apply (rule sum.mono_neutral_left)
    using cfE_ss_invE
    by (auto intro: finite_Image)
  also have "\<dots> = ?RHS"
    apply (subst sum.union_disjoint[OF _ _ DJ])
    by (auto intro: finite_Image)
  finally show "?LHS = ?RHS" .
qed  

context 
  fixes u :: node
  assumes U_ASM: "u\<in>V - {s,t}"
begin  

private lemma flow_summation_aux:
  shows "(\<Sum>v\<in>E``{u}. f' (u,v))  - (\<Sum>v\<in>E``{u}. f' (v,u))
       = (\<Sum>v\<in>E\<inverse>``{u}. f' (v,u)) - (\<Sum>v\<in>E\<inverse>``{u}. f' (u,v))"
   (is "?LHS = ?RHS" is "?A - ?B = ?RHS")
proof -
  have "?A = (\<Sum>v\<in>cf.E``{u}. f' (u, v)) - (\<Sum>v\<in>E\<inverse>``{u}. f' (u, v))"
    by (simp add: split_rflow_outgoing)
  also have "(\<Sum>v\<in>cf.E``{u}. f' (u, v)) = (\<Sum>v\<in>cf.E\<inverse>``{u}. f' (v, u))"  
    using U_ASM
    by (simp add: f'.conservation_const_pointwise)
  finally have "?A = (\<Sum>v\<in>cf.E\<inverse>``{u}. f' (v, u)) - (\<Sum>v\<in>E\<inverse>``{u}. f' (u, v))" 
    by simp
  moreover
  have "?B = (\<Sum>v\<in>cf.E\<inverse>``{u}. f' (v, u)) - (\<Sum>v\<in>E\<inverse>``{u}. f' (v, u))"
    by (simp add: split_rflow_incoming)
  ultimately show "?A - ?B = ?RHS" by simp
qed    

lemma augment_flow_presv_con: 
  shows "(\<Sum>e \<in> outgoing u. augment f' e) = (\<Sum>e \<in> incoming u. augment f' e)"
    (is "?LHS = ?RHS")
proof -
  let ?Vo = "E``{u}" let ?Vi = "E\<inverse>``{u}"

  have "?LHS = (\<Sum>v\<in>?Vo. augment f' (u,v))"
    by (auto simp: sum_outgoing_pointwise)
  also have "\<dots> 
    = (\<Sum>v\<in>?Vo. f (u,v) + f'(u,v) - f'(v,u))"  
    by (auto simp: augment_def)
  also have "\<dots> 
    = (\<Sum>v\<in>?Vo. f (u,v)) + (\<Sum>v\<in>?Vo. f' (u,v)) - (\<Sum>v\<in>?Vo. f' (v,u))"
    by (auto simp: sum_subtractf sum.distrib)
  also have "\<dots> 
    = (\<Sum>v\<in>?Vi. f (v,u)) + (\<Sum>v\<in>?Vi. f' (v,u)) - (\<Sum>v\<in>?Vi. f' (u,v))" 
    by (auto simp: conservation_const_pointwise[OF U_ASM] flow_summation_aux)
  also have "\<dots> 
    = (\<Sum>v\<in>?Vi. f (v,u) + f' (v,u) - f' (u,v))" 
    by (auto simp: sum_subtractf sum.distrib)
  also have "\<dots> 
    = (\<Sum>v\<in>?Vi. augment f' (v,u))"  
    by (auto simp: augment_def)
  also have "\<dots> 
    = ?RHS"
    by (auto simp: sum_incoming_pointwise)
  finally show "?LHS = ?RHS" .
qed  
  as closely as possible. Unfortunately, this proof generalizes the summation to all 
  nodes immediately, rendering the first equation invalid.
  Trying to fix this error, we encountered that the step that uses the conservation 
  constraints on the augmenting flow is more subtle as indicated in the original proof.
  Thus, we moved this argument to an auxiliary lemma. \<close>
end \<comment> \<open>@{term u} is node\<close>
text \<open>As main result, we get that the augmented flow is again a valid flow.\<close>
subsection \<open>Value of the Augmented Flow\<close>
text \<open>Next, we show that the value of the augmented flow is the sum of the values
  of the original flow and the augmenting flow.\<close>
  txt \<open>For this proof, we set up Isabelle's rewriting engine for rewriting of sums.
    In particular, we add lemmas to convert sums over incoming or outgoing 
    edges to sums over all vertices. This allows us to write the summations
    from Cormen et al.~a bit more concise, leaving some of the tedious 
    calculation work to the computer.\<close>
  txt \<open>Note that, if neither an edge nor its reverse is in the graph,
    there is also no edge in the residual graph, and thus the flow value
    is zero.\<close>  
  txt \<open>Now, the proposition follows by straightforward rewriting of 
    the summations:\<close>
    \<comment> \<open>Note that this is the crucial step of the proof, which Cormen et al. leave as an exercise.\<close>
txt \<open>Note, there is also an automatic proof. When creating the above 
    explicit proof, this automatic one has been used to extract meaningful
    subgoals, abusing Isabelle as a term rewriter.\<close>
end \<comment> \<open>Augmenting flow\<close>
end \<comment> \<open>Network flow\<close>
end \<comment> \<open>Theory\<close>
