theory KMP
imports
  Theory_Of_Lists
begin

hide_const abs




use strict lists.

\<close>
text\<open>

suffix of @{term "stake\<cdot>p\<cdot>xs"}.''

The following examples illustrate this behaviour:

\<close>
text\<open>

Bird's strategy for deriving KMP from this specification is encoded in the following lemmas:

\<close>
lemma smap_sfilter_split_cfcomp: \<comment>\<open> Bird (16.4) \<close>
  assumes "p\<cdot>\<bottom> = \<bottom>" \<comment>\<open> We can reasonably expect the predicate to be strict \<close>
text\<open>


\<close>
lemma endswith_def2:  \<comment>\<open> Bird p127 \<close>
    using \<open>slength\<cdot>xs = MkI\<cdot>xsl\<close> \<open>slength\<cdot>pat = MkI\<cdot>patl\<close>
    using \<open>slength\<cdot>xs = MkI\<cdot>xsl\<close>
    using False_False \<open>0 \<le> xsl\<close> \<open>0 \<le> patl\<close>
    case TT with \<open>slength\<cdot>xs = MkI\<cdot>xsl\<close> \<open>slength\<cdot>pat = MkI\<cdot>patl\<close>
    case FF \<comment>\<open> Recursive case: the lists generated by \<open>supto\<close> are too short \<close>
text\<open>


\<close>
fixrec split :: "[:'a::Eq_def:] \<rightarrow> [:'a:] \<rightarrow> [:'a:] \<times> [:'a:]" where \<comment>\<open> Bird p128 \<close>
lemma split_pattern: \<comment>\<open> Bird p128, observation \<close>
lemma endswith_split: \<comment>\<open> Bird p128, after defining \<open>split\<close> \<close>
text\<open>



\<close>
text\<open>




\<close>
lemma split_snoc: \<comment>\<open> Bird p128 \<close>
fixrec \<comment>\<open> Bird p129 \<close>
text\<open>

@{prop "op\<cdot>pat\<cdot>(split\<cdot>pat\<cdot>xs)\<cdot>x \<sqsubseteq> split\<cdot>pat\<cdot>(xs :@ [:x:])"}. For total correctness we

\<close>
text\<open>

that exhibits how KMP handles the failure of the text to continue matching the pattern:

\<close>
     (     If prefix\<cdot>[:x:]\<cdot>vs then (us :@ [:x:], stail\<cdot>vs) \<comment> \<open> continue matching \<close>
      else If snull\<cdot>us then ([::], pat) \<comment> \<open> fail at the start of the pattern: discard \<open>x\<close> \<close>
      else sfoldl\<cdot>(op'\<cdot>pat)\<cdot>([::], pat)\<cdot>(stail\<cdot>us :@ [:x:]) \<comment> \<open> fail later: discard \<open>shead\<cdot>us\<close> and determine where to restart \<close>
text\<open>


lemma op'_strict[simp]:
  "op'\<cdot>pat\<cdot>\<bottom> = \<bottom>"
  "op'\<cdot>pat\<cdot>(us, \<bottom>) = \<bottom>"
  "op'\<cdot>pat\<cdot>usvs\<cdot>\<bottom> = \<bottom>"
by fixrec_simp+

lemma sfoldl_op'_strict[simp]:
  "op'\<cdot>pat\<cdot>(sfoldl\<cdot>(op'\<cdot>pat)\<cdot>(us, \<bottom>)\<cdot>xs)\<cdot>x = \<bottom>"
by (induct xs arbitrary: x rule: srev_induct) simp_all

lemma op'_op:
  shows "op'\<cdot>pat\<cdot>usvs\<cdot>x = op\<cdot>pat\<cdot>usvs\<cdot>x"
proof(cases "pat = \<bottom>" "x = \<bottom>" rule: bool.exhaust[case_product bool.exhaust])
  case True_False then show ?thesis
    apply (subst op'.unfold)
    apply (subst op.unfold)
    apply simp
    done
next
  case False_False then show ?thesis
  proof(induct usvs arbitrary: x rule: op_induct)
    case (step usvs x)
    have *: "sfoldl\<cdot>(op'\<cdot>pat)\<cdot>([::], pat)\<cdot>xs = sfoldl\<cdot>(op\<cdot>pat)\<cdot>([::], pat)\<cdot>xs"
         if "lt\<cdot>(slength\<cdot>xs)\<cdot>(slength\<cdot>(cfst\<cdot>usvs)) = TT" for xs
    using that
    proof(induct xs rule: srev_induct)
      case (ssnoc x' xs')
      from ssnoc(1,2,4) have "lt\<cdot>(slength\<cdot>xs')\<cdot>(slength\<cdot>(cfst\<cdot>usvs)) = TT"
        using lt_slength_0(2) lt_trans by auto
      moreover
      from step(2) ssnoc(1,2,4) have "lt\<cdot>(slength\<cdot>(cfst\<cdot>(split\<cdot>pat\<cdot>xs')))\<cdot>(slength\<cdot>(cfst\<cdot>usvs)) = TT"
        using lt_trans split_length_lt by (auto 10 0)
      ultimately show ?case by (simp add: ssnoc.hyps split_sfoldl_op split_snoc_op step)
    qed simp_all
    from step.prems show ?case
      apply (subst op'.unfold)
      apply (subst op.unfold)
      apply (clarsimp simp: If2_def[symmetric] snull_FF_conv split_sfoldl_op[symmetric] * split: If2_splits)
      apply (clarsimp simp: split_sfoldl_op step split_length_lt)
      done
  qed
qed simp_all




  = Null


  "(Node\<cdot>a\<cdot>l\<cdot>r = Node\<cdot>a'\<cdot>l'\<cdot>r') \<longleftrightarrow> (a = a' \<and> (a \<noteq> \<bottom> \<longrightarrow> l = l' \<and> r = r'))"
by (cases "a = \<bottom>"; clarsimp)

lemma match_Null_match_Node_tree_case: "match_Null\<cdot>t\<cdot>k1 +++ match_Node\<cdot>t\<cdot>k2 = tree_case\<cdot>k1\<cdot>k2\<cdot>t"
by (cases t) simp_all

lemma match_Node_mplus_match_Node: "match_Node\<cdot>x\<cdot>k1 +++ match_Node\<cdot>x\<cdot>k2 = match_Node\<cdot>x\<cdot>(\<Lambda> v l r. k1\<cdot>v\<cdot>l\<cdot>r +++ k2\<cdot>v\<cdot>l\<cdot>r)"
by (cases x; clarsimp)

lemma tree_case_distr:
  "f\<cdot>\<bottom> = \<bottom> \<Longrightarrow> f\<cdot>(tree_case\<cdot>g\<cdot>h\<cdot>t) = tree_case\<cdot>(f\<cdot>g)\<cdot>(\<Lambda> x l r. f\<cdot>(h\<cdot>x\<cdot>l\<cdot>r))\<cdot>t"
  "(tree_case\<cdot>g'\<cdot>h'\<cdot>t)\<cdot>z = tree_case\<cdot>(g'\<cdot>z)\<cdot>(\<Lambda> x l r. h'\<cdot>x\<cdot>l\<cdot>r\<cdot>z)\<cdot>t"
by (case_tac [!] t) simp_all

lemma tree_case_cong:
  assumes "t = t'"
  assumes "t' = Null \<Longrightarrow> n = n'"
  assumes "\<And>v l r. \<lbrakk>t' = Node\<cdot>v\<cdot>l\<cdot>r; v \<noteq> \<bottom>\<rbrakk> \<Longrightarrow> c v l r = c' v l r"
  assumes "cont (\<lambda>(x, y, z). c x y z)"
  assumes "cont (\<lambda>(x, y, z). c' x y z)"
  shows "tree_case\<cdot>n\<cdot>(\<Lambda> v l r. c v l r)\<cdot>t = tree_case\<cdot>n'\<cdot>(\<Lambda> v l r. c' v l r)\<cdot>t'"
using assms by (cases t; cases t'; clarsimp simp: prod_cont_iff)

lemma tree_take_smaller:
  assumes "tree_take i\<cdot>t = tree_take i\<cdot>u"
  assumes "j \<le> i"
  shows "tree_take j\<cdot>t = tree_take j\<cdot>u"
using assms by (metis min.orderE tree.take_take)

fixrec tree_map' :: "('a \<rightarrow> 'b) \<rightarrow> 'a tree \<rightarrow> 'b tree" where
  "tree_map'\<cdot>f\<cdot>Null = Null"
| "a \<noteq> \<bottom> \<Longrightarrow> tree_map'\<cdot>f\<cdot>(Node\<cdot>a\<cdot>l\<cdot>r) = Node\<cdot>(f\<cdot>a)\<cdot>(tree_map'\<cdot>f\<cdot>l)\<cdot>(tree_map'\<cdot>f\<cdot>r)"

lemma tree_map'_strict[simp]: "tree_map'\<cdot>f\<cdot>\<bottom> = \<bottom>"
by fixrec_simp

lemma tree_map'_ID': "tree_map'\<cdot>ID\<cdot>xs = xs"
by (induct xs) simp_all

lemma tree_map'_ID[simp]: "tree_map'\<cdot>ID = ID"
by (clarsimp simp: cfun_eq_iff tree_map'_ID')

lemma tree_map'_strict_scons[simp]:
  assumes "f\<cdot>\<bottom> = \<bottom>"
  shows "tree_map'\<cdot>f\<cdot>(Node\<cdot>a\<cdot>l\<cdot>r) = Node\<cdot>(f\<cdot>a)\<cdot>(tree_map'\<cdot>f\<cdot>l)\<cdot>(tree_map'\<cdot>f\<cdot>r)"
using assms by (cases "a = \<bottom>"; clarsimp)

lemma tree_map'_comp'[simp]:
  assumes "f\<cdot>\<bottom> = \<bottom>"
  shows "tree_map'\<cdot>f\<cdot>(tree_map'\<cdot>g\<cdot>t) = tree_map'\<cdot>(f oo g)\<cdot>t"
using assms by (induct t) simp_all

lemma tree_map'_comp[simp]:
  assumes "f\<cdot>\<bottom> = \<bottom>"
  shows "tree_map'\<cdot>f oo tree_map'\<cdot>g = tree_map'\<cdot>(f oo g)"
using assms by (clarsimp simp: cfun_eq_iff)

  fixes x :: "'a tree"
  assumes xfx: "x = f\<cdot>x"
  assumes f: "\<And>i t u. tree_take i\<cdot>t = tree_take i\<cdot>u
                      \<Longrightarrow> tree_take (Suc i)\<cdot>(f\<cdot>t) = tree_take (Suc i)\<cdot>(f\<cdot>u)"
  shows "x = fix\<cdot>f"
proof(rule tree.take_lemma)
  fix i show "tree_take i\<cdot>x = tree_take i\<cdot>(fix\<cdot>f)"
  proof(induct i)
    case (Suc i) from xfx f[OF Suc, folded fix_eq] show ?case by simp
  qed simp
qed


fixrec "next" :: "[:'a::Eq_def:] \<rightarrow> ([:'a:] \<times> [:'a:]) tree \<rightarrow> ([:'a:] \<times> [:'a:]) tree" where
  "next\<cdot>[::]\<cdot>t = t"
| "\<lbrakk>x \<noteq> \<bottom>; xs \<noteq> \<bottom>\<rbrakk> \<Longrightarrow>
   next\<cdot>(x :# xs)\<cdot>Null = Null"
| "\<lbrakk>x \<noteq> \<bottom>; xs \<noteq> \<bottom>\<rbrakk> \<Longrightarrow>
   next\<cdot>(x :# xs)\<cdot>(Node\<cdot>(us, [::])\<cdot>l\<cdot>r) = Node\<cdot>(us, [::])\<cdot>l\<cdot>r"
| "\<lbrakk>v \<noteq> \<bottom>; vs \<noteq> \<bottom>; x \<noteq> \<bottom>; xs \<noteq> \<bottom>\<rbrakk> \<Longrightarrow>
   next\<cdot>(x :# xs)\<cdot>(Node\<cdot>(us, v :# vs)\<cdot>l\<cdot>r) = If eq\<cdot>x\<cdot>v then l else Node\<cdot>(us, v :# vs)\<cdot>l\<cdot>r"

    root2  :: "[:'a::Eq_def:] \<rightarrow> ([:'a:] \<times> [:'a:]) tree"
and op2    :: "[:'a:] \<rightarrow> ([:'a:] \<times> [:'a:]) tree \<rightarrow> 'a \<rightarrow> ([:'a:] \<times> [:'a:]) tree"
and rep2   :: "[:'a:] \<rightarrow> [:'a:] \<times> [:'a:] \<rightarrow> ([:'a:] \<times> [:'a:]) tree"
and left2  :: "[:'a:] \<rightarrow> [:'a:] \<times> [:'a:] \<rightarrow> ([:'a:] \<times> [:'a:]) tree"
and right2 :: "[:'a:] \<rightarrow> [:'a:] \<times> [:'a:] \<rightarrow> ([:'a:] \<times> [:'a:]) tree"
where
  [simp del]:
  "root2\<cdot>pat = rep2\<cdot>pat\<cdot>([::], pat)"
| "op2\<cdot>pat\<cdot>Null\<cdot>x = root2\<cdot>pat"
| "usvs \<noteq> \<bottom> \<Longrightarrow>
   op2\<cdot>pat\<cdot>(Node\<cdot>usvs\<cdot>l\<cdot>r)\<cdot>x = If prefix\<cdot>[:x:]\<cdot>(csnd\<cdot>usvs) then r else op2\<cdot>pat\<cdot>l\<cdot>x"
| [simp del]:
  "rep2\<cdot>pat\<cdot>usvs = Node\<cdot>usvs\<cdot>(left2\<cdot>pat\<cdot>usvs)\<cdot>(right2\<cdot>pat\<cdot>usvs)"
| "left2\<cdot>pat\<cdot>([::], vs) = next\<cdot>vs\<cdot>Null"
| "\<lbrakk>u \<noteq> \<bottom>; us \<noteq> \<bottom>\<rbrakk> \<Longrightarrow>
| "\<lbrakk>v \<noteq> \<bottom>; vs \<noteq> \<bottom>\<rbrakk> \<Longrightarrow>
   right2\<cdot>pat\<cdot>(us, v :# vs) = rep2\<cdot>pat\<cdot>(us :@ [:v:], vs)"

fixrec abs2 :: "([:'a:] \<times> [:'a:]) tree \<rightarrow> [:'a:] \<times> [:'a:]" where
 "usvs \<noteq> \<bottom> \<Longrightarrow> abs2\<cdot>(Node\<cdot>usvs\<cdot>l\<cdot>r) = usvs"

fixrec matches2 :: "[:'a::Eq_def:] \<rightarrow> [:'a:] \<rightarrow> [:Integer:]" where
[simp del]: "matches2\<cdot>pat = smap\<cdot>cfst oo sfilter\<cdot>(snull oo csnd oo abs2 oo csnd)
                                     oo sscanl\<cdot>(\<Lambda> (n, x) y. (n + 1, op2\<cdot>pat\<cdot>x\<cdot>y))\<cdot>(0, root2\<cdot>pat)"


lemma concrete_tree_KMP:
  shows "root2\<cdot>[:0::Integer, 1, 0, 0, 1:]
      = (\<mu> q0. Node\<cdot>([::], [:0, 1, 0, 0, 1:])
                     \<cdot>Null
                     \<cdot>(\<mu> q1. Node\<cdot>([:0:], [:1, 0, 0, 1:])
                          \<cdot>q0
                          \<cdot>(\<mu> q2. Node\<cdot>([:0,1:], [:0, 0, 1:])
                               \<cdot>(Node\<cdot>([:0,1,0:], [:0, 1:])
                                     \<cdot>q1
                                     \<cdot>(Node\<cdot>([:0,1,0,0:], [:1:])
                                          \<cdot>(Node\<cdot>([:0,1,0,0,1:], [::])\<cdot>q2\<cdot>Null))))))"
(is "?lhs = fix\<cdot>?F")
  note rep2.simps[simp]
  show "?lhs = ?F\<cdot>?lhs"
    apply (subst root2.unfold; simp)
    apply (rule tree_unique; simp)
     apply (intro conjI)
      apply (subst (1) root2.unfold; simp)
      apply (subst (1) root2.unfold; fastforce)
     apply (rule tree_unique; simp)
      apply (intro conjI)
         apply (subst (1) root2.unfold; simp)
         apply (subst (1) root2.unfold; simp)
        apply (subst (1) root2.unfold; simp)
        apply (subst (1) root2.unfold; fastforce)
       apply (subst (1) root2.unfold; simp)
       apply (subst (1) root2.unfold; simp)
       apply (subst (1) root2.unfold; simp)
       apply (subst (1 2) root2.unfold; fastforce)
      apply (subst (1) root2.unfold; simp)
      apply (subst (1) root2.unfold; simp)
      apply (subst (1) root2.unfold; fastforce)
     apply (rename_tac i t u; case_tac i; clarsimp)
     apply (rename_tac t u i; case_tac i; clarsimp)
     apply (rename_tac t u i; case_tac i; clarsimp)
     apply (meson Suc_n_not_le_n linear tree_take_smaller)
    apply (rule parallel_fix_ind; simp)
    apply (rename_tac i t u x y; case_tac i; clarsimp)
    apply (rename_tac i; case_tac i; clarsimp; intro conjI)
     apply (meson Suc_n_not_le_n linear tree_take_smaller)
    apply (rename_tac i; case_tac i; clarsimp)
    apply (rename_tac i; case_tac i; clarsimp)
    apply (meson Suc_n_not_le_n linear tree_take_smaller)
    done
  fix i :: nat
  fix t u :: "([:Integer:] \<times> [:Integer:]) tree"
  assume "tree_take i\<cdot>t = tree_take i\<cdot>u"
  then show "tree_take (Suc i)\<cdot>(?F\<cdot>t) = tree_take (Suc i)\<cdot>(?F\<cdot>u)"
    apply simp
    apply (rule parallel_fix_ind; simp)
    apply (case_tac i; clarsimp; intro conjI)
     apply (meson Suc_n_not_le_n linear tree_take_smaller)
    apply (rule parallel_fix_ind; simp)
    apply (rename_tac j t0 t1; case_tac j; clarsimp)
    apply (rename_tac j; case_tac j; clarsimp; intro conjI)
     apply (meson Suc_n_not_le_n linear tree_take_smaller)
    apply (rename_tac j; case_tac j; clarsimp; intro conjI)
     apply (meson Suc_n_not_le_n linear tree_take_smaller)
    apply (rename_tac j; case_tac j; clarsimp)
    apply (meson Suc_n_not_le_n linear tree_take_smaller)
    done
qed


any KMP node except for the rightmost
(i.e., the one that signals a complete pattern match) where no optimisation is possible.

We proceed with the formalities of the data refinement.

\<close>
schematic_goal root2_op2_rep2_left2_right2_def: \<comment> \<open> Obtain the definition of these functions as a single fixed point \<close>
lemma rep2_snoc_right2: \<comment>\<open> Bird p131 \<close>
text\<open>

justify this data refinement as his condition (iii) requires the
worker functions to coincide on all representation values. Concretely
he asks that:

\begin{center}
\end{center}

such as:

\begin{center}
\end{center}

need to establish this identity for valid representations, i.e., when
pictures, we show that this diagram commutes:

\begin{center}
  \begin{tikzcd}[column sep=8em]
  \end{tikzcd}
\end{center}

Clearly this result self-composes: after an initial @{term

\<close>
      from \<open>pat \<noteq> \<bottom>\<close> ssnoc(1,2,4) usvs show ?case
    qed (fastforce simp: \<open>pat \<noteq> \<bottom>\<close> root2.unfold)+
      from \<open>pat \<noteq> \<bottom>\<close> scons have "lt\<cdot>(slength\<cdot>(cfst\<cdot>(split\<cdot>pat\<cdot>us')))\<cdot>(slength\<cdot>us) = TT"
      from \<open>pat \<noteq> \<bottom>\<close> \<open>x \<noteq> \<bottom>\<close> usvs that scons this show ?thesis
    from \<open>usvs \<noteq> \<bottom>\<close> usvs show ?case
text\<open>

Therefore the result of this data refinement is extensionally equal to
the specification:

\<close>
      apply (subst matches_op) \<comment>\<open> Continue with previous derivation. \<close>
text\<open>

This computation can be thought of as a pair coroutines with a
laziness is not essential (see \S\ref{sec:implementations}), though it
does depend on being able to traverse incompletely defined trees.

The key difficulty in defining this computation in HOL using present

While this representation works for automata with this sort of
structure, it is unclear how general it is; in particular it may not
it is probably only useful in ``closed'' settings like the present

\label{thm:k_property}

trees that have the `K' property, viz that labels on consecutive nodes
on a left path do not start with the same symbol. This also
pattern of proof used here -- induction nested in coinduction --
recurs in \S\ref{sec:KMP:increase_sharing}.

\<close>
  case (ssnoc x xs) with \<open>pat \<noteq> \<bottom>\<close> ssnoc show ?case by (clarsimp simp: split_sfoldl_op[symmetric] op_op2_refinement)
qed (simp_all add: \<open>pat \<noteq> \<bottom>\<close> root2.unfold)
      case bottom with \<open>us \<noteq> \<bottom>\<close> show ?thesis by simp
      from \<open>pat \<noteq> \<bottom>\<close> scons \<open>us \<noteq> \<bottom>\<close> \<open>vs \<noteq> \<bottom>\<close>
        with \<open>pat \<noteq> \<bottom>\<close> \<open>us = u' :# us'\<close> \<open>u' \<noteq> \<bottom>\<close> \<open>us' \<noteq> \<bottom>\<close> \<open>vs \<noteq> \<bottom>\<close> r splitl show ?thesis
      qed (simp add: \<open>vs \<noteq> \<bottom>\<close>)
      from \<open>us :@ vs = pat\<close> \<open>us \<noteq> \<bottom>\<close> \<open>vs \<noteq> \<bottom>\<close> r
        case snil with \<open>us :@ vs = pat\<close> \<open>us = u' :# us'\<close> splitl show ?thesis
        with scons \<open>pat \<noteq> \<bottom>\<close> \<open>us = u' :# us'\<close> \<open>u' \<noteq> \<bottom>\<close> \<open>us' \<noteq> \<bottom>\<close> \<open>vs \<noteq> \<bottom>\<close> r splitl \<open>vs = v :# vs'\<close> show ?thesis
          using step(1)[OF _ \<open>pat \<noteq> \<bottom>\<close>, where us'="prod.fst (split\<cdot>pat\<cdot>us')" and vs="prod.snd (split\<cdot>pat\<cdot>us')"]
      qed (simp add: \<open>vsl \<noteq> \<bottom>\<close>)
      moreover note \<open>pat \<noteq> \<bottom>\<close> \<open>us \<noteq> \<bottom>\<close> \<open>vs \<noteq> \<bottom>\<close>
text\<open>

The remaining steps are as follows:

\<^item> 5. simplify to Bird's ``simpler forms.''

\<close>
subsection\<open> Step 3: Introduce an accumulating parameter (grep) \<close>
text\<open>

Next we prepare for the second memoization step (\S\ref{sec:KMP:increase_sharing})
subtree.

simplification.

\<close>
fixrec \<comment>\<open> Bird p131 / p132 \<close>
| [simp del]: \<comment>\<open> Inline @{const \<open>left2\<close>}, factor out @{const \<open>next\<close>}. \<close>
| [simp del]:  \<comment>\<open> @{const \<open>rep2\<close>} with @{const \<open>left2\<close>} abstracted, @{const \<open>right2\<close>} inlined. \<close>
apply (simp add: fix_cprod fix_const) \<comment>\<open> Very slow. Sensitive to tuple order due to the asymmetry of \<open>fix_cprod\<close>. \<close>
subsection\<open> Step 4: Inline rep \<close>
text\<open>


\<close>
              [::] \<Rightarrow> Null \<comment>\<open> unreachable \<close>
by (induct rule: parallel_fix_ind) (use assms in \<open>auto simp: prod_cont_iff\<close>)
apply (subst fix_syn4_permute; clarsimp simp: fix_cprod fix_const) \<comment>\<open> Slow \<close>
subsection\<open> Step 5: Simplify to Bird's ``simpler forms'' \<close>
text\<open>

@{text "case"} scrutinee from @{term "cfst\<cdot>usvs :@ [:v:]"} into @{term "cfst\<cdot>usvs"}.

\<close>
        | v :# vs \<Rightarrow> grep5\<cdot>pat\<cdot>(case cfst\<cdot>usvs of \<comment> \<open> was @{term \<open>cfst\<cdot>usvs :@ [:v:]\<close>} \<close>
subsection\<open> Step 6: Memoize left \label{sec:KMP:increase_sharing} \<close>
text\<open>

The last substantial step is to memoise the computation of the left subtrees by tying the knot.


\<close>
fixrec \<comment>\<open> Bird p132 \<close>
text\<open>

Intuitively this step cashes in the fact that, in the context of
"sfoldl\<cdot>(op6\<cdot>pat)\<cdot>(root6\<cdot>pat)\<cdot>us"} is

Connecting this step with the previous one is not simply a matter of
equational reasoning; we can see this by observing that the right
these cannot be extensionally equal. Furthermore the computations of
lockstep: consider the computation of the left subtree.

For our purposes it is enough to show that the trees @{const
from which it follows that @{prop "op6 = op5"} by induction on its
tree argument. The equality is established by exhibiting a @{emph


\<close>
text\<open>


\<close>
inductive \<comment>\<open> This relation is not inductive. \<close>
using \<open>root_bisim pat t6 t5\<close>
text\<open>

when proving that this tree has the `K' property in
\S\ref{thm:k_property}.

\<close>
  shows root_bisim_op: "root_bisim pat t6 t5 \<Longrightarrow> root_bisim pat (op6\<cdot>pat\<cdot>t6\<cdot>x) (op5\<cdot>pat\<cdot>t5\<cdot>x)" \<comment> \<open> unused \<close>
          moreover from that gl scons \<open>x \<noteq> \<bottom>\<close> have "le\<cdot>(slength\<cdot>(cfst\<cdot>usvs'))\<cdot>(slength\<cdot>us'' + 1) = TT"
      from \<open>vs \<noteq> \<bottom>\<close> \<open>xs \<noteq> \<bottom>\<close> 2(1) show ?case
        case gl with \<open>cfst\<cdot>usvs \<noteq> \<bottom>\<close> \<open>x \<noteq> \<bottom>\<close> show ?thesis using slength_ogl by blast
          case bottom with nl \<open>cfst\<cdot>usvs \<noteq> \<bottom>\<close> show ?thesis by simp
          case Null with nl \<open>us \<noteq> \<bottom>\<close> \<open>vs \<noteq> \<bottom>\<close> show ?thesis
            case bottom with \<open>us \<noteq> \<bottom>\<close> show ?thesis by simp
        case TT with \<open>pat \<noteq> \<bottom>\<close> \<open>us \<noteq> \<bottom>\<close> show ?thesis
        case FF with \<open>pat \<noteq> \<bottom>\<close> \<open>us \<noteq> \<bottom>\<close> show ?thesis
        qed (use \<open>pat \<noteq> \<bottom>\<close> ssnoc root_bisim_root in auto)
      qed (use \<open>pat \<noteq> \<bottom>\<close> root_bisim_root in auto) }
      from rbl \<open>pat \<noteq> \<bottom>\<close> show rbnl: "?rbnl us vs"
  from \<open>pat \<noteq> \<bottom>\<close> this(4) show "root_bisim pat t6 t5 \<Longrightarrow> root_bisim pat (op6\<cdot>pat\<cdot>t6\<cdot>x) (op5\<cdot>pat\<cdot>t5\<cdot>x)"
  show \<open>root_bisim pat (next\<cdot>vs\<cdot>(left6\<cdot>pat\<cdot>us)) (next\<cdot>vs\<cdot>(left5\<cdot>pat\<cdot>us))\<close> by fact
text\<open>

With this result in hand the remainder is technically fiddly but straightforward.

\<close>
  from True \<open>root6\<cdot>pat = root5\<cdot>pat\<close> have "op6\<cdot>pat\<cdot>t\<cdot>x = op5\<cdot>pat\<cdot>t\<cdot>x" for t x
text\<open>

We conclude this section by observing that accumulator-introduction is a well known technique
literature assume that the type involved is defined inductively. Bird adopts this strategy without
considering what the mixed inductive/coinductive rule is that justifies the preservation of total
correctness.

The difficulty of this step is why we wired in the `K' opt earlier: it allows us to preserve the
shape of the tree all the way from the data refinement to the final version.

\<close>
subsection\<open> Step 7: Simplify, unfold prefix \<close>
text\<open>



\<close>
| "op7\<cdot>pat\<cdot>(Node\<cdot>(us, [::])\<cdot>l\<cdot>r)\<cdot>x = op7\<cdot>pat\<cdot>l\<cdot>x" \<comment>\<open> Unfold \<open>prefix\<close> \<close>
  "grep7\<cdot>pat\<cdot>l\<cdot>(us, [::]) = Node\<cdot>(us, [::])\<cdot>l\<cdot>Null" \<comment>\<open> Case split on \<open>vs\<close> hoisted above \<open>Node\<close>. \<close>
subsection\<open> Step 8: Discard us \label{sec:KMP:step8} \<close>
text\<open>


This is essentially another data refinement.

\<close>
fixrec \<comment>\<open> Bird p133 \<close>
text\<open>

is not invertible.  Conversely the desired result is easily shown by
fixed-point induction.

\<close>
text\<open>

"sscanl_lfp_fusion"}), which states that
\begin{center}
\end{center}

\begin{center}
  \begin{tikzcd}[column sep=6em]
  \end{tikzcd}
\end{center}

\<close>
lemma matches8: \<comment>\<open> Bird p133 \<close>
  from \<open>pat \<noteq> \<bottom>\<close> show ?thesis
subsection\<open> Step 9: Factor out pat (final version) \label{sec:KMP:final_version} \<close>
text\<open>

at Bird's cyclic data structure, which when executed using lazy

of support for clausal definitions, and that \texttt{HOLCF}
awkwardness.

\<close>
text\<open>

The final program above is easily syntactically translated into the
Haskell shown in Figure~\ref{fig:haskell-kmp}, and one can expect
GHC's list fusion machinery to compile the top-level driver into an
have mechanised this optimisation for Isabelle/HOL's code generator

As we lack both pieces of infrastructure we show such a fusion is sound
by hand.

\<close>
