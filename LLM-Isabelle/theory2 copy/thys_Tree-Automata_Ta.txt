theory Ta
imports Main Automatic_Refinement.Misc Tree
begin



subsection "Basic Definitions"

subsubsection "Tree Automata"


datatype ('q,'l) ta_rule = RULE 'q 'l "'q list" ("_ \<rightarrow> _ _")

record ('Q,'L) tree_automaton_rec =
  ta_initial :: "'Q set"
  ta_rules :: "('Q,'L) ta_rule set"

fun lhs where "lhs (q \<rightarrow> l qs) = q"
fun rhsq where "rhsq (q \<rightarrow> l qs) = qs"
fun rhsl where "rhsl (q \<rightarrow> l qs) = l"
fun rule_states where "rule_states (q \<rightarrow> l qs) = insert q (set qs)"
definition "\<delta>_states \<delta> == \<Union>(rule_states ` \<delta>)"
definition "ta_rstates TA = ta_initial TA \<union> \<delta>_states (ta_rules TA)"
definition "\<delta>_symbols \<delta> == rhsl`\<delta>"

locale tree_automaton = 
  fixes TA :: "('Q,'L) tree_automaton_rec"
  assumes finite_rules[simp, intro!]: "finite (ta_rules TA)"
  assumes finite_initial[simp, intro!]: "finite (ta_initial TA)"
begin
  abbreviation "Qi == ta_initial TA"
  abbreviation "\<delta> == ta_rules TA"
  abbreviation "Q == ta_rstates TA"
end

subsubsection "Acceptance"
inductive accs :: "('Q,'L) ta_rule set \<Rightarrow> 'L tree \<Rightarrow> 'Q \<Rightarrow> bool"
where
  "\<lbrakk>
     (q \<rightarrow> f qs) \<in> \<delta>; length ts = length qs; 
     !!i. i<length qs \<Longrightarrow> accs \<delta> (ts ! i) (qs ! i) 
   \<rbrakk> \<Longrightarrow> accs \<delta> (NODE f ts) q"


inductive accs_laz :: "('Q,'L) ta_rule set \<Rightarrow> 'L tree \<Rightarrow> 'Q \<Rightarrow> bool"
where
  "\<lbrakk>
     (q \<rightarrow> f qs) \<in> \<delta>; 
     list_all_zip (accs_laz \<delta>) ts qs
   \<rbrakk> \<Longrightarrow> accs_laz \<delta> (NODE f ts) q"

lemma accs_laz: "accs = accs_laz"
  apply (intro ext)
  apply (rule iffI)
  apply (erule accs.induct)
  apply (auto intro: accs_laz.intros[simplified list_all_zip_alt]) 
  apply (erule accs_laz.induct)
  apply (auto intro: accs.intros simp add: list_all_zip_alt)
  done


subsubsection "Language"
definition "ta_lang TA == { t . \<exists>q\<in>ta_initial TA. accs (ta_rules TA) t q }"

subsection "Basic Properties"

lemma rule_states_simp: 
  "rule_states x = (case x of (q \<rightarrow> l qs) \<Rightarrow> insert q (set qs))"
  by (case_tac x) auto

lemma rule_states_lhs[simp]: "lhs r \<in> rule_states r" 
  by (auto split: ta_rule.split simp add: rule_states_simp)

lemma rule_states_rhsq: "set (rhsq r) \<subseteq> rule_states r"
  by (auto split: ta_rule.split simp add: rule_states_simp)

lemma rule_states_finite[simp, intro!]: "finite (rule_states r)"
  by (simp add: rule_states_simp split: ta_rule.split)

lemma \<delta>_statesI: 
  assumes A: "(q \<rightarrow> l qs)\<in>\<delta>"
  shows "q\<in>\<delta>_states \<delta>"
        "set qs \<subseteq> \<delta>_states \<delta>"
  using A
  apply (unfold \<delta>_states_def)
  by (auto split: ta_rule.split simp add: rule_states_simp)

lemma \<delta>_statesI': "\<lbrakk>(q \<rightarrow> l qs)\<in>\<delta>; qi\<in>set qs\<rbrakk> \<Longrightarrow> qi\<in>\<delta>_states \<delta>"
  using \<delta>_statesI(2) by fast

lemma \<delta>_states_accsI: "accs \<delta> n q \<Longrightarrow> q\<in>\<delta>_states \<delta>"
  by (auto elim: accs.cases intro: \<delta>_statesI)

lemma \<delta>_states_union[simp]: "\<delta>_states (\<delta>\<union>\<delta>') = \<delta>_states \<delta> \<union> \<delta>_states \<delta>'"
  by (auto simp add: \<delta>_states_def)

lemma \<delta>_states_insert[simp]: 
  "\<delta>_states (insert r \<delta>) = (rule_states r \<union> \<delta>_states \<delta>)"
  by (unfold \<delta>_states_def) auto

lemma \<delta>_states_mono: "\<lbrakk>\<delta> \<subseteq> \<delta>'\<rbrakk> \<Longrightarrow> \<delta>_states \<delta> \<subseteq> \<delta>_states \<delta>'"
  by (unfold \<delta>_states_def) auto

lemma \<delta>_states_finite[simp, intro]: "finite \<delta> \<Longrightarrow> finite (\<delta>_states \<delta>)"
  by (unfold \<delta>_states_def) auto

lemma \<delta>_statesE: "\<lbrakk>q\<in>\<delta>_states \<Delta>;
    !!f qs. \<lbrakk> (q \<rightarrow> f qs)\<in>\<Delta> \<rbrakk> \<Longrightarrow> P;
    !!ql f qs. \<lbrakk> (ql \<rightarrow> f qs)\<in>\<Delta>; q\<in>set qs \<rbrakk> \<Longrightarrow> P
  \<rbrakk> \<Longrightarrow> P"
  apply (unfold \<delta>_states_def)
  apply (auto)
  apply (auto simp add: rule_states_simp split: ta_rule.split_asm)
  done

lemma \<delta>_symbolsI: "(q \<rightarrow> f qs)\<in>\<delta> \<Longrightarrow> f\<in>\<delta>_symbols \<delta>" 
  by (force simp add: \<delta>_symbols_def)

lemma \<delta>_symbolsE: 
  assumes A: "f\<in>\<delta>_symbols \<delta>"
  obtains q qs where "(q \<rightarrow> f qs) \<in> \<delta>"
  using A
  apply (simp add: \<delta>_symbols_def)
  apply (erule imageE)
  apply (case_tac x)
  apply simp
  done

lemma \<delta>_symbols_simps[simp]:
  "\<delta>_symbols {} = {}"
  "\<delta>_symbols (insert r \<delta>) = insert (rhsl r) (\<delta>_symbols \<delta>)"
  "\<delta>_symbols (\<delta>\<union>\<delta>') = \<delta>_symbols \<delta> \<union> \<delta>_symbols \<delta>'"
  by (auto simp add: \<delta>_symbols_def)

lemma \<delta>_symbols_finite[simp, intro!]:
  "finite \<delta> \<Longrightarrow> finite (\<delta>_symbols \<delta>)"
  by (auto simp add: \<delta>_symbols_def)

lemma accs_mono: "\<lbrakk>accs \<delta> n q; \<delta>\<subseteq>\<delta>'\<rbrakk> \<Longrightarrow> accs \<delta>' n q"
proof (induct rule: accs.induct[case_names step])
  case (step q l qs \<delta> n)
  hence R': "(q \<rightarrow> l qs) \<in> \<delta>'" by auto
  from accs.intros[OF R' step.hyps(2)] 
       step.hyps(4)[OF _ step.prems] 
  show ?case .
qed

context tree_automaton
begin
  lemma initial_subset: "ta_initial TA \<subseteq> ta_rstates TA" 
    by (unfold ta_rstates_def) auto
  lemma states_subset: "\<delta>_states (ta_rules TA) \<subseteq> ta_rstates TA" 
    by (unfold ta_rstates_def) auto
  
  lemma finite_states[simp, intro!]: "finite (ta_rstates TA)"
    by (auto simp add: ta_rstates_def \<delta>_states_def 
             intro: finite_rules finite_UN_I)

  lemma finite_symbols[simp, intro!]: "finite (\<delta>_symbols (ta_rules TA))"
    by simp

  lemmas is_subset = rev_subsetD[OF _ initial_subset] 
                     rev_subsetD[OF _ states_subset]
end

subsection "Other Classes of Tree Automata"

subsubsection "Automata over Ranked Alphabets"
inductive_set ranked_trees :: "('L \<rightharpoonup> nat) \<Rightarrow> 'L tree set"
  for A where
  "\<lbrakk> \<forall>t\<in>set ts. t\<in>ranked_trees A; A f = Some (length ts) \<rbrakk> 
    \<Longrightarrow> NODE f ts \<in> ranked_trees A"

locale finite_alphabet =
  fixes A :: "('L \<rightharpoonup> nat)"
  assumes A_finite[simp, intro!]: "finite (dom A)"
begin
  abbreviation "F == dom A"
end

context finite_alphabet
begin

  definition "legal_rules Q == { (q \<rightarrow> f qs) | q f qs.
    q \<in> Q
    \<and> qs \<in> lists Q
    \<and> A f = Some (length qs)}"

  lemma legal_rulesI: 
    "\<lbrakk> 
      r\<in>\<delta>; 
      rule_states r \<subseteq> Q; 
      A (rhsl r) = Some (length (rhsq r)) 
    \<rbrakk> \<Longrightarrow> r\<in>legal_rules Q"
    apply (unfold legal_rules_def)
    apply (cases r)
    apply (auto)
    done

  lemma legal_rules_finite[simp, intro!]:
    fixes Q::"'Q set"
    assumes [simp, intro!]: "finite Q"
    shows "finite (legal_rules Q)"
  proof -
    define possible_rules_f
      where "possible_rules_f = (\<lambda>(Q::'Q set) f. 
      (\<lambda>(q,qs). (q \<rightarrow> f qs)) ` (Q \<times> (lists Q \<inter> {qs. A f = Some (length qs)})))"
    
    have "legal_rules Q = \<Union>(possible_rules_f Q`F)"
      by (auto simp add: legal_rules_def possible_rules_f_def)
    moreover have "!!f. finite (possible_rules_f Q f)" 
      apply (unfold possible_rules_f_def)
      apply (rule finite_imageI)
      apply (rule finite_SigmaI)
      apply simp
      apply (case_tac "A f")
      apply simp
      apply (simp add: lists_of_len_fin)
      done
    ultimately show ?thesis by auto
  qed
end

locale ranked_tree_automaton = 
  tree_automaton TA +
  finite_alphabet A
  for TA :: "('Q,'L) tree_automaton_rec" 
  and A :: "'L \<rightharpoonup> nat" +
  assumes ranked: "(q \<rightarrow> f qs)\<in>\<delta> \<Longrightarrow> A f = Some (length qs)"
begin

  lemma rules_legal: "r\<in>\<delta> \<Longrightarrow> r\<in>legal_rules Q"
    apply (rule legal_rulesI)
    apply assumption
    apply (auto simp add: ta_rstates_def \<delta>_states_def) [1]
    apply (case_tac r)
    apply (auto intro: ranked)
    done

  lemma accs_is_ranked: "accs \<delta> t q \<Longrightarrow> t\<in>ranked_trees A"
    apply (induct \<delta>\<equiv>\<delta> t q rule: accs.induct)
    apply (rule ranked_trees.intros)
    apply (auto simp add: set_conv_nth ranked)
    done

  theorem lang_is_ranked: "ta_lang TA \<subseteq> ranked_trees A"
    using accs_is_ranked by (auto simp add: ta_lang_def)

end

subsubsection "Deterministic Tree Automata"

locale det_tree_automaton = ranked_tree_automaton TA A
  for TA :: "('Q,'L) tree_automaton_rec" and A +
  assumes deterministic: "\<lbrakk> (q \<rightarrow> f qs)\<in>\<delta>; (q' \<rightarrow> f qs)\<in>\<delta> \<rbrakk> \<Longrightarrow> q=q'"
begin
  theorem accs_unique: "\<lbrakk> accs \<delta> t q; accs \<delta> t q' \<rbrakk> \<Longrightarrow> q=q'"
    unfolding accs_laz
  proof (induct \<delta>\<equiv>\<delta> t q arbitrary: q' rule: accs_laz.induct[case_names step])
    case (step q f qs ts q')
    hence I: 
      "(q \<rightarrow> f qs) \<in> \<delta>"
      "list_all_zip (accs_laz \<delta>) ts qs"
      "list_all_zip (\<lambda>t q. (\<forall>q'. accs_laz \<delta> t q' \<longrightarrow> q=q')) ts qs"
      "accs_laz \<delta> (NODE f ts) q'"
      by auto
    from I(4) obtain qs' where A':
      "(q' \<rightarrow> f qs') \<in> \<delta>"
      "list_all_zip (accs_laz \<delta>) ts qs'"
      by (auto elim!: accs_laz.cases)

    from I(2,3) A'(2) have "list_all_zip (=) qs qs'"
      by (auto simp add: list_all_zip_alt)
    hence "qs=qs'" by (auto simp add: laz_eq)
    with deterministic[OF I(1), of q'] A'(1) show "q=q'" by simp
  qed
    
end

subsubsection "Complete Tree Automata"

locale complete_tree_automaton = det_tree_automaton TA A 
  for TA :: "('Q,'L) tree_automaton_rec" and A
  +
  assumes complete: 
  "\<lbrakk> qs\<in>lists Q; A f = Some (length qs) \<rbrakk> \<Longrightarrow> \<exists>q. (q \<rightarrow> f qs)\<in>\<delta>"
begin

  theorem label_all: "t\<in>ranked_trees A \<Longrightarrow> \<exists>q\<in>Q. accs \<delta> t q"
  proof (induct rule: ranked_trees.induct[case_names constr])
    case (constr ts f)
    obtain qs where QS:
      "qs\<in>lists Q"
      "list_all_zip (accs \<delta>) ts qs" 
      and [simp]: "length qs = length ts"
    proof -
      from constr(1) have "\<forall>i<length ts. \<exists>q. q\<in>Q \<and> accs \<delta> (ts!i) q" 
        by (auto)
      thus ?thesis
        apply (erule_tac obtain_list_from_elements)
        apply (rule_tac that)
        apply (auto simp add: list_all_zip_alt set_conv_nth)
        done
    qed
    moreover from complete[OF QS(1), simplified, OF constr(2)] obtain q 
      where "(q \<rightarrow> f qs) \<in>\<delta>" ..
    ultimately show ?case 
      by (auto simp add: accs_laz ta_rstates_def 
               intro: accs_laz.intros \<delta>_statesI)
  qed

end


subsection "Algorithms"

subsubsection "Empty Automaton"
definition "ta_empty == \<lparr> ta_initial = {}, ta_rules = {}\<rparr>"

theorem ta_empty_lang[simp]: "ta_lang ta_empty = {}"
  by (auto simp add: ta_empty_def ta_lang_def)

theorem ta_empty_ta[simp, intro!]: "tree_automaton ta_empty"
  apply (unfold_locales)
  apply (unfold ta_empty_def)
  apply auto
  done

theorem (in finite_alphabet) ta_empty_rta[simp, intro!]: 
  "ranked_tree_automaton ta_empty A"
  apply (unfold_locales)
  apply (unfold ta_empty_def)
  apply auto
  done

theorem (in finite_alphabet) ta_empty_dta[simp, intro!]: 
  "det_tree_automaton ta_empty A"
  apply (unfold_locales)
  apply (unfold ta_empty_def)
  apply (auto)
  done

subsubsection "Remapping of States"

fun remap_rule where "remap_rule f (q \<rightarrow> l qs) = ((f q) \<rightarrow> l (map f qs))"
definition 
  "ta_remap f TA == \<lparr> ta_initial = f ` ta_initial TA, 
                      ta_rules = remap_rule f ` ta_rules TA 
                    \<rparr>"

lemma \<delta>_states_remap[simp]: "\<delta>_states (remap_rule f ` \<delta>) = f` \<delta>_states \<delta>"
  apply (auto simp add: \<delta>_states_def)
  apply (case_tac a)
  apply force
  apply (case_tac xb)
  apply force
  done

lemma remap_accs1: "accs \<delta> n q \<Longrightarrow> accs (remap_rule f ` \<delta>) n (f q)"
proof (induct rule: accs.induct[case_names step])
  case (step q l qs \<delta> ts)
  from step.hyps(1) have 1: "((f q) \<rightarrow> l (map f qs)) \<in> remap_rule f ` \<delta>" 
    by (drule_tac f="remap_rule f" in imageI) simp
  show ?case proof (rule accs.intros[OF 1])
    fix i assume "i<length (map f qs)"
    with step.hyps(4) show "accs (remap_rule f ` \<delta>) (ts ! i) (map f qs ! i)" 
      by auto
  qed (auto simp add: step.hyps(2))
qed

lemma remap_lang1: "t\<in>ta_lang TA \<Longrightarrow> t\<in>ta_lang (ta_remap f TA)"
  by (unfold ta_lang_def ta_remap_def) (auto dest: remap_accs1)

lemma remap_accs2: "\<lbrakk> 
    accs \<delta>' n q'; 
    \<delta>'=(remap_rule f ` \<delta>); 
    q'=f q; 
    inj_on f Q; 
    q\<in>Q; 
    \<delta>_states \<delta> \<subseteq> Q 
  \<rbrakk> \<Longrightarrow> accs \<delta> n q"
proof (induct arbitrary: \<delta> q rule: accs.induct[case_names step])
  case (step q' l qs \<delta>' ts \<delta> q)
  note [simp] = step.prems(1,2)
  from step.hyps(1)[simplified] step.prems(3,4,5) have 
    R: "(q \<rightarrow> l (map (inv_on f Q) qs))\<in>\<delta>"
    apply (erule_tac imageE)
    apply (case_tac x)
    apply (auto simp del:map_map)
    apply (subst inj_on_map_inv_f)
    apply (auto dest: \<delta>_statesI) [2]
    apply (subgoal_tac "q\<in>\<delta>_states \<delta>")
    apply (unfold inj_on_def) [1]
    apply (metis \<delta>_statesI(1) contra_subsetD)
    apply (fastforce intro: \<delta>_statesI(1) dest: inj_onD)
    done
  show ?case proof (rule accs.intros[OF R])
    fix i 
    assume "i < length (map (inv_on f Q) qs)"
    hence L: "i<length qs" by simp

    from step.hyps(1)[simplified] step.prems(5) have 
      IR: "!!i. i<length qs \<Longrightarrow> qs!i \<in> f ` Q"
      apply auto
      apply (case_tac x)
      apply (auto)
      apply (rename_tac list)
      apply (subgoal_tac "list!i \<in> \<delta>_states \<delta>")
      apply blast
      apply (auto dest!: \<delta>_statesI(2))
      done

    show "accs \<delta> (ts ! i) (map (inv_on f Q) qs ! i)"
      apply (rule step.hyps(4)[OF L, simplified])
      apply (simp_all add: f_inv_on_f[OF IR[OF L]] 
                      inv_on_f_range[OF IR[OF L]] 
                      L step.prems(3,5))
      done
  qed (auto simp add: step.hyps(2))
qed

lemma (in tree_automaton) remap_lang2: 
  assumes I: "inj_on f (ta_rstates TA)" 
  shows "t\<in>ta_lang (ta_remap f TA) \<Longrightarrow> t\<in>ta_lang TA"
  apply (unfold ta_lang_def ta_remap_def) 
  apply auto
  apply (rule_tac x=x in bexI)
  apply (drule remap_accs2[OF _ _ _ I])
  apply (auto dest: is_subset)
  done

theorem (in tree_automaton) remap_lang: 
  "inj_on f (ta_rstates TA) \<Longrightarrow> ta_lang (ta_remap f TA) = ta_lang TA"
  by (auto intro: remap_lang1 remap_lang2)

lemma (in tree_automaton) remap_ta[intro!, simp]: 
  "tree_automaton (ta_remap f TA)"
  using initial_subset states_subset finite_states finite_rules
  by (unfold_locales) (auto simp add: ta_remap_def ta_rstates_def)

lemma (in ranked_tree_automaton) remap_rta[intro!, simp]:
  "ranked_tree_automaton (ta_remap f TA) A"
proof -
  interpret ta: tree_automaton "(ta_remap f TA)" by simp
  show ?thesis
    apply (unfold_locales)
    apply (auto simp add: ta_remap_def)
    apply (case_tac x)
    apply (auto simp add: ta_remap_def intro: ranked)
    done
qed

lemma (in det_tree_automaton) remap_dta[intro, simp]:
  assumes INJ: "inj_on f Q"
  shows "det_tree_automaton (ta_remap f TA) A"
proof -
  interpret ta: ranked_tree_automaton "(ta_remap f TA)" A by simp
  show ?thesis 
  proof
    fix q q' l qs
    assume A: 
      "(q \<rightarrow> l qs) \<in>ta_rules (ta_remap f TA)"
      "(q' \<rightarrow> l qs) \<in>ta_rules (ta_remap f TA)"
    then obtain qo qo' qso qso' where RO:
      "(qo \<rightarrow> l qso) \<in> \<delta>"
      "(qo' \<rightarrow> l qso') \<in> \<delta>"
      and [simp]:
      "q=f qo"
      "q'=f qo'"
      "qs = map f qso"
      "map f qso = map f qso'"
      apply (auto simp add: ta_remap_def)
      apply (case_tac x, case_tac xa)
      apply auto
      done
    from RO have OQ: "qo\<in>Q" "qo'\<in>Q" "set qso \<subseteq> Q" "set qso' \<subseteq> Q"
      by (unfold ta_rstates_def)
         (auto dest: \<delta>_statesI)
    
    from OQ(3,4) have INJQSO: "inj_on f (set qso \<union> set qso')"
      by (auto intro: subset_inj_on[OF INJ])

    from inj_on_map_eq_map[OF INJQSO] have "qso=qso'" by simp
    with deterministic[OF RO(1)] RO(2) have "qo=qo'" by simp
    thus "q=q'" by simp
  qed
qed

  
lemma (in complete_tree_automaton) remap_cta[intro, simp]:
  assumes INJ: "inj_on f Q"
  shows "complete_tree_automaton (ta_remap f TA) A"
proof -
  interpret ta: det_tree_automaton "(ta_remap f TA)" A by (simp add: INJ)
  show ?thesis
  proof
    fix qs l
    assume A:
      "qs \<in> lists (ta_rstates (ta_remap f TA))" 
      "A l = Some (length qs)"
    from A(1) have "qs\<in>lists (f`Q)"
      by (auto simp add: ta_rstates_def ta_remap_def)
    then obtain qso where QSO:
      "qso\<in>lists Q"
      "qs = map f qso"
      by (blast elim!: lists_image_witness)
    hence [simp]: "length qso = length qs" by simp

    from complete[OF QSO(1)] A(2) obtain qo where "(qo \<rightarrow> l qso) \<in> \<delta>"
      by auto
    
    with QSO(2) have "((f qo) \<rightarrow> l qs)\<in>ta_rules (ta_remap f TA)" 
      by (force simp add: ta_remap_def)
    thus "\<exists>q. q \<rightarrow> l qs \<in> ta_rules (ta_remap f TA)" ..
  qed
qed

subsubsection "Union"

definition "ta_union TA TA' == 
  \<lparr> ta_initial = ta_initial TA \<union> ta_initial TA', 
    ta_rules = ta_rules TA \<union> ta_rules TA' 
  \<rparr>"

lemma accs_exclusive_aux: 
  "\<lbrakk> accs \<delta>n n q; \<delta>n=\<delta>\<union>\<delta>'; \<delta>_states \<delta> \<inter> \<delta>_states \<delta>' = {}; q\<in>\<delta>_states \<delta> \<rbrakk> 
   \<Longrightarrow> accs \<delta> n q"
proof (induct arbitrary: \<delta> \<delta>' rule: accs.induct[case_names step])
  case (step q l qs \<delta>n ts \<delta> \<delta>')
  note [simp] = step.prems(1)
  note [simp] = step.hyps(2)[symmetric] step.hyps(3)
  from step.prems have "q\<notin>\<delta>_states \<delta>'" by blast
  with step.hyps(1) have "set qs \<subseteq> \<delta>_states \<delta>" and R: "(q \<rightarrow> l qs)\<in>\<delta>" 
    by (auto dest: \<delta>_statesI)
  hence "!!i. i<length qs \<Longrightarrow> accs \<delta> (ts ! i) (qs ! i)" 
    by (force intro: step.hyps(4)[OF _ step.prems(1,2)])
  with accs.intros[OF R step.hyps(2)] show ?case .
qed

corollary accs_exclusive1: 
  "\<lbrakk> accs (\<delta>\<union>\<delta>') n q; \<delta>_states \<delta> \<inter> \<delta>_states \<delta>' = {}; q\<in>\<delta>_states \<delta> \<rbrakk> 
   \<Longrightarrow> accs \<delta> n q"
using accs_exclusive_aux[of _ n q \<delta> \<delta>'] by blast

corollary accs_exclusive2: 
  "\<lbrakk> accs (\<delta>\<union>\<delta>') n q; \<delta>_states \<delta> \<inter> \<delta>_states \<delta>' = {}; q\<in>\<delta>_states \<delta>' \<rbrakk> 
   \<Longrightarrow> accs \<delta>' n q"
using accs_exclusive_aux[of _ n q \<delta>' \<delta>] by blast

lemma ta_union_correct_aux1: 
  fixes TA TA'
  assumes TA: "tree_automaton TA"
  assumes TA': "tree_automaton TA'"
  assumes DJ: "ta_rstates TA \<inter> ta_rstates TA' = {}" 
  shows "ta_lang (ta_union TA TA') = ta_lang TA \<union> ta_lang TA'"
proof (safe)
  interpret ta: tree_automaton TA using TA .
  interpret ta': tree_automaton TA' using TA' .

  from DJ ta.states_subset ta'.states_subset have 
    DJ': "\<delta>_states (ta_rules TA) \<inter> \<delta>_states (ta_rules TA') = {}" 
    by blast

  fix n
  assume A: "n \<in> ta_lang (ta_union TA TA')" "n \<notin> ta_lang TA'"
  from A(1) obtain q where 
    B: "q\<in>ta_initial TA \<union> ta_initial TA'" 
       "accs (ta_rules TA \<union> ta_rules TA') n q"
    by (auto simp add: ta_lang_def ta_union_def)
  from \<delta>_states_accsI[OF B(2), simplified] show "n\<in>ta_lang TA" proof
    assume C: "q\<in>\<delta>_states (ta_rules TA)"
    with accs_exclusive1[OF B(2) DJ'] have "accs (ta_rules TA) n q" .
    moreover from DJ C ta'.initial_subset ta.states_subset B(1) have 
      "q\<in>ta_initial TA" 
      by auto
    ultimately show ?thesis by (unfold ta_lang_def) auto
  next
    assume C: "q\<in>\<delta>_states (ta_rules TA')"
    with accs_exclusive2[OF B(2) DJ'] have "accs (ta_rules TA') n q" .
    moreover from DJ C ta.initial_subset B(1) ta'.states_subset have 
      "q\<in>ta_initial TA'" 
      by auto
    ultimately have False using A(2) by (unfold ta_lang_def) auto
    thus ?thesis ..
  qed
qed (unfold ta_lang_def ta_union_def, auto intro: accs_mono)

lemma ta_union_correct_aux2: 
  fixes TA TA'
  assumes TA: "tree_automaton TA"
  assumes TA': "tree_automaton TA'"
  shows "tree_automaton (ta_union TA TA')"
proof -
  interpret ta: tree_automaton TA using TA .
  interpret ta': tree_automaton TA' using TA' .

  show ?thesis
    apply (unfold_locales)
    apply (unfold ta_union_def)
    apply auto
    done
qed

theorem ta_union_correct:
  fixes TA TA'
  assumes TA: "tree_automaton TA"
  assumes TA': "tree_automaton TA'"
  assumes DJ: "ta_rstates TA \<inter> ta_rstates TA' = {}" 
  shows "ta_lang (ta_union TA TA') = ta_lang TA \<union> ta_lang TA'"
        "tree_automaton (ta_union TA TA')"
  using ta_union_correct_aux1[OF TA TA' DJ]
        ta_union_correct_aux2[OF TA TA']
  by auto

lemma ta_union_rta: 
  fixes TA TA'
  assumes TA: "ranked_tree_automaton TA A"
  assumes TA': "ranked_tree_automaton TA' A"
  shows "ranked_tree_automaton (ta_union TA TA') A"
proof -
  interpret ta: ranked_tree_automaton TA A using TA .
  interpret ta': ranked_tree_automaton TA' A using TA' .

  show ?thesis
    apply (unfold_locales)
    apply (unfold ta_union_def)
    apply (auto intro: ta.ranked ta'.ranked)
    done
qed

text "The union-algorithm may wrap the states of the first and second automaton 
      in order to make them disjoint"
datatype ('q1,'q2) ustate_wrapper = USW1 'q1 | USW2 'q2 

lemma usw_disjoint[simp]: 
  "USW1 ` X \<inter> USW2 ` Y = {}"
  "remap_rule USW1 ` X \<inter> remap_rule USW2 ` Y = {}"
  apply auto
  apply (case_tac xa, case_tac xb)
  apply auto
  done
  
lemma states_usw_disjoint[simp]: 
  "ta_rstates (ta_remap USW1 X) \<inter> ta_rstates (ta_remap USW2 Y) = {}"
  by (auto simp add: ta_remap_def ta_rstates_def)

lemma usw_inj_on[simp, intro!]:
  "inj_on USW1 X" 
  "inj_on USW2 X" 
  by (auto intro: inj_onI)

definition "ta_union_wrap TA TA' = 
  ta_union (ta_remap USW1 TA) (ta_remap USW2 TA')"

lemma ta_union_wrap_correct:
  fixes TA :: "('Q1,'L) tree_automaton_rec"
  fixes TA' :: "('Q2,'L) tree_automaton_rec"
  assumes TA: "tree_automaton TA"
  assumes TA': "tree_automaton TA'"
  shows "ta_lang (ta_union_wrap TA TA') = ta_lang TA \<union> ta_lang TA'" (is ?T1)
        "tree_automaton (ta_union_wrap TA TA')" (is ?T2)
proof -
  interpret a1: tree_automaton TA by fact
  interpret a2: tree_automaton TA' by fact

  show ?T1 ?T2
    by (unfold ta_union_wrap_def)
       (simp_all add: ta_union_correct a1.remap_lang a2.remap_lang)
qed

lemma ta_union_wrap_rta:
  fixes TA TA'
  assumes TA: "ranked_tree_automaton TA A"
  assumes TA': "ranked_tree_automaton TA' A"
  shows "ranked_tree_automaton (ta_union_wrap TA TA') A"
proof -
  interpret ta: ranked_tree_automaton TA A using TA .
  interpret ta': ranked_tree_automaton TA' A using TA' .

  show ?thesis
    by (unfold ta_union_wrap_def)
       (simp add: ta_union_rta)

qed


subsubsection "Reduction"

definition "reduce_rules \<delta> P == \<delta> \<inter> { r. rule_states r \<subseteq> P }"

lemma reduce_rulesI: "\<lbrakk>r\<in>\<delta>; rule_states r \<subseteq> P\<rbrakk> \<Longrightarrow> r\<in>reduce_rules \<delta> P"
  by (unfold reduce_rules_def) auto

lemma reduce_rulesD: 
  "\<lbrakk> r\<in>reduce_rules \<delta> P \<rbrakk> \<Longrightarrow> r\<in>\<delta>"
  "\<lbrakk> r\<in>reduce_rules \<delta> P; q\<in>rule_states r\<rbrakk> \<Longrightarrow> q\<in>P"
  by (unfold reduce_rules_def) auto

lemma reduce_rules_subset: "reduce_rules \<delta> P \<subseteq> \<delta>"
  by (unfold reduce_rules_def) auto

lemma reduce_rules_mono: "P \<subseteq> P' \<Longrightarrow> reduce_rules \<delta> P \<subseteq> reduce_rules \<delta> P'"
  by (unfold reduce_rules_def) auto

lemma \<delta>_states_reduce_subset: 
  shows "\<delta>_states (reduce_rules \<delta> Q) \<subseteq> \<delta>_states \<delta> \<inter> Q"
  by (unfold \<delta>_states_def reduce_rules_def)
    auto

lemmas \<delta>_states_reduce_subsetI = rev_subsetD[OF _ \<delta>_states_reduce_subset]

definition ta_reduce 
  :: "('Q,'L) tree_automaton_rec \<Rightarrow> ('Q set) \<Rightarrow> ('Q,'L) tree_automaton_rec"
  where "ta_reduce TA P ==
    \<lparr> ta_initial = ta_initial TA \<inter> P,
      ta_rules = reduce_rules (ta_rules TA) P \<rparr>"

theorem ta_reduce_inv: assumes A: "tree_automaton TA" 
  shows "tree_automaton (ta_reduce TA P)"
proof -
  interpret tree_automaton TA using A .
  show ?thesis proof
    show "finite (ta_rules (ta_reduce TA P))" 
         "finite (ta_initial (ta_reduce TA P))"
      using finite_states finite_rules finite_subset[OF reduce_rules_subset]
      by (unfold ta_reduce_def) (auto simp add: Let_def)
  qed
qed
 
lemma reduce_\<delta>_states_rules[simp]: 
  "(ta_rules (ta_reduce TA (\<delta>_states (ta_rules TA)))) = ta_rules TA"
  by (auto simp add: ta_reduce_def \<delta>_states_def reduce_rules_def)

lemma ta_reduce_\<delta>_states: 
  "ta_lang (ta_reduce TA (\<delta>_states (ta_rules TA))) = ta_lang TA"
  apply (auto simp add: ta_lang_def)
  apply (frule \<delta>_states_accsI)
  apply (auto simp add: ta_reduce_def \<delta>_states_def reduce_rules_def) [1]
  apply (frule \<delta>_states_accsI)
  apply (auto simp add: ta_reduce_def \<delta>_states_def reduce_rules_def) [1]
done


inductive_set f_succ for \<delta> where
  "\<lbrakk>(q \<rightarrow> l qs)\<in>\<delta>; q'\<in>set qs\<rbrakk> \<Longrightarrow> (q,q') \<in> f_succ \<delta>"

lemma f_succ_alt: "f_succ \<delta> = {(q,q'). \<exists>l qs. (q \<rightarrow> l qs)\<in>\<delta> \<and> q'\<in>set qs}"
  by (auto intro: f_succ.intros elim!: f_succ.cases)

definition "f_accessible \<delta> Q0 == ((f_succ \<delta>)\<^sup>*) `` Q0"
