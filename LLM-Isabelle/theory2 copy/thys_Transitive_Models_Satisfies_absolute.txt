theory Satisfies_absolute imports Datatype_absolute Rec_Separation begin 




definition
  depth_fm :: "[i,i]=>i" where
  "depth_fm(p,n) == 
     Exists(Exists(Exists(
       And(formula_N_fm(n#+3,1),
         And(Neg(Member(p#+3,1)),
          And(succ_fm(n#+3,2),
           And(formula_N_fm(2,0), Member(p#+3,0))))))))"

lemma depth_fm_type [TC]:
 "[| x \<in> nat; y \<in> nat |] ==> depth_fm(x,y) \<in> formula"
by (simp add: depth_fm_def)

lemma sats_depth_fm [simp]:
   "[| x \<in> nat; y < length(env); env \<in> list(A)|]
    ==> sats(A, depth_fm(x,y), env) \<longleftrightarrow>
        is_depth(##A, nth(x,env), nth(y,env))"
apply (frule_tac x=y in lt_length_in_nat, assumption)  
apply (simp add: depth_fm_def is_depth_def) 
done

lemma depth_iff_sats:
      "[| nth(i,env) = x; nth(j,env) = y; 
          i \<in> nat; j < length(env); env \<in> list(A)|]
       ==> is_depth(##A, x, y) \<longleftrightarrow> sats(A, depth_fm(i,j), env)"
by (simp)

theorem depth_reflection:
     "REFLECTS[\<lambda>x. is_depth(L, f(x), g(x)),  
               \<lambda>i x. is_depth(##Lset(i), f(x), g(x))]"
apply (simp only: is_depth_def)
apply (intro FOL_reflections function_reflections formula_N_reflection) 
done




      will be enclosed by three quantifiers.\<close>
text\<open>The second argument of \<^term>\<open>is_a\<close> gives it direct access to \<^term>\<open>x\<close>,
  based on that of \<open>is_nat_case_reflection\<close>.\<close>
subsection \<open>Absoluteness for the Function \<^term>\<open>satisfies\<close>\<close>
   \<comment> \<open>Merely a useful abbreviation for the sequel.\<close>
text\<open>There is at present some redundancy between the relativizations in

definition
  satisfies_a :: "[i,i,i]=>i" where
   "satisfies_a(A) == 
    \<lambda>x y. \<lambda>env \<in> list(A). bool_of_o (nth(x,env) \<in> nth(y,env))"

definition
  satisfies_is_a :: "[i=>o,i,i,i,i]=>o" where
   "satisfies_is_a(M,A) == 
    \<lambda>x y zz. \<forall>lA[M]. is_list(M,A,lA) \<longrightarrow>
             is_lambda(M, lA, 
                \<lambda>env z. is_bool_of_o(M, 
                      \<exists>nx[M]. \<exists>ny[M]. 
                       is_nth(M,x,env,nx) & is_nth(M,y,env,ny) & nx \<in> ny, z),
                zz)"

definition
  satisfies_b :: "[i,i,i]=>i" where
   "satisfies_b(A) ==
    \<lambda>x y. \<lambda>env \<in> list(A). bool_of_o (nth(x,env) = nth(y,env))"

definition
  satisfies_is_b :: "[i=>o,i,i,i,i]=>o" where
  "satisfies_is_b(M,A) == 
    \<lambda>x y zz. \<forall>lA[M]. is_list(M,A,lA) \<longrightarrow>
             is_lambda(M, lA, 
                \<lambda>env z. is_bool_of_o(M, 
                      \<exists>nx[M]. is_nth(M,x,env,nx) & is_nth(M,y,env,nx), z),
                zz)"

definition 
  satisfies_c :: "[i,i,i,i,i]=>i" where
   "satisfies_c(A) == \<lambda>p q rp rq. \<lambda>env \<in> list(A). not(rp ` env and rq ` env)"

definition
  satisfies_is_c :: "[i=>o,i,i,i,i,i]=>o" where
   "satisfies_is_c(M,A,h) == 
    \<lambda>p q zz. \<forall>lA[M]. is_list(M,A,lA) \<longrightarrow>
             is_lambda(M, lA, \<lambda>env z. \<exists>hp[M]. \<exists>hq[M]. 
                 (\<exists>rp[M]. is_depth_apply(M,h,p,rp) & fun_apply(M,rp,env,hp)) & 
                 (\<exists>rq[M]. is_depth_apply(M,h,q,rq) & fun_apply(M,rq,env,hq)) & 
                 (\<exists>pq[M]. is_and(M,hp,hq,pq) & is_not(M,pq,z)),
                zz)"

definition
  satisfies_d :: "[i,i,i]=>i" where
   "satisfies_d(A) 
    == \<lambda>p rp. \<lambda>env \<in> list(A). bool_of_o (\<forall>x\<in>A. rp ` (Cons(x,env)) = 1)"

definition
  satisfies_is_d :: "[i=>o,i,i,i,i]=>o" where
   "satisfies_is_d(M,A,h) == 
    \<lambda>p zz. \<forall>lA[M]. is_list(M,A,lA) \<longrightarrow>
             is_lambda(M, lA, 
                \<lambda>env z. \<exists>rp[M]. is_depth_apply(M,h,p,rp) & 
                    is_bool_of_o(M, 
                           \<forall>x[M]. \<forall>xenv[M]. \<forall>hp[M]. 
                              x\<in>A \<longrightarrow> is_Cons(M,x,env,xenv) \<longrightarrow> 
                              fun_apply(M,rp,xenv,hp) \<longrightarrow> number1(M,hp),
                  z),
               zz)"

definition
  satisfies_MH :: "[i=>o,i,i,i,i]=>o" where
        the correct arity.\<close>
text\<open>This lemma relates the fragments defined above to the original primitive
      Induction is not required: the definitions are directly equal!\<close>
text\<open>Further constraints on the class \<^term>\<open>M\<close> in order to prove
      is the absoluteness of the function \<^term>\<open>satisfies\<close>.\<close>
      \<comment> \<open>For the \<^term>\<open>transrec\<close>\<close>
      \<comment> \<open>For the \<open>\<lambda>-abstraction\<close> in the \<^term>\<open>transrec\<close> body\<close>
text\<open>Instantiate locale \<open>Formula_Rec\<close> for the 
      Function \<^term>\<open>satisfies\<close>\<close>
subsection\<open>Internalizations Needed to Instantiate \<open>M_satisfies\<close>\<close>
subsubsection\<open>The Operator \<^term>\<open>is_depth_apply\<close>, Internalized\<close>
subsubsection\<open>The Operator \<^term>\<open>satisfies_is_a\<close>, Internalized\<close>
subsubsection\<open>The Operator \<^term>\<open>satisfies_is_b\<close>, Internalized\<close>
subsubsection\<open>The Operator \<^term>\<open>satisfies_is_c\<close>, Internalized\<close>
subsubsection\<open>The Operator \<^term>\<open>satisfies_is_d\<close>, Internalized\<close>
subsubsection\<open>The Operator \<^term>\<open>satisfies_MH\<close>, Internalized\<close>
subsection\<open>Lemmas for Instantiating the Locale \<open>M_satisfies\<close>\<close>
subsubsection\<open>The \<^term>\<open>Member\<close> Case\<close>
subsubsection\<open>The \<^term>\<open>Equal\<close> Case\<close>
subsubsection\<open>The \<^term>\<open>Nand\<close> Case\<close>
subsubsection\<open>The \<^term>\<open>Forall\<close> Case\<close>
subsubsection\<open>The \<^term>\<open>transrec_replacement\<close> Case\<close>
      \<comment> \<open>For the \<^term>\<open>transrec\<close>\<close>
subsubsection\<open>The Lambda Replacement Case\<close>
      \<comment> \<open>For the \<^term>\<open>transrec\<close>\<close>
subsection\<open>Instantiating \<open>M_satisfies\<close>\<close>
text\<open>Finally: the point of the whole theory!\<close>
