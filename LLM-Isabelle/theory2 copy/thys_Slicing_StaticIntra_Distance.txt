theory Distance imports "../Basic/CFG" begin



context CFG begin

inductive distance :: "'node \<Rightarrow> 'node \<Rightarrow> nat \<Rightarrow> bool"
where distanceI: 
  "\<lbrakk>n -as\<rightarrow>* n'; length as = x; \<forall>as'. n -as'\<rightarrow>* n' \<longrightarrow> x \<le> length as'\<rbrakk>
  \<Longrightarrow> distance n n' x"


lemma every_path_distance:
  assumes "n -as\<rightarrow>* n'"
  obtains x where "distance n n' x" and "x \<le> length as"
proof -
  have "\<exists>x. distance n n' x \<and> x \<le> length as"
  proof(cases "\<exists>as'. n -as'\<rightarrow>* n' \<and> 
                     (\<forall>asx. n -asx\<rightarrow>* n' \<longrightarrow> length as' \<le> length asx)")
    case True
    then obtain as' 
      where "n -as'\<rightarrow>* n' \<and> (\<forall>asx. n -asx\<rightarrow>* n' \<longrightarrow> length as' \<le> length asx)" 
      by blast
    hence "n -as'\<rightarrow>* n'" and all:"\<forall>asx. n -asx\<rightarrow>* n' \<longrightarrow> length as' \<le> length asx"
      by simp_all
    hence "distance n n' (length as')" by(fastforce intro:distanceI)
  next
    case False
    hence all:"\<forall>as'. n -as'\<rightarrow>* n' \<longrightarrow> (\<exists>asx. n -asx\<rightarrow>* n' \<and> length as' > length asx)"
      by fastforce
    have "wf (measure length)" by simp
      and notin:"\<And>as''. (as'',as') \<in> (measure length) \<Longrightarrow> as'' \<notin> {as. n -as\<rightarrow>* n'}"
      by(erule wfE_min)
    with all obtain asx where "n -asx\<rightarrow>* n'"
      and "length as' > length asx"
      by blast
    with notin have  "asx \<notin> {as. n -as\<rightarrow>* n'}" by simp
    hence "\<not> n -asx\<rightarrow>* n'" by simp
    thus ?thesis by simp
  qed
  with that show ?thesis by blast
qed


lemma distance_det:
  "\<lbrakk>distance n n' x; distance n n' x'\<rbrakk> \<Longrightarrow> x = x'"
apply(erule distance.cases)+ apply clarsimp
apply(erule_tac x="asa" in allE) apply(erule_tac x="as" in allE)
by simp


lemma only_one_SOME_dist_edge:
  assumes valid:"valid_edge a" and dist:"distance (targetnode a) n' x"
  shows "\<exists>!a'. sourcenode a = sourcenode a' \<and> distance (targetnode a') n' x \<and>
               valid_edge a' \<and>
               targetnode a' = (SOME nx. \<exists>a'. sourcenode a = sourcenode a' \<and>
                                              distance (targetnode a') n' x \<and>
                                              valid_edge a' \<and> targetnode a' = nx)"
proof(rule ex_ex1I)
  show "\<exists>a'. sourcenode a = sourcenode a' \<and> 
             distance (targetnode a') n' x \<and> valid_edge a' \<and>
             targetnode a' = (SOME nx. \<exists>a'. sourcenode a = sourcenode a' \<and> 
                                            distance (targetnode a') n' x \<and>
                                            valid_edge a' \<and> targetnode a' = nx)"
  proof -
    have "(\<exists>a'. sourcenode a = sourcenode a' \<and> 
                distance (targetnode a') n' x \<and> valid_edge a' \<and> 
                targetnode a' = (SOME nx. \<exists>a'. sourcenode a = sourcenode a' \<and>
                                               distance (targetnode a') n' x \<and>
                                               valid_edge a' \<and> targetnode a' = nx)) =
      (\<exists>nx. \<exists>a'. sourcenode a = sourcenode a' \<and> distance (targetnode a') n' x \<and> 
                 valid_edge a' \<and> targetnode a' = nx)"
      apply(unfold some_eq_ex[of "\<lambda>nx. \<exists>a'. sourcenode a = sourcenode a' \<and> 
                distance (targetnode a') n' x \<and>valid_edge a' \<and>  targetnode a' = nx"])
      by simp
    also have "\<dots>" using valid dist by blast
    finally show ?thesis .
  qed
next
  fix a' ax
  assume "sourcenode a = sourcenode a' \<and> 
    distance (targetnode a') n' x \<and> valid_edge a' \<and>
    targetnode a' = (SOME nx. \<exists>a'. sourcenode a = sourcenode a' \<and> 
                                   distance (targetnode a') n' x \<and> 
                                   valid_edge a' \<and> targetnode a' = nx)"
    and "sourcenode a = sourcenode ax \<and> 
    distance (targetnode ax) n' x \<and> valid_edge ax \<and>
    targetnode ax = (SOME nx. \<exists>a'. sourcenode a = sourcenode a' \<and>
                                   distance (targetnode a') n' x \<and> 
                                   valid_edge a' \<and> targetnode a' = nx)"
  thus "a' = ax" by(fastforce intro!:edge_det)
qed


lemma distance_successor_distance:
  assumes "distance n n' x" and "x \<noteq> 0" 
  obtains a where "valid_edge a" and "n = sourcenode a" 
  and "distance (targetnode a) n' (x - 1)"
  and "targetnode a = (SOME nx. \<exists>a'. sourcenode a = sourcenode a' \<and> 
                                     distance (targetnode a') n' (x - 1) \<and>
                                     valid_edge a' \<and> targetnode a' = nx)"
proof -
  have "\<exists>a. valid_edge a \<and> n = sourcenode a \<and> distance (targetnode a) n' (x - 1) \<and>
    targetnode a = (SOME nx. \<exists>a'. sourcenode a = sourcenode a' \<and> 
                                  distance (targetnode a') n' (x - 1) \<and>
                                  valid_edge a' \<and> targetnode a' = nx)"
  proof(rule ccontr)
    assume "\<not> (\<exists>a. valid_edge a \<and> n = sourcenode a \<and> 
                   distance (targetnode a) n' (x - 1) \<and> 
                   targetnode a = (SOME nx. \<exists>a'. sourcenode a = sourcenode a' \<and> 
                                                 distance (targetnode a') n' (x - 1) \<and>
                                                 valid_edge a' \<and> targetnode a' = nx))"
    hence imp:"\<forall>a. valid_edge a \<and> n = sourcenode a \<and>
                   targetnode a = (SOME nx. \<exists>a'. sourcenode a = sourcenode a' \<and>
                                                 distance (targetnode a') n' (x - 1) \<and>
                                                 valid_edge a' \<and> targetnode a' = nx)
                 \<longrightarrow> \<not> distance (targetnode a) n' (x - 1)" by blast
      and "\<forall>as'. n -as'\<rightarrow>* n' \<longrightarrow> x \<le> length as'"
      by(auto elim:distance.cases)
    thus False using imp
    proof(induct rule:path.induct)
      case (empty_path n)
    next
      case (Cons_path n'' as n' a n)
        and "y \<le> length as" by(erule every_path_distance)
        and "y = length as'"
        by(auto elim:distance.cases)
      show False
      proof(cases "y < length as")
        case True
        have "n -a#as'\<rightarrow>* n'" by -(rule path.Cons_path)
        with all have "x \<le> length (a#as')" by blast
      next
        case False
        have "distance (targetnode a) n' y" by simp
        obtain a' where "sourcenode a = sourcenode a'"
          and "distance (targetnode a') n' y" and "valid_edge a'"
          and "targetnode a' = (SOME nx. \<exists>a'. sourcenode a = sourcenode a' \<and>
                                              distance (targetnode a') n' y \<and>
                                              valid_edge a' \<and> targetnode a' = nx)"
          by(auto dest:only_one_SOME_dist_edge)
      qed
    qed
  qed
  with that show ?thesis by blast
qed

end

end


