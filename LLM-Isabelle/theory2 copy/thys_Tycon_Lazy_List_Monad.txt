theory Lazy_List_Monad
imports Monad_Zero_Plus
begin





instance llist :: "functor"
proof
  fix f g and xs :: "udom\<cdot>llist"
  show "fmapU\<cdot>f\<cdot>(fmapU\<cdot>g\<cdot>xs) = fmapU\<cdot>(\<Lambda> x. f\<cdot>(g\<cdot>x))\<cdot>xs"
    by (induct xs rule: llist.induct) simp_all
qed


instantiation llist :: monad_zero_plus
begin

fixrec plusU_llist :: "udom\<cdot>llist \<rightarrow> udom\<cdot>llist \<rightarrow> udom\<cdot>llist"
  where "plusU_llist\<cdot>LNil\<cdot>ys = ys"
  | "plusU_llist\<cdot>(LCons\<cdot>x\<cdot>xs)\<cdot>ys = LCons\<cdot>x\<cdot>(plusU_llist\<cdot>xs\<cdot>ys)"

lemma plusU_llist_strict [simp]: "plusU\<cdot>\<bottom>\<cdot>ys = (\<bottom>::udom\<cdot>llist)"
by fixrec_simp

fixrec bindU_llist :: "udom\<cdot>llist \<rightarrow> (udom \<rightarrow> udom\<cdot>llist) \<rightarrow> udom\<cdot>llist"
  where "bindU_llist\<cdot>LNil\<cdot>k = LNil"
  | "bindU_llist\<cdot>(LCons\<cdot>x\<cdot>xs)\<cdot>k = plusU\<cdot>(k\<cdot>x)\<cdot>(bindU_llist\<cdot>xs\<cdot>k)"

lemma bindU_llist_strict [simp]: "bindU\<cdot>\<bottom>\<cdot>k = (\<bottom>::udom\<cdot>llist)"
by fixrec_simp

definition zeroU_llist_def:
  "zeroU = LNil"

definition returnU_llist_def:
  "returnU = (\<Lambda> x. LCons\<cdot>x\<cdot>LNil)"

lemma plusU_LNil_right: "plusU\<cdot>xs\<cdot>LNil = xs"
by (induct xs rule: llist.induct) simp_all

lemma plusU_llist_assoc:
  fixes xs ys zs :: "udom\<cdot>llist"
  shows "plusU\<cdot>(plusU\<cdot>xs\<cdot>ys)\<cdot>zs = plusU\<cdot>xs\<cdot>(plusU\<cdot>ys\<cdot>zs)"
by (induct xs rule: llist.induct) simp_all

lemma bindU_plusU_llist:
  fixes xs ys :: "udom\<cdot>llist" shows
  "bindU\<cdot>(plusU\<cdot>xs\<cdot>ys)\<cdot>f = plusU\<cdot>(bindU\<cdot>xs\<cdot>f)\<cdot>(bindU\<cdot>ys\<cdot>f)"
by (induct xs rule: llist.induct) (simp_all add: plusU_llist_assoc)

instance proof
  fix x :: "udom"
  fix f :: "udom \<rightarrow> udom"
  fix h k :: "udom \<rightarrow> udom\<cdot>llist"
  fix xs ys zs :: "udom\<cdot>llist"
  show "fmapU\<cdot>f\<cdot>xs = bindU\<cdot>xs\<cdot>(\<Lambda> x. returnU\<cdot>(f\<cdot>x))"
    by (induct xs rule: llist.induct, simp_all add: returnU_llist_def)
  show "bindU\<cdot>(returnU\<cdot>x)\<cdot>k = k\<cdot>x"
    by (simp add: returnU_llist_def plusU_LNil_right)
  show "bindU\<cdot>(bindU\<cdot>xs\<cdot>h)\<cdot>k = bindU\<cdot>xs\<cdot>(\<Lambda> x. bindU\<cdot>(h\<cdot>x)\<cdot>k)"
    by (induct xs rule: llist.induct)
       (simp_all add: bindU_plusU_llist)
  show "bindU\<cdot>(plusU\<cdot>xs\<cdot>ys)\<cdot>k = plusU\<cdot>(bindU\<cdot>xs\<cdot>k)\<cdot>(bindU\<cdot>ys\<cdot>k)"
    by (induct xs rule: llist.induct)
       (simp_all add: plusU_llist_assoc)
  show "plusU\<cdot>(plusU\<cdot>xs\<cdot>ys)\<cdot>zs = plusU\<cdot>xs\<cdot>(plusU\<cdot>ys\<cdot>zs)"
    by (rule plusU_llist_assoc)
  show "bindU\<cdot>zeroU\<cdot>k = zeroU"
    by (simp add: zeroU_llist_def)
  show "fmapU\<cdot>f\<cdot>(plusU\<cdot>xs\<cdot>ys) = plusU\<cdot>(fmapU\<cdot>f\<cdot>xs)\<cdot>(fmapU\<cdot>f\<cdot>ys)"
    by (induct xs rule: llist.induct) simp_all
  show "fmapU\<cdot>f\<cdot>zeroU = (zeroU :: udom\<cdot>llist)"
    by (simp add: zeroU_llist_def)
  show "plusU\<cdot>zeroU\<cdot>xs = xs"
    by (simp add: zeroU_llist_def)
  show "plusU\<cdot>xs\<cdot>zeroU = xs"
    by (simp add: zeroU_llist_def plusU_LNil_right)
qed

end


