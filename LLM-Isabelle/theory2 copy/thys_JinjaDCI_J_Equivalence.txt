    Based on the Jinja theory J/Equivalence.thy by Tobias Nipkow
*)
(*<*)by(rule InitNoneRed[THEN converse_rtrancl_into_rtrancl])(*>*)
(*<*)by(rule RedInitDone[THEN converse_rtrancl_into_rtrancl])(*>*)
(*<*)by(rule RedInitProcessing[THEN converse_rtrancl_into_rtrancl])(*>*)
(*<*)by(rule RedInitError[THEN converse_rtrancl_into_rtrancl])(*>*)
(*<*)by(rule InitObjectRed[THEN converse_rtrancl_into_rtrancl])(*>*)
(*<*)by(rule InitNonObjectSuperRed[THEN converse_rtrancl_into_rtrancl])(*>*)
(*<*)by(rule RedInitRInit[THEN converse_rtrancl_into_rtrancl])(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by(rule RInitReds[THEN rtrancl_into_rtrancl, OF _ RInitThrow])(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)(is "(?a, ?c) \<in> (red P)\<^sup>*")
(*>*)
(*<*)(is "(?a, ?c) \<in> (red P)\<^sup>*")
(*>*)
(*<*)(is "(?a, ?c) \<in> (red P)\<^sup>*")
(*>*)
(*<*)
(*>*)
(*<*)by(rule CastReds[THEN rtrancl_into_rtrancl, OF _ RedCastNull])(*>*)
(*<*)by(cases s', simp) (rule CastReds[THEN rtrancl_into_rtrancl, OF _ RedCast])(*>*)
(*<*)by(cases s', simp) (rule CastReds[THEN rtrancl_into_rtrancl, OF _ RedCastFail])(*>*)
(*<*)by(rule CastReds[THEN rtrancl_into_rtrancl, OF _ red_reds.CastThrow])(*>*)
(*<*)
(*>*)
(*<*)by(rule LAssReds[THEN rtrancl_into_rtrancl, OF _ RedLAss])(*>*)
(*<*)by(rule LAssReds[THEN rtrancl_into_rtrancl, OF _ red_reds.LAssThrow])(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)by(rule BinOp1Reds[THEN rtrancl_into_rtrancl, OF _ red_reds.BinOpThrow1])(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)
(*>*)
(*<*)by(cases s',simp) (rule FAccReds[THEN rtrancl_into_rtrancl, OF _ RedFAcc])(*>*)
(*<*)by(rule FAccReds[THEN rtrancl_into_rtrancl, OF _ RedFAccNull])(*>*)
(*<*)by(cases s',simp) (auto intro: FAccReds[THEN rtrancl_into_rtrancl, OF _ RedFAccNone])(*>*)
(*<*)by(cases s',simp) (rule FAccReds[THEN rtrancl_into_rtrancl, OF _ RedFAccStatic])(*>*)
(*<*)by(rule FAccReds[THEN rtrancl_into_rtrancl, OF _ red_reds.FAccThrow])(*>*)
(*<*)by(cases s,simp) (rule RedSFAcc[THEN r_into_rtrancl])(*>*)
(*<*)by(cases s,simp) (auto intro: RedSFAccNone[THEN r_into_rtrancl])(*>*)
(*<*)by(cases s,simp) (rule RedSFAccNonStatic[THEN r_into_rtrancl])(*>*)
(*<*)(is "(?a, ?c) \<in> (red P)\<^sup>*")
(*>*)
(*<*)(is "(?a, ?c) \<in> (red P)\<^sup>*")
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)by(rule FAssReds1[THEN rtrancl_into_rtrancl, OF _ red_reds.FAssThrow1])(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)
(*>*)
(*<*)(is "(?a, ?c) \<in> (red P)\<^sup>*")
(*>*)
(*<*)by(rule SFAssReds[THEN rtrancl_into_rtrancl, OF _ red_reds.SFAssThrow])(*>*)
(*<*)by(rule SFAssReds[THEN rtrancl_into_rtrancl, OF _ RedSFAssNone])(*>*)
(*<*)by(rule SFAssReds[THEN rtrancl_into_rtrancl, OF _ RedSFAssNonStatic])(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)
(*>*)
(*<*)by(rule SeqReds[THEN rtrancl_into_rtrancl, OF _ red_reds.SeqThrow])(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)
(*>*)
(*<*)by(rule CondReds[THEN rtrancl_into_rtrancl, OF _ red_reds.CondThrow])(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)(is "(?a, ?c) \<in> (red P)\<^sup>*")
(*>*)
(*<*)(is "(?a, ?c) \<in> (red P)\<^sup>*")
(*>*)
(*<*)
(*>*)
(*<*)by(rule ThrowReds[THEN rtrancl_into_rtrancl, OF _ RedThrowNull])(*>*)
(*<*)by(rule ThrowReds[THEN rtrancl_into_rtrancl, OF _ red_reds.ThrowThrow])(*>*)
(*<*)
(*>*)
(*<*)by(blast dest:InitBlockReds_aux)(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by(rule TryReds[THEN rtrancl_into_rtrancl, OF _ RedTry])(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)by(fastforce intro!: TryReds[THEN rtrancl_into_rtrancl, OF _ RedTryFail])(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by(rule rtrancl_trans[OF ListReds1 ListReds2])(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by(rule ext) (simp add:override_on_def)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)by(rule CallRedsObj[THEN rtrancl_into_rtrancl, OF _ CallThrowObj])(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)(is "(?x, ?z) \<in> (red P)\<^sup>*")
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(***********************************)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
    using IH\<^sub>2[OF fv\<^sub>2] fun_upd_restrict[of l\<^sub>1 W] (*FIXME just l|W instead of l|(W-V) in simp rule??*) by simp
(*>*)
(*<*)
(*>*)
(*<*)by(fastforce dest:eval_notfree_unchanged simp add:fun_eq_iff [where 'b="val option"])(*>*)
(*<*)
(*>*)
(* Hiermit kann man die ganze pair-Splitterei in den automatischen Taktiken
abschalten. Wieder anschalten siehe nach dem Beweis. *)
(*<*)
(*>*)
(*>*)
(*<*)
(* ... und wieder anschalten: *)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by(blast dest: big_by_small eval_final small_by_big)(*>*)
(*<*)by(blast dest: big_iff_small WT_nsub_RI nsub_RI_iconf)(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
