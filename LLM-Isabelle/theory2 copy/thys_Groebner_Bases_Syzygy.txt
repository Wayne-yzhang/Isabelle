theory Syzygy
  imports Groebner_Bases More_MPoly_Type_Class
begin

  then provide a method for computing Gr\"obner bases of syzygy modules of lists of multivariate
  vector-polynomials. Since syzygies in this context are themselves represented by vector-polynomials,
  this method can be applied repeatedly to compute bases of syzygy modules of syzygies, and so on.\<close>
subsection \<open>Syzygy Modules Generated by Sets\<close>
    by (rule Abs_poly_mapping_inverse, simp add: \<open>finite A\<close>)
    also from \<open>finite A\<close> 2 have "... = (\<Sum>a\<in>keys r. lookup r a *s a)"
    from 2 \<open>A \<subseteq> B\<close> show "keys r \<subseteq> B" by (rule subset_trans)
    from \<open>v0 \<in> keys r\<close> have "lookup r v0 \<in> Poly_Mapping.range r" by (rule in_keys_lookup_in_range)
    with \<open>t \<in> keys (lookup r v0)\<close> show "t \<in> Keys (Poly_Mapping.range r)" by (rule in_KeysI)
    from \<open>v \<in> keys v0\<close> \<open>v0 \<in> keys r\<close> show "v \<in> Keys (keys r)" by (rule in_KeysI)
subsection \<open>Polynomial Mappings on List-Indices\<close>
    from \<open>t \<in> set xs\<close> obtain i where "i < length xs" and "t = xs ! i" by (metis in_set_conv_nth)
    moreover from \<open>i < length xs\<close> \<open>t = xs ! i\<close> have "{i. i < length xs \<and> xs ! i = t} \<noteq> {}" by auto
        with \<open>i < length xs\<close> have "k \<in> set xs" by auto
        thus ?thesis by (simp add: lookup_pm_of_idx_pm lookup_single *[OF \<open>i < length xs\<close>] True[symmetric])
            by (auto simp: \<open>k = xs ! j\<close> *[OF \<open>j < length xs\<close>])
        by (auto simp: \<open>k = xs ! j\<close> *[OF \<open>j < length xs\<close>])
    with \<open>m2 < j\<close> have "m1 < j" by simp
    with \<open>m1 < length xs\<close> \<open>xs ! m1 = i\<close> have "m1 \<in> ?B" by simp
    with \<open>m1 \<le> m2\<close> have "m1 = m2" by (rule le_antisym)
    with True \<open>i \<in> set xs\<close> show ?thesis by (simp add: lookup_pm_of_idx_pm m1_def m2_def cong: conj_cong)
        with \<open>m1 < length xs\<close> have "m1 < length ?xs" by simp
        with \<open>m1 < j\<close> have "i \<in> set ?xs" by (simp add: \<open>xs ! m1 = i\<close>)
  moreover from \<open>k \<in> set xs\<close> have "{i. i < length xs \<and> xs ! i = k} \<noteq> {}"
subsection \<open>POT Orders\<close>
      with \<open>?l\<close> have "u = v" by simp
subsection \<open>Gr\"obner Bases of Syzygy Modules\<close>
text \<open>In order to compute a Gr\"obner basis of the syzygy module of a list \<open>bs\<close> of polynomials, one
  first needs to ``lift'' \<open>bs\<close> to a new list \<open>bs'\<close> by adding further components, compute a Gr\"obner
  basis \<open>gs\<close> of \<open>bs'\<close>, and then filter out those elements of \<open>gs\<close> whose only non-zero components are
  those that were newly added to \<open>bs\<close>.
  Function \<open>init_syzygy_list\<close> takes care of constructing \<open>bs'\<close>, and function \<open>filter_syzygy_basis\<close>
  does the filtering. Function \<open>proj_orig_basis\<close>, finally, projects the Gr\"obner basis \<open>gs\<close> of \<open>bs'\<close>
  to a Gr\"obner basis of the original list \<open>bs\<close>.\<close>
subsubsection \<open>@{const lift_poly_syz}\<close>
subsubsection \<open>@{const proj_poly_syz}\<close>
    thus False by (simp add: \<open>?A = {}\<close>)
  with \<open>i \<notin> {0..<n}\<close> show ?thesis by (simp add: i)
subsubsection \<open>@{const cofactor_list_syz}\<close>
subsubsection \<open>@{const init_syzygy_list}\<close>
    by (rule poly_mapping_eqI, simp add: lookup_proj_poly lookup_lift_poly_syz_alt \<open>\<not> n \<le> i\<close> lookup_one)
    by (rule poly_mapping_eqI, simp add: lookup_proj_poly lookup_lift_poly_syz_alt \<open>\<not> n \<le> j\<close> \<open>j \<noteq> i\<close>)
subsubsection \<open>@{const proj_orig_basis}\<close>
text \<open>The following lemma could be generalized from @{const proj_poly_syz} to arbitrary module homomorphisms,
lemma pmdl_proj_orig_basis':
  "pmdl (set (proj_orig_basis n bs)) = proj_poly_syz n ` pmdl (set bs)" (is "?A = ?B")
proof
  show "?A \<subseteq> ?B"
  proof
    fix p
    assume "p \<in> pmdl (set (proj_orig_basis n bs))"
    thus "p \<in> proj_poly_syz n ` pmdl (set bs)"
    proof (induct rule: pmdl_induct)
      case module_0
      have "0 = proj_poly_syz n 0" by simp
      also from pmdl.span_zero have "... \<in> proj_poly_syz n ` pmdl (set bs)" by (rule imageI)
      finally show ?case .
    next
      case (module_plus p b c t)
      from module_plus(2) obtain q where "q \<in> pmdl (set bs)" and p: "p = proj_poly_syz n q" ..
      from module_plus(3) obtain a where "a \<in> set bs" and b: "b = proj_poly_syz n a"
        unfolding set_proj_orig_basis ..
      have "p + monom_mult c t b = proj_poly_syz n (q + monom_mult c t a)"
        by (simp add: p b proj_poly_syz_monom_mult proj_poly_syz_plus)
      also have "... \<in> proj_poly_syz n ` pmdl (set bs)"
      proof (rule imageI, rule pmdl.span_add)
        show "monom_mult c t a \<in> pmdl (set bs)"
          by (rule pmdl_closed_monom_mult, rule pmdl.span_base, fact)
      qed fact
      finally show ?case .
    qed
  qed
next
  show "?B \<subseteq> ?A"
  proof
    fix p
    assume "p \<in> proj_poly_syz n ` pmdl (set bs)"
    then obtain q where "q \<in> pmdl (set bs)" and p: "p = proj_poly_syz n q" ..
    from this(1) show "p \<in> pmdl (set (proj_orig_basis n bs))" unfolding p
    proof (induct rule: pmdl_induct)
      case module_0
      have "proj_poly_syz n 0 = 0" by simp
      also have "... \<in> pmdl (set (proj_orig_basis n bs))" by (fact pmdl.span_zero)
      finally show ?case .
    next
      case (module_plus q b c t)
      have "proj_poly_syz n (q + monom_mult c t b) =
            proj_poly_syz n q + monom_mult c t (proj_poly_syz n b)"
        by (simp add: proj_poly_syz_plus proj_poly_syz_monom_mult)
      also have "... \<in> pmdl (set (proj_orig_basis n bs))"
      proof (rule pmdl.span_add)
        show "monom_mult c t (proj_poly_syz n b) \<in> pmdl (set (proj_orig_basis n bs))"
        proof (rule pmdl_closed_monom_mult, rule pmdl.span_base)
          show "proj_poly_syz n b \<in> set (proj_orig_basis n bs)"
            by (simp add: set_proj_orig_basis, rule imageI, fact)
        qed
      qed fact
      finally show ?case .
    qed
  qed
qed


lemma filter_syzygy_basis_alt: "filter_syzygy_basis n bs = [b\<leftarrow>bs. proj_poly_syz n b = 0]"
  by (simp add: filter_syzygy_basis_def proj_poly_syz_eq_zero_iff)

lemma set_filter_syzygy_basis:
  "set (filter_syzygy_basis n bs) = {b\<in>set bs. proj_poly_syz n b = 0}"
  by (simp add: filter_syzygy_basis_alt)


lemma syzygy_module_listI:
  assumes "s' \<in> pmdl.syzygy_module (set bs)" and "s = atomize_poly (idx_pm_of_pm bs s')"
  shows "s \<in> syzygy_module_list bs"
  unfolding assms(2) syzygy_module_list_def by (intro imageI, fact assms(1))

lemma syzygy_module_listE:
  assumes "s \<in> syzygy_module_list bs"
  obtains s' where "s' \<in> pmdl.syzygy_module (set bs)" and "s = atomize_poly (idx_pm_of_pm bs s')"
  using assms unfolding syzygy_module_list_def by (elim imageE, simp)

lemma monom_mult_atomize:
  "monom_mult c t (atomize_poly p) = atomize_poly (MPoly_Type_Class.punit.monom_mult (monomial c t) 0 p)"
  by (rule poly_mapping_eqI_proj, simp add: proj_monom_mult proj_atomize_poly
      MPoly_Type_Class.punit.lookup_monom_mult times_monomial_left)

lemma punit_monom_mult_monomial_idx_pm_of_pm:
  "MPoly_Type_Class.punit.monom_mult (monomial c t) (0::nat) (idx_pm_of_pm bs s) =
    idx_pm_of_pm bs (MPoly_Type_Class.punit.monom_mult (monomial c t) (0::'t \<Rightarrow>\<^sub>0 'b::ring_1) s)"
  by (rule poly_mapping_eqI, simp add: MPoly_Type_Class.punit.lookup_monom_mult lookup_idx_pm_of_pm when_def)

lemma syzygy_module_list_closed_monom_mult:
  assumes "s \<in> syzygy_module_list bs"
  shows "monom_mult c t s \<in> syzygy_module_list bs"
proof -
  from assms obtain s' where s': "s' \<in> pmdl.syzygy_module (set bs)"
    and s: "s = atomize_poly (idx_pm_of_pm bs s')" by (rule syzygy_module_listE)
  show ?thesis unfolding s
  proof (rule syzygy_module_listI)
    from s' show "(monomial c t) \<cdot> s' \<in> pmdl.syzygy_module (set bs)"
      by (rule syzygy_module_closed_map_scale)
  next
    show "monom_mult c t (atomize_poly (idx_pm_of_pm bs s')) =
          atomize_poly (idx_pm_of_pm bs ((monomial c t) \<cdot> s'))"
      by (simp add: monom_mult_atomize punit_monom_mult_monomial_idx_pm_of_pm
            MPoly_Type_Class.punit.map_scale_eq_monom_mult)
  qed
qed

lemma pmdl_syzygy_module_list [simp]: "pmdl (syzygy_module_list bs) = syzygy_module_list bs"
proof (rule pmdl_idI)
  show "0 \<in> syzygy_module_list bs"
    by (rule syzygy_module_listI, fact pmdl.zero_in_syzygy_module, simp add: atomize_zero)
next
  fix s1 s2
  assume "s1 \<in> syzygy_module_list bs"
  then obtain s1' where s1': "s1' \<in> pmdl.syzygy_module (set bs)"
    and s1: "s1 = atomize_poly (idx_pm_of_pm bs s1')" by (rule syzygy_module_listE)
  assume "s2 \<in> syzygy_module_list bs"
  then obtain s2' where s2': "s2' \<in> pmdl.syzygy_module (set bs)"
    and s2: "s2 = atomize_poly (idx_pm_of_pm bs s2')" by (rule syzygy_module_listE)
  show "s1 + s2 \<in> syzygy_module_list bs"
  proof (rule syzygy_module_listI)
    from s1' s2' show "s1' + s2' \<in> pmdl.syzygy_module (set bs)"
      by (rule pmdl.syzygy_module_closed_plus)
  next
    show "s1 + s2 = atomize_poly (idx_pm_of_pm bs (s1' + s2'))"
      by (simp add: idx_pm_of_pm_plus atomize_plus s1 s2)
  qed
qed (fact syzygy_module_list_closed_monom_mult)

  proof becomes more difficult.\<close>
text \<open>Probably the following lemma also holds without the distinctness constraint on \<open>bs\<close>.\<close>
      by (simp add: eq \<open>s \<in> syzygy_module_list bs\<close> proj_poly_syz_eq_zero_iff component_of_syzygy_module_list)
      by (simp add: \<open>k < length bs\<close> init_syzygy_list_nth proj_lift_poly_syz cofactor_list_syz_nth)
          simp_all add: \<open>k < length bs\<close> init_syzygy_list_nth proj_lift_poly_syz)
subsubsection \<open>Cofactors\<close>
subsubsection \<open>Modules\<close>
          from \<open>f \<noteq> 0\<close> have "lt f \<in> keys f" by (rule lt_in_keys)
          also from \<open>f \<in> syzygy_module_list bs\<close> have "... \<subseteq> {0..<length bs}"
subsubsection \<open>Gr\"obner Bases\<close>
  from \<open>f \<noteq> 0\<close> have "h \<noteq> 0" by (auto simp add: f)
  with assms(2) \<open>h \<in> pmdl (set gs)\<close> obtain g where "g \<in> set gs" and "g \<noteq> 0"
    from assms(1) \<open>f \<noteq> 0\<close> have "length bs \<le> component_of_term (lt h)"
    moreover from \<open>g \<noteq> 0\<close> have "lt g \<in> keys g" by (rule lt_in_keys)
    ultimately show False using \<open>component_of_term ` keys g \<subseteq> {0..<length bs}\<close> by blast
      unfolding set_proj_orig_basis using \<open>g \<in> set gs\<close> by (rule imageI)
  from assms this \<open>f \<noteq> 0\<close>
