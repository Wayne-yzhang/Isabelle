theory ConcurrentComposition
imports Noninterference_Sequential_Composition.Propaedeutics
begin



subsection "Propaedeutic definitions and lemmas"


lemma sinks_aux_elem [rule_format]:
 "u \<in> sinks_aux I D U xs \<longrightarrow> u \<in> U \<or> (\<exists>x \<in> set xs. u = D x)"
by (induction xs rule: rev_induct, simp_all, blast)

lemma ipurge_ref_aux_cons:
 "ipurge_ref_aux I D U (x # xs) X = ipurge_ref_aux I D (sinks_aux I D U [x]) xs X"
by (subgoal_tac "x # xs = [x] @ xs", simp only: ipurge_ref_aux_append, simp)

lemma process_rule_1_futures:
 "xs \<in> traces P \<Longrightarrow> ([], {}) \<in> futures P xs"
by (simp add: futures_def, rule traces_failures)

lemma process_rule_3_futures:
 "(ys, Y) \<in> futures P xs \<Longrightarrow> Y' \<subseteq> Y \<Longrightarrow> (ys, Y') \<in> futures P xs"
by (simp add: futures_def, rule process_rule_3)

lemma process_rule_4_futures:
 "(ys, Y) \<in> futures P xs \<Longrightarrow>
    (ys @ [x], {}) \<in> futures P xs \<or> (ys, insert x Y) \<in> futures P xs"
by (simp add: futures_def, subst append_assoc [symmetric], rule process_rule_4)

lemma process_rule_5_general [rule_format]:
 "xs \<in> divergences P \<longrightarrow> xs @ ys \<in> divergences P"
proof (induction ys rule: rev_induct, simp, rule impI, simp)
qed (subst append_assoc [symmetric], rule process_rule_5)


definition future_divergences :: "'a process \<Rightarrow> 'a list \<Rightarrow> 'a list set" where
"future_divergences P xs \<equiv> {ys. xs @ ys \<in> divergences P}"

definition after :: "'a process \<Rightarrow> 'a list \<Rightarrow> 'a process" (infixl "\<setminus>" 64) where
"P \<setminus> xs \<equiv> Abs_process (futures P xs, future_divergences P xs)"

lemma process_rule_5_futures:
 "ys \<in> future_divergences P xs \<Longrightarrow> ys @ [x] \<in> future_divergences P xs"
by (simp add: future_divergences_def, subst append_assoc [symmetric],
 rule process_rule_5)

lemma process_rule_6_futures:
 "ys \<in> future_divergences P xs \<Longrightarrow> (ys, Y) \<in> futures P xs"
by (simp add: futures_def future_divergences_def, rule process_rule_6)

lemma after_rep:
  assumes A: "xs \<in> traces P"
  shows "Rep_process (P \<setminus> xs) = (futures P xs, future_divergences P xs)"
    (is "_ = ?X")
proof (subst after_def, rule Abs_process_inverse, simp add: process_set_def,
 (subst conj_assoc [symmetric])+, (rule conjI)+)
  show "process_prop_1 ?X"
  proof (simp add: process_prop_1_def)
  qed (rule process_rule_1_futures [OF A])
next
  show "process_prop_2 ?X"
  proof (simp add: process_prop_2_def del: all_simps, (rule allI)+, rule impI)
  qed (rule process_rule_2_futures)
next
  show "process_prop_3 ?X"
  proof (simp add: process_prop_3_def del: all_simps, (rule allI)+, rule impI,
   erule conjE)
  qed (rule process_rule_3_futures)
next
  show "process_prop_4 ?X"
  proof (simp add: process_prop_4_def, (rule allI)+, rule impI)
  qed (rule process_rule_4_futures)
next
  show "process_prop_5 ?X"
  proof (simp add: process_prop_5_def, rule allI, rule impI, rule allI)
  qed (rule process_rule_5_futures)
next
  show "process_prop_6 ?X"
  proof (simp add: process_prop_6_def, rule allI, rule impI, rule allI)
  qed (rule process_rule_6_futures)
qed

lemma after_failures:
  assumes A: "xs \<in> traces P"
  shows "failures (P \<setminus> xs) = futures P xs"
by (simp add: failures_def after_rep [OF A])

lemma after_futures:
  assumes A: "xs \<in> traces P"
  shows "futures (P \<setminus> xs) ys = futures P (xs @ ys)"
by (simp add: futures_def after_failures [OF A])


lemma after_secure:
  assumes A: "xs \<in> traces P"
  shows "secure P I D \<Longrightarrow> secure (P \<setminus> xs) I D"
by (simp add: secure_def after_futures [OF A], blast)

lemma ipurge_tr_ref_aux_futures:
 "\<lbrakk>secure P I D; (ys, Y) \<in> futures P xs\<rbrakk> \<Longrightarrow>
    (ipurge_tr_aux I D U ys, ipurge_ref_aux I D U ys Y) \<in> futures P xs"
proof (subgoal_tac "xs \<in> traces P", simp add: after_failures [symmetric],
 rule ipurge_tr_ref_aux_failures, rule after_secure, assumption+)
qed (simp add: futures_def, drule failures_traces, rule process_rule_2_traces)

lemma ipurge_tr_ref_aux_failures_general:
 "\<lbrakk>secure P I D; (xs @ ys, Y) \<in> failures P\<rbrakk> \<Longrightarrow>
    (xs @ ipurge_tr_aux I D U ys, ipurge_ref_aux I D U ys Y) \<in> failures P"
by (drule ipurge_tr_ref_aux_futures, simp_all add: futures_def)


subsection "Concurrent composition"


definition con_comp_divergences ::
 "'a process \<Rightarrow> 'b process \<Rightarrow> ('a \<Rightarrow> 'c) \<Rightarrow> ('b \<Rightarrow> 'c) \<Rightarrow> 'c list set" where
"con_comp_divergences P Q p q \<equiv>
  {xs @ ys | xs ys.
    set xs \<subseteq> range p \<union> range q \<and>
    map (inv p) [x\<leftarrow>xs. x \<in> range p] \<in> divergences P \<and>
    map (inv q) [x\<leftarrow>xs. x \<in> range q] \<in> divergences Q}"

definition con_comp_failures ::
 "'a process \<Rightarrow> 'b process \<Rightarrow> ('a \<Rightarrow> 'c) \<Rightarrow> ('b \<Rightarrow> 'c) \<Rightarrow> 'c failure set" where
"con_comp_failures P Q p q \<equiv>
  {(xs, X \<union> Y \<union> Z) | xs X Y Z.
    set xs \<subseteq> range p \<union> range q \<and>
    X \<subseteq> range p \<and> Y \<subseteq> range q \<and> Z \<subseteq> - (range p \<union> range q) \<and>
    (map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` X) \<in> failures P \<and>
    (map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` Y) \<in> failures Q} \<union>
  {(xs, X). xs \<in> con_comp_divergences P Q p q}"

definition con_comp ::
 "'a process \<Rightarrow> 'b process \<Rightarrow> ('a \<Rightarrow> 'c) \<Rightarrow> ('b \<Rightarrow> 'c) \<Rightarrow> 'c process" where
"con_comp P Q p q \<equiv>
  Abs_process (con_comp_failures P Q p q, con_comp_divergences P Q p q)"

abbreviation con_comp_syntax ::
 "'a process \<Rightarrow> 'b process \<Rightarrow> ('a \<Rightarrow> 'c) \<Rightarrow> ('b \<Rightarrow> 'c) \<Rightarrow> 'c process"
 ("(_ \<parallel> _ <_, _>)" 55)
where
"P \<parallel> Q <p, q> \<equiv> con_comp P Q p q"


lemma con_comp_prop_1:
 "([], {}) \<in> con_comp_failures P Q p q"
proof (simp add: con_comp_failures_def)
qed (rule disjI1, rule conjI, (rule process_rule_1)+)

lemma con_comp_prop_2:
 "(xs @ [x], X) \<in> con_comp_failures P Q p q \<Longrightarrow>
    (xs, {}) \<in> con_comp_failures P Q p q"
proof (simp add: con_comp_failures_def del: filter_append,
 erule disjE, (erule exE)+, (erule conjE)+, rule disjI1)
  fix X Y
  assume
    A: "set xs \<subseteq> range p \<union> range q" and
    B: "(map (inv p) [x\<leftarrow>xs @ [x]. x \<in> range p], inv p ` X) \<in> failures P" and
    C: "(map (inv q) [x\<leftarrow>xs @ [x]. x \<in> range q], inv q ` Y) \<in> failures Q"
  show "set xs \<subseteq> range p \<union> range q \<and>
    (map (inv p) [x\<leftarrow>xs. x \<in> range p], {}) \<in> failures P \<and>
    (map (inv q) [x\<leftarrow>xs. x \<in> range q], {}) \<in> failures Q"
  proof (simp add: A, rule conjI, cases "x \<in> range p",
   case_tac [3] "x \<in> range q")
    assume "x \<in> range p"
    hence "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @ [inv p x], inv p ` X) \<in> failures P"
     using B by simp
    thus "(map (inv p) [x\<leftarrow>xs. x \<in> range p], {}) \<in> failures P"
     by (rule process_rule_2)
  next
    assume "x \<notin> range p"
    hence "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` X) \<in> failures P"
     using B by simp
    moreover have "{} \<subseteq> inv p ` X" ..
    ultimately show "(map (inv p) [x\<leftarrow>xs. x \<in> range p], {}) \<in> failures P"
     by (rule process_rule_3)
  next
    assume "x \<in> range q"
    hence "(map (inv q) [x\<leftarrow>xs. x \<in> range q] @ [inv q x], inv q ` Y) \<in> failures Q"
     using C by simp
    thus "(map (inv q) [x\<leftarrow>xs. x \<in> range q], {}) \<in> failures Q"
     by (rule process_rule_2)
  next
    assume "x \<notin> range q"
    hence "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` Y) \<in> failures Q"
     using C by simp
    moreover have "{} \<subseteq> inv q ` Y" ..
    ultimately show "(map (inv q) [x\<leftarrow>xs. x \<in> range q], {}) \<in> failures Q"
     by (rule process_rule_3)
  qed
next
  assume A: "xs @ [x] \<in> con_comp_divergences P Q p q"
  show
   "set xs \<subseteq> range p \<union> range q \<and>
      (map (inv p) [x\<leftarrow>xs. x \<in> range p], {}) \<in> failures P \<and>
      (map (inv q) [x\<leftarrow>xs. x \<in> range q], {}) \<in> failures Q \<or>
    xs \<in> con_comp_divergences P Q p q"
    (is "?A \<or> _")
  proof (insert A, simp add: con_comp_divergences_def,
   ((erule exE)?, erule conjE)+)
    fix ws ys
    assume
      B: "xs @ [x] = ws @ ys" and
      C: "set ws \<subseteq> range p \<union> range q" and
      D: "map (inv p) [x\<leftarrow>ws. x \<in> range p] \<in> divergences P" and
      E: "map (inv q) [x\<leftarrow>ws. x \<in> range q] \<in> divergences Q"
    show "?A \<or> (\<exists>ws'.
      (\<exists>ys'. xs = ws' @ ys') \<and>
      set ws' \<subseteq> range p \<union> range q \<and>
      map (inv p) [x\<leftarrow>ws'. x \<in> range p] \<in> divergences P \<and>
      map (inv q) [x\<leftarrow>ws'. x \<in> range q] \<in> divergences Q)"
      (is "_ \<or> (\<exists>ws'. ?B ws')")
    proof (cases ys, rule disjI1, rule_tac [2] disjI2)
      case Nil
      hence "set (xs @ [x]) \<subseteq> range p \<union> range q"
       using B and C by simp
      hence "insert x (set xs) \<subseteq> range p \<union> range q"
       by simp
      moreover have "set xs \<subseteq> insert x (set xs)"
       by (rule subset_insertI)
      ultimately have "set xs \<subseteq> range p \<union> range q"
       by simp
      moreover have "map (inv p) [x\<leftarrow>xs @ [x]. x \<in> range p] \<in> divergences P"
       using Nil and B and D by simp
      hence "(map (inv p) [x\<leftarrow>xs. x \<in> range p], {}) \<in> failures P"
      proof (cases "x \<in> range p", simp_all)
        assume "map (inv p) [x\<leftarrow>xs. x \<in> range p] @ [inv p x] \<in> divergences P"
        hence "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @ [inv p x], {}) \<in> failures P"
         by (rule process_rule_6)
        thus ?thesis
         by (rule process_rule_2)
      next
        assume "map (inv p) [x\<leftarrow>xs. x \<in> range p] \<in> divergences P"
        thus ?thesis
         by (rule process_rule_6)
      qed
      moreover have "map (inv q) [x\<leftarrow>xs @ [x]. x \<in> range q] \<in> divergences Q"
       using Nil and B and E by simp
      hence "(map (inv q) [x\<leftarrow>xs. x \<in> range q], {}) \<in> failures Q"
      proof (cases "x \<in> range q", simp_all)
        assume "map (inv q) [x\<leftarrow>xs. x \<in> range q] @ [inv q x] \<in> divergences Q"
        hence "(map (inv q) [x\<leftarrow>xs. x \<in> range q] @ [inv q x], {}) \<in> failures Q"
         by (rule process_rule_6)
        thus ?thesis
         by (rule process_rule_2)
      next
        assume "map (inv q) [x\<leftarrow>xs. x \<in> range q] \<in> divergences Q"
        thus ?thesis
         by (rule process_rule_6)
      qed
      ultimately show ?A
       by blast
    next
      case Cons
      moreover have "butlast (xs @ [x]) = butlast (ws @ ys)"
       using B by simp
      ultimately have "xs = ws @ butlast ys"
       by (simp add: butlast_append)
      hence "\<exists>ys'. xs = ws @ ys'" ..
      hence "?B ws"
       using C and D and E by simp
      thus "\<exists>ws'. ?B ws'" ..
    qed
  qed
qed

lemma con_comp_prop_3:
 "\<lbrakk>(xs, Y) \<in> con_comp_failures P Q p q; X \<subseteq> Y\<rbrakk> \<Longrightarrow>
    (xs, X) \<in> con_comp_failures P Q p q"
proof (simp add: con_comp_failures_def, erule disjE, simp_all,
 (erule exE)+, (erule conjE)+, rule disjI1, simp)
  fix X' Y' Z'
  assume
    A: "X \<subseteq> X' \<union> Y' \<union> Z'" and
    B: "X' \<subseteq> range p" and
    C: "Y' \<subseteq> range q" and
    D: "Z' \<subseteq> - range p" and
    E: "Z' \<subseteq> - range q" and
    F: "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` X') \<in> failures P" and
    G: "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` Y') \<in> failures Q"
  show "\<exists>X' Y' Z'.
    X = X' \<union> Y' \<union> Z' \<and>
    X' \<subseteq> range p \<and>
    Y' \<subseteq> range q \<and>
    Z' \<subseteq> - range p \<and>
    Z' \<subseteq> - range q \<and>
    (map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` X') \<in> failures P \<and>
    (map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` Y') \<in> failures Q"
  proof (rule_tac x = "X' \<inter> X" in exI, rule_tac x = "Y' \<inter> X" in exI,
   rule_tac x = "Z' \<inter> X" in exI, (subst conj_assoc [symmetric])+, (rule conjI)+)
    show "X = X' \<inter> X \<union> Y' \<inter> X \<union> Z' \<inter> X"
     using A by blast
  next
    show "X' \<inter> X \<subseteq> range p"
     using B by blast
  next
    show "Y' \<inter> X \<subseteq> range q"
     using C by blast
  next
    show "Z' \<inter> X \<subseteq> - range p"
     using D by blast
  next
    show "Z' \<inter> X \<subseteq> - range q"
     using E by blast
  next
    have "inv p ` (X' \<inter> X) \<subseteq> inv p ` X'"
     by blast
    with F show "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` (X' \<inter> X))
      \<in> failures P"
     by (rule process_rule_3)
  next
    have "inv q ` (Y' \<inter> X) \<subseteq> inv q ` Y'"
     by blast
    with G show "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` (Y' \<inter> X))
      \<in> failures Q"
     by (rule process_rule_3)
  qed
qed

lemma con_comp_prop_4:
 "(xs, X) \<in> con_comp_failures P Q p q \<Longrightarrow>
    (xs @ [x], {}) \<in> con_comp_failures P Q p q \<or>
    (xs, insert x X) \<in> con_comp_failures P Q p q"
proof (simp add: con_comp_failures_def del: filter_append,
 erule disjE, (erule exE)+, (erule conjE)+, simp_all del: filter_append)
  fix X Y Z
  assume
    A: "X \<subseteq> range p" and
    B: "Y \<subseteq> range q" and
    C: "Z \<subseteq> - range p" and
    D: "Z \<subseteq> - range q" and
    E: "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` X) \<in> failures P" and
    F: "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` Y) \<in> failures Q"
  show
   "(x \<in> range p \<or> x \<in> range q) \<and>
      (map (inv p) [x\<leftarrow>xs @ [x]. x \<in> range p], {}) \<in> failures P \<and>
      (map (inv q) [x\<leftarrow>xs @ [x]. x \<in> range q], {}) \<in> failures Q \<or>
    xs @ [x] \<in> con_comp_divergences P Q p q \<or>
    (\<exists>X' Y' Z'.
      insert x (X \<union> Y \<union> Z) = X' \<union> Y' \<union> Z' \<and>
      X' \<subseteq> range p \<and>
      Y' \<subseteq> range q \<and>
      Z' \<subseteq> - range p \<and>
      Z' \<subseteq> - range q \<and>
      (map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` X') \<in> failures P \<and>
      (map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` Y') \<in> failures Q) \<or>
    xs \<in> con_comp_divergences P Q p q"
    (is "_ \<or> _ \<or> ?A \<or> _")
  proof (cases "x \<in> range p", case_tac [!] "x \<in> range q", simp_all)
    assume
      G: "x \<in> range p" and
      H: "x \<in> range q"
    show
     "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @ [inv p x], {}) \<in> failures P \<and>
        (map (inv q) [x\<leftarrow>xs. x \<in> range q] @ [inv q x], {}) \<in> failures Q \<or>
      xs @ [x] \<in> con_comp_divergences P Q p q \<or>
      ?A \<or>
      xs \<in> con_comp_divergences P Q p q"
      (is "?B \<or> _")
    proof (cases ?B, simp_all del: disj_not1, erule disjE)
      assume
        I: "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @ [inv p x], {}) \<notin> failures P"
      have ?A
      proof (rule_tac x = "insert x X" in exI, rule_tac x = "Y" in exI,
       rule_tac x = "Z" in exI, (subst conj_assoc [symmetric])+, (rule conjI)+)
        show "insert x (X \<union> Y \<union> Z) = insert x X \<union> Y \<union> Z"
         by simp
      next
        show "insert x X \<subseteq> range p"
         using A and G by simp
      next
        show "Y \<subseteq> range q"
         using B .
      next
        show "Z \<subseteq> - range p"
         using C .
      next
        show "Z \<subseteq> - range q"
         using D .
      next
        have
         "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @ [inv p x], {})
            \<in> failures P \<or>
          (map (inv p) [x\<leftarrow>xs. x \<in> range p], insert (inv p x) (inv p ` X))
            \<in> failures P"
         using E by (rule process_rule_4)
        thus "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` insert x X) \<in> failures P"
         using I by simp
      next
        show "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` Y) \<in> failures Q"
         using F .
      qed
      thus ?thesis
       by simp
    next
      assume
        I: "(map (inv q) [x\<leftarrow>xs. x \<in> range q] @ [inv q x], {}) \<notin> failures Q"
      have ?A
      proof (rule_tac x = "X" in exI, rule_tac x = "insert x Y" in exI,
       rule_tac x = "Z" in exI, (subst conj_assoc [symmetric])+, (rule conjI)+)
        show "insert x (X \<union> Y \<union> Z) = X \<union> insert x Y \<union> Z"
         by simp
      next
        show "X \<subseteq> range p"
         using A .
      next
        show "insert x Y \<subseteq> range q"
         using B and H by simp
      next
        show "Z \<subseteq> - range p"
         using C .
      next
        show "Z \<subseteq> - range q"
         using D .
      next
        show "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` X) \<in> failures P"
         using E .
      next
        have
         "(map (inv q) [x\<leftarrow>xs. x \<in> range q] @ [inv q x], {})
            \<in> failures Q \<or>
          (map (inv q) [x\<leftarrow>xs. x \<in> range q], insert (inv q x) (inv q ` Y))
            \<in> failures Q"
         using F by (rule process_rule_4)
        thus "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` insert x Y) \<in> failures Q"
         using I by simp
      qed
      thus ?thesis
       by simp
    qed
  next
    assume G: "x \<in> range p"
    show
     "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @ [inv p x], {}) \<in> failures P \<and>
        (map (inv q) [x\<leftarrow>xs. x \<in> range q], {}) \<in> failures Q \<or>
      xs @ [x] \<in> con_comp_divergences P Q p q \<or>
      ?A \<or>
      xs \<in> con_comp_divergences P Q p q"
    proof (cases "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @ [inv p x], {})
     \<in> failures P")
      case True
      moreover have "{} \<subseteq> inv q ` Y" ..
      with F have "(map (inv q) [x\<leftarrow>xs. x \<in> range q], {}) \<in> failures Q"
       by (rule process_rule_3)
      ultimately show ?thesis
       by simp
    next
      case False
      have ?A
      proof (rule_tac x = "insert x X" in exI, rule_tac x = "Y" in exI,
       rule_tac x = "Z" in exI, (subst conj_assoc [symmetric])+, (rule conjI)+)
        show "insert x (X \<union> Y \<union> Z) = insert x X \<union> Y \<union> Z"
         by simp
      next
        show "insert x X \<subseteq> range p"
         using A and G by simp
      next
        show "Y \<subseteq> range q"
         using B .
      next
        show "Z \<subseteq> - range p"
         using C .
      next
        show "Z \<subseteq> - range q"
         using D .
      next
        have
         "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @ [inv p x], {})
            \<in> failures P \<or>
          (map (inv p) [x\<leftarrow>xs. x \<in> range p], insert (inv p x) (inv p ` X))
            \<in> failures P"
         using E by (rule process_rule_4)
        thus "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` insert x X) \<in> failures P"
         using False by simp
      next
        show "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` Y) \<in> failures Q"
         using F .
      qed
      thus ?thesis
       by simp
    qed
  next
    assume G: "x \<in> range q"
    show
     "(map (inv p) [x\<leftarrow>xs. x \<in> range p], {}) \<in> failures P \<and>
        (map (inv q) [x\<leftarrow>xs. x \<in> range q] @ [inv q x], {}) \<in> failures Q \<or>
      xs @ [x] \<in> con_comp_divergences P Q p q \<or>
      ?A \<or>
      xs \<in> con_comp_divergences P Q p q"
    proof (cases "(map (inv q) [x\<leftarrow>xs. x \<in> range q] @ [inv q x], {})
     \<in> failures Q")
      case True
      moreover have "{} \<subseteq> inv p ` X" ..
      with E have "(map (inv p) [x\<leftarrow>xs. x \<in> range p], {}) \<in> failures P"
       by (rule process_rule_3)
      ultimately show ?thesis
       by simp
    next
      case False
      have ?A
      proof (rule_tac x = "X" in exI, rule_tac x = "insert x Y" in exI,
       rule_tac x = "Z" in exI, (subst conj_assoc [symmetric])+, (rule conjI)+)
        show "insert x (X \<union> Y \<union> Z) = X \<union> insert x Y \<union> Z"
         by simp
      next
        show "X \<subseteq> range p"
         using A .
      next
        show "insert x Y \<subseteq> range q"
         using B and G by simp
      next
        show "Z \<subseteq> - range p"
         using C .
      next
        show "Z \<subseteq> - range q"
         using D .
      next
        show "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` X) \<in> failures P"
         using E .
      next
        have
         "(map (inv q) [x\<leftarrow>xs. x \<in> range q] @ [inv q x], {})
            \<in> failures Q \<or>
          (map (inv q) [x\<leftarrow>xs. x \<in> range q], insert (inv q x) (inv q ` Y))
            \<in> failures Q"
         using F by (rule process_rule_4)
        thus "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` insert x Y) \<in> failures Q"
         using False by simp
      qed
      thus ?thesis
       by simp
    qed
  next
    assume
      G: "x \<notin> range p" and
      H: "x \<notin> range q"
    have ?A
    proof (rule_tac x = "X" in exI, rule_tac x = "Y" in exI,
     rule_tac x = "insert x Z" in exI, (subst conj_assoc [symmetric])+,
     (rule conjI)+)
      show "insert x (X \<union> Y \<union> Z) = X \<union> Y \<union> insert x Z"
       by simp
    next
      show "X \<subseteq> range p"
       using A .
    next
      show "Y \<subseteq> range q"
       using B .
    next
      show "insert x Z \<subseteq> - range p"
       using C and G by simp
    next
      show "insert x Z \<subseteq> - range q"
       using D and H by simp
    next
      show "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` X) \<in> failures P"
       using E .
    next
      show "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` Y) \<in> failures Q"
       using F .
    qed
    thus
     "xs @ [x] \<in> con_comp_divergences P Q p q \<or>
      ?A \<or>
      xs \<in> con_comp_divergences P Q p q"
     by simp
  qed
qed

lemma con_comp_prop_5:
 "xs \<in> con_comp_divergences P Q p q \<Longrightarrow>
    xs @ [x] \<in> con_comp_divergences P Q p q"
proof (simp add: con_comp_divergences_def, erule exE, (erule conjE)+, erule exE)
  fix xs' ys'
  assume
    A: "set xs' \<subseteq> range p \<union> range q" and
    B: "map (inv p) [x\<leftarrow>xs'. x \<in> range p] \<in> divergences P" and
    C: "map (inv q) [x\<leftarrow>xs'. x \<in> range q] \<in> divergences Q" and
    D: "xs = xs' @ ys'"
  show "\<exists>xs'.
    (\<exists>ys'. xs @ [x] = xs' @ ys') \<and>
    set xs' \<subseteq> range p \<union> range q \<and>
    map (inv p) [x\<leftarrow>xs'. x \<in> range p] \<in> divergences P \<and>
    map (inv q) [x\<leftarrow>xs'. x \<in> range q] \<in> divergences Q"
  proof (rule_tac x = xs' in exI, simp_all add: A B C)
  qed (rule_tac x = "ys' @ [x]" in exI, simp add: D)
qed

lemma con_comp_prop_6:
 "xs \<in> con_comp_divergences P Q p q \<Longrightarrow>
    (xs, X) \<in> con_comp_failures P Q p q"
by (simp add: con_comp_failures_def)

lemma con_comp_rep:
 "Rep_process (P \<parallel> Q <p, q>) =
    (con_comp_failures P Q p q, con_comp_divergences P Q p q)"
  (is "_ = ?X")
proof (subst con_comp_def, rule Abs_process_inverse, simp add: process_set_def,
 (subst conj_assoc [symmetric])+, (rule conjI)+)
  show "process_prop_1 ?X"
  proof (simp add: process_prop_1_def)
  qed (rule con_comp_prop_1)
next
  show "process_prop_2 ?X"
  proof (simp add: process_prop_2_def del: all_simps, (rule allI)+, rule impI)
  qed (rule con_comp_prop_2)
next
  show "process_prop_3 ?X"
  proof (simp add: process_prop_3_def del: all_simps, (rule allI)+, rule impI,
   erule conjE)
  qed (rule con_comp_prop_3)
next
  show "process_prop_4 ?X"
  proof (simp add: process_prop_4_def, (rule allI)+, rule impI)
  qed (rule con_comp_prop_4)
next
  show "process_prop_5 ?X"
  proof (simp add: process_prop_5_def, rule allI, rule impI, rule allI)
  qed (rule con_comp_prop_5)
next
  show "process_prop_6 ?X"
  proof (simp add: process_prop_6_def, rule allI, rule impI, rule allI)
  qed (rule con_comp_prop_6)
qed


lemma con_comp_failures:
 "failures (P \<parallel> Q <p, q>) = con_comp_failures P Q p q"
by (simp add: failures_def con_comp_rep)

lemma con_comp_divergences:
 "divergences (P \<parallel> Q <p, q>) = con_comp_divergences P Q p q"
by (simp add: divergences_def con_comp_rep)

lemma con_comp_futures:
 "futures (P \<parallel> Q <p, q>) xs =
    {(ys, Y). (xs @ ys, Y) \<in> con_comp_failures P Q p q}"
by (simp add: futures_def con_comp_failures)

lemma con_comp_traces:
 "traces (P \<parallel> Q <p, q>) = Domain (con_comp_failures P Q p q)"
by (simp add: traces_def con_comp_failures)

lemma con_comp_refusals:
 "refusals (P \<parallel> Q <p, q>) xs \<equiv> con_comp_failures P Q p q `` {xs}"
by (simp add: refusals_def con_comp_failures)

lemma con_comp_next_events:
 "next_events (P \<parallel> Q <p, q>) xs =
    {x. xs @ [x] \<in> Domain (con_comp_failures P Q p q)}"
by (simp add: next_events_def con_comp_traces)


lemma con_comp_ref_union_closed:
  assumes
    A: "ref_union_closed P" and
    B: "ref_union_closed Q"
  shows "ref_union_closed (P \<parallel> Q <p, q>)"
proof (simp add: ref_union_closed_def con_comp_failures con_comp_failures_def
 con_comp_divergences_def del: SUP_identity_eq cong: SUP_cong_simp, (rule allI)+, (rule impI)+,
 erule exE, rule disjI1)
  fix xs A X
  assume "\<forall>X \<in> A. \<exists>R S T.
    X = R \<union> S \<union> T \<and>
    set xs \<subseteq> range p \<union> range q \<and>
    R \<subseteq> range p \<and>
    S \<subseteq> range q \<and>
    T \<subseteq> - range p \<and>
    T \<subseteq> - range q \<and>
    (map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` R) \<in> failures P \<and>
    (map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` S) \<in> failures Q"
    (is "\<forall>X \<in> A. \<exists>R S T. ?F X R S T")
  hence "\<exists>r. \<forall>X \<in> A. \<exists>S T. ?F X (r X) S T"
   by (rule bchoice)
  then obtain r where "\<forall>X \<in> A. \<exists>S T. ?F X (r X) S T" ..
  hence "\<exists>s. \<forall>X \<in> A. \<exists>T. ?F X (r X) (s X) T"
   by (rule bchoice)
  then obtain s where "\<forall>X \<in> A. \<exists>T. ?F X (r X) (s X) T" ..
  hence "\<exists>t. \<forall>X \<in> A. ?F X (r X) (s X) (t X)"
   by (rule bchoice)
  then obtain t where C: "\<forall>X \<in> A. ?F X (r X) (s X) (t X)" ..
  assume D: "X \<in> A"
  show "\<exists>R S T. ?F (\<Union>X \<in> A. X) R S T"
  proof (rule_tac x = "\<Union>X \<in> A. r X" in exI, rule_tac x = "\<Union>X \<in> A. s X" in exI,
   rule_tac x = "\<Union>X \<in> A. t X" in exI, (subst conj_assoc [symmetric])+,
   (rule conjI)+)
    show "(\<Union>X \<in> A. X) = (\<Union>X \<in> A. r X) \<union> (\<Union>X \<in> A. s X) \<union> (\<Union>X \<in> A. t X)"
    proof (simp add: set_eq_iff, rule allI, rule iffI, erule_tac [2] disjE,
     erule_tac [3] disjE, erule_tac [!] bexE)
      fix x X
      have "\<forall>X \<in> A. X = r X \<union> s X \<union> t X"
       using C by simp
      moreover assume E: "X \<in> A"
      ultimately have "X = r X \<union> s X \<union> t X" ..
      moreover assume "x \<in> X"
      ultimately have "x \<in> r X \<or> x \<in> s X \<or> x \<in> t X"
       by blast
      hence "\<exists>X \<in> A. x \<in> r X \<or> x \<in> s X \<or> x \<in> t X"
       using E ..
      thus "(\<exists>X \<in> A. x \<in> r X) \<or> (\<exists>X \<in> A. x \<in> s X) \<or> (\<exists>X \<in> A. x \<in> t X)"
       by blast
    next
      fix x X
      have "\<forall>X \<in> A. X = r X \<union> s X \<union> t X"
       using C by simp
      moreover assume E: "X \<in> A"
      ultimately have "X = r X \<union> s X \<union> t X" ..
      moreover assume "x \<in> r X"
      ultimately have "x \<in> X"
       by blast
      thus "\<exists>X \<in> A. x \<in> X"
       using E ..
    next
      fix x X
      have "\<forall>X \<in> A. X = r X \<union> s X \<union> t X"
       using C by simp
      moreover assume E: "X \<in> A"
      ultimately have "X = r X \<union> s X \<union> t X" ..
      moreover assume "x \<in> s X"
      ultimately have "x \<in> X"
       by blast
      thus "\<exists>X \<in> A. x \<in> X"
       using E ..
    next
      fix x X
      have "\<forall>X \<in> A. X = r X \<union> s X \<union> t X"
       using C by simp
      moreover assume E: "X \<in> A"
      ultimately have "X = r X \<union> s X \<union> t X" ..
      moreover assume "x \<in> t X"
      ultimately have "x \<in> X"
       by blast
      thus "\<exists>X \<in> A. x \<in> X"
       using E ..
    qed
  next
    have "\<forall>X \<in> A. set xs \<subseteq> range p \<union> range q"
     using C by simp
    thus "set xs \<subseteq> range p \<union> range q"
     using D ..
  next
    show "(\<Union>X \<in> A. r X) \<subseteq> range p"
    proof (rule subsetI, erule UN_E)
      fix x X
      have "\<forall>X \<in> A. r X \<subseteq> range p"
       using C by simp
      moreover assume "X \<in> A"
      ultimately have "r X \<subseteq> range p" ..
      moreover assume "x \<in> r X"
      ultimately show "x \<in> range p" ..
    qed
  next
    show "(\<Union>X \<in> A. s X) \<subseteq> range q"
    proof (rule subsetI, erule UN_E)
      fix x X
      have "\<forall>X \<in> A. s X \<subseteq> range q"
       using C by simp
      moreover assume "X \<in> A"
      ultimately have "s X \<subseteq> range q" ..
      moreover assume "x \<in> s X"
      ultimately show "x \<in> range q" ..
    qed
  next
    show "(\<Union>X \<in> A. t X) \<subseteq> - range p"
    proof (rule subsetI, erule UN_E)
      fix x X
      have "\<forall>X \<in> A. t X \<subseteq> - range p"
       using C by simp
      moreover assume "X \<in> A"
      ultimately have "t X \<subseteq> - range p" ..
      moreover assume "x \<in> t X"
      ultimately show "x \<in> - range p" ..
    qed
  next
    show "(\<Union>X \<in> A. t X) \<subseteq> - range q"
    proof (rule subsetI, erule UN_E)
      fix x X
      have "\<forall>X \<in> A. t X \<subseteq> - range q"
       using C by simp
      moreover assume "X \<in> A"
      ultimately have "t X \<subseteq> - range q" ..
      moreover assume "x \<in> t X"
      ultimately show "x \<in> - range q" ..
    qed
  next
    let ?A' = "{inv p ` X | X. X \<in> r ` A}"
    have
     "(\<exists>X. X \<in> ?A') \<longrightarrow>
      (\<forall>X \<in> ?A'. (map (inv p) [x\<leftarrow>xs. x \<in> range p], X) \<in> failures P) \<longrightarrow>
        (map (inv p) [x\<leftarrow>xs. x \<in> range p], \<Union>X \<in> ?A'. X) \<in> failures P"
     using A by (simp add: ref_union_closed_def)
    moreover have "\<exists>X. X \<in> ?A'"
     using D by blast
    ultimately have
     "(\<forall>X \<in> ?A'. (map (inv p) [x\<leftarrow>xs. x \<in> range p], X) \<in> failures P) \<longrightarrow>
        (map (inv p) [x\<leftarrow>xs. x \<in> range p], \<Union>X \<in> ?A'. X) \<in> failures P" ..
    moreover have
     "\<forall>X \<in> ?A'. (map (inv p) [x\<leftarrow>xs. x \<in> range p], X) \<in> failures P"
    proof (rule ballI, simp, erule exE, erule conjE)
      fix R R'
      assume "R \<in> r ` A"
      hence "\<exists>X \<in> A. R = r X"
       by (simp add: image_iff)
      then obtain X where E: "X \<in> A" and F: "R = r X" ..
      have "\<forall>X \<in> A. (map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` r X) \<in> failures P"
       using C by simp
      hence "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` r X) \<in> failures P"
       using E ..
      moreover assume "R' = inv p ` R"
      ultimately show "(map (inv p) [x\<leftarrow>xs. x \<in> range p], R') \<in> failures P"
       using F by simp
    qed
    ultimately have "(map (inv p) [x\<leftarrow>xs. x \<in> range p], \<Union>X \<in> ?A'. X)
      \<in> failures P" ..
    moreover have "(\<Union>X \<in> ?A'. X) = inv p ` (\<Union>X \<in> A. r X)"
    proof (subst set_eq_iff, simp, rule allI, rule iffI, (erule exE, erule conjE)+)
      fix a R R'
      assume "R \<in> r ` A"
      hence "\<exists>X \<in> A. R = r X"
       by (simp add: image_iff)
      then obtain X where E: "X \<in> A" and F: "R = r X" ..
      assume "a \<in> R'" and "R' = inv p ` R"
      hence "a \<in> inv p ` r X"
       using F by simp
      hence "\<exists>x \<in> r X. a = inv p x"
       by (simp add: image_iff)
      then obtain x where G: "x \<in> r X" and H: "a = inv p x" ..
      have "x \<in> (\<Union>X \<in> A. r X)"
       using E and G by (rule UN_I)
      with H have "\<exists>x \<in> (\<Union>X \<in> A. r X). a = inv p x" ..
      thus "a \<in> inv p ` (\<Union>X \<in> A. r X)"
       by (simp add: image_iff)
    next
      fix a
      assume "a \<in> inv p ` (\<Union>X \<in> A. r X)"
      hence "\<exists>x \<in> (\<Union>X \<in> A. r X). a = inv p x"
       by (simp add: image_iff)
      then obtain x where E: "x \<in> (\<Union>X \<in> A. r X)" and F: "a = inv p x" ..
      obtain X where G: "X \<in> A" and H: "x \<in> r X" using E ..
      show "\<exists>R'. (\<exists>R. R' = inv p ` R \<and> R \<in> r ` A) \<and> a \<in> R'"
      proof (rule_tac x = "inv p ` r X" in exI, rule conjI,
       rule_tac x = "r X" in exI)
      qed (rule_tac [2] image_eqI, simp add: G, simp add: F, simp add: H)
    qed
    ultimately show "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` (\<Union>X \<in> A. r X))
      \<in> failures P"
     by simp
  next
    let ?A' = "{inv q ` X | X. X \<in> s ` A}"
    have
     "(\<exists>X. X \<in> ?A') \<longrightarrow>
      (\<forall>X \<in> ?A'. (map (inv q) [x\<leftarrow>xs. x \<in> range q], X) \<in> failures Q) \<longrightarrow>
        (map (inv q) [x\<leftarrow>xs. x \<in> range q], \<Union>X \<in> ?A'. X) \<in> failures Q"
     using B by (simp add: ref_union_closed_def)
    moreover have "\<exists>X. X \<in> ?A'"
     using D by blast
    ultimately have
     "(\<forall>X \<in> ?A'. (map (inv q) [x\<leftarrow>xs. x \<in> range q], X) \<in> failures Q) \<longrightarrow>
        (map (inv q) [x\<leftarrow>xs. x \<in> range q], \<Union>X \<in> ?A'. X) \<in> failures Q" ..
    moreover have
     "\<forall>X \<in> ?A'. (map (inv q) [x\<leftarrow>xs. x \<in> range q], X) \<in> failures Q"
    proof (rule ballI, simp, erule exE, erule conjE)
      fix S S'
      assume "S \<in> s ` A"
      hence "\<exists>X \<in> A. S = s X"
       by (simp add: image_iff)
      then obtain X where E: "X \<in> A" and F: "S = s X" ..
      have "\<forall>X \<in> A. (map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` s X) \<in> failures Q"
       using C by simp
      hence "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` s X) \<in> failures Q"
       using E ..
      moreover assume "S' = inv q ` S"
      ultimately show "(map (inv q) [x\<leftarrow>xs. x \<in> range q], S') \<in> failures Q"
       using F by simp
    qed
    ultimately have "(map (inv q) [x\<leftarrow>xs. x \<in> range q], \<Union>X \<in> ?A'. X)
      \<in> failures Q" ..
    moreover have "(\<Union>X \<in> ?A'. X) = inv q ` (\<Union>X \<in> A. s X)"
    proof (subst set_eq_iff, simp, rule allI, rule iffI, (erule exE, erule conjE)+)
      fix b S S'
      assume "S \<in> s ` A"
      hence "\<exists>X \<in> A. S = s X"
       by (simp add: image_iff)
      then obtain X where E: "X \<in> A" and F: "S = s X" ..
      assume "b \<in> S'" and "S' = inv q ` S"
      hence "b \<in> inv q ` s X"
       using F by simp
      hence "\<exists>x \<in> s X. b = inv q x"
       by (simp add: image_iff)
      then obtain x where G: "x \<in> s X" and H: "b = inv q x" ..
      have "x \<in> (\<Union>X \<in> A. s X)"
       using E and G by (rule UN_I)
      with H have "\<exists>x \<in> (\<Union>X \<in> A. s X). b = inv q x" ..
      thus "b \<in> inv q ` (\<Union>X \<in> A. s X)"
       by (simp add: image_iff)
    next
      fix b
      assume "b \<in> inv q ` (\<Union>X \<in> A. s X)"
      hence "\<exists>x \<in> (\<Union>X \<in> A. s X). b = inv q x"
       by (simp add: image_iff)
      then obtain x where E: "x \<in> (\<Union>X \<in> A. s X)" and F: "b = inv q x" ..
      obtain X where G: "X \<in> A" and H: "x \<in> s X" using E ..
      show "\<exists>S'. (\<exists>S. S' = inv q ` S \<and> S \<in> s ` A) \<and> b \<in> S'"
      proof (rule_tac x = "inv q ` s X" in exI, rule conjI,
       rule_tac x = "s X" in exI)
      qed (rule_tac [2] image_eqI, simp add: G, simp add: F, simp add: H)
    qed
    ultimately show "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` (\<Union>X \<in> A. s X))
      \<in> failures Q"
     by simp
  qed
qed

lemma con_comp_failures_traces:
 "(xs, X) \<in> con_comp_failures P Q p q \<Longrightarrow>
    map (inv p) [x\<leftarrow>xs. x \<in> range p] \<in> traces P \<and>
    map (inv q) [x\<leftarrow>xs. x \<in> range q] \<in> traces Q"
proof (simp add: con_comp_failures_def con_comp_divergences_def, erule disjE,
 (erule exE)+, (erule conjE)+, erule_tac [2] exE, (erule_tac [2] conjE)+,
 erule_tac [2] exE)
  fix X Y
  assume "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` X) \<in> failures P"
  hence "map (inv p) [x\<leftarrow>xs. x \<in> range p] \<in> traces P"
   by (rule failures_traces)
  moreover assume "(map (inv q) [x\<leftarrow>xs. x \<in> range q], inv q ` Y) \<in> failures Q"
  hence "map (inv q) [x\<leftarrow>xs. x \<in> range q] \<in> traces Q"
   by (rule failures_traces)
  ultimately show ?thesis ..
next
  fix vs ws
  assume A: "xs = vs @ ws"
  assume "map (inv p) [x\<leftarrow>vs. x \<in> range p] \<in> divergences P"
  hence "map (inv p) [x\<leftarrow>vs. x \<in> range p] @ map (inv p) [x\<leftarrow>ws. x \<in> range p]
    \<in> divergences P"
   by (rule process_rule_5_general)
  hence "map (inv p) [x\<leftarrow>xs. x \<in> range p] \<in> divergences P"
   using A by simp
  hence "(map (inv p) [x\<leftarrow>xs. x \<in> range p], {}) \<in> failures P"
   by (rule process_rule_6)
  hence "map (inv p) [x\<leftarrow>xs. x \<in> range p] \<in> traces P"
   by (rule failures_traces)
  moreover assume "map (inv q) [x\<leftarrow>vs. x \<in> range q] \<in> divergences Q"
  hence "map (inv q) [x\<leftarrow>vs. x \<in> range q] @ map (inv q) [x\<leftarrow>ws. x \<in> range q]
    \<in> divergences Q"
   by (rule process_rule_5_general)
  hence "map (inv q) [x\<leftarrow>xs. x \<in> range q] \<in> divergences Q"
   using A by simp
  hence "(map (inv q) [x\<leftarrow>xs. x \<in> range q], {}) \<in> failures Q"
   by (rule process_rule_6)
  hence "map (inv q) [x\<leftarrow>xs. x \<in> range q] \<in> traces Q"
   by (rule failures_traces)
  ultimately show ?thesis ..
qed

lemma con_comp_failures_divergences:
 "(xs @ y # ys, Y) \<in> con_comp_failures P Q p q \<Longrightarrow>
  y \<notin> range p \<Longrightarrow>
  y \<notin> range q \<Longrightarrow>
    \<exists>xs'.
      (\<exists>ys'. xs @ zs = xs' @ ys') \<and>
      set xs' \<subseteq> range p \<union> range q \<and>
      map (inv p) [x\<leftarrow>xs'. x \<in> range p] \<in> divergences P \<and>
      map (inv q) [x\<leftarrow>xs'. x \<in> range q] \<in> divergences Q"
proof (simp add: con_comp_failures_def con_comp_divergences_def,
 erule exE, (erule conjE)+, erule exE)
  fix xs' ys'
  assume
    A: "y \<notin> range p" and
    B: "y \<notin> range q" and
    C: "set xs' \<subseteq> range p \<union> range q" and
    D: "map (inv p) [x\<leftarrow>xs'. x \<in> range p] \<in> divergences P" and
    E: "map (inv q) [x\<leftarrow>xs'. x \<in> range q] \<in> divergences Q" and
    F: "xs @ y # ys = xs' @ ys'"
  have "length xs' \<le> length xs"
  proof (rule ccontr)
    assume "\<not> length xs' \<le> length xs"
    moreover have "take (length xs') (xs @ [y] @ ys) =
      take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys"
      (is "_ = _ @ ?vs")
     by (simp only: take_append, simp)
    ultimately have "take (length xs') (xs @ y # ys) = xs @ y # ?vs"
     by simp
    moreover have "take (length xs') (xs @ y # ys) =
      take (length xs') (xs' @ ys')"
     using F by simp
    ultimately have "xs' = xs @ y # ?vs"
     by simp
    hence "set (xs @ y # ?vs) \<subseteq> range p \<union> range q"
     using C by simp
    hence "y \<in> range p \<union> range q"
     by simp
    thus False
     using A and B by simp
  qed
  moreover have "xs @ zs =
    take (length xs') (xs @ zs) @ drop (length xs') (xs @ zs)"
    (is "_ = _ @ ?vs")
   by (simp only: append_take_drop_id)
  ultimately have "xs @ zs = take (length xs') (xs @ y # ys) @ ?vs"
   by simp
  moreover have "take (length xs') (xs @ y # ys) =
    take (length xs') (xs' @ ys')"
   using F by simp
  ultimately have G: "xs @ zs = xs' @ ?vs"
   by (simp del: take_append, simp)
  show ?thesis
  proof (rule_tac x = xs' in exI, rule conjI, rule_tac x = ?vs in exI)
  qed (subst G, simp_all add: C D E)
qed


definition con_comp_pol ::
 "('d \<times> 'd) set \<Rightarrow> ('d option \<times> 'd option) set" where
"con_comp_pol I \<equiv>
  {(Some d, Some e) | d e. (d, e) \<in> I} \<union> {(u, v). v = None}"

function con_comp_map ::
 "('a \<Rightarrow> 'd) \<Rightarrow> ('b \<Rightarrow> 'd) \<Rightarrow> ('a \<Rightarrow> 'c) \<Rightarrow> ('b \<Rightarrow> 'c) \<Rightarrow> 'c \<Rightarrow> 'd option" where
"x \<in> range p \<Longrightarrow>
  con_comp_map D E p q x = Some (D (inv p x))" |
"x \<notin> range p \<Longrightarrow> x \<in> range q \<Longrightarrow>
  con_comp_map D E p q x = Some (E (inv q x))" |
"x \<notin> range p \<Longrightarrow> x \<notin> range q \<Longrightarrow>
  con_comp_map D E p q x = None"
by (atomize_elim, simp_all add: split_paired_all, blast)
termination by lexicographic_order

definition consistent_maps ::
 "('a \<Rightarrow> 'd) \<Rightarrow> ('b \<Rightarrow> 'd) \<Rightarrow> ('a \<Rightarrow> 'c) \<Rightarrow> ('b \<Rightarrow> 'c) \<Rightarrow> bool" where
"consistent_maps D E p q \<equiv>
  \<forall>x \<in> range p \<inter> range q. D (inv p x) = E (inv q x)"


subsection "Auxiliary intransitive purge functions"


primrec ipurge_tr_aux_foldr ::
 "('d \<times> 'd) set \<Rightarrow> ('a \<Rightarrow> 'd) \<Rightarrow> ('a \<Rightarrow> bool) \<Rightarrow> 'd set \<Rightarrow> 'a list \<Rightarrow> 'a list"
where
"ipurge_tr_aux_foldr I D P U [] = []" |
"ipurge_tr_aux_foldr I D P U (x # xs) = ipurge_tr_aux I D U
   ((if P x then [x] else []) @
     ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)"


primrec ipurge_ref_aux_foldr ::
 "('d \<times> 'd) set \<Rightarrow> ('a \<Rightarrow> 'd) \<Rightarrow> ('a \<Rightarrow> bool) \<Rightarrow> 'd set \<Rightarrow> 'a list \<Rightarrow> 'a set \<Rightarrow> 'a set"
where
"ipurge_ref_aux_foldr I D P U [] X = ipurge_ref_aux I D U [] X" |
"ipurge_ref_aux_foldr I D P U (x # xs) X = ipurge_ref_aux I D U
   ((if P x then [x] else []) @
     ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)
   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)"


lemma ipurge_tr_aux_foldr_subset:
 "U \<subseteq> V \<Longrightarrow>
  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P V xs) =
    ipurge_tr_aux_foldr I D P V xs"
proof (induction xs, simp_all add: ipurge_tr_aux_union [symmetric])
qed (drule Un_absorb2, simp)

lemma ipurge_tr_aux_foldr_eq:
 "[x\<leftarrow>ipurge_tr_aux I D U xs. P x] = ipurge_tr_aux_foldr I D P U xs"
proof (induction xs arbitrary: U, simp)
  fix x xs U
  assume
    A: "\<And>U. [x\<leftarrow>ipurge_tr_aux I D U xs. P x] = ipurge_tr_aux_foldr I D P U xs"
  show "[x\<leftarrow>ipurge_tr_aux I D U (x # xs). P x] =
    ipurge_tr_aux_foldr I D P U (x # xs)"
  proof (cases "\<exists>u \<in> U. (u, D x) \<in> I",
   simp_all only: ipurge_tr_aux_foldr.simps ipurge_tr_aux_cons
   sinks_aux_single_event if_True if_False)
    case True
    have B: "[x\<leftarrow>ipurge_tr_aux I D (insert (D x) U) xs. P x] =
      ipurge_tr_aux_foldr I D P (insert (D x) U) xs"
     using A .
    show "[x\<leftarrow>ipurge_tr_aux I D (insert (D x) U) xs. P x] = ipurge_tr_aux I D U
      ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P (insert (D x) U) xs)"
    proof (cases "P x", simp_all add: ipurge_tr_aux_cons True
     del: con_comp_map.simps)
      have "insert (D x) U \<subseteq> insert (D x) U" ..
      hence "ipurge_tr_aux I D (insert (D x) U)
        (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =
          ipurge_tr_aux_foldr I D P (insert (D x) U) xs"
       by (rule ipurge_tr_aux_foldr_subset)
      thus "[x\<leftarrow>ipurge_tr_aux I D (insert (D x) U) xs. P x] =
        ipurge_tr_aux I D (insert (D x) U)
          (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)"
       using B by simp
    next
      have "U \<subseteq> insert (D x) U"
       by (rule subset_insertI)
      hence "ipurge_tr_aux I D U
        (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =
          ipurge_tr_aux_foldr I D P (insert (D x) U) xs"
       by (rule ipurge_tr_aux_foldr_subset)
      thus "[x\<leftarrow>ipurge_tr_aux I D (insert (D x) U) xs. P x] =
        ipurge_tr_aux I D U
          (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)"
       using B by simp
    qed
  next
    case False
    have B: "[x\<leftarrow>ipurge_tr_aux I D U xs. P x] = ipurge_tr_aux_foldr I D P U xs"
     using A .
    show "[x\<leftarrow>x # ipurge_tr_aux I D U xs. P x] = ipurge_tr_aux I D U
      ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P U xs)"
    proof (cases "P x", simp_all add: ipurge_tr_aux_cons False
     del: con_comp_map.simps)
      have "U \<subseteq> U" ..
      hence "ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =
        ipurge_tr_aux_foldr I D P U xs"
       by (rule ipurge_tr_aux_foldr_subset)
      thus "[x\<leftarrow>ipurge_tr_aux I D U xs. P x] =
        ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)"
       using B by simp
    next
      have "U \<subseteq> U" ..
      hence "ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =
        ipurge_tr_aux_foldr I D P U xs"
       by (rule ipurge_tr_aux_foldr_subset)
      thus "[x\<leftarrow>ipurge_tr_aux I D U xs. P x] =
        ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)"
       using B by simp
    qed
  qed
qed


lemma ipurge_tr_aux_foldr_sinks_aux [rule_format]:
 "U \<subseteq> V \<longrightarrow> sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U"
proof (induction xs arbitrary: V, simp, rule impI)
  fix x xs V
  assume
    A: "\<And>V. U \<subseteq> V \<longrightarrow> sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U" and
    B: "U \<subseteq> V"
  show "sinks_aux I D U (ipurge_tr_aux_foldr I D P V (x # xs)) = U"
  proof (cases "P x", case_tac [!] "\<exists>v \<in> V. (v, D x) \<in> I",
   simp_all (no_asm_simp) add: sinks_aux_cons ipurge_tr_aux_cons)
    have "U \<subseteq> insert (D x) V \<longrightarrow>
      sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U"
      (is "_ \<longrightarrow> sinks_aux I D U ?ys = U")
     using A .
    moreover have "U \<subseteq> insert (D x) V"
     using B by (rule subset_insertI2)
    ultimately have "sinks_aux I D U ?ys = U" ..
    moreover have "insert (D x) V \<subseteq> insert (D x) V" ..
    hence "ipurge_tr_aux I D (insert (D x) V)
      (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = ?ys"
      (is "?zs = _")
     by (rule ipurge_tr_aux_foldr_subset)
    ultimately show "sinks_aux I D U ?zs = U"
     by simp
  next
    assume C: "\<not> (\<exists>v \<in> V. (v, D x) \<in> I)"
    have "\<not> (\<exists>u \<in> U. (u, D x) \<in> I)"
    proof
      assume "\<exists>u \<in> U. (u, D x) \<in> I"
      then obtain u where D: "u \<in> U" and E: "(u, D x) \<in> I" ..
      have "u \<in> V"
       using B and D ..
      with E have "\<exists>v \<in> V. (v, D x) \<in> I" ..
      thus False
       using C by contradiction
    qed
    thus
     "((\<exists>v \<in> U. (v, D x) \<in> I) \<longrightarrow> sinks_aux I D (insert (D x) U)
        (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) = U) \<and>
      ((\<forall>v \<in> U. (v, D x) \<notin> I) \<longrightarrow> sinks_aux I D U
        (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) = U)"
    proof simp
      have "U \<subseteq> V \<longrightarrow> sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U"
        (is "_ \<longrightarrow> sinks_aux I D U ?ys = U")
       using A .
      hence "sinks_aux I D U ?ys = U" using B ..
      moreover have "V \<subseteq> V" ..
      hence "ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) = ?ys"
        (is "?zs = _")
       by (rule ipurge_tr_aux_foldr_subset)
      ultimately show "sinks_aux I D U ?zs = U"
       by simp
    qed
  next
    have "U \<subseteq> insert (D x) V \<longrightarrow>
      sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U"
      (is "_ \<longrightarrow> sinks_aux I D U ?ys = U")
     using A .
    moreover have "U \<subseteq> insert (D x) V"
     using B by (rule subset_insertI2)
    ultimately have "sinks_aux I D U ?ys = U" ..
    moreover have "V \<subseteq> insert (D x) V"
     by (rule subset_insertI)
    hence "ipurge_tr_aux I D V
      (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = ?ys"
      (is "?zs = _")
     by (rule ipurge_tr_aux_foldr_subset)
    ultimately show "sinks_aux I D U ?zs = U"
     by simp
  next
    have "U \<subseteq> V \<longrightarrow> sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U"
      (is "_ \<longrightarrow> sinks_aux I D U ?ys = U")
     using A .
    hence "sinks_aux I D U ?ys = U" using B ..
    moreover have "V \<subseteq> V" ..
    hence "ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) = ?ys"
      (is "?zs = _")
     by (rule ipurge_tr_aux_foldr_subset)
    ultimately show "sinks_aux I D U ?zs = U"
     by simp
  qed
qed

lemma ipurge_tr_aux_foldr_ref_aux:
  assumes A: "U \<subseteq> V"
  shows "ipurge_ref_aux I D U (ipurge_tr_aux_foldr I D P V xs) X =
    ipurge_ref_aux I D U [] X"
by (simp add: ipurge_ref_aux_def ipurge_tr_aux_foldr_sinks_aux [OF A])

lemma ipurge_ref_aux_foldr_subset [rule_format]:
 "sinks_aux I D U ys \<subseteq> V \<longrightarrow>
  ipurge_ref_aux I D U ys (ipurge_ref_aux_foldr I D P V xs X) =
    ipurge_ref_aux_foldr I D P V xs X"
proof (induction xs arbitrary: ys U V, rule_tac [!] impI,
 simp add: ipurge_ref_aux_def, blast)
  fix x xs ys U V
  assume
    A: "\<And>ys U V.
      sinks_aux I D U ys \<subseteq> V \<longrightarrow>
      ipurge_ref_aux I D U ys (ipurge_ref_aux_foldr I D P V xs X) =
        ipurge_ref_aux_foldr I D P V xs X" and
    B: "sinks_aux I D U ys \<subseteq> V"
  show "ipurge_ref_aux I D U ys (ipurge_ref_aux_foldr I D P V (x # xs) X) =
    ipurge_ref_aux_foldr I D P V (x # xs) X"
  proof (cases "P x", simp_all add: ipurge_ref_aux_cons)
    have C: "sinks_aux I D V [x] \<subseteq> sinks_aux I D V [x]" ..
    show
     "ipurge_ref_aux I D U ys (ipurge_ref_aux I D (sinks_aux I D V [x])
        (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)
        (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =
      ipurge_ref_aux I D (sinks_aux I D V [x])
        (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)
        (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)"
    proof (simp add: ipurge_tr_aux_foldr_ref_aux [OF C])
      have "sinks_aux I D (sinks_aux I D V [x]) [] \<subseteq> sinks_aux I D V [x] \<longrightarrow>
        ipurge_ref_aux I D (sinks_aux I D V [x]) []
          (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =
        ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X"
        (is "?A \<longrightarrow> ?us = ?vs")
       using A .
      moreover have ?A
       by simp
      ultimately have "?us = ?vs" ..
      thus "ipurge_ref_aux I D U ys ?us = ?us"
      proof simp
        have "sinks_aux I D U ys \<subseteq> sinks_aux I D V [x] \<longrightarrow>
          ipurge_ref_aux I D U ys
            (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =
          ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X"
          (is "_ \<longrightarrow> ?T")
         using A .
        moreover have "V \<subseteq> sinks_aux I D V [x]"
         by (rule sinks_aux_subset)
        hence "sinks_aux I D U ys \<subseteq> sinks_aux I D V [x]"
         using B by simp
        ultimately show ?T ..
      qed
    qed
  next
    have C: "V \<subseteq> sinks_aux I D V [x]"
     by (rule sinks_aux_subset)
    show
     "ipurge_ref_aux I D U ys (ipurge_ref_aux I D V
        (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)
        (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =
      ipurge_ref_aux I D V
        (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)
        (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)"
    proof (simp add: ipurge_tr_aux_foldr_ref_aux [OF C])
      have "sinks_aux I D V [] \<subseteq> sinks_aux I D V [x] \<longrightarrow>
        ipurge_ref_aux I D V []
          (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =
        ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X"
        (is "?A \<longrightarrow> ?us = ?vs")
       using A .
      moreover have ?A
       using C by simp
      ultimately have "?us = ?vs" ..
      thus "ipurge_ref_aux I D U ys ?us = ?us"
      proof simp
        have "sinks_aux I D U ys \<subseteq> sinks_aux I D V [x] \<longrightarrow>
          ipurge_ref_aux I D U ys
            (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =
          ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X"
          (is "_ \<longrightarrow> ?T")
         using A .
        moreover have "sinks_aux I D U ys \<subseteq> sinks_aux I D V [x]"
         using B and C by simp
        ultimately show ?T ..
      qed
    qed
  qed
qed

lemma ipurge_ref_aux_foldr_eq:
 "ipurge_ref_aux I D U xs X = ipurge_ref_aux_foldr I D P U xs X"
proof (induction xs arbitrary: U, simp)
  fix x xs U
  assume A: "\<And>U. ipurge_ref_aux I D U xs X = ipurge_ref_aux_foldr I D P U xs X"
  show "ipurge_ref_aux I D U (x # xs) X =
    ipurge_ref_aux_foldr I D P U (x # xs) X"
  proof (cases "P x", simp_all add: ipurge_ref_aux_cons)
    have "sinks_aux I D U [x] \<subseteq> sinks_aux I D U [x]" ..
    hence
     "ipurge_ref_aux I D (sinks_aux I D U [x])
        (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)
        (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =
      ipurge_ref_aux I D (sinks_aux I D U [x]) []
        (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)"
      (is "ipurge_ref_aux _ _ _ ?xs' ?X' = _")
     by (rule ipurge_tr_aux_foldr_ref_aux)
    also have "sinks_aux I D (sinks_aux I D U [x]) [] \<subseteq> sinks_aux I D U [x]"
     by simp
    hence "ipurge_ref_aux I D (sinks_aux I D U [x]) [] ?X' = ?X'"
     by (rule ipurge_ref_aux_foldr_subset)
    finally have "ipurge_ref_aux I D (sinks_aux I D U [x]) ?xs' ?X' = ?X'" .
    thus "ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =
      ipurge_ref_aux I D (sinks_aux I D U [x]) ?xs' ?X'"
    proof simp
      show "ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =
        ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X"
       using A .
    qed
  next
    have "U \<subseteq> sinks_aux I D U [x]"
     by (rule sinks_aux_subset)
    hence
     "ipurge_ref_aux I D U
        (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)
        (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =
      ipurge_ref_aux I D U []
        (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)"
      (is "ipurge_ref_aux _ _ _ ?xs' ?X' = _")
     by (rule ipurge_tr_aux_foldr_ref_aux)
    also have "sinks_aux I D U [] \<subseteq> sinks_aux I D U [x]"
     by (simp, rule sinks_aux_subset)
    hence "ipurge_ref_aux I D U [] ?X' = ?X'"
     by (rule ipurge_ref_aux_foldr_subset)
    finally have "ipurge_ref_aux I D U ?xs' ?X' = ?X'" .
    thus "ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =
      ipurge_ref_aux I D U ?xs' ?X'"
    proof simp
      show "ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =
        ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X"
       using A .
    qed
  qed
qed


lemma con_comp_sinks_aux_range:
  assumes
    A: "U \<subseteq> range Some" and
    B: "set xs \<subseteq> range p \<union> range q"
  shows "sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs \<subseteq> range Some"
    (is "sinks_aux _ ?D' _ _ \<subseteq> _")
proof (rule subsetI, drule sinks_aux_elem, erule disjE, erule_tac [2] bexE)
  fix u
  assume "u \<in> U"
  with A show "u \<in> range Some" ..
next
  fix u x
  assume "x \<in> set xs"
  with B have "x \<in> range p \<union> range q" ..
  hence "?D' x \<in> range Some"
   by (cases "x \<in> range p", simp_all)
  moreover assume "u = ?D' x"
  ultimately show "u \<in> range Some"
   by simp
qed

lemma con_comp_sinks_aux [rule_format]:
  assumes A: "U \<subseteq> range Some"
  shows "set xs \<subseteq> range p \<longrightarrow>
    sinks_aux I D (the ` U) (map (inv p) xs) =
    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs"
    (is "_ \<longrightarrow> _ = the ` sinks_aux ?I' ?D' _ _")
proof (induction xs rule: rev_induct, simp, rule impI)
  fix x xs
  assume "set xs \<subseteq> range p \<longrightarrow>
    sinks_aux I D (the ` U) (map (inv p) xs) =
    the ` sinks_aux ?I' ?D' U xs"
  moreover assume B: "set (xs @ [x]) \<subseteq> range p"
  ultimately have C: "sinks_aux I D (the ` U) (map (inv p) xs) =
    the ` sinks_aux ?I' ?D' U xs"
   by simp
  show "sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =
    the ` sinks_aux ?I' ?D' U (xs @ [x])"
  proof (cases "\<exists>u \<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \<in> ?I'",
   simp_all (no_asm_simp) del: map_append)
    case True
    then obtain u where
      D: "u \<in> sinks_aux ?I' ?D' U xs" and E: "(u, ?D' x) \<in> ?I'" ..
    have "(the u, D (inv p x)) \<in> I"
     using B and E by (simp add: con_comp_pol_def, erule_tac exE, simp)
    moreover have "the u \<in> the ` sinks_aux ?I' ?D' U xs"
     using D by simp
    hence "the u \<in> sinks_aux I D (the ` U) (map (inv p) xs)"
     using C by simp
    ultimately have "\<exists>d \<in> sinks_aux I D (the ` U) (map (inv p) xs).
      (d, D (inv p x)) \<in> I" ..
    hence "sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =
      insert (D (inv p x)) (sinks_aux I D (the ` U) (map (inv p) xs))"
     by simp
    thus "sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =
      insert (the (?D' x)) (the ` sinks_aux ?I' ?D' U xs)"
     using B and C by simp
  next
    case False
    have "\<not> (\<exists>d \<in> sinks_aux I D (the ` U) (map (inv p) xs).
      (d, D (inv p x)) \<in> I)"
    proof (rule notI, erule bexE)
      fix d
      assume "d \<in> sinks_aux I D (the ` U) (map (inv p) xs)"
      hence "d \<in> the ` sinks_aux ?I' ?D' U xs"
       using C by simp
      hence "\<exists>u \<in> sinks_aux ?I' ?D' U xs. d = the u"
       by (simp add: image_iff)
      then obtain u where
        D: "u \<in> sinks_aux ?I' ?D' U xs" and E: "d = the u" ..
      have "set xs \<subseteq> range p \<union> range q"
       using B by (simp, blast)
      with A have "sinks_aux ?I' ?D' U xs \<subseteq> range Some"
       by (rule con_comp_sinks_aux_range)
      hence "u \<in> range Some"
       using D ..
      hence "u = Some d"
       using E by (simp add: image_iff)
      moreover assume "(d, D (inv p x)) \<in> I"
      hence "(Some d, Some (D (inv p x))) \<in> ?I'"
       by (simp add: con_comp_pol_def)
      ultimately have "(u, ?D' x) \<in> ?I'"
       using B by simp
      hence "\<exists>u \<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \<in> ?I'"
       using D ..
      thus False
       using False by contradiction
    qed
    thus "sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =
      the ` sinks_aux ?I' ?D' U xs"
     using C by simp
  qed
qed

lemma con_comp_ipurge_tr_aux [rule_format]:
  assumes A: "U \<subseteq> range Some"
  shows "set xs \<subseteq> range p \<longrightarrow>
    ipurge_tr_aux I D (the ` U) (map (inv p) xs) =
    map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)"
    (is "_ \<longrightarrow> _ = map (inv p) (ipurge_tr_aux ?I' ?D' _ _)")
proof (induction xs rule: rev_induct, simp, rule impI)
  fix x xs
  assume "set xs \<subseteq> range p \<longrightarrow>
    ipurge_tr_aux I D (the ` U) (map (inv p) xs) =
    map (inv p) (ipurge_tr_aux ?I' ?D' U xs)"
  moreover assume B: "set (xs @ [x]) \<subseteq> range p"
  ultimately have C: "ipurge_tr_aux I D (the ` U) (map (inv p) xs) =
    map (inv p) (ipurge_tr_aux ?I' ?D' U xs)"
   by simp
  show "ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =
    map (inv p) (ipurge_tr_aux ?I' ?D' U (xs @ [x]))"
  proof (cases "\<exists>u \<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \<in> ?I'")
    case True
    then obtain u where
      D: "u \<in> sinks_aux ?I' ?D' U xs" and E: "(u, ?D' x) \<in> ?I'" ..
    have "(the u, D (inv p x)) \<in> I"
     using B and E by (simp add: con_comp_pol_def, erule_tac exE, simp)
    moreover have F: "the u \<in> the ` sinks_aux ?I' ?D' U xs"
     using D by simp
    have "set xs \<subseteq> range p"
     using B by simp
    with A have "sinks_aux I D (the ` U) (map (inv p) xs) =
      the ` sinks_aux ?I' ?D' U xs"
     by (rule con_comp_sinks_aux)
    hence "the u \<in> sinks_aux I D (the ` U) (map (inv p) xs)"
     using F by simp
    ultimately have "\<exists>d \<in> sinks_aux I D (the ` U) (map (inv p) xs).
      (d, D (inv p x)) \<in> I" ..
    hence "ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =
      ipurge_tr_aux I D (the ` U) (map (inv p) xs)"
     by simp
    moreover have "map (inv p) (ipurge_tr_aux ?I' ?D' U (xs @ [x])) =
      map (inv p) (ipurge_tr_aux ?I' ?D' U xs)"
     using True by simp
    ultimately show ?thesis
     using C by simp
  next
    case False
    have "\<not> (\<exists>d \<in> sinks_aux I D (the ` U) (map (inv p) xs).
      (d, D (inv p x)) \<in> I)"
    proof (rule notI, erule bexE)
      fix d
      assume "d \<in> sinks_aux I D (the ` U) (map (inv p) xs)"
      moreover have "set xs \<subseteq> range p"
       using B by simp
      with A have "sinks_aux I D (the ` U) (map (inv p) xs) =
        the ` sinks_aux ?I' ?D' U xs"
       by (rule con_comp_sinks_aux)
      ultimately have "d \<in> the ` sinks_aux ?I' ?D' U xs"
       by simp
      hence "\<exists>u \<in> sinks_aux ?I' ?D' U xs. d = the u"
       by (simp add: image_iff)
      then obtain u where
        D: "u \<in> sinks_aux ?I' ?D' U xs" and E: "d = the u" ..
      have "set xs \<subseteq> range p \<union> range q"
       using B by (simp, blast)
      with A have "sinks_aux ?I' ?D' U xs \<subseteq> range Some"
       by (rule con_comp_sinks_aux_range)
      hence "u \<in> range Some"
       using D ..
      hence "u = Some d"
       using E by (simp add: image_iff)
      moreover assume "(d, D (inv p x)) \<in> I"
      hence "(Some d, Some (D (inv p x))) \<in> ?I'"
       by (simp add: con_comp_pol_def)
      ultimately have "(u, ?D' x) \<in> ?I'"
       using B by simp
      hence "\<exists>u \<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \<in> ?I'"
       using D ..
      thus False
       using False by contradiction
    qed
    hence "ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =
      ipurge_tr_aux I D (the ` U) (map (inv p) xs) @ [inv p x]"
     by simp
    moreover have "map (inv p) (ipurge_tr_aux ?I' ?D' U (xs @ [x])) =
      map (inv p) (ipurge_tr_aux ?I' ?D' U xs) @ [inv p x]"
     using False by simp
    ultimately show ?thesis
     using C by simp
  qed
qed

lemma con_comp_ipurge_ref_aux:
  assumes
    A: "U \<subseteq> range Some" and
    B: "set xs \<subseteq> range p" and
    C: "X \<subseteq> range p"
  shows "ipurge_ref_aux I D (the ` U) (map (inv p) xs) (inv p ` X) =
    inv p ` ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U xs X"
  (is "_ = inv p ` ipurge_ref_aux ?I' ?D' _ _ _")
proof (simp add: ipurge_ref_aux_def set_eq_iff image_iff, rule allI, rule iffI,
 erule conjE, erule bexE, erule_tac [2] exE, (erule_tac [2] conjE)+)
  fix a x
  assume
    D: "x \<in> X" and
    E: "a = inv p x" and
    F: "\<forall>d \<in> sinks_aux I D (the ` U) (map (inv p) xs). (d, D a) \<notin> I"
  show "\<exists>x. x \<in> X \<and> (\<forall>u \<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \<notin> ?I') \<and>
    a = inv p x"
  proof (rule_tac x = x in exI, simp add: D E, rule ballI)
    fix u
    assume G: "u \<in> sinks_aux ?I' ?D' U xs"
    moreover have "sinks_aux I D (the ` U) (map (inv p) xs) =
      the ` sinks_aux ?I' ?D' U xs"
     using A and B by (rule con_comp_sinks_aux)
    ultimately have "the u \<in> sinks_aux I D (the ` U) (map (inv p) xs)"
     by simp
    with F have "(the u, D a) \<notin> I" ..
    moreover have "set xs \<subseteq> range p \<union> range q"
     using B by blast
    with A have "sinks_aux ?I' ?D' U xs \<subseteq> range Some"
     by (rule con_comp_sinks_aux_range)
    hence "u \<in> range Some"
     using G ..
    hence "\<exists>d. u = Some d"
     by (simp add: image_iff)
    then obtain d where H: "u = Some d" ..
    ultimately have "(d, D (inv p x)) \<notin> I"
     using E by simp
    hence "(u, Some (D (inv p x))) \<notin> ?I'"
     using H by (simp add: con_comp_pol_def)
    moreover have "x \<in> range p"
     using C and D ..
    ultimately show "(u, ?D' x) \<notin> ?I'"
     by simp
  qed
next
  fix a x
  assume
    D: "x \<in> X" and
    E: "a = inv p x" and
    F: "\<forall>u \<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \<notin> ?I'"
  show "(\<exists>x \<in> X. a = inv p x) \<and>
    (\<forall>u \<in> sinks_aux I D (the ` U) (map (inv p) xs). (u, D a) \<notin> I)"
  proof (rule conjI, rule_tac [2] ballI)
    show "\<exists>x \<in> X. a = inv p x"
     using E and D ..
  next
    fix d
    assume "d \<in> sinks_aux I D (the ` U) (map (inv p) xs)"
    moreover have "sinks_aux I D (the ` U) (map (inv p) xs) =
      the ` sinks_aux ?I' ?D' U xs"
     using A and B by (rule con_comp_sinks_aux)
    ultimately have "d \<in> the ` sinks_aux ?I' ?D' U xs"
     by simp
    hence "\<exists>u \<in> sinks_aux ?I' ?D' U xs. d = the u"
     by (simp add: image_iff)
    then obtain u where G: "u \<in> sinks_aux ?I' ?D' U xs" and H: "d = the u" ..
    have "(u, ?D' x) \<notin> ?I'"
     using F and G ..
    moreover have "set xs \<subseteq> range p \<union> range q"
     using B by blast
    with A have "sinks_aux ?I' ?D' U xs \<subseteq> range Some"
     by (rule con_comp_sinks_aux_range)
    hence "u \<in> range Some"
     using G ..
    hence "u = Some d"
     using H by (simp add: image_iff)
    moreover have "x \<in> range p"
     using C and D ..
    ultimately have "(d, D (inv p x)) \<notin> I"
     by (simp add: con_comp_pol_def)
    thus "(d, D a) \<notin> I"
     using E by simp
  qed
qed

lemma con_comp_sinks_filter:
 "sinks (con_comp_pol I) (con_comp_map D E p q) u
    [x\<leftarrow>xs. x \<in> range p \<union> range q] =
  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \<inter> range Some"
  (is "sinks ?I' ?D' _ _ = _")
proof (induction xs rule: rev_induct, simp)
  fix x xs
  assume A: "sinks ?I' ?D' u [x\<leftarrow>xs. x \<in> range p \<union> range q] =
    sinks ?I' ?D' u xs \<inter> range Some"
    (is "sinks _ _ _ ?xs' = _")
  show "sinks ?I' ?D' u [x\<leftarrow>xs @ [x]. x \<in> range p \<union> range q] =
    sinks ?I' ?D' u (xs @ [x]) \<inter> range Some"
  proof (cases "x \<in> range p \<union> range q", simp_all del: Un_iff sinks.simps,
   cases "(u, ?D' x) \<in> ?I' \<or> (\<exists>v \<in> sinks ?I' ?D' u ?xs'. (v, ?D' x) \<in> ?I')")
    assume
      B: "x \<in> range p \<union> range q" and
      C: "(u, ?D' x) \<in> ?I' \<or> (\<exists>v \<in> sinks ?I' ?D' u ?xs'. (v, ?D' x) \<in> ?I')"
    have "sinks ?I' ?D' u (?xs' @ [x]) =
      insert (?D' x) (sinks ?I' ?D' u ?xs')"
     using C by simp
    also have "\<dots> =
      insert (?D' x) (sinks ?I' ?D' u xs \<inter> range Some)"
     using A by simp
    also have "\<dots> =
      insert (?D' x) (sinks ?I' ?D' u xs) \<inter> insert (?D' x) (range Some)"
     by simp
    finally have "sinks ?I' ?D' u (?xs' @ [x]) =
      insert (?D' x) (sinks ?I' ?D' u xs) \<inter> insert (?D' x) (range Some)" .
    moreover have "insert (?D' x) (range Some) = range Some"
     using B by (rule_tac insert_absorb, cases "x \<in> range p", simp_all)
    ultimately have "sinks ?I' ?D' u (?xs' @ [x]) =
      insert (?D' x) (sinks ?I' ?D' u xs) \<inter> range Some"
     by simp
    moreover have "(u, ?D' x) \<in> ?I' \<or>
      (\<exists>v \<in> sinks ?I' ?D' u xs. (v, ?D' x) \<in> ?I')"
     using A and C by (simp, blast)
    ultimately show "sinks ?I' ?D' u (?xs' @ [x]) =
      sinks ?I' ?D' u (xs @ [x]) \<inter> range Some"
     by simp
  next
    assume
      B: "x \<in> range p \<union> range q" and
      C: "\<not> ((u, ?D' x) \<in> ?I' \<or> (\<exists>v \<in> sinks ?I' ?D' u ?xs'. (v, ?D' x) \<in> ?I'))"
    have "sinks ?I' ?D' u (?xs' @ [x]) = sinks ?I' ?D' u ?xs'"
     using C by simp
    hence "sinks ?I' ?D' u (?xs' @ [x]) = sinks ?I' ?D' u xs \<inter> range Some"
     using A by simp
    moreover from C have
     "\<not> ((u, ?D' x) \<in> ?I' \<or> (\<exists>v \<in> sinks ?I' ?D' u xs. (v, ?D' x) \<in> ?I'))"
    proof (rule_tac notI, simp del: bex_simps)
      assume "\<exists>v \<in> sinks ?I' ?D' u xs. (v, ?D' x) \<in> ?I'"
      then obtain v where E: "v \<in> sinks ?I' ?D' u xs" and F: "(v, ?D' x) \<in> ?I'" ..
      have "\<exists>d. ?D' x = Some d"
       using B by (cases "x \<in> range p", simp_all)
      then obtain d where "?D' x = Some d" ..
      hence "(v, Some d) \<in> ?I'"
       using F by simp
      hence "v \<in> range Some"
       by (cases v, simp_all add: con_comp_pol_def)
      with E have "v \<in> sinks ?I' ?D' u xs \<inter> range Some" ..
      hence "v \<in> sinks ?I' ?D' u ?xs'"
       using A by simp
      with F have "\<exists>v \<in> sinks ?I' ?D' u ?xs'. (v, ?D' x) \<in> ?I'" ..
      thus False
       using C by simp
    qed
    ultimately show "sinks ?I' ?D' u (?xs' @ [x]) =
      sinks ?I' ?D' u (xs @ [x]) \<inter> range Some"
     by simp
  next
    assume B: "x \<notin> range p \<union> range q"
    hence "(u, ?D' x) \<in> ?I'"
     by (simp add: con_comp_pol_def)
    hence "sinks ?I' ?D' u (xs @ [x]) = insert (?D' x) (sinks ?I' ?D' u xs)"
     by simp
    moreover have "insert (?D' x) (sinks ?I' ?D' u xs) \<inter> range Some =
      sinks ?I' ?D' u xs \<inter> range Some"
     using B by simp
    ultimately have "sinks ?I' ?D' u (xs @ [x]) \<inter> range Some =
      sinks ?I' ?D' u xs \<inter> range Some"
     by simp
    thus "sinks ?I' ?D' u ?xs' = sinks ?I' ?D' u (xs @ [x]) \<inter> range Some"
     using A by simp
  qed
qed

lemma con_comp_ipurge_tr_filter:
 "ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u
    [x\<leftarrow>xs. x \<in> range p \<union> range q] =
  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs"
  (is "ipurge_tr ?I' ?D' _ _ = _")
proof (induction xs rule: rev_induct, simp)
  fix x xs
  assume A: "ipurge_tr ?I' ?D' u [x\<leftarrow>xs. x \<in> range p \<union> range q] =
    ipurge_tr ?I' ?D' u xs"
    (is "ipurge_tr _ _ _ ?xs' = _")
  show "ipurge_tr ?I' ?D' u [x\<leftarrow>xs @ [x]. x \<in> range p \<union> range q] =
    ipurge_tr ?I' ?D' u (xs @ [x])"
  proof (cases "x \<in> range p \<union> range q", simp_all del: Un_iff ipurge_tr.simps,
   cases "?D' x \<in> sinks ?I' ?D' u (?xs' @ [x])")
    assume
      B: "x \<in> range p \<union> range q" and
      C: "?D' x \<in> sinks ?I' ?D' u (?xs' @ [x])"
    have "ipurge_tr ?I' ?D' u (?xs' @ [x]) = ipurge_tr ?I' ?D' u ?xs'"
     using C by simp
    hence "ipurge_tr ?I' ?D' u (?xs' @ [x]) = ipurge_tr ?I' ?D' u xs"
     using A by simp
    moreover have "?D' x \<in> sinks ?I' ?D' u [x\<leftarrow>xs @ [x]. x \<in> range p \<union> range q]"
     using B and C by simp
    hence "?D' x \<in> sinks ?I' ?D' u (xs @ [x])"
     by (simp only: con_comp_sinks_filter, blast)
    ultimately show "ipurge_tr ?I' ?D' u (?xs' @ [x]) =
      ipurge_tr ?I' ?D' u (xs @ [x])"
     by simp
  next
    assume
      B: "x \<in> range p \<union> range q" and
      C: "\<not> (?D' x \<in> sinks ?I' ?D' u (?xs' @ [x]))"
    have "ipurge_tr ?I' ?D' u (?xs' @ [x]) = ipurge_tr ?I' ?D' u ?xs' @ [x]"
     using C by simp
    hence "ipurge_tr ?I' ?D' u (?xs' @ [x]) = ipurge_tr ?I' ?D' u xs @ [x]"
     using A by simp
    moreover have "?D' x \<notin> sinks ?I' ?D' u [x\<leftarrow>xs @ [x]. x \<in> range p \<union> range q]"
     using B and C by simp
    hence "?D' x \<notin> sinks ?I' ?D' u (xs @ [x]) \<inter> range Some"
     by (simp only: con_comp_sinks_filter, simp)
    hence "?D' x \<notin> sinks ?I' ?D' u (xs @ [x])"
     using B by (cases "x \<in> range p", simp_all)
    ultimately show "ipurge_tr ?I' ?D' u (?xs' @ [x]) =
      ipurge_tr ?I' ?D' u (xs @ [x])"
     by simp
  next
    assume "x \<notin> range p \<union> range q"
    hence "(u, ?D' x) \<in> ?I'"
     by (simp add: con_comp_pol_def)
    hence "?D' x \<in> sinks ?I' ?D' u (xs @ [x])"
     by simp
    thus "ipurge_tr ?I' ?D' u ?xs' = ipurge_tr ?I' ?D' u (xs @ [x])"
     using A by simp
  qed
qed

lemma con_comp_ipurge_ref_filter:
 "ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u
    [x\<leftarrow>xs. x \<in> range p \<union> range q] X =
  ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u xs X"
  (is "ipurge_ref ?I' ?D' _ _ _ = _")
proof (simp add: ipurge_ref_def con_comp_sinks_filter set_eq_iff del: Un_iff,
 rule allI, rule iffI, simp_all, (erule conjE)+, rule ballI)
  fix x v
  assume
    A: "(u, ?D' x) \<notin> ?I'" and
    B: "\<forall>v \<in> sinks ?I' ?D' u xs \<inter> range Some. (v, ?D' x) \<notin> ?I'" and
    C: "v \<in> sinks ?I' ?D' u xs"
  show "(v, ?D' x) \<notin> ?I'"
  proof (cases v, simp)
    have "?D' x \<in> range Some"
     using A by (cases "?D' x", simp_all add: con_comp_pol_def)
    thus "(None, ?D' x) \<notin> ?I'"
     by (simp add: image_iff con_comp_pol_def)
  next
    fix d
    assume "v = Some d"
    hence "v \<in> range Some"
     by simp
    with C have "v \<in> sinks ?I' ?D' u xs \<inter> range Some" ..
    with B show "(v, ?D' x) \<notin> ?I'" ..
  qed
qed

lemma con_comp_secure_aux [rule_format]:
  assumes
    A: "secure P I D" and
    B: "Y \<subseteq> range p"
  shows "set ys \<subseteq> range p \<union> range q \<longrightarrow> U \<subseteq> range Some \<longrightarrow>
    (map (inv p) [x\<leftarrow>xs @ ys. x \<in> range p], inv p ` Y) \<in> failures P \<longrightarrow>
    (map (inv p) [x\<leftarrow>xs. x \<in> range p] @
     map (inv p) (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)
       (\<lambda>x. x \<in> range p) U ys),
     inv p ` ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)
       (\<lambda>x. x \<in> range p) U ys Y) \<in> failures P"
proof (induction ys arbitrary: xs U, (rule_tac [!] impI)+, simp)
  fix xs U
  assume "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` Y) \<in> failures P"
  moreover have
   "ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U [] Y \<subseteq> Y"
    (is "?Y' \<subseteq> _")
   by (rule ipurge_ref_aux_subset)
  hence "inv p ` ?Y' \<subseteq> inv p ` Y"
   by (rule image_mono)
  ultimately show "(map (inv p) [x\<leftarrow>xs. x \<in> range p], inv p ` ?Y') \<in> failures P"
   by (rule process_rule_3)
next
  fix y ys xs U
  assume "\<And>xs U. set ys \<subseteq> range p \<union> range q \<longrightarrow> U \<subseteq> range Some \<longrightarrow>
    (map (inv p) [x\<leftarrow>xs @ ys. x \<in> range p], inv p ` Y) \<in> failures P \<longrightarrow>
    (map (inv p) [x\<leftarrow>xs. x \<in> range p] @
     map (inv p) (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)
       (\<lambda>x. x \<in> range p) U ys),
     inv p ` ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)
       (\<lambda>x. x \<in> range p) U ys Y) \<in> failures P"
  hence "set ys \<subseteq> range p \<union> range q \<longrightarrow>
    sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y] \<subseteq> range Some \<longrightarrow>
    (map (inv p) [x\<leftarrow>(xs @ [y]) @ ys. x \<in> range p], inv p ` Y) \<in> failures P \<longrightarrow>
    (map (inv p) [x\<leftarrow>xs @ [y]. x \<in> range p] @
     map (inv p) (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)
       (\<lambda>x. x \<in> range p) (sinks_aux (con_comp_pol I) (con_comp_map D E p q)
         U [y]) ys),
     inv p ` ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)
       (\<lambda>x. x \<in> range p) (sinks_aux (con_comp_pol I) (con_comp_map D E p q)
         U [y]) ys Y) \<in> failures P"
    (is "_ \<longrightarrow> _ \<longrightarrow> _ \<longrightarrow>
      (_ @ map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F ?U' _), _) \<in> _") .
  moreover assume C: "set (y # ys) \<subseteq> range p \<union> range q"
  hence "set ys \<subseteq> range p \<union> range q"
   by simp
  ultimately have "?U' \<subseteq> range Some \<longrightarrow>
    (map (inv p) [x\<leftarrow>(xs @ [y]) @ ys. x \<in> range p], inv p ` Y) \<in> failures P \<longrightarrow>
    (map (inv p) [x\<leftarrow>xs @ [y]. x \<in> range p] @
     map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys),
     inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y) \<in> failures P" ..
  moreover assume D: "U \<subseteq> range Some"
  hence "?U' \<subseteq> range Some"
  proof (cases "\<exists>u \<in> U. (u, ?D' y) \<in> ?I'", simp_all add: sinks_aux_single_event)
    have "y \<in> range p \<union> range q"
     using C by simp
    thus "?D' y \<in> range Some"
     by (cases "y \<in> range p", simp_all)
  qed
  ultimately have
   "(map (inv p) [x\<leftarrow>(xs @ [y]) @ ys. x \<in> range p], inv p ` Y) \<in> failures P \<longrightarrow>
    (map (inv p) [x\<leftarrow>xs @ [y]. x \<in> range p] @
     map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys),
     inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y) \<in> failures P" ..
  moreover assume
   "(map (inv p) [x\<leftarrow>xs @ y # ys. x \<in> range p], inv p ` Y) \<in> failures P"
  ultimately have
   "(map (inv p) [x\<leftarrow>xs @ [y]. x \<in> range p] @
     map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys),
     inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y) \<in> failures P"
   by simp
  hence
   "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @
     map (inv p) ((if y \<in> range p then [y] else []) @
       ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys),
     inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y) \<in> failures P"
   by (cases "y \<in> range p", simp_all)
  with A have
   "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @
     ipurge_tr_aux I D (the ` U) (map (inv p) ((if y \<in> range p then [y] else []) @
       ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys)),
     ipurge_ref_aux I D (the ` U) (map (inv p) ((if y \<in> range p then [y] else []) @
       ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys))
     (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y)) \<in> failures P"
   by (rule ipurge_tr_ref_aux_failures_general)
  moreover have
   "ipurge_tr_aux I D (the ` U) (map (inv p) ((if y \<in> range p then [y] else []) @
      ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys)) =
    map (inv p) (ipurge_tr_aux ?I' ?D' U ((if y \<in> range p then [y] else []) @
      ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys))"
   by (rule con_comp_ipurge_tr_aux, simp_all add:
    D ipurge_tr_aux_foldr_eq [symmetric], blast)
  moreover have
   "ipurge_ref_aux I D (the ` U) (map (inv p) ((if y \<in> range p then [y] else []) @
      ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys))
      (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y) =
    inv p ` ipurge_ref_aux ?I' ?D' U ((if y \<in> range p then [y] else []) @
      ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys)
      (ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y)"
  proof (rule con_comp_ipurge_ref_aux, simp_all add:
   D ipurge_tr_aux_foldr_eq [symmetric] ipurge_ref_aux_foldr_eq [symmetric], blast)
    have "ipurge_ref_aux ?I' ?D' ?U' ys Y \<subseteq> Y"
     by (rule ipurge_ref_aux_subset)
    thus "ipurge_ref_aux ?I' ?D' ?U' ys Y \<subseteq> range p"
     using B by simp
  qed
  ultimately show
   "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @
     map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F U (y # ys)),
     inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F U (y # ys) Y) \<in> failures P"
   by simp
qed


subsection "Conservation of noninterference security under concurrent composition"


lemma con_comp_secure_del_aux_1:
  assumes
    A: "secure P I D" and
    B: "y \<in> range p \<or> y \<in> range q" and
    C: "set ys \<subseteq> range p \<union> range q" and
    D: "Y \<subseteq> range p" and
    E: "(map (inv p) [x\<leftarrow>xs @ y # ys. x \<in> range p], inv p ` Y) \<in> failures P"
  shows
   "(map (inv p) [x\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
       (con_comp_map D E p q y) ys. x \<in> range p],
     inv p ` ipurge_ref (con_comp_pol I) (con_comp_map D E p q)
       (con_comp_map D E p q y) ys Y) \<in> failures P"
    (is "(map (inv p) [x\<leftarrow>xs @ ipurge_tr ?I' ?D' _ _. _], _) \<in> _")
proof (simp add:
 ipurge_tr_aux_single_dom [symmetric] ipurge_ref_aux_single_dom [symmetric]
 ipurge_tr_aux_foldr_eq ipurge_ref_aux_foldr_eq [where P = "\<lambda>x. x \<in> range p"])
  have "(map (inv p) [x\<leftarrow>xs @ [y]. x \<in> range p] @
    map (inv p) (ipurge_tr_aux_foldr ?I' ?D' (\<lambda>x. x \<in> range p) {?D' y} ys),
    inv p ` ipurge_ref_aux_foldr ?I' ?D' (\<lambda>x. x \<in> range p) {?D' y} ys Y)
      \<in> failures P"
    (is "(_ @ map (inv p) (ipurge_tr_aux_foldr _ _ ?F _ _), _) \<in> _")
  proof (rule con_comp_secure_aux [OF A D C])
    show "{?D' y} \<subseteq> range Some"
     using B by (cases "y \<in> range p", simp_all)
  next
    show "(map (inv p) [x\<leftarrow>(xs @ [y]) @ ys. x \<in> range p], inv p ` Y) \<in> failures P"
     using E by simp
  qed
  thus "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @
    map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {?D' y} ys),
    inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {?D' y} ys Y)
      \<in> failures P"
  proof (cases "y \<in> range p", simp_all)
    assume "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @ inv p y #
      map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys),
      inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y)
      \<in> failures P"
    hence "(inv p y #
      map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys),
      inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y)
      \<in> futures P (map (inv p) [x\<leftarrow>xs. x \<in> range p])"
     by (simp add: futures_def)
    hence
     "(ipurge_tr I D (D (inv p y))
         (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)),
       ipurge_ref I D (D (inv p y))
         (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys))
         (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y))
      \<in> futures P (map (inv p) [x\<leftarrow>xs. x \<in> range p])"
     using A by (simp add: secure_def)
    hence
     "(ipurge_tr_aux I D (the ` {Some (D (inv p y))})
         (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)),
       ipurge_ref_aux I D (the ` {Some (D (inv p y))})
         (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys))
         (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y))
      \<in> futures P (map (inv p) [x\<leftarrow>xs. x \<in> range p])"
     by (simp add: ipurge_tr_aux_single_dom ipurge_ref_aux_single_dom)
    moreover have
     "ipurge_tr_aux I D (the ` {Some (D (inv p y))})
        (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)) =
      map (inv p) (ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}
        (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys))"
     by (rule con_comp_ipurge_tr_aux, simp_all add:
      ipurge_tr_aux_foldr_eq [symmetric], blast)
    moreover have
     "ipurge_ref_aux I D (the ` {Some (D (inv p y))})
        (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys))
        (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y) =
      inv p ` ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}
        (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)
        (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y)"
    proof (rule con_comp_ipurge_ref_aux, simp_all add:
     ipurge_tr_aux_foldr_eq [symmetric] ipurge_ref_aux_foldr_eq [symmetric], blast)
      have "ipurge_ref_aux ?I' ?D' {Some (D (inv p y))} ys Y \<subseteq> Y"
       by (rule ipurge_ref_aux_subset)
      thus "ipurge_ref_aux ?I' ?D' {Some (D (inv p y))} ys Y \<subseteq> range p"
       using D by simp
    qed
    ultimately have
     "(map (inv p) (ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}
         (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)),
       inv p ` ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}
         (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)
         (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y))
      \<in> futures P (map (inv p) [x\<leftarrow>xs. x \<in> range p])"
     by simp
    moreover have
     "ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}
        (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys) =
      ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys"
     by (rule ipurge_tr_aux_foldr_subset, simp)
    moreover have
     "ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}
        (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)
        (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y) =
      ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y"
     by (rule ipurge_ref_aux_foldr_subset, subst ipurge_tr_aux_foldr_sinks_aux, simp)
    ultimately have
     "(map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys),
       inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y)
      \<in> futures P (map (inv p) [x\<leftarrow>xs. x \<in> range p])"
     by simp
    thus "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @
      map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys),
      inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y)
      \<in> failures P"
     by (simp add: futures_def)
  qed
qed

lemma con_comp_secure_add_aux_1:
  assumes
    A: "secure P I D" and
    B: "y \<in> range p \<or> y \<in> range q" and
    C: "set zs \<subseteq> range p \<union> range q" and
    D: "Z \<subseteq> range p" and
    E: "(map (inv p) [x\<leftarrow>xs @ zs. x \<in> range p], inv p ` Z) \<in> failures P" and
    F: "map (inv p) [x\<leftarrow>xs @ [y]. x \<in> range p] \<in> traces P"
  shows
   "(map (inv p) [x\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
       (con_comp_map D E p q y) zs. x \<in> range p],
     inv p ` ipurge_ref (con_comp_pol I) (con_comp_map D E p q)
       (con_comp_map D E p q y) zs Z) \<in> failures P"
    (is "(map (inv p) [x\<leftarrow>xs @ y # ipurge_tr ?I' ?D' _ _. _], _) \<in> _")
proof -
  have
   "(map (inv p) [x\<leftarrow>(xs @ [y]) @ ipurge_tr ?I' ?D' (?D' y) zs. x \<in> range p],
     inv p ` ipurge_ref ?I' ?D' (?D' y) zs Z) \<in> failures P"
  proof (subst filter_append, simp del: filter_append add:
   ipurge_tr_aux_single_dom [symmetric] ipurge_ref_aux_single_dom [symmetric]
   ipurge_tr_aux_foldr_eq ipurge_ref_aux_foldr_eq [where P = "\<lambda>x. x \<in> range p"])
    have "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @
      map (inv p) (ipurge_tr_aux_foldr ?I' ?D' (\<lambda>x. x \<in> range p) {?D' y} zs),
      inv p ` ipurge_ref_aux_foldr ?I' ?D' (\<lambda>x. x \<in> range p) {?D' y} zs Z)
        \<in> failures P"
      (is "(_ @ map (inv p) (ipurge_tr_aux_foldr _ _ ?F _ _), _) \<in> _")
    proof (rule con_comp_secure_aux [OF A D C])
      show "{?D' y} \<subseteq> range Some"
       using B by (cases "y \<in> range p", simp_all)
    next
      show "(map (inv p) [x\<leftarrow>xs @ zs. x \<in> range p], inv p ` Z) \<in> failures P"
       using E .
    qed
    thus "(map (inv p) [x\<leftarrow>xs @ [y]. x \<in> range p] @
      map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {?D' y} zs),
      inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {?D' y} zs Z)
        \<in> failures P"
    proof (cases "y \<in> range p", simp_all)
      case True
      assume "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @
        map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs),
        inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z)
        \<in> failures P"
      hence
       "(map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs),
         inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z)
        \<in> futures P (map (inv p) [x\<leftarrow>xs. x \<in> range p])"
       by (simp add: futures_def)
      moreover have "(map (inv p) [x\<leftarrow>xs @ [y]. x \<in> range p], {}) \<in> failures P"
       using F by (rule traces_failures)
      hence "([inv p y], {}) \<in> futures P (map (inv p) [x\<leftarrow>xs. x \<in> range p])"
       using True by (simp add: futures_def)
      ultimately have
       "(inv p y # ipurge_tr I D (D (inv p y))
           (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)),
         ipurge_ref I D (D (inv p y))
           (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs))
           (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z))
        \<in> futures P (map (inv p) [x\<leftarrow>xs. x \<in> range p])"
       using A by (simp add: secure_def)
      hence
       "(inv p y # ipurge_tr_aux I D (the ` {Some (D (inv p y))})
           (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)),
         ipurge_ref_aux I D (the ` {Some (D (inv p y))})
           (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs))
           (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z))
        \<in> futures P (map (inv p) [x\<leftarrow>xs. x \<in> range p])"
       by (simp add: ipurge_tr_aux_single_dom ipurge_ref_aux_single_dom)
      moreover have
       "ipurge_tr_aux I D (the ` {Some (D (inv p y))})
          (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)) =
        map (inv p) (ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}
          (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs))"
       by (rule con_comp_ipurge_tr_aux, simp_all add:
        ipurge_tr_aux_foldr_eq [symmetric], blast)
      moreover have
       "ipurge_ref_aux I D (the ` {Some (D (inv p y))})
          (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs))
          (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z) =
        inv p ` ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}
          (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)
          (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z)"
      proof (rule con_comp_ipurge_ref_aux, simp_all add:
       ipurge_tr_aux_foldr_eq [symmetric] ipurge_ref_aux_foldr_eq [symmetric], blast)
        have "ipurge_ref_aux ?I' ?D' {Some (D (inv p y))} zs Z \<subseteq> Z"
         by (rule ipurge_ref_aux_subset)
        thus "ipurge_ref_aux ?I' ?D' {Some (D (inv p y))} zs Z \<subseteq> range p"
         using D by simp
      qed
      ultimately have
       "(inv p y # map (inv p) (ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}
           (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)),
         inv p ` ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}
           (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)
           (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z))
        \<in> futures P (map (inv p) [x\<leftarrow>xs. x \<in> range p])"
       by simp
      moreover have
       "ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}
          (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs) =
        ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs"
       by (rule ipurge_tr_aux_foldr_subset, simp)
      moreover have
       "ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}
          (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)
          (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z) =
        ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z"
       by (rule ipurge_ref_aux_foldr_subset, subst ipurge_tr_aux_foldr_sinks_aux, simp)
      ultimately have
       "(inv p y # map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F
           {Some (D (inv p y))} zs),
         inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F
           {Some (D (inv p y))} zs Z)
        \<in> futures P (map (inv p) [x\<leftarrow>xs. x \<in> range p])"
       by simp
      thus "(map (inv p) [x\<leftarrow>xs. x \<in> range p] @ inv p y #
        map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs),
        inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z)
        \<in> failures P"
       by (simp add: futures_def)
    qed
  qed
  thus ?thesis
   by simp
qed

lemma con_comp_consistent_maps:
 "consistent_maps D E p q \<Longrightarrow> con_comp_map D E p q = con_comp_map E D q p"
using [[simproc del: defined_all]] proof (simp add: consistent_maps_def, rule ext)
  fix x
  assume A: "\<forall>x \<in> range p \<inter> range q. D (inv p x) = E (inv q x)"
  show "con_comp_map D E p q x = con_comp_map E D q p x"
  proof (rule con_comp_map.cases [of "(D, E, p, q, x)"], simp_all, (erule conjE)+)
    fix p' q' D' E' x'
    assume
      B: "p = p'" and
      C: "q = q'" and
      D: "D = D'" and
      E: "E = E'" and
      F: "x' \<in> range p'"
    show "Some (D' (inv p' x')) = con_comp_map E' D' q' p' x'"
    proof (cases "x' \<in> range q'", simp_all add: F)
      case True
      with F have "x' \<in> range p' \<inter> range q'" ..
      hence "x' \<in> range p \<inter> range q"
       using B and C by simp
      with A have "D (inv p x') = E (inv q x')" ..
      thus "D' (inv p' x') = E' (inv q' x')"
       using B and C and D and E by simp
    qed
  qed
qed

lemma con_comp_secure_del_aux_2:
  assumes A: "consistent_maps D E p q"
  shows
   "secure Q I E \<Longrightarrow>
    y \<in> range p \<or> y \<in> range q \<Longrightarrow>
    set ys \<subseteq> range p \<union> range q \<Longrightarrow>
    Y \<subseteq> range q \<Longrightarrow>
    (map (inv q) [x\<leftarrow>xs @ y # ys. x \<in> range q], inv q ` Y) \<in> failures Q \<Longrightarrow>
      (map (inv q) [x\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
         (con_comp_map D E p q y) ys. x \<in> range q],
       inv q ` ipurge_ref (con_comp_pol I) (con_comp_map D E p q)
         (con_comp_map D E p q y) ys Y) \<in> failures Q"
proof (simp only: con_comp_consistent_maps [OF A], rule con_comp_secure_del_aux_1)
qed (simp_all, blast+)

lemma con_comp_secure_add_aux_2:
  assumes A: "consistent_maps D E p q"
  shows
   "secure Q I E \<Longrightarrow>
    y \<in> range p \<or> y \<in> range q \<Longrightarrow>
    set zs \<subseteq> range p \<union> range q \<Longrightarrow>
    Z \<subseteq> range q \<Longrightarrow>
    (map (inv q) [x\<leftarrow>xs @ zs. x \<in> range q], inv q ` Z) \<in> failures Q \<Longrightarrow>
    map (inv q) [x\<leftarrow>xs @ [y]. x \<in> range q] \<in> traces Q \<Longrightarrow>
      (map (inv q) [x\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)
         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \<in> range q],
       inv q ` ipurge_ref (con_comp_pol I)
         (con_comp_map D E p q) (con_comp_map D E p q y) zs Z) \<in> failures Q"
proof (simp only: con_comp_consistent_maps [OF A], rule con_comp_secure_add_aux_1)
qed (simp_all, blast+)

lemma con_comp_secure_del_case_1:
  assumes
    A: "consistent_maps D E p q" and
    B: "secure P I D" and
    C: "secure Q I E"
  shows
   "\<exists>R S T.
      Y = R \<union> S \<union> T \<and>
      (y \<in> range p \<or> y \<in> range q) \<and>
      set xs \<subseteq> range p \<union> range q \<and>
      set ys \<subseteq> range p \<union> range q \<and>
      R \<subseteq> range p \<and>
      S \<subseteq> range q \<and>
      T \<subseteq> - range p \<and>
      T \<subseteq> - range q \<and>
      (map (inv p) [x\<leftarrow>xs @ y # ys. x \<in> range p], inv p ` R) \<in> failures P \<and>
      (map (inv q) [x\<leftarrow>xs @ y # ys. x \<in> range q], inv q ` S) \<in> failures Q \<Longrightarrow>
    \<exists>R S T.
      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) ys Y = R \<union> S \<union> T \<and>
      set xs \<subseteq> range p \<union> range q \<and>                     
      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) ys) \<subseteq> range p \<union> range q \<and>
      R \<subseteq> range p \<and>
      S \<subseteq> range q \<and>
      T \<subseteq> - range p \<and>
      T \<subseteq> - range q \<and>
      (map (inv p) [x\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) ys. x \<in> range p], inv p ` R) \<in> failures P \<and>
      (map (inv q) [x\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) ys. x \<in> range q], inv q ` S) \<in> failures Q"
  (is "_ \<Longrightarrow> \<exists>_ _ _. ipurge_ref ?I' ?D' _ _ _ = _ \<and> _")
proof ((erule exE)+, (erule conjE)+)
  fix R S T
  assume
    D: "Y = R \<union> S \<union> T" and
    E: "y \<in> range p \<or> y \<in> range q" and
    F: "set xs \<subseteq> range p \<union> range q" and
    G: "set ys \<subseteq> range p \<union> range q" and
    H: "R \<subseteq> range p" and
    I: "S \<subseteq> range q" and
    J: "T \<subseteq> - range p" and
    K: "T \<subseteq> - range q" and
    L: "(map (inv p) [x\<leftarrow>xs @ y # ys. x \<in> range p], inv p ` R) \<in> failures P" and
    M: "(map (inv q) [x\<leftarrow>xs @ y # ys. x \<in> range q], inv q ` S) \<in> failures Q"
  show ?thesis
  proof (rule_tac x = "ipurge_ref ?I' ?D' (?D' y) ys R" in exI,
   rule_tac x = "ipurge_ref ?I' ?D' (?D' y) ys S" in exI, rule_tac x = "{}" in exI,
   (subst conj_assoc [symmetric])+, (rule conjI)+, simp_all del: filter_append)
    have "ipurge_ref ?I' ?D' (?D' y) ys Y =
      ipurge_ref ?I' ?D' (?D' y) ys (R \<union> S \<union> T)"
     using D by simp
    hence "ipurge_ref ?I' ?D' (?D' y) ys Y =
      ipurge_ref ?I' ?D' (?D' y) ys R \<union>
      ipurge_ref ?I' ?D' (?D' y) ys S \<union>
      ipurge_ref ?I' ?D' (?D' y) ys T"
     by (simp add: ipurge_ref_distrib_union)
    moreover have "ipurge_ref ?I' ?D' (?D' y) ys T = {}"
    proof (rule ipurge_ref_empty [of "?D' y"], simp, insert E,
     cases "y \<in> range p", simp_all)
      fix x
      assume N: "x \<in> T"
      with J have "x \<in> - range p" ..
      moreover have "x \<in> - range q"
       using K and N ..
      ultimately have "?D' x = None"
       by simp
      thus "(Some (D (inv p y)), ?D' x) \<in> ?I'"
       by (simp add: con_comp_pol_def)
    next
      fix x
      assume N: "x \<in> T"
      with J have "x \<in> - range p" ..
      moreover have "x \<in> - range q"
       using K and N ..
      ultimately have "?D' x = None"
       by simp
      thus "(Some (E (inv q y)), ?D' x) \<in> ?I'"
       by (simp add: con_comp_pol_def)
    qed
    ultimately show "ipurge_ref ?I' ?D' (?D' y) ys Y =
      ipurge_ref ?I' ?D' (?D' y) ys R \<union>
      ipurge_ref ?I' ?D' (?D' y) ys S"
     by simp
  next
    show "set xs \<subseteq> range p \<union> range q"
     using F .
  next
    have "set (ipurge_tr ?I' ?D' (?D' y) ys) \<subseteq> set ys"
     by (rule ipurge_tr_set)
    thus "set (ipurge_tr ?I' ?D' (?D' y) ys) \<subseteq> range p \<union> range q"
     using G by simp
  next
    have "ipurge_ref ?I' ?D' (?D' y) ys R \<subseteq> R"
     by (rule ipurge_ref_subset)
    thus "ipurge_ref ?I' ?D' (?D' y) ys R \<subseteq> range p"
     using H by simp
  next
    have "ipurge_ref ?I' ?D' (?D' y) ys S \<subseteq> S"
     by (rule ipurge_ref_subset)
    thus "ipurge_ref ?I' ?D' (?D' y) ys S \<subseteq> range q"
     using I by simp
  next
    show "(map (inv p) [x\<leftarrow>xs @ ipurge_tr ?I' ?D' (?D' y) ys. x \<in> range p],
      inv p ` ipurge_ref ?I' ?D' (?D' y) ys R) \<in> failures P"
     by (rule con_comp_secure_del_aux_1 [OF B E G H L])
  next
    show "(map (inv q) [x\<leftarrow>xs @ ipurge_tr ?I' ?D' (?D' y) ys. x \<in> range q],
      inv q ` ipurge_ref ?I' ?D' (?D' y) ys S) \<in> failures Q"
     by (rule con_comp_secure_del_aux_2 [OF A C E G I M])
  qed
qed

lemma con_comp_secure_del_case_2:
  assumes
    A: "consistent_maps D E p q" and
    B: "secure P I D" and
    C: "secure Q I E"
  shows
   "\<exists>xs'.
      (\<exists>ys'. xs @ y # ys = xs' @ ys') \<and>
      set xs' \<subseteq> range p \<union> range q \<and>
      map (inv p) [x\<leftarrow>xs'. x \<in> range p] \<in> divergences P \<and>
      map (inv q) [x\<leftarrow>xs'. x \<in> range q] \<in> divergences Q \<Longrightarrow>
    (\<exists>R S T.
      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) ys Y = R \<union> S \<union> T \<and>
      set xs \<subseteq> range p \<union> range q \<and>
      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) ys) \<subseteq> range p \<union> range q \<and>
      R \<subseteq> range p \<and>
      S \<subseteq> range q \<and>
      T \<subseteq> - range p \<and>
      T \<subseteq> - range q \<and>
      (map (inv p) [x\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) ys. x \<in> range p], inv p ` R) \<in> failures P \<and>
      (map (inv q) [x\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) ys. x \<in> range q], inv q ` S) \<in> failures Q) \<or>
    (\<exists>xs'.
      (\<exists>ys'. xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) ys = xs' @ ys') \<and>
      set xs' \<subseteq> range p \<union> range q \<and>
      map (inv p) [x\<leftarrow>xs'. x \<in> range p] \<in> divergences P \<and>
      map (inv q) [x\<leftarrow>xs'. x \<in> range q] \<in> divergences Q)"
  (is "_ \<Longrightarrow> (\<exists>R S T. ?F R S T ys) \<or> ?G")
proof (erule exE, (erule conjE)+, erule exE)
  fix xs' ys'
  assume
    D: "set xs' \<subseteq> range p \<union> range q" and
    E: "map (inv p) [x\<leftarrow>xs'. x \<in> range p] \<in> divergences P" and
    F: "map (inv q) [x\<leftarrow>xs'. x \<in> range q] \<in> divergences Q" and
    G: "xs @ y # ys = xs' @ ys'"
  show ?thesis
  proof (cases "length xs < length xs'", rule disjI1, rule_tac [2] disjI2)
    case True
    moreover have "take (length xs') (xs @ [y] @ ys) =
      take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys"
     by (simp only: take_append, simp)
    ultimately have "take (length xs') (xs @ [y] @ ys) =
      xs @ y # take (length xs' - Suc (length xs)) ys"
      (is "_ = _ @ _ # ?vs")
     by simp
    moreover have "take (length xs') (xs @ [y] @ ys) =
      take (length xs') (xs' @ ys')"
     using G by simp
    ultimately have H: "xs @ y # ?vs = xs'"
     by simp
    moreover have "y \<in> set (xs @ y # ?vs)"
     by simp
    ultimately have "y \<in> set xs'"
     by simp
    with D have I: "y \<in> range p \<union> range q" ..
    have "set xs \<subseteq> set (xs @ y # ?vs)"
     by auto
    hence "set xs \<subseteq> set xs'"
     using H by simp
    hence J: "set xs \<subseteq> range p \<union> range q"
     using D by simp
    have "\<exists>R S T. ?F R S T [x\<leftarrow>ys. x \<in> range p \<union> range q]"
      (is "\<exists>_ _ _. ipurge_ref ?I' ?D' _ _ _ = _ \<and> _")
    proof (rule con_comp_secure_del_case_1 [OF A B C],
     rule_tac x = "range p \<inter> Y" in exI, rule_tac x = "range q \<inter> Y" in exI,
     rule_tac x = "- range p \<inter> - range q \<inter> Y" in exI,
     (subst conj_assoc [symmetric])+, (rule conjI)+, simp_all del: filter_append)
      show "Y = range p \<inter> Y \<union> range q \<inter> Y \<union> - range p \<inter> - range q \<inter> Y"
       by blast
    next
      show "y \<in> range p \<or> y \<in> range q"
       using I by simp
    next
      show "set xs \<subseteq> range p \<union> range q"
       using J .
    next
      show "{x \<in> set ys. x \<in> range p \<or> x \<in> range q} \<subseteq> range p \<union> range q"
       by blast
    next
      show "- range p \<inter> - range q \<inter> Y \<subseteq> - range p"
       by blast
    next
      show "- range p \<inter> - range q \<inter> Y \<subseteq> - range q"
       by blast
    next
      have "map (inv p) [x\<leftarrow>xs @ y # ?vs. x \<in> range p] \<in> divergences P"
       using E and H by simp
      hence "map (inv p) [x\<leftarrow>xs @ y # ?vs. x \<in> range p] @
        map (inv p) [x\<leftarrow>drop (length xs' - Suc (length xs)) ys. x \<in> range p]
        \<in> divergences P"
        (is "_ @ map (inv p) [x\<leftarrow>?ws. _] \<in> _")
       by (rule process_rule_5_general)
      hence "map (inv p) [x\<leftarrow>(xs @ y # ?vs) @ ?ws. x \<in> range p] \<in> divergences P"
       by (subst filter_append, simp)
      hence "map (inv p) [x\<leftarrow>(xs @ [y]) @ ys. x \<in> range p] \<in> divergences P"
       by simp
      hence "map (inv p) [x\<leftarrow>(xs @ [y]) @ [x\<leftarrow>ys. x \<in> range p \<or> x \<in> range q].
        x \<in> range p] \<in> divergences P"
      proof (subst (asm) filter_append, subst filter_append, subst filter_filter)
      qed (subgoal_tac "(\<lambda>x. (x \<in> range p \<or> x \<in> range q) \<and> x \<in> range p) =
       (\<lambda>x. x \<in> range p)", simp, blast)
      hence "map (inv p) [x\<leftarrow>xs @ y # [x\<leftarrow>ys. x \<in> range p \<or> x \<in> range q].
        x \<in> range p] \<in> divergences P"
       by simp
      thus "(map (inv p) [x\<leftarrow>xs @ y # [x\<leftarrow>ys. x \<in> range p \<or> x \<in> range q].
        x \<in> range p], inv p ` (range p \<inter> Y)) \<in> failures P"
       by (rule process_rule_6)
    next
      have "map (inv q) [x\<leftarrow>xs @ y # ?vs. x \<in> range q] \<in> divergences Q"
       using F and H by simp
      hence "map (inv q) [x\<leftarrow>xs @ y # ?vs. x \<in> range q] @
        map (inv q) [x\<leftarrow>drop (length xs' - Suc (length xs)) ys. x \<in> range q]
        \<in> divergences Q"
        (is "_ @ map (inv q) [x\<leftarrow>?ws. _] \<in> _")
       by (rule process_rule_5_general)
      hence "map (inv q) [x\<leftarrow>(xs @ y # ?vs) @ ?ws. x \<in> range q] \<in> divergences Q"
       by (subst filter_append, simp)
      hence "map (inv q) [x\<leftarrow>(xs @ [y]) @ ys. x \<in> range q] \<in> divergences Q"
       by simp
      hence "map (inv q) [x\<leftarrow>(xs @ [y]) @ [x\<leftarrow>ys. x \<in> range p \<or> x \<in> range q].
        x \<in> range q] \<in> divergences Q"
      proof (subst (asm) filter_append, subst filter_append, subst filter_filter)
      qed (subgoal_tac "(\<lambda>x. (x \<in> range p \<or> x \<in> range q) \<and> x \<in> range q) =
       (\<lambda>x. x \<in> range q)", simp, blast)
      hence "map (inv q) [x\<leftarrow>xs @ y # [x\<leftarrow>ys. x \<in> range p \<or> x \<in> range q].
        x \<in> range q] \<in> divergences Q"
       by simp
      thus "(map (inv q) [x\<leftarrow>xs @ y # [x\<leftarrow>ys. x \<in> range p \<or> x \<in> range q].
        x \<in> range q], inv q ` (range q \<inter> Y)) \<in> failures Q"
       by (rule process_rule_6)
    qed
    then obtain R and S and T where
     "?F R S T [x\<leftarrow>ys. x \<in> range p \<union> range q]"
     by blast
    thus "\<exists>R S T. ?F R S T ys"
    proof (rule_tac x = R in exI, rule_tac x = S in exI, rule_tac x = T in exI)
    qed (simp only: con_comp_ipurge_tr_filter con_comp_ipurge_ref_filter)
  next
    let
      ?I' = "con_comp_pol I" and
      ?D' = "con_comp_map D E p q"
    case False
    moreover have "xs @ ipurge_tr ?I' ?D' (?D' y) ys =
      take (length xs') (xs @ ipurge_tr ?I' ?D' (?D' y) ys) @
      drop (length xs') (xs @ ipurge_tr ?I' ?D' (?D' y) ys)"
      (is "_ = _ @ ?vs")
     by (simp only: append_take_drop_id)
    ultimately have "xs @ ipurge_tr ?I' ?D' (?D' y) ys =
      take (length xs') (xs @ y # ys) @ ?vs"
     by simp
    hence H: "xs @ ipurge_tr ?I' ?D' (?D' y) ys = xs' @ ?vs"
     using G by simp
    show ?G
    proof (rule_tac x = xs' in exI, rule conjI, rule_tac x = ?vs in exI)
    qed (subst H, simp_all add: D E F)
  qed
qed

lemma con_comp_secure_add_case_1:
  assumes
    A: "consistent_maps D E p q" and
    B: "secure P I D" and
    C: "secure Q I E" and
    D: "(xs @ y # ys, Y) \<in> con_comp_failures P Q p q" and
    E: "y \<in> range p \<or> y \<in> range q"
  shows
   "\<exists>R S T.
      Z = R \<union> S \<union> T \<and>
      set xs \<subseteq> range p \<union> range q \<and>
      set zs \<subseteq> range p \<union> range q \<and>
      R \<subseteq> range p \<and>
      S \<subseteq> range q \<and>
      T \<subseteq> - range p \<and>
      T \<subseteq> - range q \<and>
      (map (inv p) [x\<leftarrow>xs @ zs. x \<in> range p], inv p ` R) \<in> failures P \<and>
      (map (inv q) [x\<leftarrow>xs @ zs. x \<in> range q], inv q ` S) \<in> failures Q \<Longrightarrow>
    \<exists>R S T.
      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) zs Z = R \<union> S \<union> T \<and>
      set xs \<subseteq> range p \<union> range q \<and>
      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) zs) \<subseteq> range p \<union> range q \<and>
      R \<subseteq> range p \<and>
      S \<subseteq> range q \<and>
      T \<subseteq> - range p \<and>
      T \<subseteq> - range q \<and>
      (map (inv p) [x\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)
         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \<in> range p],
       inv p ` R) \<in> failures P \<and>
      (map (inv q) [x\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)
         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \<in> range q],
       inv q ` S) \<in> failures Q"
  (is "_ \<Longrightarrow> \<exists>_ _ _. ipurge_ref ?I' ?D' _ _ _ = _ \<and> _")
proof ((erule exE)+, (erule conjE)+)
  fix R S T
  assume
    F: "Z = R \<union> S \<union> T" and
    G: "set xs \<subseteq> range p \<union> range q" and
    H: "set zs \<subseteq> range p \<union> range q" and
    I: "R \<subseteq> range p" and
    J: "S \<subseteq> range q" and
    K: "T \<subseteq> - range p" and
    L: "T \<subseteq> - range q" and
    M: "(map (inv p) [x\<leftarrow>xs @ zs. x \<in> range p], inv p ` R) \<in> failures P" and
    N: "(map (inv q) [x\<leftarrow>xs @ zs. x \<in> range q], inv q ` S) \<in> failures Q"
  show ?thesis
  proof (rule_tac x = "ipurge_ref ?I' ?D' (?D' y) zs R" in exI,
   rule_tac x = "ipurge_ref ?I' ?D' (?D' y) zs S" in exI, rule_tac x = "{}" in exI,
   (subst conj_assoc [symmetric])+, (rule conjI)+, simp_all del: filter_append)
    have "ipurge_ref ?I' ?D' (?D' y) zs Z =
      ipurge_ref ?I' ?D' (?D' y) zs (R \<union> S \<union> T)"
     using F by simp
    hence "ipurge_ref ?I' ?D' (?D' y) zs Z =
      ipurge_ref ?I' ?D' (?D' y) zs R \<union>
      ipurge_ref ?I' ?D' (?D' y) zs S \<union>
      ipurge_ref ?I' ?D' (?D' y) zs T"
     by (simp add: ipurge_ref_distrib_union)
    moreover have "ipurge_ref ?I' ?D' (?D' y) zs T = {}"
    proof (rule ipurge_ref_empty [of "?D' y"], simp, insert E,
     cases "y \<in> range p", simp_all)
      fix x
      assume O: "x \<in> T"
      with K have "x \<in> - range p" ..
      moreover have "x \<in> - range q"
       using L and O ..
      ultimately have "?D' x = None"
       by simp
      thus "(Some (D (inv p y)), ?D' x) \<in> ?I'"
       by (simp add: con_comp_pol_def)
    next
      fix x
      assume O: "x \<in> T"
      with K have "x \<in> - range p" ..
      moreover have "x \<in> - range q"
       using L and O ..
      ultimately have "?D' x = None"
       by simp
      thus "(Some (E (inv q y)), ?D' x) \<in> ?I'"
       by (simp add: con_comp_pol_def)
    qed
    ultimately show "ipurge_ref ?I' ?D' (?D' y) zs Z =
      ipurge_ref ?I' ?D' (?D' y) zs R \<union>
      ipurge_ref ?I' ?D' (?D' y) zs S"
     by simp
  next
    show "set xs \<subseteq> range p \<union> range q"
     using G .
  next
    have "set (ipurge_tr ?I' ?D' (?D' y) zs) \<subseteq> set zs"
     by (rule ipurge_tr_set)
    thus "set (ipurge_tr ?I' ?D' (?D' y) zs) \<subseteq> range p \<union> range q"
     using H by simp
  next
    have "ipurge_ref ?I' ?D' (?D' y) zs R \<subseteq> R"
     by (rule ipurge_ref_subset)
    thus "ipurge_ref ?I' ?D' (?D' y) zs R \<subseteq> range p"
     using I by simp
  next
    have "ipurge_ref ?I' ?D' (?D' y) zs S \<subseteq> S"
     by (rule ipurge_ref_subset)
    thus "ipurge_ref ?I' ?D' (?D' y) zs S \<subseteq> range q"
     using J by simp
  next
    have "map (inv p) [x\<leftarrow>xs @ y # ys. x \<in> range p] \<in> traces P \<and>
      map (inv q) [x\<leftarrow>xs @ y # ys. x \<in> range q] \<in> traces Q"
     using D by (rule con_comp_failures_traces)
    hence "map (inv p) [x\<leftarrow>(xs @ [y]) @ ys. x \<in> range p] \<in> traces P"
     by simp
    hence "map (inv p) [x\<leftarrow>xs @ [y]. x \<in> range p] @
      map (inv p) [x\<leftarrow>ys. x \<in> range p] \<in> traces P"
     by (subst (asm) filter_append, simp)
    hence "map (inv p) [x\<leftarrow>xs @ [y]. x \<in> range p] \<in> traces P"
     by (rule process_rule_2_traces)
    thus "(map (inv p) [x\<leftarrow>xs @ y # ipurge_tr ?I' ?D' (?D' y) zs. x \<in> range p],
      inv p ` ipurge_ref ?I' ?D' (?D' y) zs R) \<in> failures P"
     by (rule con_comp_secure_add_aux_1 [OF B E H I M])
  next
    have "map (inv p) [x\<leftarrow>xs @ y # ys. x \<in> range p] \<in> traces P \<and>
      map (inv q) [x\<leftarrow>xs @ y # ys. x \<in> range q] \<in> traces Q"
     using D by (rule con_comp_failures_traces)
    hence "map (inv q) [x\<leftarrow>(xs @ [y]) @ ys. x \<in> range q] \<in> traces Q"
     by simp
    hence "map (inv q) [x\<leftarrow>xs @ [y]. x \<in> range q] @
      map (inv q) [x\<leftarrow>ys. x \<in> range q] \<in> traces Q"
     by (subst (asm) filter_append, simp)
    hence "map (inv q) [x\<leftarrow>xs @ [y]. x \<in> range q] \<in> traces Q"
     by (rule process_rule_2_traces)
    thus "(map (inv q) [x\<leftarrow>xs @ y # ipurge_tr ?I' ?D' (?D' y) zs. x \<in> range q],
      inv q ` ipurge_ref ?I' ?D' (?D' y) zs S) \<in> failures Q"
     by (rule con_comp_secure_add_aux_2 [OF A C E H J N])
  qed
qed

lemma con_comp_secure_add_case_2:
  assumes
    A: "consistent_maps D E p q" and
    B: "secure P I D" and
    C: "secure Q I E" and
    D: "(xs @ y # ys, Y) \<in> con_comp_failures P Q p q" and
    E: "y \<in> range p \<or> y \<in> range q"
  shows
   "\<exists>xs'.
      (\<exists>ys'. xs @ zs = xs' @ ys') \<and>
      set xs' \<subseteq> range p \<union> range q \<and>
      map (inv p) [x\<leftarrow>xs'. x \<in> range p] \<in> divergences P \<and>
      map (inv q) [x\<leftarrow>xs'. x \<in> range q] \<in> divergences Q \<Longrightarrow>
    (\<exists>R S T.
      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) zs Z = R \<union> S \<union> T \<and>
      set xs \<subseteq> range p \<union> range q \<and>
      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) zs) \<subseteq> range p \<union> range q \<and>
      R \<subseteq> range p \<and>
      S \<subseteq> range q \<and>
      T \<subseteq> - range p \<and>
      T \<subseteq> - range q \<and>
      (map (inv p) [x\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)
         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \<in> range p],
       inv p ` R) \<in> failures P \<and>
      (map (inv q) [x\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)
         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \<in> range q],
       inv q ` S) \<in> failures Q) \<or>
    (\<exists>xs'.
      (\<exists>ys'. xs @ y # ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
        (con_comp_map D E p q y) zs = xs' @ ys') \<and>
      set xs' \<subseteq> range p \<union> range q \<and>
      map (inv p) [x\<leftarrow>xs'. x \<in> range p] \<in> divergences P \<and>
      map (inv q) [x\<leftarrow>xs'. x \<in> range q] \<in> divergences Q)"
  (is "_ \<Longrightarrow> (\<exists>R S T. ?F R S T zs) \<or> ?G")
proof (erule exE, (erule conjE)+, erule exE)
  fix xs' ys'
  assume
    F: "set xs' \<subseteq> range p \<union> range q" and
    G: "map (inv p) [x\<leftarrow>xs'. x \<in> range p] \<in> divergences P" and
    H: "map (inv q) [x\<leftarrow>xs'. x \<in> range q] \<in> divergences Q" and
    I: "xs @ zs = xs' @ ys'"
  show ?thesis
  proof (cases "length xs < length xs'", rule disjI1, rule_tac [2] disjI2)
    case True
    moreover have "take (length xs') (xs @ zs) =
      take (length xs') xs @ take (length xs' - length xs) zs"
     by simp
    ultimately have "take (length xs') (xs @ zs) =
      xs @ take (length xs' - length xs) zs"
      (is "_ = _ @ ?vs")
     by simp
    moreover have "take (length xs') (xs @ zs) =
      take (length xs') (xs' @ ys')"
     using I by simp
    ultimately have J: "xs @ ?vs = xs'"
     by simp
    moreover have "set xs \<subseteq> set (xs @ ?vs)"
     by simp
    ultimately have "set xs \<subseteq> set xs'"
     by simp
    hence K: "set xs \<subseteq> range p \<union> range q"
     using F by simp
    have "\<exists>R S T. ?F R S T [x\<leftarrow>zs. x \<in> range p \<union> range q]"
      (is "\<exists>_ _ _. ipurge_ref ?I' ?D' _ _ _ = _ \<and> _")
    proof (rule con_comp_secure_add_case_1 [OF A B C D E],
     rule_tac x = "range p \<inter> Z" in exI, rule_tac x = "range q \<inter> Z" in exI,
     rule_tac x = "- range p \<inter> - range q \<inter> Z" in exI,
     (subst conj_assoc [symmetric])+, (rule conjI)+, simp_all del: filter_append)
      show "Z = range p \<inter> Z \<union> range q \<inter> Z \<union> - range p \<inter> - range q \<inter> Z"
       by blast
    next
      show "set xs \<subseteq> range p \<union> range q"
       using K .
    next
      show "{x \<in> set zs. x \<in> range p \<or> x \<in> range q} \<subseteq> range p \<union> range q"
       by blast
    next
      show "- range p \<inter> - range q \<inter> Z \<subseteq> - range p"
       by blast
    next
      show "- range p \<inter> - range q \<inter> Z \<subseteq> - range q"
       by blast
    next
      have "map (inv p) [x\<leftarrow>xs @ ?vs. x \<in> range p] \<in> divergences P"
       using G and J by simp
      hence "map (inv p) [x\<leftarrow>xs @ ?vs. x \<in> range p] @
        map (inv p) [x\<leftarrow>drop (length xs' - length xs) zs. x \<in> range p]
        \<in> divergences P"
        (is "_ @ map (inv p) [x\<leftarrow>?ws. _] \<in> _")
       by (rule process_rule_5_general)
      hence "map (inv p) [x\<leftarrow>(xs @ ?vs) @ ?ws. x \<in> range p] \<in> divergences P"
       by (subst filter_append, simp)
      hence "map (inv p) [x\<leftarrow>xs @ zs. x \<in> range p] \<in> divergences P"
       by simp
      hence "map (inv p) [x\<leftarrow>xs @ [x\<leftarrow>zs. x \<in> range p \<or> x \<in> range q].
        x \<in> range p] \<in> divergences P"
      proof (subst (asm) filter_append, subst filter_append, subst filter_filter)
      qed (subgoal_tac "(\<lambda>x. (x \<in> range p \<or> x \<in> range q) \<and> x \<in> range p) =
       (\<lambda>x. x \<in> range p)", simp, blast)
      thus "(map (inv p) [x\<leftarrow>xs @ [x\<leftarrow>zs. x \<in> range p \<or> x \<in> range q].
        x \<in> range p], inv p ` (range p \<inter> Z)) \<in> failures P"
       by (rule process_rule_6)
    next
      have "map (inv q) [x\<leftarrow>xs @ ?vs. x \<in> range q] \<in> divergences Q"
       using H and J by simp
      hence "map (inv q) [x\<leftarrow>xs @ ?vs. x \<in> range q] @
        map (inv q) [x\<leftarrow>drop (length xs' - length xs) zs. x \<in> range q]
        \<in> divergences Q"
        (is "_ @ map (inv q) [x\<leftarrow>?ws. _] \<in> _")
       by (rule process_rule_5_general)
      hence "map (inv q) [x\<leftarrow>(xs @ ?vs) @ ?ws. x \<in> range q] \<in> divergences Q"
       by (subst filter_append, simp)
      hence "map (inv q) [x\<leftarrow>xs @ zs. x \<in> range q] \<in> divergences Q"
       by simp
      hence "map (inv q) [x\<leftarrow>xs @ [x\<leftarrow>zs. x \<in> range p \<or> x \<in> range q].
        x \<in> range q] \<in> divergences Q"
      proof (subst (asm) filter_append, subst filter_append, subst filter_filter)
      qed (subgoal_tac "(\<lambda>x. (x \<in> range p \<or> x \<in> range q) \<and> x \<in> range q) =
       (\<lambda>x. x \<in> range q)", simp, blast)
      thus "(map (inv q) [x\<leftarrow>xs @ [x\<leftarrow>zs. x \<in> range p \<or> x \<in> range q].
        x \<in> range q], inv q ` (range q \<inter> Z)) \<in> failures Q"
       by (rule process_rule_6)
    qed
    then obtain R and S and T where
     "?F R S T [x\<leftarrow>zs. x \<in> range p \<union> range q]"
     by blast
    thus "\<exists>R S T. ?F R S T zs"
    proof (rule_tac x = R in exI, rule_tac x = S in exI, rule_tac x = T in exI)
    qed (simp only: con_comp_ipurge_tr_filter con_comp_ipurge_ref_filter)
  next
    let
      ?I' = "con_comp_pol I" and
      ?D' = "con_comp_map D E p q"
    case False
    moreover have "xs @ y # ipurge_tr ?I' ?D' (?D' y) zs =
      take (length xs') (xs @ y # ipurge_tr ?I' ?D' (?D' y) zs) @
      drop (length xs') (xs @ y # ipurge_tr ?I' ?D' (?D' y) zs)"
      (is "_ = _ @ ?vs")
     by (simp only: append_take_drop_id)
    ultimately have "xs @ y # ipurge_tr ?I' ?D' (?D' y) zs =
      take (length xs') (xs @ zs) @ ?vs"
     by simp
    hence J: "xs @ y # ipurge_tr ?I' ?D' (?D' y) zs = xs' @ ?vs"
     using I by simp
    show ?G
    proof (rule_tac x = xs' in exI, rule conjI, rule_tac x = ?vs in exI)
    qed (subst J, simp_all add: F G H)
  qed
qed

theorem con_comp_secure:
  assumes
    A: "consistent_maps D E p q" and
    B: "secure P I D" and
    C: "secure Q I E"
  shows "secure (P \<parallel> Q <p, q>) (con_comp_pol I) (con_comp_map D E p q)"
proof (simp add: secure_def con_comp_futures, (rule allI)+, rule impI,
 erule conjE, rule conjI, (erule rev_mp)+, rotate_tac [2], erule_tac [2] rev_mp)
  fix xs y ys Y zs Z
  show
   "(xs @ zs, Z) \<in> con_comp_failures P Q p q \<longrightarrow>
    (xs @ y # ys, Y) \<in> con_comp_failures P Q p q \<longrightarrow>
      (xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
         (con_comp_map D E p q y) ys,
       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)
         (con_comp_map D E p q y) ys Y)
      \<in> con_comp_failures P Q p q"
    (is "_ \<longrightarrow> _ \<longrightarrow> (_ @ ipurge_tr ?I' ?D' _ _, _) \<in> _")
  proof ((rule impI)+, thin_tac "(xs @ zs, Z) \<in> con_comp_failures P Q p q",
   simp_all add: con_comp_failures_def con_comp_divergences_def
   del: filter_append, erule disjE, rule disjI1)
  qed (erule con_comp_secure_del_case_1 [OF A B C],
   rule con_comp_secure_del_case_2 [OF A B C])
next
  fix xs y ys Y zs Z
  assume D: "(xs @ y # ys, Y) \<in> con_comp_failures P Q p q"
  show
   "(xs @ zs, Z) \<in> con_comp_failures P Q p q \<longrightarrow>
      (xs @ y # ipurge_tr (con_comp_pol I) (con_comp_map D E p q)
         (con_comp_map D E p q y) zs,
       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)
         (con_comp_map D E p q y) zs Z)
      \<in> con_comp_failures P Q p q"
    (is "_ \<longrightarrow> (_ @ _ # ipurge_tr ?I' ?D' _ _, _) \<in> _")
  proof (rule impI, simp_all add: con_comp_failures_def con_comp_divergences_def
   del: filter_append, cases "y \<in> range p \<or> y \<in> range q", simp del: filter_append,
   erule disjE, rule disjI1, rule_tac [3] disjI2)
  qed (erule con_comp_secure_add_case_1 [OF A B C D], assumption,
   erule con_comp_secure_add_case_2 [OF A B C D], assumption,
   rule con_comp_failures_divergences [OF D], simp_all)
qed


subsection "Conservation of noninterference security in the absence of fake events"


lemma con_comp_sinks_range:
 "u \<in> range Some \<Longrightarrow>
  set xs \<subseteq> range p \<union> range q \<Longrightarrow>
    sinks (con_comp_pol I) (con_comp_map D E p q) u xs \<subseteq> range Some"
by (insert con_comp_sinks_aux_range [of "{u}" xs p q I D E],
 simp add: sinks_aux_single_dom)

lemma con_comp_sinks_no_fake:
  assumes
    A: "range p \<union> range q = UNIV" and
    B: "u \<in> range Some"
  shows "sinks I (the \<circ> con_comp_map D E p q) (the u) xs =
    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs"
    (is "_ = the ` sinks ?I' ?D' _ _")
proof (induction xs rule: rev_induct, simp)
  fix x xs
  assume C: "sinks I (the \<circ> ?D') (the u) xs = the ` sinks ?I' ?D' u xs"
  have "x \<in> range p \<union> range q"
   using A by simp
  hence D: "?D' x = Some (the (?D' x))"
   by (cases "x \<in> range p", simp_all)
  have E: "u = Some (the u)"
   using B by (simp add: image_iff)
  show "sinks I (the \<circ> ?D') (the u) (xs @ [x]) = the ` sinks ?I' ?D' u (xs @ [x])"
  proof (cases "(u, ?D' x) \<in> ?I' \<or> (\<exists>v \<in> sinks ?I' ?D' u xs. (v, ?D' x) \<in> ?I')")
    case True
    hence "sinks ?I' ?D' u (xs @ [x]) = insert (?D' x) (sinks ?I' ?D' u xs)"
     by simp
    moreover have "(the u, the (?D' x)) \<in> I \<or>
      (\<exists>d \<in> sinks I (the \<circ> ?D') (the u) xs. (d, the (?D' x)) \<in> I)"
    proof (rule disjE [OF True], rule disjI1, rule_tac [2] disjI2)
      assume "(u, ?D' x) \<in> ?I'"
      hence "(Some (the u), Some (the (?D' x))) \<in> ?I'"
       using D and E by simp
      thus "(the u, the (?D' x)) \<in> I"
       by (simp add: con_comp_pol_def)
    next
      assume "\<exists>v \<in> sinks ?I' ?D' u xs. (v, ?D' x) \<in> ?I'"
      then obtain v where F: "v \<in> sinks ?I' ?D' u xs" and G: "(v, ?D' x) \<in> ?I'" ..
      have "sinks ?I' ?D' u xs \<subseteq> range Some"
       by (rule con_comp_sinks_range, simp_all add: A B)
      hence "v \<in> range Some"
       using F ..
      hence "v = Some (the v)"
       by (simp add: image_iff)
      hence "(Some (the v), Some (the (?D' x))) \<in> ?I'"
       using D and G by simp
      hence "(the v, the (?D' x)) \<in> I"
       by (simp add: con_comp_pol_def)
      moreover have "the v \<in> sinks I (the \<circ> ?D') (the u) xs"
       using C and F by simp
      ultimately show "\<exists>d \<in> sinks I (the \<circ> ?D') (the u) xs.
        (d, the (?D' x)) \<in> I" ..
    qed
    hence "sinks I (the \<circ> ?D') (the u) (xs @ [x]) =
      insert (the (?D' x)) (sinks I (the \<circ> ?D') (the u) xs)"
     by simp
    ultimately show ?thesis
     using C by simp
  next
    case False
    hence "sinks ?I' ?D' u (xs @ [x]) = sinks ?I' ?D' u xs"
     by simp
    moreover have "\<not> ((the u, the (?D' x)) \<in> I \<or>
      (\<exists>v \<in> sinks I (the \<circ> ?D') (the u) xs. (v, the (?D' x)) \<in> I))"
    proof (insert False, simp, erule conjE, rule conjI, rule_tac [2] ballI)
      assume "(u, ?D' x) \<notin> ?I'"
      hence "(Some (the u), Some (the (?D' x))) \<notin> ?I'"
       using D and E by simp
      thus "(the u, the (?D' x)) \<notin> I"
       by (simp add: con_comp_pol_def)
    next
      fix d
      assume "d \<in> sinks I (the \<circ> ?D') (the u) xs"
      hence "d \<in> the ` sinks ?I' ?D' u xs"
       using C by simp
      hence "\<exists>v \<in> sinks ?I' ?D' u xs. d = the v"
       by (simp add: image_iff)
      then obtain v where F: "v \<in> sinks ?I' ?D' u xs" and G: "d = the v" ..
      have "sinks ?I' ?D' u xs \<subseteq> range Some"
       by (rule con_comp_sinks_range, simp_all add: A B)
      hence "v \<in> range Some"
       using F ..
      hence H: "v = Some d"
       using G by (simp add: image_iff)
      assume "\<forall>v \<in> sinks ?I' ?D' u xs. (v, ?D' x) \<notin> ?I'"
      hence "(v, ?D' x) \<notin> ?I'"
       using F ..
      hence "(Some d, Some (the (?D' x))) \<notin> ?I'"
       using D and H by simp
      thus "(d, the (?D' x)) \<notin> I"
       by (simp add: con_comp_pol_def)
    qed
    hence "sinks I (the \<circ> ?D') (the u) (xs @ [x]) = sinks I (the \<circ> ?D') (the u) xs"
     by simp
    ultimately show ?thesis
     using C by simp
  qed
qed

lemma con_comp_ipurge_tr_no_fake:
  assumes
    A: "range p \<union> range q = UNIV" and
    B: "u \<in> range Some"
  shows "ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs =
    ipurge_tr I (the \<circ> con_comp_map D E p q) (the u) xs"
    (is "ipurge_tr ?I' ?D' _ _ = _")
proof (induction xs rule: rev_induct, simp)
  fix x xs
  assume C: "ipurge_tr ?I' ?D' u xs = ipurge_tr I (the \<circ> ?D') (the u) xs"
  show "ipurge_tr ?I' ?D' u (xs @ [x]) = ipurge_tr I (the \<circ> ?D') (the u) (xs @ [x])"
  proof (cases "?D' x \<in> sinks ?I' ?D' u (xs @ [x])")
    case True
    hence "ipurge_tr ?I' ?D' u (xs @ [x]) = ipurge_tr ?I' ?D' u xs"
     by simp
    moreover have "the (?D' x) \<in> the ` sinks ?I' ?D' u (xs @ [x])"
     using True by simp
    hence "the (?D' x) \<in> sinks I (the \<circ> ?D') (the u) (xs @ [x])"
     by (subst con_comp_sinks_no_fake [OF A B])
    hence "ipurge_tr I (the \<circ> ?D') (the u) (xs @ [x]) =
      ipurge_tr I (the \<circ> ?D') (the u) xs"
     by simp
    ultimately show ?thesis
     using C by simp
  next
    case False
    hence "ipurge_tr ?I' ?D' u (xs @ [x]) = ipurge_tr ?I' ?D' u xs @ [x]"
     by simp
    moreover have "the (?D' x) \<notin> the ` sinks ?I' ?D' u (xs @ [x])"
    proof
      assume "the (?D' x) \<in> the ` sinks ?I' ?D' u (xs @ [x])"
      hence "\<exists>v \<in> sinks ?I' ?D' u (xs @ [x]). the (?D' x) = the v"
       by (simp add: image_iff)
      then obtain v where
        D: "v \<in> sinks ?I' ?D' u (xs @ [x])" and E: "the (?D' x) = the v" ..
      have "x \<in> range p \<union> range q"
       using A by simp
      hence "\<exists>d. ?D' x = Some d"
       by (cases "x \<in> range p", simp_all)
      then obtain d where "?D' x = Some d" ..
      moreover have "sinks ?I' ?D' u (xs @ [x]) \<subseteq> range Some"
       by (rule con_comp_sinks_range, simp_all add: A B)
      hence "v \<in> range Some"
       using D ..
      hence "\<exists>d'. v = Some d'"
       by (simp add: image_iff)
      then obtain d' where "v = Some d'" ..
      ultimately have "?D' x = v"
       using E by simp
      hence "?D' x \<in> sinks ?I' ?D' u (xs @ [x])"
       using D by simp
      thus False
       using False by contradiction
    qed
    hence "the (?D' x) \<notin> sinks I (the \<circ> ?D') (the u) (xs @ [x])"
     by (subst con_comp_sinks_no_fake [OF A B])
    hence "ipurge_tr I (the \<circ> ?D') (the u) (xs @ [x]) =
      ipurge_tr I (the \<circ> ?D') (the u) xs @ [x]"
     by simp
    ultimately show ?thesis
     using C by simp
  qed
qed

lemma con_comp_ipurge_ref_no_fake:
  assumes
    A: "range p \<union> range q = UNIV" and
    B: "u \<in> range Some"
  shows "ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u xs X =
    ipurge_ref I (the \<circ> con_comp_map D E p q) (the u) xs X"
    (is "ipurge_ref ?I' ?D' _ _ _ = _")
proof (simp add: ipurge_ref_def set_eq_iff, rule allI,
 simp_all add: con_comp_sinks_no_fake [OF A B])
  fix x
  have "x \<in> range p \<union> range q"
   using A by simp
  hence C: "?D' x = Some (the (?D' x))"
   by (cases "x \<in> range p", simp_all)
  have D: "u = Some (the u)"
   using B by (simp add: image_iff)
  show
   "(x \<in> X \<and> (u, ?D' x) \<notin> con_comp_pol I \<and>
      (\<forall>v \<in> sinks ?I' ?D' u xs. (v, ?D' x) \<notin> con_comp_pol I)) =
    (x \<in> X \<and> (the u, the (?D' x)) \<notin> I \<and>
      (\<forall>v \<in> sinks ?I' ?D' u xs. (the v, the (?D' x)) \<notin> I))"
  proof (rule iffI, (erule_tac [!] conjE)+, simp_all, rule_tac [!] conjI,
   rule_tac [2] ballI, rule_tac [4] ballI)
    assume "(u, ?D' x) \<notin> ?I'"
    hence "(Some (the u), Some (the (?D' x))) \<notin> ?I'"
     using C and D by simp
    thus "(the u, the (?D' x)) \<notin> I"
     by (simp add: con_comp_pol_def)
  next
    fix v
    assume "\<forall>v \<in> sinks ?I' ?D' u xs. (v, ?D' x) \<notin> ?I'" and
      E: "v \<in> sinks ?I' ?D' u xs"
    hence "(v, ?D' x) \<notin> ?I'" ..
    moreover have "sinks ?I' ?D' u xs \<subseteq> range Some"
     by (rule con_comp_sinks_range, simp_all add: A B)
    hence "v \<in> range Some"
     using E ..
    hence "v = Some (the v)"
     by (simp add: image_iff)
    ultimately have "(Some (the v), Some (the (?D' x))) \<notin> ?I'"
     using C by simp
    thus "(the v, the (?D' x)) \<notin> I"
     by (simp add: con_comp_pol_def)
  next
    assume "(the u, the (?D' x)) \<notin> I"
    hence "(Some (the u), Some (the (?D' x))) \<notin> ?I'"
     by (simp add: con_comp_pol_def)
    thus "(u, ?D' x) \<notin> ?I'"
     using C and D by simp
  next
    fix v
    assume "\<forall>v \<in> sinks ?I' ?D' u xs. (the v, the (?D' x)) \<notin> I" and
      E: "v \<in> sinks ?I' ?D' u xs"
    hence "(the v, the (?D' x)) \<notin> I" ..
    hence "(Some (the v), Some (the (?D' x))) \<notin> ?I'"
     by (simp add: con_comp_pol_def)
    moreover have "sinks ?I' ?D' u xs \<subseteq> range Some"
     by (rule con_comp_sinks_range, simp_all add: A B)
    hence "v \<in> range Some"
     using E ..
    hence "v = Some (the v)"
     by (simp add: image_iff)
    ultimately show "(v, ?D' x) \<notin> ?I'"
     using C by simp
  qed
qed

theorem con_comp_secure_no_fake:
  assumes
    A: "range p \<union> range q = UNIV" and
    B: "consistent_maps D E p q" and
    C: "secure P I D" and
    D: "secure Q I E"
  shows "secure (P \<parallel> Q <p, q>) I (the \<circ> con_comp_map D E p q)"
proof (insert con_comp_secure [OF B C D], simp add: secure_def,
 (rule allI)+, rule impI)
  fix xs y ys Y zs Z
  let
    ?I' = "con_comp_pol I" and
    ?D' = "con_comp_map D E p q"
  have "y \<in> range p \<union> range q"
   using A by simp
  hence E: "?D' y \<in> range Some"
   by (cases "y \<in> range p", simp_all)
  assume "\<forall>xs y ys Y zs Z.
    (y # ys, Y) \<in> futures (P \<parallel> Q <p, q>) xs \<and>
    (zs, Z) \<in> futures (P \<parallel> Q <p, q>) xs \<longrightarrow>
      (ipurge_tr ?I' ?D' (?D' y) ys, ipurge_ref ?I' ?D' (?D' y) ys Y)
        \<in> futures (P \<parallel> Q <p, q>) xs \<and>
      (y # ipurge_tr ?I' ?D' (?D' y) zs, ipurge_ref ?I' ?D' (?D' y) zs Z)
        \<in> futures (P \<parallel> Q <p, q>) xs" and
   "(y # ys, Y) \<in> futures (P \<parallel> Q <p, q>) xs \<and>
    (zs, Z) \<in> futures (P \<parallel> Q <p, q>) xs"
  hence
   "(ipurge_tr ?I' ?D' (?D' y) ys, ipurge_ref ?I' ?D' (?D' y) ys Y)
      \<in> futures (P \<parallel> Q <p, q>) xs \<and>
    (y # ipurge_tr ?I' ?D' (?D' y) zs, ipurge_ref ?I' ?D' (?D' y) zs Z)
      \<in> futures (P \<parallel> Q <p, q>) xs"
   by blast
  thus
   "(ipurge_tr I (the \<circ> ?D') (the (?D' y)) ys,
      ipurge_ref I (the \<circ> ?D') (the (?D' y)) ys Y) \<in> futures (P \<parallel> Q <p, q>) xs \<and>
    (y # ipurge_tr I (the \<circ> ?D') (the (?D' y)) zs,
      ipurge_ref I (the \<circ> ?D') (the (?D' y)) zs Z) \<in> futures (P \<parallel> Q <p, q>) xs"
   by (simp add: con_comp_ipurge_tr_no_fake [OF A E]
    con_comp_ipurge_ref_no_fake [OF A E])
qed

end
