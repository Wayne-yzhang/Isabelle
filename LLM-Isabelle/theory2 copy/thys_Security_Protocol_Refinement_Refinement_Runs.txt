theory Runs imports Atoms
begin




datatype role_t = Init | Resp | Serv

fun 
  roleIdx :: "role_t \<Rightarrow> nat"
where
  "roleIdx Init = 0"
| "roleIdx Resp = 1"
| "roleIdx Serv = 2"



type_synonym
  rid_t = "fid_t"

type_synonym
  runs_t = "rid_t \<rightharpoonup> role_t \<times> agent list \<times> atom list"




definition 
  map_runs :: "([role_t, atom list] \<Rightarrow> atom list) \<Rightarrow> runs_t \<Rightarrow> runs_t"
where
  "map_runs h runz rid \<equiv> case runz rid of
     None \<Rightarrow> None
   | Some (rol, agts, al) \<Rightarrow> Some (rol, agts, h rol al)"

lemma map_runs_empty [simp]: "map_runs h Map.empty = Map.empty"
by (rule ext) (auto simp add: map_runs_def)

lemma map_runs_dom [simp]: "dom (map_runs h runz) = dom runz"
by (auto simp add: map_runs_def split: option.split_asm)

lemma map_runs_update [simp]:
  "map_runs h (runz(R \<mapsto> (rol, agts, al))) 
   = (map_runs h runz)(R \<mapsto> (rol, agts, h rol al))"
by (auto simp add: map_runs_def)



end
