theory Test_Side_Conditions
imports Dict_Construction
begin


fun head where
"head (x # _) = x"


lemma head_side_eq: "head_side xs \<longleftrightarrow> xs \<noteq> []"
by (cases xs) (auto intro: head_side.intros elim: head_side.cases)


fun map where
"map f [] = []" |
"map f (x # xs) = f x # map f xs"

thm map_side.intros


experiment begin


  fun tail where
  "tail (_ # xs) = xs"


  lemma tail_side_eq: "tail_side xs \<longleftrightarrow> xs \<noteq> []"
  by (cases xs) (auto intro: tail_side.intros elim: tail_side.cases)


  function map' where
  "map' f xs = (if xs = [] then [] else f (head xs) # map' f (tail xs))"
  by auto

  termination
    apply (relation "measure (size \<circ> snd)")
    apply rule
    subgoal for f xs by (cases xs) auto
    done

  thm map'_side.intros


end

lemma map_cong:
  assumes "xs = ys" "\<And>x. x \<in> set ys \<Longrightarrow> f x = g x"
  shows "map f xs = map g ys"
unfolding assms(1)
using assms(2)
by (induction ys) auto

definition map_head where
"map_head xs = map head xs"

experiment begin

  declare map_cong[fundef_cong]

  thm map_head_side.intros

  lemma "map_head_side xs \<longleftrightarrow> (\<forall>x \<in> set xs. x \<noteq> [])"
  by (auto intro: map_head_side.intros elim: map_head_side.cases)

  definition map_head' where
  "map_head' xss = map (map head) xss"

  thm map_head'_side.intros

  lemma "map_head'_side xss \<longleftrightarrow> (\<forall>xs \<in> set xss. \<forall>x \<in> set xs. x \<noteq> [])"
  by (auto intro: map_head'_side.intros elim: map_head'_side.cases)

end

experiment begin

  term map_head_side
  thm map_head_side.intros

  lemma "\<not> map_head_side xs"
  by (auto elim: map_head_side.cases)

end


definition head_known where
"head_known xs = head (3 # xs)"

thm head_known_side.intros


fun odd :: "nat \<Rightarrow> bool" and even where
"odd 0 \<longleftrightarrow> False" |
"even 0 \<longleftrightarrow> True" |
"odd (Suc n) \<longleftrightarrow> even n" |
"even (Suc n) \<longleftrightarrow> odd n"

thm odd_side_even_side.intros


definition odd_known where
"odd_known = odd (Suc 0)"

thm odd_known_side.intros


end