theory Binary_Code_Imprimitive
  imports
    Combinatorics_Words_Graph_Lemma.Glued_Codes
    Binary_Square_Interpretation
begin



context code

begin


lemma shift_disjoint:
  assumes  "ws \<in> lists \<C>" and "ws' \<in> lists \<C>" and  "z \<notin> \<langle>\<C>\<rangle>" and "z \<cdot> concat ws = concat ws' \<cdot> z"
    "us \<le>p ws\<^sup>@n" and "vs \<le>p ws'\<^sup>@n"
  shows "z \<cdot> concat us \<noteq> concat vs"
proof (elim contrapos_nn)
  assume "z \<cdot> concat us = concat vs"
  have "z \<noteq> \<epsilon>"
  obtain us' where "ws\<^sup>@n = us \<cdot> us'"
  obtain vs' where "ws'\<^sup>@n = vs \<cdot> vs'"
  have "z \<cdot> concat (ws\<^sup>@n)  = concat (ws'\<^sup>@n) \<cdot> z"
    unfolding concat_pow.
  have "concat vs' \<cdot> z = concat us'"..
  show "z \<in> \<langle>\<C>\<rangle>"
  proof (rule stability)
    have "us \<in> lists \<C>" and "us' \<in> lists \<C>" and "vs \<in> lists \<C>" and "vs' \<in> lists \<C>"
      by inlists
    thus "z \<cdot> concat us \<in> \<langle>\<C>\<rangle>" and "concat vs' \<in> \<langle>\<C>\<rangle>" and "concat us \<in> \<langle>\<C>\<rangle>" and "concat vs' \<cdot> z \<in> \<langle>\<C>\<rangle>"
      by (simp_all add: concat_in_hull')
  qed
qed


lemma  shift_interp:
  assumes  "ws \<in> lists \<C>" and "ws' \<in> lists \<C>"  and "z \<notin> \<langle>\<C>\<rangle>" and
    conjug: "z \<cdot> concat ws = concat ws' \<cdot> z" and "\<^bold>|z\<^bold>| \<le> \<^bold>|concat ws'\<^bold>|"
    and "us \<le>p ws" and "us \<noteq> \<epsilon>"
  obtains p s vs ps where
     "p us s \<sim>\<^sub>\<D> vs" and "vs \<in> lists \<C>"
     and "ps \<cdot> vs \<le>p ws' \<cdot> ws'" and "concat ps \<cdot> p = z"
proof-
  have "ws' \<cdot> ws' \<in> lists \<C>"
  have "concat us \<noteq> \<epsilon>"
  have "\<^bold>|concat ws'\<^bold>| = \<^bold>|concat ws\<^bold>|"
    using lenarg[OF conjug, unfolded lenmorph] by linarith
  have "z \<cdot> concat(ws \<cdot> ws) = concat (ws' \<cdot> ws') \<cdot> z"
    unfolding rassoc concat_morph conjug[symmetric] unfolding lassoc cancel_right
    using conjug.
  hence "concat (ws' \<cdot> ws') \<le>p z \<cdot> concat (ws \<cdot> ws)"
    by blast
  have "z \<cdot> concat ws \<le>p concat (ws' \<cdot> ws')"
  obtain su where fac_u[symmetric]: "concat (ws' \<cdot> ws') = z \<cdot> concat us \<cdot> su".

  obtain ps ss' p s vs where "p (concat us) s \<sim>\<^sub>\<I> vs" and
    "ps \<cdot> vs \<cdot> ss' = ws' \<cdot> ws'" and "concat ps \<cdot> p = z" and "s \<cdot> concat ss' = su".

  let ?ss = "us\<inverse>\<^sup>>(ws \<cdot> ws)"
  have "us \<cdot> ?ss = ws \<cdot> ws"

  have "ps \<cdot> vs \<le>p ws' \<cdot> ws'"

  hence "vs \<in> lists \<C>"
    by inlists

  have "s \<le>p concat ?ss"
    unfolding concat_morph rassoc pref_cancel_conv
    using append_prefixD by auto

  have "\<^bold>|p\<^bold>| \<le> \<^bold>|concat ws\<^bold>|"
    by simp

  have "p \<le>s concat ws"
    by blast

  have disjoint: "p \<cdot> concat us' \<noteq> concat vs'" if "us' \<le>p us" "vs' \<le>p vs" for us' vs'
  proof
    have "us' \<le>p ws \<cdot> ws"
    have "ps \<cdot> vs' \<le>p ws' \<cdot> ws'"
    assume "p \<cdot> concat us' = concat vs'"
    hence "z \<cdot> concat us' = concat (ps \<cdot> vs')"
    thus False
  qed
  from disjoint[of \<epsilon> \<epsilon>]
  have "p \<noteq> \<epsilon>" by blast
  have "s \<noteq> \<epsilon>"

  have "p us s \<sim>\<^sub>\<D> vs"
    by blast

  show thesis.
qed


lemma imprim_witness_shift:
  assumes "ws \<in> lists \<C>" and "primitive ws" and "\<not> primitive (concat ws)"
  obtains z n  where "concat ws = z\<^sup>@n" "z \<notin> \<langle>\<C>\<rangle>" and
    "z \<cdot> concat ws = concat ws \<cdot> z" and "\<^bold>|z\<^bold>| < \<^bold>|concat ws\<^bold>|" and "2 \<le> n"
proof-
  have "concat ws \<noteq> \<epsilon>"
  obtain z n where [symmetric]: "z\<^sup>@n = concat ws" and "2 \<le> n"

  hence "z \<noteq> \<epsilon>"

  have "z \<notin> \<langle>\<C>\<rangle>"
  proof
    assume "z \<in> \<langle>\<C>\<rangle>"
    then obtain zs where "zs \<in> lists \<C>" and "concat zs = z"
      using hull_concat_lists0 by blast
    show False
  qed

  have "\<^bold>|z\<^bold>| < \<^bold>|concat ws\<^bold>|"

  show thesis

qed

end



lemma cover_xy_xxx: assumes "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" and "p \<cdot> x \<cdot> y \<cdot> s = x \<cdot> x \<cdot> x"
  shows "x = y"
  using append_assoc assms(1) assms(2) eq_le_pref le_refl long_pref lq_triv prefI pref_comm_eq' by metis

lemma cover_xy_yyy: assumes "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" and eq: "p \<cdot> x \<cdot> y \<cdot> s = y \<cdot> y \<cdot> y"
  shows "x = y"

lemma cover_xy_xxy: assumes "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" and "s \<noteq> \<epsilon>" and eq: "p \<cdot> x \<cdot> y \<cdot> s = x \<cdot> x \<cdot> y"
  shows "x = y"
proof-
  have "\<^bold>|p\<^bold>| < \<^bold>|x\<^bold>|"
  then obtain t where x: "x = p \<cdot> t" and "t \<noteq> \<epsilon>"
    using eqd[OF eq] by force
  from eq[unfolded this rassoc cancel]
  have "p \<cdot> t = t \<cdot> p"
    by mismatch
  hence "x \<le>p t \<cdot> x"
    unfolding x by auto
  from eq[unfolded x]
  have "y \<le>p t \<cdot> y"
  show "x = y"
qed

lemma cover_xy_xyy: assumes "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" and "p \<noteq> \<epsilon>" and eq: "p \<cdot> x \<cdot> y \<cdot> s = x \<cdot> y \<cdot> y"
  shows "x = y"
  using cover_xy_xxy[reversed, unfolded rassoc, OF assms(1)[symmetric] assms(2) eq]..

lemma cover_xy_yyx: assumes "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" and eq: "p \<cdot> x \<cdot> y \<cdot> s = y \<cdot> y \<cdot> x"
  shows "x = y"
proof-
  have "\<^bold>|p\<^bold>| \<le> \<^bold>|y\<^bold>|"
    using lenarg[OF eq]  unfolding lenmorph by linarith
  then obtain t where y: "y = p \<cdot> t"
    using eqd[OF eq] by force
  have x: "x = t \<cdot> p" by blast
  from eq[unfolded x y rassoc cancel]
  have "p \<cdot> t = t \<cdot> p"
    by mismatch
  thus "x = y"
    unfolding x y..
qed

lemma cover_xy_yxx: assumes "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" and eq: "p \<cdot> x \<cdot> y \<cdot> s = y \<cdot> x \<cdot> x"
  shows "x = y"
  using cover_xy_yyx[reversed, unfolded rassoc, OF assms(1)[symmetric] eq]..

lemma cover_xy_xyx: assumes "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" and "p \<noteq> \<epsilon>" and "s \<noteq> \<epsilon>" and eq: "p \<cdot> x \<cdot> y \<cdot> s = x \<cdot> y \<cdot> x"
  shows "\<not> primitive (x \<cdot> y)"
proof
  assume "primitive (x \<cdot> y)"
  have "p \<cdot> (x \<cdot> y) \<cdot> (s \<cdot> y) = (x \<cdot> y) \<cdot> (x \<cdot> y)"
    unfolding lassoc eq[unfolded lassoc]..
  show False
qed

  shows "\<not> primitive (x \<cdot> y)"
  using cover_xy_xyx[reversed, unfolded rassoc, OF assms(1)[symmetric] assms(3) assms(2) eq].

theorem uniform_square_interp: assumes "x\<cdot>y \<noteq> y\<cdot>x" and  "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" and "vs \<in> lists {x,y}"
  and "p  (x \<cdot> y)  s \<sim>\<^sub>\<I> vs" and "p \<noteq> \<epsilon>"
shows "\<not> primitive (x\<cdot>y)" and  "vs = [x,y,x] \<or> vs = [y,x,y]"
proof-

  have "vs \<noteq> \<epsilon>"
  have "\<^bold>|p\<^bold>| < \<^bold>|x\<^bold>|"
    by fastforce
  have "\<^bold>|s\<^bold>| < \<^bold>|x\<^bold>|"
    by fastforce
  have "\<^bold>|concat vs\<^bold>| = \<^bold>|x\<^bold>| * \<^bold>|vs\<^bold>|"
    using assms(2-3)
  proof (induction vs)
    case (Cons a vs)
    have "\<^bold>|a\<^bold>| = \<^bold>|x\<^bold>|" and "\<^bold>|a # vs\<^bold>| = Suc \<^bold>|vs\<^bold>|" and
      "\<^bold>|concat (a # vs)\<^bold>| = \<^bold>|a\<^bold>| + \<^bold>|concat vs\<^bold>|" and "\<^bold>|concat vs\<^bold>| = \<^bold>|x\<^bold>| * \<^bold>|vs\<^bold>|"
    then show ?case by force
  qed simp
  hence "\<^bold>|x\<^bold>| * \<^bold>|vs\<^bold>| < \<^bold>|x\<^bold>| * 4" and  "2 * \<^bold>|x\<^bold>| < \<^bold>|x\<^bold>| * \<^bold>|vs\<^bold>| "
  hence "\<^bold>|vs\<^bold>| = 3"
    by force
  hence "s \<noteq> \<epsilon>"

  have "x \<noteq> y"
    using assms(1) by blast
  have "(\<not> primitive (x\<cdot>y)) \<and> (vs = [x,y,x] \<or> vs = [y,x,y])"
  proof(list_inspection, simp_all)
    assume "p \<cdot> x \<cdot> y \<cdot> s = x \<cdot> x \<cdot> x"
    show False
  next
    assume "p \<cdot> x \<cdot> y \<cdot> s = x \<cdot> x \<cdot> y"
    show False
  next
    assume "p \<cdot> x \<cdot> y \<cdot> s = x \<cdot> y \<cdot> x"
    show "\<not> primitive (x \<cdot> y)"
      by blast
  next
    assume "p \<cdot> x \<cdot> y \<cdot> s = x \<cdot> y \<cdot> y"
    show False
  next
    assume "p \<cdot> x \<cdot> y \<cdot> s = y \<cdot> x \<cdot> x"
    show False
  next
    assume "p \<cdot> x \<cdot> y \<cdot> s = y \<cdot> x \<cdot> y"
    show "\<not> primitive (x \<cdot> y)"
      by blast
  next
    assume "p \<cdot> x \<cdot> y \<cdot> s = y \<cdot> y \<cdot> x"
    show False
  next
    assume "p \<cdot> x \<cdot> y \<cdot> s = y \<cdot> y \<cdot> y"
    show False
  qed
  thus "\<not> primitive (x\<cdot>y)" "vs = [x,y,x] \<or> vs = [y,x,y]"
    by blast+
qed



theorem bin_uniform_prim_morph:
  assumes "x \<cdot> y \<noteq> y \<cdot> x" and "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" and "primitive (x \<cdot> y)"
         and "ws \<in> lists {x,y}" and "2 \<le> \<^bold>|ws\<^bold>|"
         shows "primitive ws \<longleftrightarrow>  primitive (concat ws)"
proof (standard, rule ccontr)
  obtain ws' where "ws \<sim> ws'" "[x, y] \<le>p ws'".
  have "ws' \<in> lists {x,y}"
  have "primitive ws'"
  have "\<not> primitive (concat ws')"
  interpret code "{x,y}"

  have "[x,y] \<noteq> \<epsilon>" by blast
  obtain z n where "concat ws' = z \<^sup>@ n" "z \<notin> \<langle>{x, y}\<rangle>" "z \<cdot> concat ws' = concat ws' \<cdot> z" "\<^bold>|z\<^bold>| < \<^bold>|concat ws'\<^bold>|".
  obtain p s vs ps where "p [x, y] s \<sim>\<^sub>\<D> vs" "vs \<in> lists {x, y}" "s \<le>p concat ([x, y]\<inverse>\<^sup>>(ws' \<cdot> ws'))"
        "p \<le>s concat ws'" "ps \<cdot> vs \<le>p ws' \<cdot> ws'" "concat ps \<cdot> p = z".
  show False by force
qed (simp add: prim_concat_prim)


lemma bin_uniform_imprim: assumes "x \<cdot> y \<noteq> y \<cdot> x" and "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" and "\<not> primitive (x \<cdot> y)"
  shows "primitive x"
proof-
  have "x \<cdot> y \<noteq> \<epsilon>" and "x \<noteq> \<epsilon>" and "y \<noteq> \<epsilon>"
  obtain z k where "primitive z" and  "2 \<le> k" and "z\<^sup>@k = x \<cdot> y".
  hence "0 < k"
    by simp
  obtain u v l m where [symmetric]: "z = u \<cdot> v" and "v \<noteq> \<epsilon>" "x = (u\<cdot>v) \<^sup>@ l \<cdot> u"  "y = (v \<cdot> u) \<^sup>@ m \<cdot> v" "k = l + m + 1".
  have "u \<cdot> v \<noteq> v \<cdot> u"
      shifts unfolding add_exps[symmetric] add.commute[of m] by force
  have "u \<noteq> \<epsilon>" and "v \<noteq> \<epsilon>" and "u \<noteq> v"
  have "m = l" and "\<^bold>|u\<^bold>| = \<^bold>|v\<^bold>|"
  have "l \<noteq> 0"
  let ?w = "[u,v]\<^sup>@l \<cdot> [u]"
  have "?w \<in> lists {u,v}"
    by (induct l, simp_all)
  have "2 \<le> \<^bold>|?w\<^bold>|"
  have "concat ?w = x"
  show "primitive x"
qed


theorem bin_uniform_prim_morph':
  assumes "x \<cdot> y \<noteq> y \<cdot> x" and "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" and "primitive (x \<cdot> y) \<or> \<not> primitive x \<or> \<not> primitive y"
         and "ws \<in> lists {x,y}" and "2 \<le> \<^bold>|ws\<^bold>|"
       shows "primitive ws \<longleftrightarrow>  primitive (concat ws)"
  using bin_uniform_prim_morph[OF assms(1-2) _ assms(4-5)] bin_uniform_imprim[OF assms(1-2)]
        bin_uniform_imprim[OF assms(1-2)[symmetric], unfolded conjug_prim_iff'[of y]]
        assms(3) by blast




lemma bin_imprim_single_y:
  assumes  non_comm: "x \<cdot> y \<noteq> y \<cdot> x" and
    "ws \<in> lists {x,y}" and
    "\<^bold>|y\<^bold>| \<le> \<^bold>|x\<^bold>|" and
    "2 \<le> count_list ws x" and
    "count_list ws y < 2" and
    "primitive ws" and
    "\<not> primitive (concat ws)"
  shows "ws \<sim> [x,x,y]" and "primitive x" and "primitive y"
proof-
  have "x \<noteq> y"
    using non_comm by blast
  have "count_list ws y \<noteq> 0"
  proof
    assume "count_list ws y = 0"
    have "ws \<in> lists {x}".
    show False
  qed
  hence "count_list ws y = 1"

  have "ws \<sim> [x]\<^sup>@count_list ws x \<cdot> [y]"
    using  non_comm (1) by metis
  from conjug_concat_prim_iff[OF this]
  have "\<not> primitive (x\<^sup>@(count_list ws x) \<cdot> y)"

  from not_prim_primroot_expE[OF this]
  obtain z l where [symmetric]: "z\<^sup>@l = x\<^sup>@(count_list ws x) \<cdot> y\<^sup>@1" and "2 \<le> l"
    unfolding pow_1.

  interpret LS_len_le x y "count_list ws x" 1 l z
    by (unfold_locales)

  have "primitive x" and "primitive y" and "count_list ws x = 2" by blast+

  show  "primitive x" and "primitive y" and "ws \<sim> [x,x,y]"
    by simp_all

qed


lemma bin_imprim_not_conjug:
  assumes "ws \<in> lists {x,y}" and
    "x \<cdot> y \<noteq> y \<cdot> x" and
    "2 \<le> \<^bold>|ws\<^bold>|" and
    "primitive ws" and
    "\<not> primitive (concat ws)"
  shows "\<not> x \<sim> y"
proof
  assume "x \<sim> y"
  hence "\<^bold>|x\<^bold>| = \<^bold>|y\<^bold>|" by force
  have "\<not> primitive (x\<cdot>y)"







  show False
qed



lemma bin_imprim_primitive:
  assumes "x \<cdot> y \<noteq> y \<cdot> x"
    and  "primitive x" and "primitive y"
    and "\<^bold>|y\<^bold>| \<le> \<^bold>|x\<^bold>|"
    and "ws \<in> lists {x, y}"
    and "primitive ws" and "\<not> primitive (concat ws)"
    and "[x, x] \<le>f ws \<cdot> ws"
  shows "ws \<sim> [x, x, y]"
proof-
  have "x \<noteq> y"
    using assms(1) by blast
  have "\<^bold>|ws\<^bold>| \<noteq> 1"
    by blast
  have "2 \<le> \<^bold>|ws\<^bold>|"
    by auto
  hence "\<^bold>|[x, x]\<^bold>| \<le> \<^bold>|ws\<^bold>|"
     by force
  have "\<not> x \<sim> y"
    by (rule bin_imprim_not_conjug) fact+
  have "primitive [x,x,y]"
  have "concat [x,x] = x \<cdot> x"
    by simp
  interpret xy: binary_code x y

  obtain ws' where "ws \<sim> ws'" "[x,x] \<le>p ws'"

  have "ws' \<in> lists {x,y}" and "primitive ws'" and "\<not> primitive (concat ws')"
  have "2 \<le> \<^bold>|ws'\<^bold>|" and "[x,x] \<noteq> \<epsilon>" and "ws' \<noteq> \<epsilon>"
  have "concat ws' \<noteq> \<epsilon>"
  have "ws' \<cdot> ws' \<cdot> ws' \<in> lists {x, y}" and "ws' \<cdot> ws' \<in> lists {x, y}"

  have "ws' = [x,x,y]"
  proof(rule ccontr)
    assume "ws' \<noteq> [x,x,y]"

    obtain z n where con_ws: "concat ws' = z \<^sup>@ n" and "z \<notin> \<langle>{x, y}\<rangle>" and "z \<cdot> concat ws' = concat ws' \<cdot> z"
        and "\<^bold>|z\<^bold>| < \<^bold>|concat ws'\<^bold>|" and "2 \<le> n".
    have "0 < n"
      "s \<le>p concat ([x,x]\<inverse>\<^sup>>(ws'\<cdot>ws'))" and "p \<le>s concat ws'" and "ps \<cdot> vs \<le>p ws' \<cdot> ws'" and "concat ps \<cdot> p = z".

    from disj_interp_nemp(1)[OF this(1)]
    have "p \<noteq> \<epsilon>" by simp

    have "p \<cdot> concat p1 \<noteq> concat p2" if  "p1 \<le>p [x, x]" and "p2 \<le>p vs" for p1 p2

    have "ps \<in> lists {x,y}"
    have "vs \<in> lists {x,y}"
    have "[x,x]\<inverse>\<^sup>>(ws'\<cdot>ws') \<in> lists {x,y}"
    have "p x \<cdot> x s \<sim>\<^sub>\<I> vs"

    interpret square_interp_ext x y p s vs
    proof (rule square_interp_ext.intro[OF square_interp.intro, unfolded square_interp_ext_axioms_def])
      show "(\<exists>pe. pe \<in> \<langle>{x, y}\<rangle> \<and> p \<le>s pe) \<and> (\<exists>se. se \<in> \<langle>{x, y}\<rangle> \<and> s \<le>p se)"
    qed fact+


    define xp where "xp = x \<cdot> p"

    have "concat [x,x,y] = xp \<cdot> xp"
      by (simp add: xxy_root xp_def)

    hence "ws' \<cdot> [x,x,y] \<noteq> [x,x,y] \<cdot> ws'"

    have "z \<cdot> xp \<noteq> xp \<cdot> z"
    proof
      assume "z \<cdot> xp = xp \<cdot> z"
      from comm_add_exp[symmetric, OF this[symmetric], of 2,
          THEN comm_add_exp, of n, unfolded pow_two]
      have "z\<^sup>@n \<cdot> xp \<cdot> xp = xp \<cdot> xp \<cdot> z\<^sup>@n"
        unfolding  rassoc.
      hence "concat ws' \<cdot> concat [x,x,y] = concat [x,x,y] \<cdot> concat ws'"
      from  xy.is_code[OF _ _ this[folded concat_morph]]
      have "ws' \<cdot> [x, x, y] = [x,x,y] \<cdot> ws'"
      thus False
    qed

    then interpret binary_code z xp
      by (unfold_locales)

    have "\<not> concat (ws' \<cdot> [x, x, y]) \<bowtie> concat ([x, x, y] \<cdot> ws')"
    proof (rule notI)
      assume "concat (ws' \<cdot> [x, x, y]) \<bowtie> concat ([x, x, y] \<cdot> ws')"
      have "z \<^sup>@ n \<cdot> xp\<^sup>@Suc(Suc 0) = xp\<^sup>@Suc(Suc 0) \<cdot> z \<^sup>@ n"
        unfolding pow_Suc pow_zero emp_simps rassoc.
      from comm_drop_exps[OF this]
      show False
    qed


    define lcp_ws where "lcp_ws = ws' \<cdot> [x,x,y] \<and>\<^sub>p [x,x,y] \<cdot> ws'"

    have "lcp_ws \<in> lists {x,y}"
      unfolding lcp_ws_def by inlists

    have lcp_xp_z: "concat (ws' \<cdot> [x,x,y]) \<and>\<^sub>p concat ([x,x,y] \<cdot> ws') = bin_lcp z (x \<cdot> p)"

    have "(concat lcp_ws) \<cdot> bin_lcp x y = bin_lcp z (x \<cdot> p)"
      show "ws' \<cdot> [x, x, y] \<in> lists {x, y}" and  "[x, x, y] \<cdot> ws' \<in> lists {x, y}"
        by inlists
    qed


    define ws'' where "ws'' = ps \<cdot> [x,y]"
    define lcp_ws' where "lcp_ws' = ws' \<cdot> ws'' \<and>\<^sub>p ws'' \<cdot> ws'"

    have "lcp_ws' \<in> lists {x,y}"
      unfolding lcp_ws'_def

    have "concat ws'' = z \<cdot> xp"

    have "ws' \<cdot> ws'' \<noteq> ws'' \<cdot> ws'"
    proof
      assume "ws' \<cdot> ws'' = ws'' \<cdot> ws'"
      from arg_cong[OF this, of concat, unfolded concat_morph con_ws
          unfolded lassoc pow_comm, unfolded rassoc cancel]
      show False
    qed

    have
      lcp_xp_z': "concat (ws' \<cdot> ws'') \<and>\<^sub>p concat (ws'' \<cdot> ws') = z \<cdot> bin_lcp z (x \<cdot> p)"
      unfolding lcp_ext_left[symmetric] bin_lcp_def shifts
      unfolding rassoc lcp_ext_left cancel
      unfolding bin_lcp_def xp_def rassoc emp_simps by linarith

    have "z \<cdot> bin_lcp z (x \<cdot> p) = concat (lcp_ws') \<cdot> bin_lcp x y"
      unfolding lcp_xp_z'[symmetric] lcp_ws'_def
    proof (rule xy.bin_code_lcp_concat')
      show "ws' \<cdot> ws'' \<in> lists {x, y}"
      thus "ws'' \<cdot> ws' \<in> lists {x, y}"
        by inlists
      show "\<not> concat (ws' \<cdot> ws'') \<bowtie> concat (ws'' \<cdot> ws')"
        unfolding rassoc comp_cancel
           comm_comp_eq_conv
    qed

    have "concat lcp_ws' = z \<cdot> concat lcp_ws"
      unfolding cancel_right[of "concat lcp_ws'" "bin_lcp x y" "z \<cdot> concat lcp_ws", symmetric]

    have "lcp_ws \<le>p ws' \<cdot> [x,x,y]"
      unfolding lcp_ws_def using  longest_common_prefix_prefix1.
    have "lcp_ws \<noteq> ws' \<cdot> [x,x,y]"
      unfolding lcp_ws_def lcp_pref_conv
    have "lcp_ws \<le>p ws' \<cdot> [x,x]"
      unfolding butlast_append by simp
    obtain ws''\<^sub>1 where "ws' \<cdot> ws' \<cdot> ws' = lcp_ws \<cdot> ws''\<^sub>1" using rassoc by metis

    have "ws' \<cdot> ps \<cdot> [x,y] \<le>p ws' \<cdot> ps \<cdot> [x,y,x]"
      by simp
    from pref_trans[OF pref_trans[OF longest_common_prefix_prefix1 this]]
    have "lcp_ws' \<le>p ws' \<cdot> ws' \<cdot> ws'"
      unfolding pref_cancel_conv[symmetric, of "ps \<cdot> [x,y,x]" "ws' \<cdot> ws'" ws'] by blast
    from prefixE[OF this]
    obtain ws''\<^sub>2 where "ws' \<cdot> ws' \<cdot> ws' = lcp_ws' \<cdot> ws''\<^sub>2".

    have "concat lcp_ws'\<cdot> concat ws''\<^sub>1 = z \<cdot> concat(lcp_ws) \<cdot> concat ws''\<^sub>1"
    also have "... = z \<cdot> concat (ws' \<cdot> ws' \<cdot> ws')"
    also have "... = concat (ws' \<cdot> ws' \<cdot> ws') \<cdot> z"
      unfolding concat_morph con_ws add_exps[symmetric]
        pow_Suc[symmetric] pow_Suc'[symmetric]..
    also have "... = concat lcp_ws'\<cdot> concat ws''\<^sub>2 \<cdot> z"
    finally have "concat ws''\<^sub>1 = concat ws''\<^sub>2 \<cdot> z"
      unfolding cancel.

    from xy.stability[of "concat ws''\<^sub>2"  "concat lcp_ws" z,
    have "z \<in> \<langle>{x, y}\<rangle>"
        append_in_lists_dest append_in_lists_dest' concat_in_hull' by metis
    thus False
  qed
  thus "ws \<sim> [x, x, y]"
qed


lemma bin_imprim_both_squares_prim:
  assumes "x \<cdot> y \<noteq> y \<cdot> x"
    and "ws \<in> lists {x, y}"
    and "primitive ws" and "\<not> primitive (concat ws)"
    and "[x, x] \<le>f ws \<cdot> ws"
    and "[y, y] \<le>f ws \<cdot> ws"
    and  "primitive x" and "primitive y"
  shows False
proof-
    by blast
  have "ws \<sim> [x, x, y] \<or> ws \<sim> [y, y, x]"
    by force
  hence "\<^bold>|ws\<^bold>| = 3"
    using conjug_len by force
  note[simp] = sublist_code(3)
  show False
   by list_inspection simp_all
qed

lemma bin_imprim_both_squares:
  assumes "x \<cdot> y \<noteq> y \<cdot> x"
    and "ws \<in> lists {x, y}"
    and "primitive ws" and "\<not> primitive (concat ws)"
    and "[x, x] \<le>f ws \<cdot> ws"
    and "[y, y] \<le>f ws \<cdot> ws"
  shows False
proof (rule bin_imprim_both_squares_prim)
  have "x \<noteq> \<epsilon>" and "y \<noteq> \<epsilon>" and "x \<noteq> y"
  let ?R = "\<lambda> x. [\<rho> x]\<^sup>@(e\<^sub>\<rho> x)"
  define ws' where "ws' = concat (map ?R ws)"
  show "\<rho> x \<cdot> \<rho> y \<noteq> \<rho> y \<cdot> \<rho> x"
  have [simp]: "a = x \<or> a = y \<Longrightarrow> [\<rho> a] \<^sup>@ e\<^sub>\<rho> a \<in> lists {\<rho> x, \<rho> y}" for a
    using insert_iff sing_pow_lists[of _ "{\<rho> x, \<rho> y}"] by metis
  show "ws' \<in> lists {\<rho> x, \<rho> y}"
    by (induction ws, simp_all)

  interpret binary_code x y
  note[simp] = sublist_code(3)
  have "\<^bold>|ws\<^bold>| \<le> 3 \<Longrightarrow> ws \<in> lists {x,y} \<Longrightarrow> x \<noteq> y \<Longrightarrow> [x, x] \<le>f ws \<cdot> ws \<Longrightarrow> [y, y] \<le>f ws \<cdot> ws \<Longrightarrow> False"
    by list_inspection simp_all
  show "primitive ws'"
    unfolding ws'_def  by fastforce

  show "\<not> primitive (concat ws')"

  have "concat(map ?R [x,x]) \<le>f ws' \<cdot> ws'" and "concat(map ?R [y,y]) \<le>f ws' \<cdot> ws'"
    unfolding ws'_def
    unfolding concat_morph  map_append.

  have "Suc (Suc (e\<^sub>\<rho> x + e\<^sub>\<rho> x - 2)) = e\<^sub>\<rho> x + e\<^sub>\<rho> x"
  have "concat (map ?R [x,x]) = [\<rho> x] \<^sup>@ (Suc (e\<^sub>\<rho> x -1) + Suc (e\<^sub>\<rho> x - 1))"
  hence "[\<rho> x, \<rho> x] \<le>f concat (map ?R [x,x])"
    by auto
  thus "[\<rho> x, \<rho> x] \<le>f ws' \<cdot> ws'"

  have "Suc (Suc (e\<^sub>\<rho> y + e\<^sub>\<rho> y - 2)) = e\<^sub>\<rho> y + e\<^sub>\<rho> y"
  have "concat (map ?R [y,y]) = [\<rho> y] \<^sup>@ (Suc (e\<^sub>\<rho> y -1) + Suc (e\<^sub>\<rho> y - 1))"
  hence "[\<rho> y, \<rho> y] \<le>f concat (map ?R [y,y])"
    by auto
  thus "[\<rho> y, \<rho> y] \<le>f ws' \<cdot> ws'"

  show "primitive (\<rho> x)" and "primitive (\<rho> y)"
qed


lemma bin_imprim_longer_twice:
  assumes "x \<cdot> y \<noteq> y \<cdot> x"
    and "ws \<in> lists {x, y}"
    and "\<^bold>|y\<^bold>| \<le> \<^bold>|x\<^bold>|"
    and "count_list ws x \<ge> 2"
    and "primitive ws" and "\<not> primitive (concat ws)"
  shows "ws \<sim> [x,x,y] \<and> primitive x \<and> primitive y"
  using assms proof (induction "\<^bold>|ws\<^bold>|" arbitrary: x y ws rule: less_induct)
  case less
  then show ?case
  proof (cases)
    assume "[x, x] \<le>f ws \<cdot> ws \<and> [y, y] \<le>f ws \<cdot> ws"
    have False by blast
    thus ?case by blast
  next
    assume missing_sq: "\<not> ([x, x] \<le>f ws \<cdot> ws \<and> [y, y] \<le>f ws \<cdot> ws)"
    then show ?case
    proof (cases)
      assume "count_list ws y < 2"
      with bin_imprim_single_y[OF less.prems(1-4) this less.prems(5-6)]
      show "ws \<sim> [x,x,y] \<and> primitive x \<and> primitive y"
        by blast
    next
      assume "\<not> count_list ws y < 2" hence "2 \<le> count_list ws y" by simp

      define x' where "x' = (if \<not> [x, x] \<le>f ws \<cdot> ws then x else y)"
      define y' where "y' = (if \<not> [x, x] \<le>f ws \<cdot> ws then y else x)"

      have "{x', y'} = {x, y}"
        by (simp add: doubleton_eq_iff x'_def y'_def)
      note cases = disjE[OF this[unfolded doubleton_eq_iff]]
      have "\<not> [x', x'] \<le>f ws \<cdot> ws"
        using missing_sq x'_def by presburger
      have "count_list ws x' \<ge> 2" and "count_list ws y' \<ge> 2"
      have "x' \<cdot>  y' \<noteq> y' \<cdot> x'"
      have "x' \<noteq> \<epsilon>" and "x' \<noteq> y'" and "x' \<cdot> y' \<noteq> y'"

      hence rot: "last ws = x' \<Longrightarrow> hd ws = x' \<Longrightarrow> butlast ws \<cdot> [x',x'] \<cdot> tl ws = ws \<cdot> ws"
        using append_butlast_last_id hd_tl hd_word rassoc by metis
      from this[THEN facI']
      have "last ws = x' \<Longrightarrow> hd ws \<noteq> x'"
      define ws' where "ws' = (if last ws \<noteq> x' then ws else tl ws \<cdot> [hd ws])"
      have "ws' \<sim> ws"
      hence counts': "count_list ws' x' \<ge> 2" "count_list ws' y' \<ge> 2"

      let ?ws = "glue x' ws'"
      have c1: "\<^bold>|?ws\<^bold>| < \<^bold>|ws\<^bold>|"
      hence c2: "(x' \<cdot> y') \<cdot> y' \<noteq> y' \<cdot> x' \<cdot> y'"

      have "ws' \<le>f ws \<cdot> ws"
      hence "\<not> [x', x'] \<le>f ws'"
      have "ws' \<in> lists {x',y'}"
      have  c3: "?ws \<in> lists {x' \<cdot> y', y'}"

      have c4: "2 \<le> count_list (glue x' ws') (x' \<cdot> y')"

      have c5: "primitive (glue x' ws')"

      have "count_list ws' x' \<ge> 2"

      have "concat (glue x' ws') = concat ws'"
        by (simp add: cond)
      have c6: "\<not> primitive (concat (glue x' ws'))"
          conjug_concat_conjug prim_conjug by metis
      from less.hyps[OF c1 c2 c3 _ c4 c5 c6]
      have "glue x' ws' \<sim> [x' \<cdot> y', x' \<cdot> y', y']" by simp
      have False
      thus ?case by blast
    qed
  qed
qed

lemma bin_imprim_both_twice:
  assumes "x \<cdot> y \<noteq> y \<cdot> x"
    and "ws \<in> lists {x, y}"
    and "count_list ws x \<ge> 2"
    and "count_list ws y \<ge> 2"
    and "primitive ws" and "\<not> primitive (concat ws)"
  shows False
proof-
  have "x \<noteq> y"
  from bin_imprim_longer_twice[OF assms(1-2) _ assms(3) assms(5-6)]
    bin_imprim_longer_twice[OF assms(1)[symmetric] assms(2)[unfolded insert_commute[of x]] _ assms(4) assms(5-6)]
  have or: "ws \<sim> [x, x, y] \<or> ws \<sim> [y, y, x]" by linarith
  thus False
  proof (rule disjE)
    assume "ws \<sim> [x, x, y]"
    show False
  next
    assume "ws \<sim> [y, y, x]"
    show False
  qed
qed


lemma "x \<noteq> \<epsilon> \<Longrightarrow>  \<epsilon> (x\<cdot>x) \<epsilon> \<sim>\<^sub>\<I> [x,x]"
  unfolding factor_interpretation_def
  by simp

lemma assumes "x = [(0::nat),1,0,1,0]" and "y = [1,0,0,1]"
  shows "[0,1] (x\<cdot>x) [1,0] \<sim>\<^sub>\<I> [x,y,x]"
  unfolding factor_interpretation_def assms by (simp add: suffix_def)

section "Primitivity non-preserving binary code"


lemma bin_imprim_expsE_y: assumes "x \<cdot> y \<noteq> y \<cdot> x" and
  "ws \<in> lists {x,y}" and
  "2 \<le> \<^bold>|ws\<^bold>|" and
  "primitive ws" and
  "\<not> primitive (concat ws)" and
  "count_list ws y = 1"
obtains j k where "1 \<le> j" "1 \<le> k" "j = 1 \<or> k = 1"
  "ws \<sim> [x]\<^sup>@j \<cdot> [y]\<^sup>@k"
proof-
  obtain j1 j2 where "[x]\<^sup>@j1\<cdot>[y]\<cdot>[x]\<^sup>@j2 = ws"
  have "1 \<le> j2 + j1"
  have "ws \<sim> [x]\<^sup>@(j2+j1)\<cdot>[y]\<^sup>@1"
    using conjugI'[of "[x] \<^sup>@ j1 \<cdot> [y]" "[x] \<^sup>@ j2"]
  show ?thesis
    by blast
qed

lemma bin_imprim_expsE: assumes "x \<cdot> y \<noteq> y \<cdot> x" and
  "ws \<in> lists {x,y}" and
  "2 \<le> \<^bold>|ws\<^bold>|" and
  "primitive ws" and
  "\<not> primitive (concat ws)"
obtains j k where "1 \<le> j" "1 \<le> k" "j = 1 \<or> k = 1"
  "ws \<sim> [x]\<^sup>@j \<cdot> [y]\<^sup>@k"
proof-

    sing_lists_exp_len[of ws y]
  have "count_list ws x \<noteq> 0"

    sing_lists_exp_len[of ws x]
  have "count_list ws y \<noteq> 0"

  consider "count_list ws x = 1" | "count_list ws y = 1"
    unfolding One_less_Two_le_iff[symmetric] less_one[symmetric] by fastforce
  thus thesis
  proof(cases)
    show thesis
      using that by metis
  next
    show ?thesis
      using that.
  qed
qed



theorem bin_imprim_code: assumes "x \<cdot> y \<noteq> y \<cdot> x"  and "ws \<in> lists {x,y}" and
  "2 \<le> \<^bold>|ws\<^bold>|" and "primitive ws" and  "\<not> primitive (concat ws)"
obtains j k where "1 \<le> j" and "1 \<le> k" and "j = 1 \<or> k = 1"
  "\<And>ws. ws \<in> lists {x,y} \<Longrightarrow>  2 \<le> \<^bold>|ws\<^bold>| \<Longrightarrow>
       (primitive ws \<and> \<not> primitive (concat ws) \<longleftrightarrow> ws \<sim> [x]\<^sup>@j \<cdot> [y]\<^sup>@k)" and
  "\<^bold>|y\<^bold>| \<le> \<^bold>|x\<^bold>| \<Longrightarrow> 2 \<le> j \<Longrightarrow> j = 2 \<and> primitive x \<and> primitive y" and
  "\<^bold>|y\<^bold>| \<le> \<^bold>|x\<^bold>| \<Longrightarrow> 2 \<le> k \<Longrightarrow> j = 1 \<and> primitive x"
proof-
  obtain j k where "1 \<le> j" "1 \<le> k" "j = 1 \<or> k = 1"
    "ws \<sim> [x]\<^sup>@j \<cdot> [y]\<^sup>@k"
    using assms by metis

  have "\<not> primitive (x\<^sup>@j \<cdot> y\<^sup>@k)"
    unfolding concat_morph  concat_sing_pow

  from not_prim_primroot_expE[OF this]
  obtain z l where [symmetric]: "z\<^sup>@l = x\<^sup>@j \<cdot> y\<^sup>@k" and "2 \<le> l".

  show thesis
  proof (rule that[of j k ])
    show "1 \<le> j" "1 \<le> k" "j = 1 \<or> k = 1" by fact+

    fix ws'
    assume hyps: "ws' \<in> lists {x,y}" "2 \<le> \<^bold>|ws'\<^bold>|"
    show  "primitive ws' \<and> \<not> primitive (concat ws') \<longleftrightarrow> ws' \<sim> [x]\<^sup>@j \<cdot> [y]\<^sup>@k"
    proof
      assume " primitive ws' \<and> \<not> primitive (concat ws')"
      hence prems: "primitive ws'" "\<not> primitive (concat ws')" by blast+
      obtain j' k' where "1 \<le> j'" "1 \<le> k'" "j' = 1 \<or> k' = 1"
        "ws' \<sim> [x]\<^sup>@j' \<cdot> [y]\<^sup>@k'"

      have "\<not> primitive (x \<^sup>@ j'\<cdot> y \<^sup>@ k')"
        unfolding concat_morph  concat_sing_pow

      have "j = j'" "k = k'"

      show "ws' \<sim> [x] \<^sup>@ j \<cdot> [y] \<^sup>@ k"
    next
      assume  "ws' \<sim> [x]\<^sup>@j \<cdot> [y]\<^sup>@k"
      show "primitive ws' \<and> \<not> primitive (concat ws')" by blast
    qed
  next
    assume "\<^bold>|y\<^bold>| \<le> \<^bold>|x\<^bold>|"
    interpret LS_len_le x y j k l z
    by unfold_locales fact+

    assume "2 \<le> j"
    with jk_small
    have "k = 1" by fastforce
    show "j = 2 \<and> primitive x \<and> primitive y"
      by blast
  next
    assume "\<^bold>|y\<^bold>| \<le> \<^bold>|x\<^bold>|"
    interpret LS_len_le x y j k l z
      by unfold_locales fact+

    assume "2 \<le> k"
    show "j = 1 \<and> primitive x"
  qed
qed


definition bin_imprim_code where "bin_imprim_code x y \<equiv> x \<cdot> y \<noteq> y \<cdot> x \<and> (\<not> bin_prim x y)"

theorem bin_imprim_code': assumes "bin_imprim_code x y"
obtains j k where "1 \<le> j" and "1 \<le> k" and "j = 1 \<or> k = 1"
  "\<And>ws. ws \<in> lists {x,y} \<Longrightarrow>  2 \<le> \<^bold>|ws\<^bold>| \<Longrightarrow>
       (primitive ws \<and> \<not> primitive (concat ws) \<longleftrightarrow> ws \<sim> [x]\<^sup>@j \<cdot> [y]\<^sup>@k)" and
  "\<^bold>|y\<^bold>| \<le> \<^bold>|x\<^bold>| \<Longrightarrow> 2 \<le> j \<Longrightarrow> j = 2 \<and> primitive x \<and> primitive y" and
  "\<^bold>|y\<^bold>| \<le> \<^bold>|x\<^bold>| \<Longrightarrow> 2 \<le> k \<Longrightarrow> j = 1 \<and> primitive x"
proof-
  thm bin_imprim_code
  obtain ws where "x \<cdot> y \<noteq> y \<cdot> x"
  and "ws \<in> lists {x,y}" and  "2 \<le> \<^bold>|ws\<^bold>|" and "primitive ws" and  "\<not> primitive (concat ws)"
    using assms  unfolding bin_imprim_code_def bin_prim_altdef2 by blast
  from bin_imprim_code[OF this] that
  show thesis
    by blast
qed


end
