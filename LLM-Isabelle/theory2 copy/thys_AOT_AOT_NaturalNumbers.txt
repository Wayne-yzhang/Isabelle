theory AOT_NaturalNumbers
  imports AOT_PossibleWorlds AOT_ExtendedRelationComprehension
begin

 





proof(rule "\<equiv>I"; rule "\<rightarrow>I")
    using "\<equiv>\<^sub>d\<^sub>fE"[OF "1-1-cor"] "&E" by blast+
  proof (rule "\<equiv>\<^sub>d\<^sub>fI"[OF "fFG:1"]; rule "&I")
      using "cqt:2[const_var]"[axiom_inst] "&I" by metis
  next
  qed
  proof (rule "\<equiv>\<^sub>d\<^sub>fI"[OF "fFG:4"]; rule "&I")
    proof (rule "\<equiv>\<^sub>d\<^sub>fI"[OF "fFG:2"]; rule "&I")
    next
      proof(rule GEN; rule GEN; rule GEN; rule "\<rightarrow>I"; rule "\<rightarrow>I")
        fix x y z
          using B "&E" "\<forall>E" "\<rightarrow>E" by fast
          by (rule "uni-most"[THEN "\<rightarrow>E", OF 3, THEN "\<forall>E"(2)[where \<beta>=x],
                              THEN "\<forall>E"(2)[where \<beta>=y], THEN "\<rightarrow>E"])
             (metis "&I" "&E" 1 2)
      qed
    qed
  next
    proof (rule "\<equiv>\<^sub>d\<^sub>fI"[OF "fFG:3"]; rule "&I")
    next
      proof(rule GEN; rule "\<rightarrow>I")
        fix y
          using B[THEN "\<forall>E"(2), THEN "\<rightarrow>E"] by blast
          using "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
          using "\<exists>E"[rotated] "&E" by blast
      qed
    qed
  qed
next
    using "\<equiv>\<^sub>d\<^sub>fE"[OF "fFG:4"] "&E" by blast+
    using "\<equiv>\<^sub>d\<^sub>fE"[OF "fFG:2"] "\<equiv>\<^sub>d\<^sub>fE"[OF "fFG:3"] "&E" by blast+
  proof(rule "1-1-cor"[THEN "\<equiv>\<^sub>d\<^sub>fI"]; safe intro!: "&I" "cqt:2[const_var]"[axiom_inst])
      using "\<equiv>\<^sub>d\<^sub>fE"[OF "fFG:1", OF C] "&E" by blast
  next
    proof (rule "GEN"; rule "\<rightarrow>I")
      fix y
        using E "\<forall>E" "\<rightarrow>E" by fast
        using "\<exists>E"[rotated] by blast
      proof (rule GEN; rule "\<rightarrow>I")
        fix z
          using D[THEN "\<forall>E"(2)[where \<beta>=z], THEN "\<forall>E"(2)[where \<beta>=a],
                  THEN "\<forall>E"(2)[where \<beta>=y], THEN "\<rightarrow>E", THEN "\<rightarrow>E"]
                a_prop 0 "&E" "&I" by metis
      qed
        using "&I" "\<exists>I"(2) by fast
        using "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] by fast
    qed
  qed
qed

AOT_register_variable_names
  Ordinary: u v r t s

proof(rule "\<equiv>I"; rule "\<rightarrow>I")
    using "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
    using "\<exists>E"[rotated] by blast
  {
    fix \<beta>
      using x_prop[THEN "&E"(2), THEN "\<forall>E"(2)[where \<beta>=\<beta>]] "&I" "\<rightarrow>E" by blast
      using "ord-=E=:1"[THEN "\<rightarrow>E", OF "\<or>I"(1)[OF beta_ord],
                        THEN "qml:2"[axiom_inst, THEN "\<rightarrow>E"],
                        THEN "\<equiv>E"(1)]
      by blast
  }
    using "\<rightarrow>I" by blast
    by (rule GEN)
    using x_prop[THEN "&E"(1)] "&I" by blast
    using "&E" "&I" by meson
    using "\<exists>I" by fast
next
    by blast
    using "\<exists>E"[rotated] by blast
  proof(rule GEN; rule "\<rightarrow>I")
    fix y
      using x_prop[THEN "&E"(2), THEN "&E"(2), THEN "\<forall>E"(2)[where \<beta>=y]]
            "\<rightarrow>E" "&E" by blast
      using "ord-=E=:1"[THEN "\<rightarrow>E", OF "\<or>I"(2)[OF x_prop[THEN "&E"(1)]],
                        THEN "qml:2"[axiom_inst, THEN "\<rightarrow>E"], THEN "\<equiv>E"(2)] by blast
  qed
    using x_prop "&E" "&I" by meson
    by (rule "\<exists>I")
    by (rule "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
qed



proof -
    using "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fE"] that by blast
    using "\<exists>E"[rotated] by blast
    using "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
qed

proof -
    using "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fE"] that by blast
    using "\<exists>E"[rotated] by blast
    using "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
qed

proof (safe intro!: "&I" GEN "\<rightarrow>I" "cqt:2[const_var]"[axiom_inst]
                    "\<equiv>\<^sub>d\<^sub>fI"[OF "equi:3"] "\<equiv>\<^sub>d\<^sub>fI"[OF "equi:2"] "\<exists>I"(1))
  fix x
  proof(rule "equi:1"[THEN "\<equiv>E"(2)];
        rule "\<exists>I"(2)[where \<beta>=x];
        safe dest!: "&E"(2)
             intro!:  "&I" "\<rightarrow>I" 1 2 Ordinary.GEN "ord=Eequiv:1"[THEN "\<rightarrow>E", OF 1])
      by (metis that "ord=Eequiv:2"[THEN "\<rightarrow>E"])
  qed
next
  fix y
    by(safe dest!: "&E"(2)
            intro!: "equi:1"[THEN "\<equiv>E"(2)] "\<exists>I"(2)[where \<beta>=y]
                    "&I" "\<rightarrow>I" 1 2 GEN "ord=Eequiv:1"[THEN "\<rightarrow>E", OF 1])
qed(auto simp: "=E[denotes]")


proof (rule "\<rightarrow>I")
    using "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
    using "\<exists>E"[rotated] by blast
    using "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast

        (safe intro!: "&I" "cqt:2[const_var]"[axiom_inst] 0[THEN "&E"(2)]
                      0[THEN "&E"(1), THEN "&E"(2)]; "cqt:2[lambda]")?)
    AOT_modally_strict {
        by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2"
                 simp: "&I" "ex:1:a" prod_denotesI "rule-ui:3" that)
        using "\<beta>\<rightarrow>C"(1)[where \<phi>="\<lambda>(x,y). _ (x,y)" and \<kappa>\<^sub>1\<kappa>\<^sub>n="(_,_)",
                        simplified, OF that, simplified].
        by (metis "deduction-theorem" "\<equiv>I")
    }
  qed
    using "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"] by blast
    by (rule "\<exists>I"(1)) "cqt:2[lambda]"
    using "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fI"] by blast
qed

  using "eq-part:2"[unvarify F G] eq_den_1 eq_den_2 "\<rightarrow>I" by meson
declare "eq-part:2[terms]"[THEN "\<rightarrow>E", sym]

proof (rule "\<rightarrow>I")
  then AOT_obtain R\<^sub>1 and R\<^sub>2 where
    using "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" "\<exists>E"[rotated] by metis
    using "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)]
          "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(1), THEN "&E"(2)]
          "&I" by blast+
    by (rule "free-thms:3[lambda]") cqt_2_lambda_inst_prover
    using "\<exists>E"[rotated] by blast
  proof (rule "\<equiv>E"(2)[OF "equi:1"])
    AOT_obtain b where
      using \<theta>[THEN "&E"(1), THEN "\<forall>E"(2), THEN "\<rightarrow>E", THEN "\<rightarrow>E",
              OF a b, THEN "\<equiv>E"(1)[OF "equi:1"]]
            "\<exists>E"[rotated] by blast
    AOT_obtain c where
      c_prop: "[O!]c & ([H]c & [R\<^sub>2]bc & \<forall>v ([H]v & [R\<^sub>2]bv \<rightarrow> v =\<^sub>E c))"
      using \<xi>[THEN "&E"(1), THEN "\<forall>E"(2)[where \<beta>=b], THEN "\<rightarrow>E",
              OF b_prop[THEN "&E"(1)], THEN "\<rightarrow>E",
              OF b_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(1)],
              THEN "\<equiv>E"(1)[OF "equi:1"]]
    "\<exists>E"[rotated] by blast
    proof (safe intro!: "&I" GEN "\<rightarrow>I" "\<exists>I"(2)[where \<beta>=c])
    next
    next
        by (safe intro!: "&I" a c_prop[THEN "&E"(1)] "\<exists>I"(2)[where \<beta>=b]
                         b_prop[THEN "&E"(1)] b_prop[THEN "&E"(2), THEN "&E"(1)]
                         c_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(2)])
        by (auto intro: "rule=E"[rotated, OF R_def[symmetric]]
                 intro!: "\<beta>\<leftarrow>C"(1) "cqt:2"
                 simp: "&I" "ex:1:a" prod_denotesI "rule-ui:3" 0)
    next
      fix x
        using "rule=E"[rotated, OF R_def] by fast
        by (rule "\<beta>\<rightarrow>C"(1)[where \<phi>="\<lambda>(\<kappa>,\<kappa>'). _ \<kappa> \<kappa>'" and \<kappa>\<^sub>1\<kappa>\<^sub>n="(_,_)", simplified])
        using "&E" "\<exists>E"[rotated] by blast
        using b_prop[THEN "&E"(2), THEN "&E"(2), THEN "\<forall>E"(2)[where \<beta>=z]]
        using "&E" "\<rightarrow>E" by metis
        by (metis "=E-simple:2"[THEN "\<rightarrow>E"])
        using z_prop[THEN "&E"(2), THEN "&E"(2)] "rule=E" by fast
        using c_prop[THEN "&E"(2), THEN "&E"(2), THEN "\<forall>E"(2)[where \<beta>=x],
                     THEN "\<rightarrow>E", THEN "\<rightarrow>E", OF ordx]
              hx "&I" by blast
    qed
  qed
  proof (rule "\<equiv>E"(2)[OF "equi:1"])
    AOT_obtain b where
      using \<xi>[THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E", THEN "\<rightarrow>E",
              OF a b, THEN "\<equiv>E"(1)[OF "equi:1"]]
            "\<exists>E"[rotated] by blast
    AOT_obtain c where
      c_prop: "[O!]c & ([F]c & [R\<^sub>1]cb & \<forall>v ([F]v & [R\<^sub>1]vb \<rightarrow> v =\<^sub>E c))"
      using \<theta>[THEN "&E"(2), THEN "\<forall>E"(2)[where \<beta>=b], THEN "\<rightarrow>E",
              OF b_prop[THEN "&E"(1)], THEN "\<rightarrow>E",
              OF b_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(1)],
              THEN "\<equiv>E"(1)[OF "equi:1"]]
    "\<exists>E"[rotated] by blast
    proof (safe intro!: "&I" GEN "\<rightarrow>I" "\<exists>I"(2)[where \<beta>=c])
    next
    next
        by (safe intro!: "&I" a "\<exists>I"(2)[where \<beta>=b] 
                     c_prop[THEN "&E"(1)] b_prop[THEN "&E"(1)]
                     b_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(1)]
                     b_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(2)]
                     c_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(2)])
        by (auto intro: "rule=E"[rotated, OF R_def[symmetric]]
                 intro!: "\<beta>\<leftarrow>C"(1) "cqt:2"
                 simp: "&I" "ex:1:a" prod_denotesI "rule-ui:3")
    next
      fix x
        using "rule=E"[rotated, OF R_def] by fast
        by (rule "\<beta>\<rightarrow>C"(1)[where \<phi>="\<lambda>(\<kappa>,\<kappa>'). _ \<kappa> \<kappa>'" and \<kappa>\<^sub>1\<kappa>\<^sub>n="(_,_)", simplified])
        using "&E" "\<exists>E"[rotated] by blast
        using b_prop[THEN "&E"(2), THEN "&E"(2), THEN "\<forall>E"(2)[where \<beta>=z]]
        using "&E" "\<rightarrow>E" "&I" by metis
        by (metis "=E-simple:2"[THEN "\<rightarrow>E"])
        using z_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(2)] "rule=E" by fast
        using c_prop[THEN "&E"(2), THEN "&E"(2), THEN "\<forall>E"(2)[where \<beta>=x],
                     THEN "\<rightarrow>E", THEN "\<rightarrow>E", OF ordx]
              hx "&I" by blast
    qed
  qed
    apply (rule "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
    apply (rule "\<exists>I"(2)[where \<beta>=R])
    by (auto intro!: 1 2 "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "cqt:2[const_var]"[axiom_inst]
                     Ordinary.GEN "\<rightarrow>I" Ordinary.\<psi>)
qed

  using "eq-part:3"[unvarify F G H, THEN "\<rightarrow>E"] eq_den_1 eq_den_2 "\<rightarrow>I" "&I"
  by (metis that(1) that(2))
declare "eq-part:3[terms]"[trans]

proof(rule "\<equiv>I"; rule "\<rightarrow>I")
  proof (rule GEN; rule "\<equiv>I"; rule "\<rightarrow>I")
      by (meson "&I" "eq-part:3" that "vdash-properties:6")
  next
      by (metis "&I" "eq-part:3" that "vdash-properties:6")
  qed
next
qed

  "equi-rem:1":

  "equi-rem:2":

  "equi-rem:3":

  "equi-rem:4":

AOT_theorem "equi-rem-thm":
proof -
  proof(safe intro!: "\<equiv>I" "\<rightarrow>I" "&I")
      using "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
      using "Ordinary.\<forall>E" by fast+
       apply (rule "beta-C-meta"[THEN "\<rightarrow>E"])
       apply "cqt:2[lambda]"
       apply (rule "beta-C-meta"[THEN "\<rightarrow>E"])
       apply "cqt:2[lambda]"
       apply (meson "\<equiv>E"(6) "Associativity of &" "oth-class-taut:3:a")
      apply (rule "\<rightarrow>I") apply (frule "&E"(1)) apply (drule "&E"(2))
      by (fact a[unconstrain u, THEN "\<rightarrow>E", THEN "\<rightarrow>E", of x])
      by (rule GEN)
       apply (rule "beta-C-meta"[THEN "\<rightarrow>E"])
       apply "cqt:2[lambda]"
       apply (rule "beta-C-meta"[THEN "\<rightarrow>E"])
       apply "cqt:2[lambda]"
       apply (meson "\<equiv>E"(6) "Associativity of &" "oth-class-taut:3:a")
      apply (rule "\<rightarrow>I") apply (frule "&E"(1)) apply (drule "&E"(2))
      by (fact b[unconstrain v, THEN "\<rightarrow>E", THEN "\<rightarrow>E", of y])
      by (rule GEN)
      by (safe intro!: "1-1-cor"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I"
                       "cqt:2[const_var]"[axiom_inst] A B)
          "cqt:2[lambda]"+
  next
      using "1-1-cor"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" "\<forall>E"(2) by blast+
    proof (safe intro!: "\<rightarrow>I")
        by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "cqt:2[const_var]"[axiom_inst]
                         Ordinary.\<psi> fu "&I")
         apply (simp add: "Associativity of &")
         apply (rule "beta-C-meta"[THEN "\<rightarrow>E"])
         apply "cqt:2[lambda]"
        using a[THEN "\<rightarrow>E", OF 0] by blast
    qed
      by (rule Ordinary.GEN)
    proof (safe intro!: "\<rightarrow>I")
        by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "cqt:2[const_var]"[axiom_inst]
                         Ordinary.\<psi> gu "&I")
         apply (simp add: "Associativity of &")
         apply (rule "beta-C-meta"[THEN "\<rightarrow>E"])
         apply "cqt:2[lambda]"
        using b[THEN "\<rightarrow>E", OF 0] by blast
    qed
      by (safe intro!: "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" A B "cqt:2[const_var]"[axiom_inst])
  qed
  proof(safe intro!: "\<equiv>I" "\<rightarrow>I" "&I")
      using "1-1-cor"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" "\<forall>E"(2) by blast+
    proof (safe intro!: "equi-rem:4"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "equi-rem:3"[THEN "\<equiv>\<^sub>d\<^sub>fI"]
                        "equi-rem:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "equi-rem:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"]
                        "cqt:2[const_var]"[axiom_inst] Ordinary.GEN "\<rightarrow>I")
      fix u
        by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "cqt:2[const_var]"[axiom_inst]
                         Ordinary.\<psi> fu "&I")
        using a[THEN "\<rightarrow>E"] by blast
         apply (simp add: "Associativity of &")
         apply (rule "beta-C-meta"[THEN "\<rightarrow>E"])
         apply "cqt:2[lambda]"
        by (fact 1)
    next
      fix t u v
        by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I"
                 simp: Ordinary.\<psi> dest: "&E")
        using b[THEN "\<rightarrow>E"] by blast
      then AOT_obtain a where
        using "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "\<exists>E"[rotated] by blast
        using ofu rtv_tuv[THEN "&E"(2)] "\<forall>E"(2) "\<rightarrow>E" "&I" "&E"(2) by blast
        using a_prop oft rtv_tuv[THEN "&E"(1)] "\<forall>E"(2) "\<rightarrow>E" "&I" "&E"(2) by blast
        using "rule=E" id_sym "ord=Eequiv:1" Ordinary.\<psi> ta ua "\<rightarrow>E" by fast
    next
      fix u
        by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I"
                 simp: "cqt:2[const_var]"[axiom_inst]  Ordinary.\<psi>)
        using a[THEN "\<rightarrow>E"] by blast
      then AOT_obtain a where
        using "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "\<exists>E"[rotated] by blast
        by (rule "\<beta>\<rightarrow>C"(1)) (auto simp: a_prop[THEN "&E"(1), THEN "&E"(1)])
      proof(safe intro!: Ordinary.GEN "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
        fix v
          by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" simp: Ordinary.\<psi>)
          using a_prop[THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E", OF "&I"] ruv by blast
          using "rule=E" "ord=Eequiv:1" Ordinary.\<psi> "\<rightarrow>E" by fast
      qed
        using "\<exists>I" "&I" a_prop[THEN "&E"(1), THEN "&E"(2)] by simp
        by (rule "\<exists>I")
        by (rule "equi:1"[THEN "\<equiv>E"(2)])
    next
      fix v
        by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" Ordinary.\<psi>)
        using b[THEN "\<rightarrow>E"] by blast
      then AOT_obtain a where
        using "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "\<exists>E"[rotated]] by blast
        by (rule "\<beta>\<rightarrow>C"(1)) (auto simp: a_prop[THEN "&E"(1), THEN "&E"(1)])
        using a_prop[THEN "&E"(1), THEN "&E"(2)] "&E" "&I" by metis
        by (rule "\<exists>I")
    qed
  next
      using "equi-rem:4"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
      using "equi-rem:2"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF 1] "&E" by blast+
      using "equi-rem:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
      using "equi-rem:3"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF 2] "&E" by blast
    proof (rule "1-1-cor"[THEN "\<equiv>\<^sub>d\<^sub>fI"];
           safe intro!: "&I" "cqt:2" GEN "\<rightarrow>I")
      fix x
        by (rule "\<beta>\<rightarrow>C"(1)) (auto simp: 1)
        using B[THEN "\<forall>E"(2), THEN "\<rightarrow>E", THEN "\<rightarrow>E"] "&E" by blast
      then AOT_obtain y where
        using "equi:1"[THEN "\<equiv>E"(1)] "\<exists>E"[rotated] by fastforce
        by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" dest: "&E")
      proof(safe intro!: GEN "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
        fix z
          by (rule "\<beta>\<rightarrow>C"(1)) (auto simp: 1)
          using y_prop[THEN "&E"(2), THEN "&E"(2), THEN "\<forall>E"(2),
                       THEN "\<rightarrow>E", THEN "\<rightarrow>E", rotated, OF "&I"] "&E"
          by blast
          using 2[THEN "&E"(1)] by (metis "=E-simple:2" "\<rightarrow>E")
      qed
        using y_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(2)] "&I" by auto
        by (rule "\<exists>I")
        using "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] by fast
    next
      fix y
        by (rule "\<beta>\<rightarrow>C"(1)) (auto simp: 1)
        using C[THEN "\<forall>E"(2), THEN "\<rightarrow>E", THEN "\<rightarrow>E"] "&E" by blast
        using "\<exists>E"[rotated] by blast
        by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" dest: "&E")
      proof (safe intro!: "\<exists>I"(2)[where \<beta>=x] "&I" GEN "\<rightarrow>I")
      next
      next
        fix z
          by (rule "\<beta>\<rightarrow>C"(1)) (auto simp: 1[THEN "&E"(1)])
          using A[THEN "\<forall>E"(2)[where \<beta>=z], THEN "\<rightarrow>E", THEN "\<forall>E"(2)[where \<beta>=x],
                  THEN "\<rightarrow>E", THEN "\<forall>E"(2)[where \<beta>=y], THEN "\<rightarrow>E",
                  THEN "\<rightarrow>E", THEN "\<rightarrow>E", OF oz_fz[THEN "&E"(1)],
                  OF x_prop[THEN "&E"(1)], OF oy_gy[THEN "&E"(1)], OF "&I", OF "&I",
                  OF oz_fz[THEN "&E"(2)], OF x_prop[THEN "&E"(2), THEN "&E"(1)],
                  OF oy_gy[THEN "&E"(2)], OF "&I", OF 1[THEN "&E"(2)],
                  OF x_prop[THEN "&E"(2), THEN "&E"(2)]].
          by (metis "=E-simple:2" "vdash-properties:10")
      qed
        by (rule "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
    qed
  qed
  finally show ?thesis.
qed

proof(rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
  proof(rule Ordinary.GEN; rule "\<rightarrow>I"; rule "raa-cor:1")
    fix u
  qed
  proof(rule Ordinary.GEN; rule "\<rightarrow>I"; rule "raa-cor:1")
    fix v
  qed
    apply (safe intro!: "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" GEN "cqt:2[const_var]"[axiom_inst])
    using "\<forall>E" by blast+
    by (rule "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
qed

proof(rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2); rule "raa-cor:2")
    using 1 "\<exists>E"[rotated] by blast
    by (rule "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fE"])
    using "\<exists>E"[rotated] by blast
    using "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
    using \<theta>[THEN "\<forall>E"(2)[where \<beta>=b], THEN "\<rightarrow>E", THEN "\<rightarrow>E",
            OF b_prop[THEN "&E"(1)], OF b_prop[THEN "&E"(2)]].
    by (rule "equi:1"[THEN "\<equiv>E"(1)])
    using "\<exists>E"[rotated] by blast
qed



  by (rule "=\<^sub>d\<^sub>fI"(1)[OF "F-u", where \<tau>\<^sub>1\<tau>\<^sub>n="(_,_)", simplified]; "cqt:2[lambda]")
  by (auto intro: "F-u"[THEN "=\<^sub>d\<^sub>fI"(1), where \<tau>\<^sub>1\<tau>\<^sub>n="(_,_)", simplified]
           intro!: "cqt:2" "beta-C-cor:2"[THEN "\<rightarrow>E", THEN "\<forall>E"(2)])

proof (rule "\<rightarrow>I"; frule "&E"(2); drule "&E"(1); frule "&E"(2); drule "&E"(1))
    using "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
    using "\<exists>E"[rotated] by blast
    using "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
    using "equi-rem-thm"[THEN "\<equiv>E"(1), OF R_prop].
    using "equi-rem:4"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
    using "equi-rem:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
    by "cqt:2[lambda]"
  note \<Pi>_minus_\<kappa>I = "rule-id-df:2:b[2]"[
   and \<Pi>_minus_\<kappa>E = "rule-id-df:2:a[2]"[
    by (rule \<Pi>_minus_\<kappa>I) "cqt:2[lambda]"+
  {
    fix R
      using "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
      using "equi-rem-thm"[THEN "\<equiv>E"(1), OF R_prop].
      using "equi-rem:4"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
      using "equi-rem:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast

    proof(safe intro!: "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "cqt:2[const_var]"[axiom_inst]
                       \<Pi>_minus_\<kappa>_den Ordinary.GEN "\<rightarrow>I")
      fix u'
        using \<Pi>_minus_\<kappa>E by fast
        by (rule "\<beta>\<rightarrow>C"(1)[where \<kappa>\<^sub>1\<kappa>\<^sub>n="AOT_term_of_var (Ordinary.Rep u')"]) (fact 0)
        using A[THEN "Ordinary.\<forall>E"[where \<alpha>=u'], THEN "\<rightarrow>E", OF 0[THEN "&E"(1)]].
      then AOT_obtain v' where
        using "equi:1"[THEN "\<equiv>E"(1)] "Ordinary.\<exists>E"[rotated] by fastforce

      proof (safe intro!: "equi:1"[THEN "\<equiv>E"(2)] "Ordinary.\<exists>I"[where \<beta>=v']
                          "&I" Ordinary.GEN "\<rightarrow>I")
        proof (rule \<Pi>_minus_\<kappa>I; 
               safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" "thm-neg=E"[THEN "\<equiv>E"(2)])
        next
          proof (rule "raa-cor:2")
              by (rule C[THEN "Ordinary.\<forall>E", THEN "Ordinary.\<forall>E",
                         THEN "Ordinary.\<forall>E"[where \<alpha>=v'], THEN "\<rightarrow>E", THEN "\<rightarrow>E"])
                 (safe intro!: "&I" 0[THEN "&E"(1)] fu
                               v'_prop[THEN "&E"(1), THEN "&E"(1)]
                               Ruv' v'_prop[THEN "&E"(1), THEN "&E"(2)])
              using "0" "&E"(2) "\<equiv>E"(1) "thm-neg=E" by blast
          qed
        qed
      next
      next
        fix t
          apply (rule "\<beta>\<rightarrow>C"(1)[where \<kappa>\<^sub>1\<kappa>\<^sub>n="AOT_term_of_var (Ordinary.Rep t)"])
          apply (rule \<Pi>_minus_\<kappa>E)
          by (fact t_prop[THEN "&E"(1)])
          using v'_prop[THEN "&E"(2), THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E",
                        OF "&I", OF gt_t_noteq_v[THEN "&E"(1)],
                        OF t_prop[THEN "&E"(2)]].
      qed
    next
      fix v'
        apply (rule "\<beta>\<rightarrow>C"(1)[where \<kappa>\<^sub>1\<kappa>\<^sub>n="AOT_term_of_var (Ordinary.Rep v')"])
        apply (rule \<Pi>_minus_\<kappa>E)
        by (fact G_minus_v_v')
        using B[THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E", OF gt_t_noteq_v[THEN "&E"(1)]].
      then AOT_obtain u' where
        using "equi:1"[THEN "\<equiv>E"(1)] "Ordinary.\<exists>E"[rotated] by fastforce
      proof (safe intro!: "equi:1"[THEN "\<equiv>E"(2)] "Ordinary.\<exists>I"[where \<beta>=u'] "&I"
                          u'_prop[THEN "&E"(1), THEN "&E"(2)] Ordinary.GEN "\<rightarrow>I")
        proof (rule \<Pi>_minus_\<kappa>I;
               safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" "thm-neg=E"[THEN "\<equiv>E"(2)]
               u'_prop[THEN "&E"(1), THEN "&E"(1)]; rule "raa-cor:2")
            using "=E-simple:2" "vdash-properties:10" by blast
            using "&E"(2) gt_t_noteq_v by blast
            using A[THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E",
                    OF u'_prop[THEN "&E"(1), THEN "&E"(1)],
                    THEN "equi:1"[THEN "\<equiv>E"(1)]].
          then AOT_obtain t where
            using "Ordinary.\<exists>E"[rotated] by meson
            using t_prop[THEN "&E"(2), THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E",
                         OF "&I", OF that].
            by (auto simp: gt_t_noteq_v[THEN "&E"(1)] Ru'v gv
                           u'_prop[THEN "&E"(1), THEN "&E"(2)])
            using "rule=E" "=E-simple:2" id_sym "\<rightarrow>E" by fast
            using v'_noteq_v "&I" by blast
        qed
      next
        fix t
          apply (rule "\<beta>\<rightarrow>C"(1)[where \<kappa>\<^sub>1\<kappa>\<^sub>n="AOT_term_of_var (Ordinary.Rep t)"])
          apply (rule \<Pi>_minus_\<kappa>E)
          by (fact 0[THEN "&E"(1)])
          using u'_prop[THEN "&E"(2), THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E", OF "&I"]
                "&E" by blast
      qed
    qed
      by (rule "\<exists>I")
  } note 1 = this
  moreover {
      using A[THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E", OF fu].
    then AOT_obtain b where
      using "equi:1"[THEN "\<equiv>E"(1)] "\<exists>E"[rotated] by fastforce
      using "&E" by blast+
      using b_prop "&E"(2) "\<forall>E"(2) by blast
      by (metis Adjunction "modus-tollens:1" "reductio-aa:1" that)
    proof(rule "raa-cor:2")
        by (metis "=E-simple:2" "\<rightarrow>E")
        using b_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(2)]
              "rule=E"[rotated, OF 0[symmetric]] by fast
        using not_Ruv "&I" by blast
    qed
      using "modus-tollens:1" not_v_eq_b "ord=Eequiv:2" by blast
      using B[THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E", OF gv].
    then AOT_obtain a where
      using "equi:1"[THEN "\<equiv>E"(1)] "\<exists>E"[rotated] by fastforce
      using "&E" by blast+
      using a_prop "&E" "\<forall>E"(2) by blast
      by (metis Adjunction "modus-tollens:1" "reductio-aa:1" that) 
    proof(rule "raa-cor:2")
        by (metis "=E-simple:2" "\<rightarrow>E")
        using a_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(2)]
              "rule=E"[rotated, OF 0[symmetric]] by fast
        using not_Ruv "&I" by blast
    qed
      using "modus-tollens:1" not_u_eq_a "ord=Eequiv:2" by blast
      using "free-thms:1" "\<equiv>E"(1) by fast
      using "\<exists>E"[rotated] by blast
    proof -
        by (rule "rule=E"[rotated, OF R\<^sub>1_def]) (fact that(1))
        using "\<beta>\<rightarrow>C"(1)[OF 0] by simp
        by (metis "\<or>E"(3) "Conjunction Simplification"(1) "\<equiv>E"(1)
                  "modus-tollens:1" "thm-neg=E")
    qed
    proof -
        by (rule "rule=E"[rotated, OF R\<^sub>1_def]) (fact that(1))
        using "\<beta>\<rightarrow>C"(1)[OF 0] by simp
        using that(2,3)
        by (metis "\<or>E"(3) "Conjunction Simplification"(2) "\<equiv>E"(1)
                  "modus-tollens:1" "thm-neg=E")
    qed
      by (rule "rule=E"[rotated, OF R\<^sub>1_def[symmetric]])
         (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2"
                 simp: "&I" "ex:1:a" prod_denotesI "rule-ui:3" that "\<or>I"(1))
      apply (rule "rule=E"[rotated, OF R\<^sub>1_def[symmetric]])
      apply (safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" prod_denotesI "&I")
      by (meson a_prop b_prop "&I" "&E"(1) "\<or>I"(1) "\<or>I"(2) "ord=Eequiv:1" "\<rightarrow>E")
      apply (rule "rule=E"[rotated, OF R\<^sub>1_def[symmetric]])
      apply (safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" prod_denotesI "&I")
      by (meson "&I" "\<or>I"(2) "ord=Eequiv:1" Ordinary.\<psi> "\<rightarrow>E")
    proof (safe intro!: "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "cqt:2" Ordinary.GEN "\<rightarrow>I")
      fix u'
      {
          by (metis "\<equiv>E"(2) "thm-neg=E")+
          using A[THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E", OF fu'].
          using "equi:1"[THEN "\<equiv>E"(1)] by simp
        then AOT_obtain v' where
          using "Ordinary.\<exists>E"[rotated] by meson
          using "&E" by blast+
        proof (rule "raa-cor:2")
            by (metis "=E-simple:2" "\<rightarrow>E")
            using "rule=E" Ru'v' by fast
            using a_unique[OF Ordinary.\<psi>, OF fu', OF Ru'v].
            using not_u'_eq_a "&I" by blast
        qed
          using "\<equiv>E"(2) "thm-neg=E" by blast
          using v'_prop "&E" by blast
          using "Ordinary.\<forall>E" by meson
          by (metis "&I" that "\<rightarrow>E")

        proof (safe intro!: "&I" gv' R\<^sub>1xy Ru'v' u'_noteq_u u'_noteq_a "\<rightarrow>I"
                            Ordinary.GEN "thm-neg=E"[THEN "\<equiv>E"(2)] not_v'_eq_v)
          fix t
            using Rxy1[OF 1[THEN "&E"(2)], OF u'_noteq_u, OF u'_noteq_a].
            using v'_unique 1[THEN "&E"(1)] by blast
        qed
          by (rule "Ordinary.\<exists>I")
          by (rule "equi:1"[THEN "\<equiv>E"(2)])
      }
      moreover {
          using "=E-simple:2" "\<rightarrow>E" by blast
        proof (safe intro!: "equi:1"[THEN "\<equiv>E"(2)] "Ordinary.\<exists>I"[where \<beta>=v]
                            "&I" Ordinary.GEN "\<rightarrow>I" gv)
            apply (rule "rule=E"[rotated, OF R\<^sub>1_def[symmetric]])
            apply (safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" prod_denotesI)
            by (safe intro!: "\<or>I"(2) "&I" 0 "ord=Eequiv:1"[THEN "\<rightarrow>E", OF Ordinary.\<psi>])
        next
          fix v'
            using "rule=E"[rotated, OF u'_eq_u] "&E"(2) by fast
            by (rule "rule=E"[rotated, OF R\<^sub>1_def]) (fact 0)
            using "\<beta>\<rightarrow>C"(1)[OF 1] by simp
            using "\<equiv>E"(4) "modus-tollens:1" "ord=Eequiv:1" Ordinary.\<psi>
                  "reductio-aa:2" "thm-neg=E" by blast
            using not_u_eq_a
            by (metis "\<or>E"(2) "Conjunction Simplification"(1)
                      "modus-tollens:1" "reductio-aa:1")
            using 2 by (metis "\<or>E"(2))
            using "&E" by blast
        qed
      }
      moreover {
          using "=E-simple:2" "\<rightarrow>E" by blast
        proof (safe intro!: "equi:1"[THEN "\<equiv>E"(2)] "\<exists>I"(2)[where \<beta>=b] "&I"
                            Ordinary.GEN "\<rightarrow>I" b_prop[THEN "&E"(1)]
                            b_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(1)])
            apply (rule "rule=E"[rotated, OF R\<^sub>1_def[symmetric]])
            apply (safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" prod_denotesI)
            apply (rule "\<or>I"(1); rule "\<or>I"(2); rule "&I")
             apply (fact 0)
            using b_prop "&E"(1) "ord=Eequiv:1" "\<rightarrow>E" by blast
        next
          fix v'
            using u'_eq_a by (meson "rule=E" "&E"(2))
            by (rule "rule=E"[rotated, OF R\<^sub>1_def]) (fact 0)
            using "\<beta>\<rightarrow>C"(1)[OF 1] by simp
          moreover {
              using A[THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E", OF fu'].
              using u'_eq_a "rule=E" by fast
              using "equi:1"[THEN "\<equiv>E"(1)] by fast
            then AOT_obtain s where
              using "Ordinary.\<exists>E"[rotated] by meson
              using s_prop[THEN "&E"(2), THEN "Ordinary.\<forall>E"]
                    gv'_R1u'v'[THEN "&E"(1)] 0[THEN "&E"(2)]
              by (metis "&I" "vdash-properties:10")
              using s_prop[THEN "&E"(2), THEN "Ordinary.\<forall>E"] gv Rav
              by (metis "&I" "\<rightarrow>E")
              by (metis "&I" "ord=Eequiv:2" "ord=Eequiv:3" "\<rightarrow>E")
              using 0[THEN "&E"(1), THEN "&E"(2)]
              by (metis "\<equiv>E"(1) "thm-neg=E") 
              by (metis "raa-cor:3")
          }
          moreover {
              by (metis "&E"(1) not_a_eq_u "reductio-aa:1")
          }
            by (metis "&E"(2) "\<or>E"(3) "reductio-aa:1") 
        qed
      }
        by (metis "raa-cor:1")
    next
      fix v'
      {
          by (metis "\<equiv>E"(2) "thm-neg=E")+
          using B[THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E", OF gv'].
          using "equi:1"[THEN "\<equiv>E"(1)] by simp
        then AOT_obtain u' where
          using "Ordinary.\<exists>E"[rotated] by meson
          using "&E" by blast+
        proof (rule "raa-cor:2")
            by (metis "=E-simple:2" "\<rightarrow>E")
            using "rule=E" Ru'v' by fast
            using b_unique[OF Ordinary.\<psi>, OF gv', OF Ruv'].
            using not_v'_eq_b "&I" by blast
        qed
          using "\<equiv>E"(2) "thm-neg=E" by blast
          using u'_prop "&E" by blast
          using "Ordinary.\<forall>E" by meson
          by (metis "&I" that "\<rightarrow>E")

        proof (safe intro!: "&I" gv' R\<^sub>1xy Ru'v' u'_noteq_u Ordinary.GEN "\<rightarrow>I"
                            "thm-neg=E"[THEN "\<equiv>E"(2)] not_v'_eq_v fu')
          fix t
            using Rxy2[OF 1[THEN "&E"(2)], OF v'_noteq_v, OF v'_noteq_b].
            using u'_unique 1[THEN "&E"(1)] by blast
        qed
          by (rule "Ordinary.\<exists>I")
          by (rule "equi:1"[THEN "\<equiv>E"(2)])
      }
      moreover {
          using "=E-simple:2" "\<rightarrow>E" by blast
        proof (safe intro!: "equi:1"[THEN "\<equiv>E"(2)] "Ordinary.\<exists>I"[where \<beta>=u]
                            "&I" Ordinary.GEN "\<rightarrow>I" fu)
            by (rule "rule=E"[rotated, OF R\<^sub>1_def[symmetric]])
               (safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" prod_denotesI Ordinary.\<psi>
                             "\<or>I"(2) 0 "ord=Eequiv:1"[THEN "\<rightarrow>E"])
        next
          fix u'
            using "rule=E"[rotated, OF u'_eq_u] "&E"(2) by fast
            by (rule "rule=E"[rotated, OF R\<^sub>1_def]) (fact 0)
            using "\<beta>\<rightarrow>C"(1)[OF 1, simplified] by simp
            using "\<equiv>E"(4) "modus-tollens:1" "ord=Eequiv:1" Ordinary.\<psi>
                  "reductio-aa:2" "thm-neg=E" by blast
            by (metis "&E"(1) "&E"(2) "\<or>E"(3) not_v_eq_b "raa-cor:3")
            using 2 by (metis "\<or>E"(2))
            using "&E" by blast
        qed
      }
      moreover {
          using "=E-simple:2" "\<rightarrow>E" by blast
        proof (safe intro!: "equi:1"[THEN "\<equiv>E"(2)] "\<exists>I"(2)[where \<beta>=a] "&I"
                            Ordinary.GEN "\<rightarrow>I" b_prop[THEN "&E"(1)] Oa fa
                            b_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(1)])
            apply (rule "rule=E"[rotated, OF R\<^sub>1_def[symmetric]])
            apply (safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" prod_denotesI)
            apply (rule "\<or>I"(1); rule "\<or>I"(2); rule "&I")
            using Oa "ord=Eequiv:1" "\<rightarrow>E" apply blast
            using "0" by blast
        next
          fix u'
            using v'_eq_b by (meson "rule=E" "&E"(2))
            by (rule "rule=E"[rotated, OF R\<^sub>1_def]) (fact 0)
            using "\<beta>\<rightarrow>C"(1)[OF 1, simplified] by simp
          moreover {
              using B[THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E", OF gv'].
              using v'_eq_b "rule=E" by fast
              using "equi:1"[THEN "\<equiv>E"(1)] by fast
            then AOT_obtain s where
              using "Ordinary.\<exists>E"[rotated] by meson
              using s_prop[THEN "&E"(2), THEN "Ordinary.\<forall>E"]
                    fu'_R1u'v'[THEN "&E"(1)] 0[THEN "&E"(2)]
              by (metis "&I" "\<rightarrow>E")
              using s_prop[THEN "&E"(2), THEN "Ordinary.\<forall>E"] fu Rub
              by (metis "&I" "\<rightarrow>E")
              by (metis "&I" "ord=Eequiv:2" "ord=Eequiv:3" "\<rightarrow>E")
              using 0[THEN "&E"(1), THEN "&E"(1)] by (metis "\<equiv>E"(1) "thm-neg=E") 
              by (metis "raa-cor:3")
          }
          moreover {
              by (metis "&E"(2) not_b_eq_v "reductio-aa:1")
          }
            by (metis "&E"(1) "\<or>E"(3) "reductio-aa:1") 
        qed
      }
        by (metis "raa-cor:1")
    qed
      using 1 by blast
  }
    using R_prop by (metis "reductio-aa:2") 
    by (rule "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
qed


proof(safe intro!: "\<rightarrow>I"; frule "&E"(1); drule "&E"(2);
      frule "&E"(1); drule "&E"(2))
  note \<Pi>_minus_\<kappa>I = "rule-id-df:2:b[2]"[
   and \<Pi>_minus_\<kappa>E = "rule-id-df:2:a[2]"[
    by (rule \<Pi>_minus_\<kappa>I) "cqt:2[lambda]"+

  proof -
      using \<Pi>_minus_\<kappa>E that by fast
      by (rule "\<beta>\<rightarrow>C"(1))
      using "&E" by blast+
  qed
  proof -
      by (metis "russell-axiom[exe,1].\<psi>_denotes_asm" that(1))
      by (safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" \<kappa>'_den "&I" that)
      using \<Pi>_minus_\<kappa>I by fast
  qed

    using "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
    using "\<exists>E"[rotated] by blast
    using "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
    using "equi-rem-thm"[unvarify F G, OF \<Pi>_minus_\<kappa>_den, OF \<Pi>_minus_\<kappa>_den,
                         THEN "\<equiv>E"(1), OF R_prop].
    using "equi-rem:4"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
  AOT_hence Fact2:
    using "equi-rem:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast


  proof(safe intro!: "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "\<exists>I"(1)[where \<tau>="?R"] R_den
                     "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "cqt:2" Ordinary.GEN "\<rightarrow>I")
    fix r
    {
        using "\<equiv>E"(2) "thm-neg=E" by blast
        by(rule \<Pi>_minus_\<kappa>I; safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" Fr r_noteq_u)
        using Fact1[THEN "\<forall>E"(2)] "\<rightarrow>E" Ordinary.\<psi> by blast
        using "equi:1"[THEN "\<equiv>E"(1)] by simp
        using "Ordinary.\<exists>E"[rotated] by meson
        using "&E" by blast+
        using s_prop[THEN "&E"(2), THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E", OF "&I", OF that].
        using \<Pi>_minus_\<kappa>E1[OF G_minus_v_s].
        using \<Pi>_minus_\<kappa>E2[OF G_minus_v_s].
      proof(safe intro!: "Ordinary.\<exists>I"[where \<beta>=s] "&I" Gs Ordinary.GEN "\<rightarrow>I")
          by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" "\<or>I"(1) \<Pi>_minus_\<kappa>I' Fr Gs
                           s_noteq_v Rrs r_noteq_u
                   simp: "&I" "ex:1:a" prod_denotesI "rule-ui:3")
      next
        fix t
          using "\<beta>\<rightarrow>C"(1)[OF 0[THEN "&E"(2)], simplified] by blast
          using not_r_eq_u by (metis "&E"(1) "\<or>E"(3) "reductio-aa:1")
      qed
    }
    moreover {
      proof(safe intro!: "Ordinary.\<exists>I"[where \<beta>=v] "&I" Gv Ordinary.GEN "\<rightarrow>I")
          by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" "\<or>I"(2) \<Pi>_minus_\<kappa>I' Fr r_eq_u
                           "ord=Eequiv:1"[THEN "\<rightarrow>E"] Ordinary.\<psi>
                   simp: "&I" "ex:1:a" prod_denotesI "rule-ui:3")
      next
        fix t
          using "\<beta>\<rightarrow>C"(1)[OF 0[THEN "&E"(2)], simplified] by blast
          using r_eq_u \<Pi>_minus_\<kappa>E2
          by (metis "&E"(1) "\<or>E"(2) "\<equiv>E"(1) "reductio-aa:1" "thm-neg=E")
      qed
    }
      using "reductio-aa:2" "equi:1"[THEN "\<equiv>E"(2)] by fast
  next
    fix s

    {
        using "\<equiv>E"(2) "thm-neg=E" by blast
        by (rule \<Pi>_minus_\<kappa>I; auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" Gs s_noteq_v)
        using Fact1'[THEN "Ordinary.\<forall>E"] "\<rightarrow>E" by blast
        using "equi:1"[THEN "\<equiv>E"(1)] by simp
      then AOT_obtain r where
        using "Ordinary.\<exists>E"[rotated] by meson
        using "&E" by blast+
        using r_prop[THEN "&E"(2), THEN "Ordinary.\<forall>E",
                     THEN "\<rightarrow>E", OF "&I", OF that].
        using \<Pi>_minus_\<kappa>E1[OF F_minus_u_r].
        using \<Pi>_minus_\<kappa>E2[OF F_minus_u_r].
      proof(safe intro!: "Ordinary.\<exists>I"[where \<beta>=r] "&I" Fr Ordinary.GEN "\<rightarrow>I")
          by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" "\<or>I"(1) \<Pi>_minus_\<kappa>I' Fr
                           Gs s_noteq_v Rrs r_noteq_u
                   simp: "&I" "ex:1:a" prod_denotesI "rule-ui:3")
      next
        fix t
          using "\<beta>\<rightarrow>C"(1)[OF 0[THEN "&E"(2)], simplified] by blast
          using not_s_eq_v by (metis "&E"(2) "\<or>E"(3) "reductio-aa:1")
      qed
    }
    moreover {
      proof(safe intro!: "Ordinary.\<exists>I"[where \<beta>=u] "&I" Fu Ordinary.GEN "\<rightarrow>I")
          by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" prod_denotesI "\<or>I"(2)
                            \<Pi>_minus_\<kappa>I' Gs s_eq_v Ordinary.\<psi>
                            "ord=Eequiv:1"[THEN "\<rightarrow>E"])
      next
        fix t
          using "\<beta>\<rightarrow>C"(1)[OF 0[THEN "&E"(2)], simplified] by blast
        proof (rule "raa-cor:2")
            by (metis \<Pi>_minus_\<kappa>E2 "\<equiv>E"(4) "reductio-aa:1" s_eq_v "thm-neg=E")
        qed
          by (metis "\<or>E"(2))
      qed
    }
      using "\<equiv>E"(2) "equi:1" "reductio-aa:2" by fast
  qed
qed


proof -
    by (rule q\<^sub>0_def[THEN "=\<^sub>d\<^sub>fE"(2), rotated])
       (simp add: "log-prop-prop:2")
     apply (rule "beta-C-meta"[THEN "\<rightarrow>E"]; "cqt:2[lambda]")
    by (fact 1)
  show ?thesis
  proof (rule "\<exists>I"(1))+
    proof (rule "&I"; rule "RM\<diamond>"[THEN "\<rightarrow>E"]; (rule "\<rightarrow>I")?)
      AOT_modally_strict {
        proof (safe intro!: "empty-approx:1"[unvarify F H, THEN "\<rightarrow>E"]
                            "rel-neg-T:3" "&I")
        next
          proof (rule "raa-cor:2")
              using "Ordinary.\<exists>E"[rotated] by blast
              using "thm-noncont-e-e:2"[THEN "contingent-properties:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"],
                                        THEN "&E"(2)]
              by (metis "qml:2"[axiom_inst] "rule-ui:3" "\<rightarrow>E")
              by (metis  "raa-cor:3")
          qed
        next
          proof (rule "raa-cor:2")
              using "Ordinary.\<exists>E"[rotated] by blast
              using "&E" by blast
              by (rule "\<exists>I")
              using A "&I" by blast
          qed
        qed
      }
    next
        using \<theta> "&E" by blast
    next
      AOT_modally_strict {
        proof (safe intro!: "empty-approx:2"[unvarify F H, THEN "\<rightarrow>E"]
                            "rel-neg-T:3" "&I")
            by "cqt:2[lambda]"
        next
            using A "\<exists>E" by blast
            by (rule "\<beta>\<rightarrow>C"(1))
            by (metis "T\<diamond>" "&E"(1) "vdash-properties:10")
            by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" 1)
            by (rule AOT_ordinary[THEN "=\<^sub>d\<^sub>fI"(2), rotated]) "cqt:2[lambda]"
            using Px "&I" by blast
            by (rule "\<exists>I")
        next
          proof (rule "raa-cor:2")
              using "Ordinary.\<exists>E"[rotated] by blast
              using "thm-noncont-e-e:2"[THEN "contingent-properties:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"]]
              by (metis "qml:2"[axiom_inst] "rule-ui:3" "\<rightarrow>E" "&E"(2))
              by (metis "raa-cor:3")
          qed
        qed
        proof (rule "raa-cor:2")
            apply (rule "eq-part:2"[unvarify F G, THEN "\<rightarrow>E", rotated 2])
             apply "cqt:2[lambda]"
            by (simp add: "rel-neg-T:3")
            using B "&I" by blast
        qed
      }
    next
        using \<theta> "&E" by blast
    qed
      using "S5Basic:11" "\<equiv>E"(2) by blast
  next
      by "cqt:2"
  next
      by (simp add: "rel-neg-T:3")
  qed
qed


AOT_theorem "approx-cont:2":
proof -
    by (rule q\<^sub>0_def[THEN "=\<^sub>d\<^sub>fE"(2), rotated])
       (simp add: "log-prop-prop:2")
     apply (rule "beta-C-meta"[THEN "\<rightarrow>E"]; "cqt:2")
    by (fact 1)
  show ?thesis
  proof (rule "\<exists>I"(1))+
    proof (rule "&I"; rule "RM\<diamond>"[THEN "\<rightarrow>E"]; (rule "\<rightarrow>I")?)
      AOT_modally_strict {
        proof (safe intro!: "empty-approx:1"[unvarify F H, THEN "\<rightarrow>E"]
                            "rel-neg-T:3" "&I")
        next
          proof (rule "raa-cor:2")
              using "Ordinary.\<exists>E"[rotated] by blast
              using "\<beta>\<rightarrow>C"(1) "&E" by blast
              using "thm-noncont-e-e:2"[THEN "contingent-properties:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"]]
              by (metis RN "qml:2"[axiom_inst] "rule-ui:3" "\<rightarrow>E" "&E"(2))
              by (metis "Act-Sub:3" "KBasic2:1" "\<equiv>E"(1) "raa-cor:3" "\<rightarrow>E")
          qed
        next
          proof (rule "raa-cor:2")
              using "Ordinary.\<exists>E"[rotated] by blast
              using "&E" by blast
              by (rule "\<exists>I")
              using A "&I" by blast
          qed
        next
        qed
      }
    next
    next
      AOT_modally_strict {
        proof (safe intro!: "empty-approx:2"[unvarify F H, THEN "\<rightarrow>E"]
                            "rel-neg-T:3" "&I")
        next
            using A "\<exists>E" by blast
            by (rule "\<beta>\<rightarrow>C"(1))
            by (metis "T\<diamond>" "&E"(1) "\<rightarrow>E")
            by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2")
            by (rule AOT_ordinary[THEN "=\<^sub>d\<^sub>fI"(2), rotated]) "cqt:2"
            using Px "&I" by blast
            by (rule "\<exists>I")
        next
          proof (rule "raa-cor:2")
              using "Ordinary.\<exists>E"[rotated] by blast
              using "\<beta>\<rightarrow>C"(1) "&E" by blast
              using "thm-noncont-e-e:2"[THEN "contingent-properties:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"]]
              by (metis RN "qml:2"[axiom_inst] "rule-ui:3" "\<rightarrow>E" "&E"(2))
              by (metis "Act-Sub:3" "KBasic2:1" "\<equiv>E"(1) "raa-cor:3" "\<rightarrow>E")
          qed
        next
        qed
        proof (rule "raa-cor:2")
            by (rule "eq-part:2"[unvarify F G, THEN "\<rightarrow>E", rotated 2])
               "cqt:2"+
            using B "&I" by blast
        qed
      }
    next
        using \<theta> "&E" by blast
    qed
      using "S5Basic:11" "\<equiv>E"(2) by blast
  next
  next
      by (simp add: "rel-neg-T:3")
  qed
qed

notepad
begin
    using eqE by blast
end

proof(rule "\<rightarrow>I")
  proof (safe intro!: "\<exists>I"(1)[where \<tau>="\<guillemotleft>(=\<^sub>E)\<guillemotright>"] "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I"
                      "=E[denotes]" "cqt:2[const_var]"[axiom_inst] Ordinary.GEN
                      "\<rightarrow>I" "equi:1"[THEN "\<equiv>E"(2)])
    fix u
      using "\<equiv>\<^sub>d\<^sub>fE"[OF eqE, OF 0, THEN "&E"(2),
                   THEN "Ordinary.\<forall>E"[where \<alpha>=u], THEN "\<equiv>E"(1)]
            Ordinary.\<psi> Fu by blast
      by (safe intro!: "Ordinary.\<exists>I"[where \<beta>=u] "&I" GEN "\<rightarrow>I" Ordinary.\<psi> Gu
                       "ord=Eequiv:1"[THEN "\<rightarrow>E", OF Ordinary.\<psi>]
                       "ord=Eequiv:2"[THEN "\<rightarrow>E"] dest!: "&E"(2))
  next
    fix v
      using "\<equiv>\<^sub>d\<^sub>fE"[OF eqE, OF 0, THEN "&E"(2),
                   THEN "Ordinary.\<forall>E"[where \<alpha>=v], THEN "\<equiv>E"(2)]
            Ordinary.\<psi> Gv by blast
      by (safe intro!: "Ordinary.\<exists>I"[where \<beta>=v] "&I" GEN "\<rightarrow>I" Ordinary.\<psi> Fv
                       "ord=Eequiv:1"[THEN "\<rightarrow>E", OF Ordinary.\<psi>]
                       "ord=Eequiv:2"[THEN "\<rightarrow>E"] dest!: "&E"(2))
  qed
    by (rule "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
qed

proof(rule "\<rightarrow>I")
    using "apE-eqE:1"[THEN "\<rightarrow>E"] "&E" by blast+
    by (metis Adjunction "eq-part:3" "vdash-properties:10")
qed


proof (safe intro!: eqE[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "cqt:2" Ordinary.GEN "\<rightarrow>I")
  fix u
    by (rule "beta-C-meta"[THEN "\<rightarrow>E"]) "cqt:2[lambda]"
    using "act-conj-act:4" "logic-actual"[act_axiom_inst, THEN "\<rightarrow>E"] by blast
qed

  by (safe intro!: "apE-eqE:1"[unvarify F, THEN "\<rightarrow>E"] "eq-part-act:1") "cqt:2"


proof -
    by (meson "Act-Basic:5" "act-conj-act:4" "\<equiv>E"(2) "Commutativity of \<equiv>")
     apply (rule "beta-C-meta"[THEN "\<rightarrow>E"])
     apply "cqt:2[lambda]"
    by (fact 1)
    by (metis "\<rightarrow>I") 
    using "\<forall>I" by fast
    by (metis "Ordinary.res-var-bound-reas[2]" "\<rightarrow>E")
  AOT_modally_strict {
  } note 2 = this
    using eqE[THEN "\<equiv>Df", THEN "\<equiv>S"(1), OF "&I",
              OF "cqt:2[const_var]"[axiom_inst], OF 2]
    by (auto simp: 1)
    using "apE-eqE:1"[unvarify G, THEN "RA[2]", OF 2] by metis
    by (metis "act-cond" "\<rightarrow>E")
qed

proof(safe intro!: GEN "\<rightarrow>I" "df-rigid-rel:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I")
next
  proof(rule RN; rule GEN; rule "\<rightarrow>I")
    AOT_modally_strict {
      fix x
        by (rule "\<beta>\<rightarrow>C"(1))
         apply (rule "beta-C-meta"[THEN "\<rightarrow>E"])
         apply "cqt:2[lambda]"
        by (fact 1)
    }
  qed
qed

proof(rule "\<rightarrow>I")
    using "df-rigid-rel:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)] by blast
    using CBF[THEN "\<rightarrow>E"] by blast
    using A "qml:2"[axiom_inst, THEN "\<rightarrow>E"] by blast
    by "cqt:2"
  proof (safe intro!: "apE-eqE:1"[unvarify G, THEN "\<rightarrow>E"] eqE[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I"
                      "cqt:2" act_F_den Ordinary.GEN "\<rightarrow>I" "\<equiv>I")
    fix u
      using 1[THEN "\<forall>E"(2), THEN "\<rightarrow>E"] by blast
      by (metis "nec-imp-act" "\<rightarrow>E")
      by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" act_F_u)
  next
    fix u
      by (rule "\<beta>\<rightarrow>C"(1))
      using 0[THEN "\<forall>E"(2)]
      by (metis "\<equiv>E"(1) "sc-eq-fur:2" "\<rightarrow>E")
  qed
qed


AOT_theorem "approx-nec:2":
proof(rule "\<equiv>I"; rule "\<rightarrow>I")
    using "eq-part:4"[THEN "\<equiv>E"(1), OF 0] by blast
    by (rule "\<forall>E"(1)[OF "eq-part:4"[THEN "\<equiv>E"(1), OF 0]]) "cqt:2"
    by (rule GEN)
next
    using "rigid-der:3" "\<exists>E" by metis
    using "df-rigid-rel:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
    using H[THEN "&E"(1), THEN "df-rigid-rel:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(2)].
    using "CBF" "vdash-properties:10" by blast
     by (metis "\<equiv>E"(6) "oth-class-taut:3:a" "sc-eq-fur:2" "\<rightarrow>E")
  proof (safe intro!: eqE[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "cqt:2" Ordinary.GEN "\<rightarrow>I")
  qed
    by (rule "apE-eqE:2"[THEN "\<rightarrow>E", OF "&I", rotated])
       (simp add: "eq-part:1")
    by (metis "eq-part:2" "\<rightarrow>E")
  proof (safe intro!: eqE[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "cqt:2" Ordinary.GEN "\<rightarrow>I")
       apply (rule "beta-C-meta"[THEN "\<rightarrow>E"])
       apply "cqt:2[lambda]"
      using rigid by blast
  qed
    apply (rule "apE-eqE:2"[unvarify H, THEN "\<rightarrow>E"])
     apply "cqt:2[lambda]"
    using F_approx_H H_eq_act_H "&I" by blast
    apply (rule "eq-part:2"[unvarify G, THEN "\<rightarrow>E", rotated])
    by "cqt:2[lambda]"
    by (rule 0[THEN "\<forall>E"(1), THEN "\<equiv>E"(1), rotated]) "cqt:2" 
    by (rule "eq-part:3"[unvarify G, THEN "\<rightarrow>E", rotated, OF "&I", OF a, OF b])
       "cqt:2"
qed

AOT_theorem "approx-nec:3":
proof (rule "\<rightarrow>I")
    using "df-rigid-rel:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)] "&E" by blast+
    using "KBasic:3" "4" "&I" "\<equiv>E"(2) "vdash-properties:10" by meson
  proof(rule RM; rule "\<rightarrow>I"; rule "\<rightarrow>I")
    AOT_modally_strict {
        using "&E" by blast+
        using CBF[THEN "\<rightarrow>E"] by blast+
        using "\<forall>E"(2) by blast+
        by (metis "\<equiv>\<^sub>d\<^sub>fE" "equi:3")
        using "\<exists>E"[rotated] by blast
        using "equi:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
        using "rigid-der:3" "\<exists>E"[rotated] by blast
        using "df-rigid-rel:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
        using "df-rigid-rel:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
        using "\<equiv>E"(1) "rigid-rel-thms:1" by blast
        using tuple_forall[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
        using tuple_forall[THEN "\<equiv>\<^sub>d\<^sub>fE", OF 1[THEN "&E"(2)]] by blast
      proof (safe intro!: Ordinary.GEN "\<rightarrow>I")
        fix u
        proof (rule "raa-cor:1")
            using "KBasic:11" "\<equiv>E"(1) by blast
             apply (meson "\<equiv>E"(6) "oth-class-taut:1:b" "oth-class-taut:3:a")
            by (fact 1)
            using "KBasic2:3" "\<rightarrow>E" by blast
            using F_nec "&E"(1) "\<equiv>E"(1) "sc-eq-box-box:1" "\<rightarrow>E" by blast
            by (metis "qml:2"[axiom_inst] "\<rightarrow>E")
            using C1[THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E"] by blast
            using "equi:1"[THEN "\<equiv>E"(1)] by auto
          then AOT_obtain a where
            using "\<exists>E"[rotated] by blast
          proof(safe intro!: "\<exists>I"(2)[where \<beta>=a] "&I" a_prop[THEN "&E"(1)]
                             "KBasic:3"[THEN "\<equiv>E"(2)])
              using a_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(1)]
              by (metis G_nec "qml:2"[axiom_inst] "\<rightarrow>E")
          next
              using D[THEN "\<forall>E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"]
                    E[THEN "\<forall>E"(2), THEN "\<forall>E"(2), THEN "\<equiv>E"(2),
                      OF a_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(2)]]
              by (metis "T\<diamond>" "\<rightarrow>E")
          next
            proof (rule Ordinary.GEN; rule "raa-cor:1")
              fix v'
                by (metis "KBasic:11" "\<equiv>E"(1))
                   (meson "\<equiv>E"(6) "oth-class-taut:1:b" "oth-class-taut:3:a")
                using "KBasic2:3"[THEN "\<rightarrow>E", THEN "&E"(1)]
                      "KBasic2:3"[THEN "\<rightarrow>E", THEN "&E"(2)] by blast+
                by (meson "B\<diamond>" "KBasic:13" "\<rightarrow>E")
                using 2 D[THEN "\<forall>E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"] by blast
                by (metis "B\<diamond>" "T\<diamond>" "\<rightarrow>E") 
                using E[THEN "\<forall>E"(2), THEN "\<forall>E"(2), THEN "\<equiv>E"(1)] by blast
                using a_prop[THEN "&E"(2), THEN "&E"(2), THEN "Ordinary.\<forall>E",
                             THEN "\<rightarrow>E", OF "&I", OF Gv'] by blast
                by (metis "id-nec3:1" "\<equiv>E"(4) "raa-cor:3")
                using 3 "KBasic:11" "\<equiv>E"(2) by blast
                using "&I" by blast
            qed
              using "Ordinary.res-var-bound-reas[BF]" "\<rightarrow>E" by fast
          qed
            using "Ordinary.res-var-bound-reas[Buridan]" "\<rightarrow>E" by fast
            by (AOT_subst_thm "equi:1")
            using A[THEN "&E"(2)] "KBasic:11"[THEN "\<equiv>E"(2)] by blast
            by (rule "&I")
        qed
      next
        fix v
        proof (rule "raa-cor:1")
            using "KBasic:11" "\<equiv>E"(1) by blast
               (meson "\<equiv>E"(6) "oth-class-taut:1:b" "oth-class-taut:3:a")
            using "KBasic2:3" "\<rightarrow>E" by blast
            using G_nec "&E"(1) "\<equiv>E"(1) "sc-eq-box-box:1" "\<rightarrow>E" by blast
            using C2[THEN "Ordinary.\<forall>E", THEN "\<rightarrow>E"] by blast
            using "equi:1"[THEN "\<equiv>E"(1)] by auto
          then AOT_obtain a where
            using "\<exists>E"[rotated] by blast
          proof(safe intro!: "\<exists>I"(2)[where \<beta>=a] "&I" a_prop[THEN "&E"(1)]
                             "KBasic:3"[THEN "\<equiv>E"(2)])
              using a_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(1)]
              by (metis F_nec "qml:2"[axiom_inst] "\<rightarrow>E")
          next
              using D[THEN "\<forall>E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"]
                    E[THEN "\<forall>E"(2), THEN "\<forall>E"(2), THEN "\<equiv>E"(2),
                      OF a_prop[THEN "&E"(2), THEN "&E"(1), THEN "&E"(2)]]
              by (metis "T\<diamond>" "\<rightarrow>E")
          next
            proof (rule Ordinary.GEN; rule "raa-cor:1")
              fix u'
                by (metis "KBasic:11" "\<equiv>E"(1))
                   (meson "\<equiv>E"(6) "oth-class-taut:1:b" "oth-class-taut:3:a")
                using "KBasic2:3"[THEN "\<rightarrow>E", THEN "&E"(1)]
                      "KBasic2:3"[THEN "\<rightarrow>E", THEN "&E"(2)] by blast+
                by (meson "B\<diamond>" "KBasic:13" "\<rightarrow>E")
                using 2 D[THEN "\<forall>E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"] by blast
                by (metis "B\<diamond>" "T\<diamond>" "\<rightarrow>E") 
                using E[THEN "\<forall>E"(2), THEN "\<forall>E"(2), THEN "\<equiv>E"(1)] by blast
                using a_prop[THEN "&E"(2), THEN "&E"(2), THEN "Ordinary.\<forall>E",
                             THEN "\<rightarrow>E", OF "&I", OF Fu'] by blast
                by (metis "id-nec3:1" "\<equiv>E"(4) "raa-cor:3")
                using 3 "KBasic:11" "\<equiv>E"(2) by blast
                using "&I" by blast
            qed
              using "Ordinary.res-var-bound-reas[BF]" "\<rightarrow>E" by fast
          qed
            using "Ordinary.res-var-bound-reas[Buridan]" "\<rightarrow>E" by fast
            by (AOT_subst_thm "equi:1")
            using A[THEN "&E"(2)] "KBasic:11"[THEN "\<equiv>E"(2)] by blast
            by (rule "&I")
        qed
      qed
        using "Ordinary.res-var-bound-reas[BF]"[THEN "\<rightarrow>E"] by auto
        by (simp_all add: "ex:2:a")
        using "KBasic:3" "&I" "\<equiv>E"(2) by meson
        by (AOT_subst_def "equi:2")
        by (rule "\<exists>I"(2))
        by (metis Buridan "\<rightarrow>E")
        by (AOT_subst_def "equi:3")
    }
  qed
    using "\<rightarrow>E" by blast
qed



AOT_theorem "numbers[den]":
  apply (safe intro!: numbers[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "\<equiv>I" "\<rightarrow>I" "cqt:2"
               dest!: numbers[THEN "\<equiv>\<^sub>d\<^sub>fE"])
  using "&E" by blast+

AOT_theorem "num-tran:1":
proof (safe intro!: "\<rightarrow>I" "\<equiv>I")
    using numbers[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
  proof(safe intro!: numbers[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" Ax "cqt:2" GEN)
    fix F
      using \<theta>[THEN "\<forall>E"(2)].
      using 0 "approx-nec:2"[THEN "\<equiv>E"(1), THEN "\<forall>E"(2)] by metis
  qed
next
    by (metis "eq-part:2" "\<rightarrow>E")
    using numbers[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
  proof(safe intro!: numbers[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" Ax "cqt:2"  GEN)
    fix F
      using \<theta>[THEN "\<forall>E"(2)].
      using 0 "approx-nec:2"[THEN "\<equiv>E"(1), THEN "\<forall>E"(2)] by metis
  qed
qed

AOT_theorem "num-tran:2":
proof (rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
    using numbers[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
    using "\<forall>E"(2) by blast
    using numbers[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
    using "\<forall>E"(2) by blast
    by (metis "1" "\<equiv>E"(6))
    using "approx-nec:2"[THEN "\<equiv>E"(2), OF GEN] by blast
qed

AOT_theorem "num-tran:3":
  using "apE-eqE:1" "Hypothetical Syllogism" "num-tran:1" by blast

AOT_theorem "pre-Hume":
proof(safe intro!: "\<rightarrow>I" "\<equiv>I"; frule "&E"(1); drule "&E"(2))
next
    using numbers[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
    using numbers[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
  proof(rule "ab-obey:1"[THEN "\<rightarrow>E", THEN "\<rightarrow>E", OF "&I", OF Ax, OF Ay]; rule GEN)
    fix F
      using xF[THEN "\<forall>E"(2)].
      using "approx-nec:2"[THEN "\<equiv>E"(1), OF G_approx_H, THEN "\<forall>E"(2)].
      using yF[THEN "\<forall>E"(2), symmetric].
  qed
qed

AOT_theorem "two-num-not":
proof (rule "\<rightarrow>I")
    using "&E" "\<exists>E"[rotated] by blast
    using "&E" "\<exists>E"[rotated] by blast
    using "=E-simple:2"[THEN "\<rightarrow>E"] "=E-simple:2" "\<equiv>E"(2) "modus-tollens:1"
          "=-infix" "\<equiv>\<^sub>d\<^sub>fE" "thm-neg=E" by fast
    using "\<equiv>E"(1) "thm-neg=E" by blast
    by (simp add: "A-objects"[axiom_inst])
    using "\<exists>E"[rotated] by blast
    by (simp add: "A-objects" "vdash-properties:1[2]")
    using "\<exists>E"[rotated] by blast
    by (safe intro!: numbers[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" a_prop[THEN "&E"(1)]
                     a_prop[THEN "&E"(2)]) "cqt:2"
    by (safe intro!: numbers[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" b_prop[THEN "&E"(1)]
                     b_prop[THEN "&E"(2)]) "cqt:2"
  proof (rule "equi:3"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
      by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" prod_denotesI
                       "ord=Eequiv:1"[THEN "\<rightarrow>E"] Od Oc)
                        eqE_den Ordinary.GEN "\<rightarrow>I")
    next
      fix u
        by (metis "\<beta>\<rightarrow>C"(1))
        by (metis "=E-simple:2" "\<rightarrow>E")
      proof (safe intro!: "equi:1"[THEN "\<equiv>E"(2)] "\<exists>I"(2)[where \<beta>=d] "&I"
                          Od Ordinary.GEN "\<rightarrow>I")
          by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "ord=Eequiv:1"[THEN "\<rightarrow>E", OF Od])
      next
          using u_is_c[symmetric] Rcd "rule=E" by fast
      next
        fix v
          by (metis "\<beta>\<rightarrow>C"(1) "&E"(1))
      qed
    next
      fix v
        by (metis "\<beta>\<rightarrow>C"(1))
        by (metis "=E-simple:2" "\<rightarrow>E")
      proof (safe intro!: "equi:1"[THEN "\<equiv>E"(2)] "\<exists>I"(2)[where \<beta>=c] "&I"
                          Oc Ordinary.GEN "\<rightarrow>I")
          by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "ord=Eequiv:1"[THEN "\<rightarrow>E", OF Oc])
      next
          using v_is_d[symmetric] Rcd "rule=E" by fast
      next
        fix u
          by (metis "\<beta>\<rightarrow>C"(1) "&E"(1))
      qed
    next
        by "cqt:2"
    qed
  qed
    using "pre-Hume"[unvarify G H, OF eqE_den, OF eqE_den, THEN "\<rightarrow>E",
                     OF "&I", THEN "\<equiv>E"(2)] by blast
    using num_b_eq_d "rule=E" id_sym by fast
  proof (rule "raa-cor:2")
      using eqE[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"] Oc by blast
      by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "ord=Eequiv:1"[THEN "\<rightarrow>E", OF Oc])
      using "\<equiv>E"(1) by blast
      by (rule "\<beta>\<rightarrow>C"(1))
      using not_c_eqE_d "&I" by blast
  qed
    apply (rule "\<exists>I"(2)[where \<beta>=a])
    by (safe intro!: eqE_den "&I" num_a_eq_c num_a_eq_d not_equiv)
qed

     (auto simp: "numbers[den]"[THEN "\<rightarrow>E", OF "cqt:2[const_var]"[axiom_inst]]
                 "A-objects"[axiom_inst])

     (auto simp: "numbers[den]"[THEN "\<rightarrow>E", OF "cqt:2[const_var]"[axiom_inst]]
                 "A-objects!")

AOT_theorem "num-cont:1":
proof -
    using "approx-cont:2".
    using "\<exists>E"[rotated] by blast
    using "\<exists>E"[rotated] by blast
    using "KBasic2:3"[THEN "\<rightarrow>E"] "&E" "4\<diamond>"[THEN "\<rightarrow>E"] by blast+
    using "num:1" "\<exists>E"[rotated] by blast
  proof (rule "raa-cor:2")
      by (AOT_subst_def (reverse) numbers)
      using "KBasic:3"[THEN "\<equiv>E"(1)] "&E" by blast+
      using CBF[THEN "\<rightarrow>E"] by blast
      using "\<forall>E"(2) by blast
      using "KBasic:4"[THEN "\<equiv>E"(1)] "&E" by blast+
       using "\<equiv>I" "useful-tautologies:4" "useful-tautologies:5" apply presburger
       by (fact A)
       by (metis "KBasic:13" \<zeta> "\<rightarrow>E")
      by (metis "KBasic:11" "en-eq:2[1]" "\<equiv>E"(2) "\<equiv>E"(4))
      by (metis "en-eq:3[1]" "\<equiv>E"(4))
      by (meson B \<theta> "KBasic:13" "\<rightarrow>E")
      using "&I" by blast
  qed

    using "&I" by blast
    by (rule "\<exists>I")
    by (rule "\<exists>I")
qed

AOT_theorem "num-cont:2":
proof(rule "\<rightarrow>I")
    using "df-rigid-rel:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)] by blast
  proof(rule RM; safe intro!: "\<rightarrow>I" GEN)
    AOT_modally_strict {
      fix x
        using "df-rigid-rel:1"[THEN "\<equiv>\<^sub>d\<^sub>fI", OF "&I"] "cqt:2"
        by blast
        using numbers[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
        using "&E" by blast+
        using "\<forall>E"(2) by blast
        using "approx-nec:3"[unvarify F, OF act_den, THEN "\<rightarrow>E", OF "&I",
                             OF "actuallyF:2", OF G_rigid].
        by (simp add: RN "pre-en-eq:1[1]")
        using "sc-eq-box-box:5" "\<rightarrow>E" "qml:2"[axiom_inst] "&I" by meson
        by (rule "\<forall>I")
        using BF[THEN "\<rightarrow>E"] by fast
        by (simp add: "ex:2:a")
        using Ax "oa-facts:2" "\<rightarrow>E" by blast
        by (metis "KBasic:3" "&I" "\<equiv>E"(2))
        using 1 "KBasic:3" "&I" "\<equiv>E"(2) by fast
        by (AOT_subst_def numbers)
    }
  qed
    using "\<rightarrow>E" by blast
qed

AOT_theorem "num-cont:3":
  by (rule "num-cont:2"[unvarify G, THEN "\<rightarrow>E"];
      ("cqt:2[lambda]" | rule "actuallyF:2"))

  using "\<equiv>E"(2) "A-Exists:2" "RA[2]" "num:2" by blast


  using "num-def:1"[THEN "=\<^sub>d\<^sub>fI"(1)] "num-uniq" by simp

AOT_theorem "num-can:1":
proof -
    by (safe intro!: RN GEN "numbers[den]"[THEN "\<rightarrow>E"] "cqt:2")
    using "num-uniq" "equiv-desc-eq:3"[THEN "\<rightarrow>E", OF "&I"] by auto
  thus ?thesis
    by (rule "=\<^sub>d\<^sub>fI"(1)[OF "num-def:1", OF "num-uniq"])
qed

proof (rule id_trans[OF "num-can:1"]; rule "equiv-desc-eq:2"[THEN "\<rightarrow>E"];
       safe intro!: "&I" "A-descriptions" GEN "Act-Basic:5"[THEN "\<equiv>E"(2)]
                    "logic-actual-nec:3"[axiom_inst, THEN "\<equiv>E"(2)])
    by "cqt:2"
    by (metis "&I" "eq-part:2" "eq-part:3" "\<rightarrow>I" "&E" "\<rightarrow>E")
  fix x
  {
    fix F
      by (simp add: "actuallyF:1")
      by (auto intro!: "RA[2]" "\<rightarrow>I" "\<equiv>I"
               simp: "eq-part:3"[unvarify G, OF act_den, THEN "\<rightarrow>E", OF "&I"]
                     "eq-part:3[terms]"[unvarify G, OF act_den, THEN "\<rightarrow>E", OF "&I"])
      using "logic-actual-nec:2"[axiom_inst, THEN "\<equiv>E"(1), THEN "\<rightarrow>E"] by blast

      by (metis "Act-Basic:5" "\<equiv>E"(1))
      by (auto intro!: "\<equiv>I" "\<rightarrow>I" elim: "\<equiv>E")
      by (simp add: "Act-Basic:5")
      by (meson "Act-Basic:5" "\<equiv>E"(6) "oth-class-taut:3:a")
  } note 0 = this
    using "logic-actual-nec:3" "vdash-properties:1[2]" by blast
    apply (safe intro!: "\<equiv>I" "\<rightarrow>I" GEN)
    using 0 "\<equiv>E"(1) "\<equiv>E"(2) "rule-ui:3" by blast+
    using "\<equiv>E"(6) "logic-actual-nec:3"[axiom_inst] "oth-class-taut:3:a" by fast
    by (simp add: "Act-Basic:2")
    using 0 "oth-class-taut:4:f" "\<rightarrow>E" by blast
    using "Act-Basic:2" "\<equiv>E"(6) "oth-class-taut:3:a" by blast
qed


proof(rule "\<rightarrow>I")
    by (AOT_subst_def card)
qed

  apply (rule "=\<^sub>d\<^sub>fI"(1)[OF "num-def:1"])
  apply (simp add: "num-uniq")
  using "num-uniq" "vdash-properties:10" "y-in:3" by blast

  by (safe intro!: "pre-Hume"[unvarify x y, OF "num-def:2",
                              OF "num-def:2", THEN "\<rightarrow>E"] "&I" "hume:1")

  using "equi-rem-thm"
  using "equi:3" "hume:2" "\<equiv>E"(5) "\<equiv>Df" by blast

  by (metis "apE-eqE:1" "deduction-theorem" "hume:2" "\<equiv>E"(2) "\<rightarrow>E")

AOT_theorem "hume-strict:1":
proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
    using "\<exists>E"[rotated] by blast
    using "num-tran:2" "\<rightarrow>E" by blast
next
    by (metis "instantiation" "num:1")
    using calculation "num-tran:1"[THEN "\<rightarrow>E", THEN "\<equiv>E"(1)] by blast
    by (safe intro!: "&I")
    by (rule "\<exists>I")
qed

AOT_theorem "hume-strict:2":
proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
  then AOT_obtain x where
    using "\<exists>E"[rotated] by blast
  then AOT_obtain y where
    using "\<exists>E"[rotated] by blast
    using "&E" by blast+
    using "&I" "rule=E" by fast
    by (rule "\<exists>I")
    using "hume-strict:1"[THEN "\<equiv>E"(1)] by blast
next
    using "hume-strict:1"[THEN "\<equiv>E"(2)] by blast
    using "\<exists>E"[rotated] by blast
    using calculation
    by (auto intro!: GEN "\<rightarrow>I" "pre-Hume"[THEN "\<rightarrow>E", OF "&I", THEN "\<equiv>E"(2),
                                         rotated 2, OF "eq-part:1"] dest: "&E")
    by (auto intro!: "&I" "id-eq:1" dest: "&E")
    by (auto intro!: "\<exists>I")
qed

proof(rule "raa-cor:2")
    using "\<exists>E"[rotated] by blast
    by (rule "\<beta>\<rightarrow>C"(1))
    using "&E"(2) "\<equiv>E"(1) "thm-neg=E" by blast
    by (metis 0[THEN "&E"(1)] "ord=Eequiv:1" "\<rightarrow>E")
    by (metis "raa-cor:3")
qed


  by (rule "=\<^sub>d\<^sub>fI"(2)[OF "zero:1"]; rule "num-def:2"[unvarify G]; "cqt:2")

  apply (rule "=\<^sub>d\<^sub>fI"(2)[OF "zero:1"])
   apply (rule "num-def:2"[unvarify G]; "cqt:2")
  apply (rule card[THEN "\<equiv>\<^sub>d\<^sub>fI"])
   apply (rule "rule=I:1"; rule "num-def:2"[unvarify G]; "cqt:2")
  by "cqt:2"

AOT_theorem "eq-num:1":
proof -
    using "hume-strict:1"[unvarify G, OF act_den, THEN RN].
    using "nec-imp-act"[THEN "\<rightarrow>E"] by fast
    using "actuallyF:1" "Act-Basic:5" "\<equiv>E"(1) "\<equiv>E"(2) by fast
    by (metis "Act-Basic:10" "intro-elim:3:a")
    using "\<exists>E"[rotated] by blast
    using "Act-Basic:2" "&E" "\<equiv>E"(1) by blast+
    using "num-cont:2"[unvarify G, OF act_den, THEN "\<rightarrow>E", OF "actuallyF:2",
                       THEN CBF[THEN "\<rightarrow>E"], THEN "\<forall>E"(2)]
    by (metis "\<equiv>E"(1) "sc-eq-fur:2" "vdash-properties:6")
    using "pre-Hume"[THEN "\<rightarrow>E", THEN "\<equiv>E"(2), rotated, OF "eq-part:1"]
          "\<rightarrow>I" by blast
  show ?thesis
  proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
      using 0[THEN "RA[2]", THEN "act-cond"[THEN "\<rightarrow>E"], THEN "\<rightarrow>E",
              OF "Act-Basic:2"[THEN "\<equiv>E"(2)], OF "&I"]
            act_a_num_G by blast
      using "rule=E" num_a_act_g by fast
  next
      using "pre-Hume"[unvarify G H, THEN "\<rightarrow>E", OF act_den, OF act_den, OF "&I",
                       OF num_a_act_g, THEN "\<equiv>E"(2)]
            "eq-part:1"[unvarify F, OF act_den] by blast
      using act_a_num_G "rule=E" by fast
  qed
qed

proof -
       (auto simp: "eq-num:1" descriptions[axiom_inst])
    using 0[unvarify x, OF "num-def:2"].
    using "num-def:1" "num-uniq" "rule-id-df:1" by blast
    using "\<equiv>E" by blast
  thus ?thesis using "\<forall>E"(2) by blast
qed

proof -
    by (simp add: "rule=I:1" "num-def:2")
  thus ?thesis
    using "eq-num:2"[unvarify x, OF "num-def:2", THEN "\<equiv>E"(2)] by blast
qed

AOT_theorem "eq-num:4":
  by (auto intro!: "&I" "eq-num:3"[THEN numbers[THEN "\<equiv>\<^sub>d\<^sub>fE"],
                                   THEN "&E"(1), THEN "&E"(1)]
                   "eq-num:3"[THEN numbers[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(2)])

  by (auto intro!: "eq-num:4"[THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<equiv>E"(2)]
                   "eq-part:1"[unvarify F] simp: "cqt:2")

proof(rule "\<rightarrow>I")
    by "cqt:2"
    by (metis "instantiation" "rigid-der:3")
    using "df-rigid-rel:2"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)]
          "df-rigid-rel:2"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(1)]
    by blast+
    by (auto intro!: eqE[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "cqt:2" GEN "\<rightarrow>I" elim: "\<forall>E"(2))
    using "num-tran:3"[THEN "\<rightarrow>E", THEN "\<equiv>E"(2)] by blast
    using \<theta> "approx-nec:1" "\<rightarrow>E" by blast
    using "num-tran:1"[unvarify H, OF act_den, THEN "\<rightarrow>E", THEN "\<equiv>E"(1)] by blast
    using "eq-num:2"[THEN "\<equiv>E"(1)] by blast
    by (rule "\<exists>I")
    using card[THEN "\<equiv>\<^sub>d\<^sub>fI"] by blast
qed

proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
    using "\<exists>E"[rotated] by blast
    using "eq-num:2"[THEN "\<equiv>E"(2)] by blast
next
    using "\<exists>E"[rotated] by blast
    using "eq-num:6"[THEN "\<rightarrow>E"] by blast
    using card[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
qed

proof(rule "\<rightarrow>I"; rule GEN)
  fix F
    using card[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
    using "\<exists>E"[rotated] by blast
    using "eq-num:2"[THEN "\<equiv>E"(2)] by blast
    using "eq-num:4"[THEN "&E"(2), THEN "\<forall>E"(2)] by blast
    using x_def[symmetric] "rule=E" by fast
    using "num-tran:1"[unvarify G H, OF act_den, OF act_den]
    using "num-tran:2"[unvarify G H, OF act_den, OF act_den]
    by (metis "&I" "deduction-theorem" "\<equiv>I" "\<equiv>E"(2) num_x_act_P)
    using "eq-num:2" by blast
qed

proof -
  proof(rule "raa-cor:2")
      using "\<exists>E"[rotated] "&E" by blast
      by (rule "\<beta>\<rightarrow>C"(1))
       apply (meson "\<equiv>E"(2) "Commutativity of \<equiv>" "thm-neg=E")
      by (fact 0[THEN "&E"(2)])
      by (metis "\<not>\<not>I" "Act-Sub:1" "id-act2:1" "\<equiv>E"(4))
      by (metis 0[THEN "&E"(1)] "ord=Eequiv:1" "\<rightarrow>E")
      by (metis "raa-cor:3")
  qed
    apply (rule "=\<^sub>d\<^sub>fI"(2)[OF "zero:1"])
     apply (rule "num-def:2"[unvarify G]; "cqt:2")
    apply (rule "eq-num:3"[unvarify G])
    by "cqt:2[lambda]"
  proof (rule "num-tran:3"[unvarify x G H, THEN "\<rightarrow>E", THEN "\<equiv>E"(1), rotated 4])
    proof (safe intro!: eqE[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" Ordinary.GEN "\<rightarrow>I" "cqt:2")
      fix u
        by (rule "beta-C-meta"[THEN "\<rightarrow>E"]; "cqt:2[lambda]")
         apply (rule "beta-C-meta"[THEN "\<rightarrow>E"]; "cqt:2[lambda]")
        by (simp add: "oth-class-taut:3:a")
        by (simp add: "Act-Basic:2")
        by (metis Ordinary.\<psi> "&I" "&E"(2) "\<rightarrow>I" "\<equiv>I" "\<equiv>E"(1) "oa-facts:7")
        by (rule "beta-C-meta"[THEN "\<rightarrow>E", symmetric]; "cqt:2[lambda]")
    qed
  qed(fact "zero:2" | "cqt:2")+
  show ?thesis
  proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
      using unotEu_act_ord.
      by (rule "empty-approx:1"[unvarify H, THEN "\<rightarrow>E", rotated, OF "&I"]) "cqt:2"
      by (rule "num-tran:1"[unvarify x H, THEN "\<rightarrow>E",
                            THEN "\<equiv>E"(2), rotated, rotated])
         (fact "zero:2" numbers0 | "cqt:2[lambda]")+
  next
      by (rule "num-tran:2"[unvarify x H, THEN "\<rightarrow>E", rotated 2, OF "&I"])
         (fact numbers0 "zero:2" | "cqt:2[lambda]")+
    proof(rule "raa-cor:2")
        by (rule "empty-approx:2"[unvarify H, OF 0, THEN "\<rightarrow>E", OF "&I"])
           (rule unotEu_act_ord)
        using 1 "&I" by blast
    qed
  qed
qed

proof(rule "\<equiv>I"; rule "\<rightarrow>I")
  proof(rule "raa-cor:2")
      using "Ordinary.\<exists>E"[rotated] by blast
      by (metis "betaC:1:a")
      by (rule "Ordinary.\<exists>I")
      using 0 "&I" by blast
  qed
    by (safe intro!: "0F:1"[unvarify F, THEN "\<equiv>E"(1)]) "cqt:2"
    by (rule "eq-num:2"[unvarify x, OF "zero:2", THEN "\<equiv>E"(1)])
next
    by (rule "eq-num:2"[unvarify x, OF "zero:2", THEN "\<equiv>E"(2)])
    by (safe intro!: "0F:1"[unvarify F, THEN "\<equiv>E"(2)]) "cqt:2"
  proof(rule "raa-cor:2")
      using "Ordinary.\<exists>E"[rotated] by meson
      by (auto intro!: "\<beta>\<leftarrow>C" "cqt:2")
      using "Ordinary.\<exists>I" by blast
      using "&I" 0 by blast
  qed
qed

proof(rule "\<rightarrow>I")
    using "KBasic2:1" "\<equiv>E"(1) by blast
  proof(rule "raa-cor:2")
      using "Ordinary.\<exists>E"[rotated] by blast
      by (metis "betaC:1:a")
      by (metis "Act-Sub:3" "\<rightarrow>E")
      by (rule "Ordinary.\<exists>I")
      using "Ordinary.res-var-bound-reas[CBF\<diamond>]"[THEN "\<rightarrow>E"] by blast
      using 0 "&I" by blast
  qed
    by (safe intro!: "0F:1"[unvarify F, THEN "\<equiv>E"(1)]) "cqt:2"
    by (rule "eq-num:2"[unvarify x, OF "zero:2", THEN "\<equiv>E"(1)])
qed

proof (rule "rule-id-df:2:b"[OF "w-index", where \<tau>\<^sub>1\<tau>\<^sub>n="(_,_)", simplified])
    by (simp add: "w-rel:3")
next
  proof (rule "\<equiv>I"; rule "\<rightarrow>I")
      using "coherent:1"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(1)] by blast
    proof(rule "raa-cor:2")
        using "Ordinary.\<exists>E"[rotated] by meson
            safe intro!: "beta-C-meta"[THEN "\<rightarrow>E"] "w-rel:1"[THEN "\<rightarrow>E"])
           "cqt:2"
        using "rigid-truth-at:4"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(1)]
        by blast
        using "Ordinary.\<exists>I" "\<rightarrow>I" RN by simp
        using "fund:2"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(1)]
              "PossibleWorld.\<forall>E" by fast
        using 1 "conj-dist-w:2"[unvarify p q, OF "log-prop-prop:2",
                                OF "log-prop-prop:2", THEN "\<equiv>E"(1),
                                THEN "\<rightarrow>E"] by blast
        using 0 "&I" by blast
    qed
      by (safe intro!: "0F:2"[unvarify F, THEN "\<equiv>E"(1)] "w-rel:1"[THEN "\<rightarrow>E"])
         "cqt:2"
  next
      by (safe intro!: "0F:2"[unvarify F, THEN "\<equiv>E"(2)] "w-rel:1"[THEN "\<rightarrow>E"])
         "cqt:2"
    proof (rule "raa-cor:2")
        using "conj-dist-w:6"[THEN "\<equiv>E"(1)] by fast
        using "\<exists>E"[rotated] by blast
        using "conj-dist-w:1"[unvarify p q] "\<equiv>E"(1) "log-prop-prop:2"
              "&E" by blast+
        using "fund:1"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(2)]
              "PossibleWorld.\<exists>I" by simp
        using "oa-facts:3"[THEN "\<rightarrow>E"] by blast
        using "rigid-truth-at:4"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(2)]
              Fx_in_w by blast
            safe intro!: "beta-C-meta"[THEN "\<rightarrow>E"] "w-rel:1"[THEN "\<rightarrow>E"]) "cqt:2"
        using ord_x "&I" by blast
        using "\<exists>I" by fast
        using 0 "&I" by blast
    qed
      using "coherent:1"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(2)] by blast
  qed
qed

AOT_act_theorem "zero=:1":
proof(safe intro!: "\<rightarrow>I" GEN)
  fix F
    by (metis "card-en" "\<rightarrow>E")
    using "\<forall>E"(2) by blast
    by (rule "num-def:1"[THEN "=\<^sub>d\<^sub>fE"(1)])
       (auto simp: 1 "num-uniq")
    using "y-in:1" by blast
  proof(rule "\<rightarrow>I")
      using "num:2"[THEN "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"]] "\<exists>E"[rotated] "&E" by blast
      using "\<forall>E"(2) "\<rightarrow>E" by blast
      using z_prop "rule=E" id_sym by fast
      by (rule hintikka[THEN "\<equiv>E"(2), OF "&I", rotated])
         (fact 1)
  qed
    by (metis "\<equiv>I")
    using 2 by (metis "\<equiv>E"(5))
qed

proof -
    using "zero=:1"[unvarify x, OF "zero:2", THEN "\<rightarrow>E",
                    OF "zero-card", THEN "\<forall>E"(2)].
    using "0F:1"[symmetric].
  finally show ?thesis.
qed

proof -
    using "card-en"[unvarify x, OF "zero:2", THEN "\<rightarrow>E",
                    OF "zero-card", THEN "\<forall>E"(2)].
    by (simp add: "deduction-theorem" id_sym "\<equiv>I")
  finally show ?thesis.
qed

  "hered:1":

AOT_theorem "hered:2":
  by "cqt:2[lambda]"

  "ances-df":

AOT_theorem "ances":
  apply (rule "=\<^sub>d\<^sub>fI"(1)[OF "ances-df"])
   apply "cqt:2[lambda]"
  apply (rule "beta-C-meta"[THEN "\<rightarrow>E", OF "hered:2", unvarify \<nu>\<^sub>1\<nu>\<^sub>n,
  by (simp add: "&I" "ex:1:a" prod_denotesI "rule-ui:3")

AOT_theorem "anc-her:1":
proof (safe intro!: "\<rightarrow>I" ances[THEN "\<equiv>E"(2)] GEN)
  fix F
    using "\<forall>E"(2) "&E" by blast
    using "\<rightarrow>E" by blast
qed

AOT_theorem "anc-her:2":
proof(rule "\<rightarrow>I"; (frule "&E"(1); drule "&E"(2))+)
    using ances[THEN "\<equiv>E"(1)] "\<forall>E"(2) by blast
    using "\<rightarrow>E" "&I" by blast
qed

AOT_theorem "anc-her:3":
proof(rule "\<rightarrow>I"; (frule "&E"(1); drule "&E"(2))+)
    using "hered:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
  proof (rule GEN; rule "\<rightarrow>I")
    fix z
      using 3 "\<forall>E"(2) by blast
      using 1 "\<rightarrow>E" by blast
  qed
    by (auto intro!: 2 "anc-her:2"[THEN "\<rightarrow>E"] "&I")
qed

proof(rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
  proof(safe intro!: ances[THEN "\<equiv>E"(2)] GEN "&I" "\<rightarrow>I";
                     frule "&E"(1); drule "&E"(2))
    fix F
      using 1 "\<forall>E"(2) "\<rightarrow>E" by blast
      by (rule "anc-her:3"[THEN "\<rightarrow>E"]; auto intro!: "&I" 1 2 0)
  qed
qed

proof (rule "\<rightarrow>I")
  proof(rule "anc-her:2"[unvarify F, OF 0, THEN "\<rightarrow>E"];
        safe intro!: "&I" GEN "\<rightarrow>I" "hered:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "cqt:2" 0)
  next
    fix z
      by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2")
  next
    fix x y
      by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2")
  qed
    by (rule "\<beta>\<rightarrow>C"(1))
qed

proof (rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
    using "\<forall>E"(2)  ances[THEN "\<equiv>E"(1)] by blast
    using "\<forall>E"(2) ances[THEN "\<equiv>E"(1)] by blast
  proof (rule ances[THEN "\<equiv>E"(2)]; safe intro!: GEN "\<rightarrow>I")
    fix F
    proof (rule \<xi>[THEN "\<rightarrow>E", OF "&I"])
        using \<zeta>[THEN "&E"(2)].
    next
      proof(rule GEN; rule "\<rightarrow>I")
        fix z
          using \<theta>[THEN "\<rightarrow>E", OF \<zeta>].
          using \<zeta>[THEN "&E"(2), THEN "hered:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"],
                  THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<forall>E"(2),
                  THEN "\<rightarrow>E", THEN "\<rightarrow>E"]
          by blast
      qed
    qed
  qed
qed



proof(rule "\<rightarrow>I")
    using "df-1-1:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
    using "df-1-1:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E"(2) "\<forall>E"(2) by blast
       (auto simp: 1 "id-nec:2" "\<equiv>I" "qml:2"[axiom_inst])
    using "df-rigid-rel:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF RigidR] "&E" by blast
    using "CBF"[THEN "\<rightarrow>E"] by fast
    using tuple_forall[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
    using "\<forall>E"(2) by blast
    by (metis "KBasic:3" "&I" "\<equiv>E"(3) "raa-cor:3")
    by (rule RM) (metis "\<rightarrow>I" "KBasic:3" "&I" "&E"(1) "&E"(2) "\<equiv>E"(2) "\<rightarrow>E")
    using "\<rightarrow>E" by blast
    using "sc-eq-box-box:6"[THEN "\<rightarrow>E", THEN "\<rightarrow>E", OF 2, OF 1] by blast
    by (safe intro!: GEN BF[THEN "\<rightarrow>E"] 3)
    by (AOT_subst_thm "df-1-1:1"[THEN "\<equiv>Df", THEN "\<equiv>S"(1),
                                 OF "cqt:2[const_var]"[axiom_inst]])
qed

proof(rule GEN;rule "\<rightarrow>I")
AOT_modally_strict {
  fix R
        by (meson "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) "df-1-1:1" "df-1-1:2")
        using "exist-nec" "\<rightarrow>E" by blast
        using "df-1-1:3"[unvarify R, OF 1, THEN "\<rightarrow>E", OF 0].
        using 0 "\<equiv>\<^sub>d\<^sub>fE"[OF "df-1-1:2"] "&E" by blast
        using  "df-rigid-rel:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
        by (metis "S5Basic:6" "\<equiv>E"(1))
        apply (AOT_subst_def "df-rigid-rel:1")
        using 2 "KBasic:3" "\<equiv>S"(2) "\<equiv>E"(2) by blast
        apply (AOT_subst_def "df-1-1:2")
        using 4 "KBasic:3" "\<equiv>S"(2) "\<equiv>E"(2) by blast
}
qed


AOT_register_rigid_restricted_type
proof
  AOT_modally_strict {
      proof (safe intro!: "df-1-1:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "df-1-1:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"]
                          GEN "\<rightarrow>I" "df-rigid-rel:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "=E[denotes]")
        fix x y z
          by (metis "rule=E" "&E"(1) "Conjunction Simplification"(2)
                    "=E-simple:2" id_sym "\<rightarrow>E")
      next
        proof(rule GEN; rule GEN)
            by (meson RN "deduction-theorem" "id-nec3:1" "\<equiv>E"(1))
        qed
          by (rule tuple_forall[THEN "\<equiv>\<^sub>d\<^sub>fI"])
          using BF[THEN "\<rightarrow>E"] by fast
      qed
    qed(fact "=E[denotes]")
  }
next
  AOT_modally_strict {
    proof(rule "\<rightarrow>I")
        using "df-1-1:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
        using "df-1-1:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
    qed
  }
next
  AOT_modally_strict {
      by (safe intro!: GEN "df-1-1:4"[THEN "\<forall>E"(2)])
  }
qed
AOT_register_variable_names
  RigidOneToOneRelation: \<R> \<S>


translations
  "_AOT_id_d_R_infix \<kappa> \<Pi> \<kappa>'" ==
  "CONST AOT_exe (CONST IdentityRestrictedToDomain \<Pi>) (\<kappa>,\<kappa>')"

proof -
  show ?thesis
    apply (rule "=\<^sub>d\<^sub>fI"(1)[OF "id-d-R"])
    apply (fact 0)
    apply (rule "beta-C-meta"[THEN "\<rightarrow>E", OF 0, unvarify \<nu>\<^sub>1\<nu>\<^sub>n,
    by (simp add: "&I" "ex:1:a" prod_denotesI "rule-ui:3")
qed

AOT_theorem "id-R-thm:2":
proof(rule "\<rightarrow>I")
    using "id-R-thm:1"[THEN "\<equiv>E"(1)] by simp
    using "\<exists>E"[rotated] by blast
  proof (safe intro!: "&I" "df-1-1:5"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
      using z_prop[THEN "&E"(1)] "\<exists>I" by fast
  next
      using z_prop[THEN "&E"(2)] "\<exists>I" by fast
  qed
qed

proof(rule "\<rightarrow>I")
    using "id-R-thm:1"[THEN "\<equiv>E"(1)] by simp
    using "\<exists>E"[rotated] by blast
    using "df-1-1:3"[THEN "\<rightarrow>E", OF RigidOneToOneRelation.\<psi>,
                     THEN "qml:2"[axiom_inst, THEN "\<rightarrow>E"],
                     THEN "\<equiv>\<^sub>d\<^sub>fE"[OF "df-1-1:1"], THEN "&E"(2),
                     THEN "\<forall>E"(2), THEN "\<forall>E"(2),
                     THEN "\<forall>E"(2), THEN "\<rightarrow>E"]
     by blast
qed

AOT_theorem "id-R-thm:4":
proof (rule "\<rightarrow>I")
  moreover {
      by (metis "\<equiv>\<^sub>d\<^sub>fE" "df-1-1:5")
      using "\<exists>E"[rotated] by blast
    proof(safe intro!: "\<equiv>I" "\<rightarrow>I" "id-R-thm:3"[THEN "\<rightarrow>E"])
        using z_prop "rule=E" by fast
        using z_prop "&I" by blast
        by (rule "\<exists>I")
        using "id-R-thm:1" "\<equiv>E"(2) by blast
    qed
  }
  moreover {
      by (metis "\<equiv>\<^sub>d\<^sub>fE" "df-1-1:5")
      using "\<exists>E"[rotated] by blast
    proof(safe intro!: "\<equiv>I" "\<rightarrow>I" "id-R-thm:3"[THEN "\<rightarrow>E"])
        using z_prop "rule=E" id_sym by fast
        using z_prop "&I" by blast
        by (rule "\<exists>I")
        using "id-R-thm:1" "\<equiv>E"(2) by blast
    qed
  }
    by (metis "\<or>E"(2) "raa-cor:1")
qed

proof (rule "\<rightarrow>I")
    by (metis "\<equiv>\<^sub>d\<^sub>fE" "df-1-1:5")
    using "\<exists>E"[rotated] by blast
    using "&I" by blast
    using "\<exists>I" by fast
    using "id-R-thm:1" "\<equiv>E"(2) by blast
qed

proof(rule "\<rightarrow>I")
    using "id-R-thm:2"[THEN "\<rightarrow>E"] by blast
    using "id-R-thm:4"[THEN "\<rightarrow>E", OF "\<or>I"(1)] "&E" by blast
    using 0 by (metis "\<equiv>E"(1))
    using id_sym by blast
    using "id-R-thm:4"[THEN "\<rightarrow>E", OF "\<or>I"(2)] 1 "&E" by blast
    by (metis "\<equiv>E"(2))
qed

proof (rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
    using "id-R-thm:2"[THEN "\<rightarrow>E"] by blast
    using "id-R-thm:4"[THEN "\<rightarrow>E", OF "\<or>I"(1)] "&E" by blast
    using 0 by (metis "\<equiv>E"(1))
    using "id-R-thm:2"[THEN "\<rightarrow>E"] by blast
    using "id-R-thm:4"[THEN "\<rightarrow>E", OF "\<or>I"(1)] "&E" by blast
    using 2 by (metis "\<equiv>E"(1))
    using x_eq_y id_trans by blast
    using 1 3 "&I" "&E" by meson
    using "id-R-thm:4"[THEN "\<rightarrow>E", OF "\<or>I"(1)] "&E" by blast
    using x_eq_z "\<equiv>E"(2) by blast
qed


  by "cqt:2"
  using "w-ances-df[den1]" "=\<^sub>d\<^sub>fI"(1)[OF "w-ances-df"] by blast

proof -
    by "cqt:2"
    by (simp add: "&I" "ex:1:a" prod_denotesI "rule-ui:3")
    by (simp add: cond_case_prod_eta)
  show ?thesis
    apply (rule "=\<^sub>d\<^sub>fI"(1)[OF "w-ances-df"])
     apply (fact "w-ances-df[den1]")
    using "beta-C-meta"[THEN "\<rightarrow>E", OF 0, unvarify \<nu>\<^sub>1\<nu>\<^sub>n,
qed

proof(rule "\<rightarrow>I")
    using "anc-her:1"[THEN "\<rightarrow>E"] by blast
    using "w-ances"[THEN "\<equiv>E"(2)] "\<or>I" by blast
qed

AOT_theorem "w-ances-her:2":
proof(rule "\<rightarrow>I"; (frule "&E"(1); drule "&E"(2))+)
    using "w-ances"[THEN "\<equiv>E"(1)] by simp
  moreover {
      using "anc-her:3"[THEN "\<rightarrow>E", OF "&I", OF "&I"] 0 1 by blast
  }
  moreover {
      using "id-R-thm:3"[THEN "\<rightarrow>E"] by blast
      using 0 "rule=E" by blast
  }
    by (metis "\<or>E"(3) "raa-cor:1")
qed

proof(rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
    using "w-ances"[THEN "\<equiv>E"(1)] by metis
  moreover {
    proof (safe intro!: ances[THEN "\<equiv>E"(2)] "\<rightarrow>I" GEN)
      fix F
        using R_star_xy ances[THEN "\<equiv>E"(1), OF R_star_xy,
                              THEN "\<forall>E"(2), THEN "\<rightarrow>E"] by blast
        using "hered:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF 0[THEN "&E"(2)], THEN "&E"(2)]
              "\<forall>E"(2) "\<rightarrow>E" Ryz by blast
    qed
  }
  moreover {
      using "id-R-thm:3"[THEN "\<rightarrow>E"] by blast
      using Ryz "rule=E" id_sym by fast
      by (metis "anc-her:1"[THEN "\<rightarrow>E"])
  }
    by (metis "\<or>E"(3) "raa-cor:1")
qed

proof(rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
    using "\<or>I" by blast
    using "w-ances"[THEN "\<equiv>E"(2)] by blast
    using "w-ances-her:3"[THEN "\<rightarrow>E", OF "&I"] by simp
    using "\<or>I" by blast
    using "w-ances"[THEN "\<equiv>E"(2)] by blast
qed

proof(rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
    by (metis "\<equiv>E"(1) "w-ances")
  moreover {
      using 0 by (metis "anc-her:4" Adjunction "\<rightarrow>E")
  }
  moreover {
      by (metis "id-R-thm:3" "\<rightarrow>E")
      using 0 "rule=E" by fast
      by (metis "anc-her:1" "\<rightarrow>E")
  }
qed

proof(rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
    by (metis "\<equiv>E"(1) "w-ances")
  {
      by (metis "id-R-thm:3" "\<rightarrow>E")
      using 2 "rule=E" id_sym by fast
  }
  moreover {
      using 1 by (metis "\<or>E"(3)) 
      using 2 by (metis "\<equiv>E"(1) "w-ances")
    moreover {
        using 3 by (metis "anc-her:6" Adjunction "\<rightarrow>E")
        by (metis "\<or>I"(1) "\<equiv>E"(2) "w-ances")
    }
    moreover {
        by (metis "id-R-thm:3" "\<rightarrow>E")
        using 0 "rule=E" id_sym by fast
    }
      by (metis "\<or>E"(3) "reductio-aa:1")
  }
    by (metis "reductio-aa:1")
qed

proof(rule "\<rightarrow>I")
    using ances[THEN "\<equiv>E"(1), THEN "\<forall>E"(1), OF 0] that by blast
  proof (rule 1[THEN "\<rightarrow>E"]; "cqt:2[lambda]"?;
         safe intro!: "&I" GEN "\<rightarrow>I" "hered:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "cqt:2")
    fix z
      by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2")
  next
    fix x' y
      using "\<beta>\<rightarrow>C"(1) by blast
      using "\<exists>E"[rotated] by blast
      by (meson Rx'y "anc-her:1" "anc-her:6" Adjunction "\<rightarrow>E" "w-ances-her:3")
      by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2")
  qed
    using "\<beta>\<rightarrow>C"(1) by fast
qed

proof(rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
    using "w-ances-her:7"[THEN "\<rightarrow>E"] by simp
    using "\<exists>E"[rotated] by blast
    using "df-1-1:2"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF RigidOneToOneRelation.\<psi>, THEN "&E"(1),
                     THEN "\<equiv>\<^sub>d\<^sub>fE"[OF "df-1-1:1"], THEN "&E"(2), THEN "\<forall>E"(2),
                     THEN "\<forall>E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E", OF "&I"]
    "&E" by blast
    using a_prop[THEN "&E"(1)] "rule=E" id_sym by fast
qed

proof(rule "\<rightarrow>I"; rule "useful-tautologies:5"[THEN "\<rightarrow>E"]; rule "\<rightarrow>I")
    using "1-1-R:1"[THEN "\<rightarrow>E", OF "&I"] by blast
    using 0 by (metis "&I" "\<rightarrow>E" "w-ances-her:5")
qed

proof(safe intro!: "\<rightarrow>I")
  proof(rule "w-ances-her:2"[unvarify F, OF 0, THEN "\<rightarrow>E"];
        safe intro!: "&I" "hered:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "cqt:2" GEN "\<rightarrow>I")
      by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" simp: 1)
  next
  next
    fix x y
      using "1-1-R:2"[THEN "\<rightarrow>E", THEN "\<rightarrow>E"] by blast
      by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2")
  qed
    using "\<beta>\<rightarrow>C"(1) by blast
qed

proof(rule "\<rightarrow>I"; rule "df-1-1:5"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
  proof (safe intro!: "anc-her:2"[unvarify F, THEN "\<rightarrow>E"];
         safe intro!: "cqt:2" "&I" GEN "\<rightarrow>I" "hered:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
  next
    fix z
      by (safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2")
         (meson "\<rightarrow>I" "existential:2[const_var]")
  next
    fix x' y
    proof(rule "\<rightarrow>I")
      moreover {
      }
      moreover {
      }
        by (metis "\<or>E"(3) "reductio-aa:1")
    qed
      by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" 1)
  qed
qed

proof (rule "\<rightarrow>I")
    by (metis "\<equiv>E"(1) "w-ances")
  moreover {
      using "1-1-R:4" "\<rightarrow>E" by blast
  }
  moreover {
      by (metis "Conjunction Simplification"(1) "id-R-thm:2" "\<rightarrow>E")
  }
    by (metis "\<or>E"(3) "reductio-aa:1")
qed

AOT_theorem "pre-ind":
proof(safe intro!: "\<rightarrow>I" GEN)
  fix x

  proof (rule "w-ances-her:2"[unvarify F, OF den, THEN "\<rightarrow>E"]; safe intro!: "&I")
    proof (safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I")
    next
        by (rule "w-ances"[THEN "\<equiv>E"(2), OF "\<or>I"(2)])
           (meson "0" "id-R-thm:5" "1-1-R:5" "\<rightarrow>E")
    qed
  next
  next
    proof (safe intro!: "hered:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "cqt:2" GEN "\<rightarrow>I")
      fix x' y
        by (metis Adjunction "modus-tollens:1" "reductio-aa:1" "w-ances-her:3")
      proof (safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" "&I" 3)
        proof (rule \<theta>[THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<forall>E"(2),
                      THEN "\<rightarrow>E", THEN "\<rightarrow>E", THEN "\<rightarrow>E"])
            using 2 3 "&E" "&I" by blast
        next
        next
        qed
      qed
    qed
  qed
qed

AOT_theorem pred_coex:
proof(safe intro!: "\<equiv>I" "\<rightarrow>I" GEN)
  fix F
    using "exist-nec" "\<rightarrow>E" by blast
  moreover AOT_have
  proof(rule RM; safe intro!: "\<rightarrow>I" GEN)
    AOT_modally_strict {
      fix x y
      AOT_hence pred_equiv:
                                       rotated, OF pred_den, simplified]
                         tuple_denotes[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "cqt:2")
      AOT_have CardinalPredecessor:
      proof -
          using card[THEN "\<equiv>\<^sub>d\<^sub>fE", OF card_x].
          using "eq-df-num"[THEN "\<equiv>E"(1)] by blast
          using "\<exists>E"[rotated] by blast
          using "rigid-der:3" "\<exists>E"[rotated] by blast
      
          using "df-rigid-rel:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
          using H[THEN "&E"(1), THEN "df-rigid-rel:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(2)].
          using "CBF" "\<rightarrow>E" by blast
           by (metis "\<equiv>E"(6) "oth-class-taut:3:a" "sc-eq-fur:2" "\<rightarrow>E")
        proof (safe intro!: eqE[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "cqt:2" GEN "\<rightarrow>I")
        qed
          by (rule "apE-eqE:2"[THEN "\<rightarrow>E", OF "&I", rotated])
             (simp add: "eq-part:1")
          using "num-tran:1"[THEN "\<rightarrow>E", THEN "\<equiv>E"(2)] numxG' by blast
      
        {
            using "cqt-further:4" "\<rightarrow>E" by blast
            using "\<forall>E"(2) by blast
            using "\<not>\<not>E" "intro-elim:3:c" "oth-class-taut:5:a" by blast
          {
            fix y
              using 0 "\<not>\<not>I" "con-dis-i-e:4:c" by blast
              using "=-infix" "\<equiv>\<^sub>d\<^sub>fI" "raa-cor:4" by blast
          } note Pxy_imp_eq = this
          proof(rule "raa-cor:1")
              using pred_equiv "intro-elim:3:c" by blast
              using "cqt-further:4"[THEN "\<rightarrow>E"] by blast
              using "\<forall>E"(2) by blast
              using "cqt-further:4"[THEN "\<rightarrow>E"] by blast
              using "\<forall>E"(2) by blast
            proof(rule "raa-cor:1")
                using "\<equiv>\<^sub>d\<^sub>fI" "conventions:5" by blast
                by (metis "Ordinary.res-var-bound-reas[BF\<diamond>]"[THEN "\<rightarrow>E"])
                using "Ordinary.\<exists>E"[rotated] by meson
                by (meson "B\<diamond>" "K\<diamond>" "\<rightarrow>E" R)
                using 0 Ordinary.\<psi>
                by (metis "con-dis-i-e:1" "raa-cor:1")
                using Gu numxG "con-dis-i-e:1" "raa-cor:5" by metis
                using "num:1"[unvarify G, OF "F-u[den]"] "\<exists>E"[rotated] by blast
                using Gu numxG "&I" by blast
                by (rule "Ordinary.\<exists>I")
                by (rule "\<exists>I")
                using pred_equiv[THEN "\<equiv>E"(2)] by blast
                using numy "rule=E" by fast
            qed
              using "qml:2"[axiom_inst, THEN "\<rightarrow>E"] by blast
              using "0F:1"[THEN "\<equiv>E"(1)] by blast
              using "pre-Hume"[unvarify x, THEN "\<rightarrow>E", OF "zero:2", OF "&I",
                               THEN "\<equiv>E"(2), OF num0G, OF numxG, OF "eq-part:1"]
                id_sym by blast
              using x_nonzero
              using "=-infix" "\<equiv>\<^sub>d\<^sub>fE" by blast
          qed
        }
          using "con-dis-i-e:3:a" "con-dis-i-e:3:b" "raa-cor:1" by blast
        moreover {
            by (rule "\<exists>I")
        }
        moreover {
            using "\<exists>E"[rotated] by blast
            using "&E" by blast
            by (rule "\<exists>I")
        }
          using "\<or>E"(1) "\<rightarrow>I" by blast
      qed

        by (metis "eq-num:6" "vdash-properties:10")
      {
          by (metis "=-infix" "\<equiv>\<^sub>d\<^sub>fI")
          using CardinalPredecessor 0 by blast
          using "\<exists>E"[rotated] by blast
          by (safe intro!: "\<beta>\<leftarrow>C" "cqt:2")
          by (safe intro!: indist[THEN "\<forall>E"(1), THEN "\<equiv>E"(1)] "cqt:2")
          using "\<beta>\<rightarrow>C"(1) by blast
          using Pyz pred_equiv[THEN "\<equiv>E"(1)] by blast
          using "\<exists>E"[rotated] by blast
          using "Ordinary.\<exists>E"[rotated] by meson
          using Pxz pred_equiv[THEN "\<equiv>E"(1)] by blast
          using "\<exists>E"[rotated] by blast
          using "Ordinary.\<exists>E"[rotated] by meson
          using "hume-strict:1"[unvarify F G, THEN "\<equiv>E"(1), OF "F-u[den]",
                                OF "F-u[den]", OF "\<exists>I"(2)[where \<beta>=z], OF "&I"]
                  v_prop u_prop "&E" by blast
          using "P'-eq"[THEN "\<rightarrow>E", OF "&I", OF "&I"] 
                 u_prop v_prop "&E" by meson
          using "pre-Hume"[THEN "\<rightarrow>E", THEN "\<equiv>E"(2), OF "&I"]
                v_prop u_prop "&E" by blast
      }
      moreover {
        fix u
        proof (safe intro!: "0F:1"[unvarify F, THEN "\<equiv>E"(1)] "cqt:2" "raa-cor:2"
                            "F-u[den]"[unvarify F])
            using "Ordinary.\<exists>E"[rotated] by meson
            by (auto intro: "F-u"[THEN "=\<^sub>d\<^sub>fE"(1), where \<tau>\<^sub>1\<tau>\<^sub>n="(_,_)", simplified]
                     intro!: "cqt:2" "F-u[equiv]"[unvarify F, THEN "\<equiv>E"(1)]
                             "F-u[den]"[unvarify F])
            using "\<beta>\<rightarrow>C" "thm-neg=E"[THEN "\<equiv>E"(1)] "&E" "&I"
                  "raa-cor:3" by fast
        qed
          using "rule=E" id_sym by fast
          by (safe intro!: "num:1"[unvarify G] "cqt:2")
          using "\<exists>E" by metis
          by (safe intro!: "\<beta>\<leftarrow>C" "cqt:2" "ord=Eequiv:1"[THEN "\<rightarrow>E"] Ordinary.\<psi>)
        ultimately AOT_have
          using 0 "&I" by auto
          by (rule "Ordinary.\<exists>I")
          by (rule "\<exists>I"; "cqt:2")
          using "beta-C-cor:2"[THEN "\<rightarrow>E", OF pred_den,
                  THEN tuple_forall[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "\<forall>E"(2),
                  THEN "\<forall>E"(2), THEN "\<equiv>E"(2)] by simp
          by (safe intro!: "\<beta>\<leftarrow>C" "cqt:2")
          by (safe intro!: indist[THEN "\<forall>E"(1), THEN "\<equiv>E"(1)] "cqt:2")
          using "\<beta>\<rightarrow>C" by blast
          using "\<beta>\<rightarrow>C" by fast
          using "\<exists>E"[rotated] by blast
          using "Ordinary.\<exists>E"[rotated] by meson
          by (auto intro!: "hume-strict:1"[unvarify F, THEN "\<equiv>E"(1), rotated,
                                OF "\<exists>I"(2)[where \<beta>=z], OF "&I"] "cqt:2"
                   dest: "&E")
          using 1 2
          by (safe_step intro!: "eqP'"[unvarify F, THEN "\<rightarrow>E"])
             (auto dest: "&E" intro!: "cqt:2" "&I")
          by (auto intro!: "pre-Hume"[unvarify G H, THEN "\<rightarrow>E",
                                      THEN "\<equiv>E"(2), rotated 3, OF 3]
                           "F-u[den]"[unvarify F] "cqt:2" "&I"
                   dest: "&E")
      }
        using "\<or>E"(1) "\<rightarrow>I" "reductio-aa:1" by blast
          using numxF "rule=E" by fast
    } note 0 = this
    AOT_modally_strict {
      fix x y
        by (metis "cqt-basic:11" "intro-elim:3:a" calculation(2))
        using 0 "\<equiv>I" "\<rightarrow>I" by auto
    }
  qed
    using "kirchner-thm:1"[THEN "\<equiv>E"(2)] "\<rightarrow>E" by fast
next
    using "\<forall>E"(2) by blast
    using "exist-nec"[THEN "\<rightarrow>E"] by blast
    by (rule GEN)
    using BF[THEN "\<rightarrow>E"] by fast
  moreover AOT_have
  proof(rule RM; safe intro!: "\<rightarrow>I" GEN)
    AOT_modally_strict {
      fix x y
      proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
        then AOT_obtain F where
          using "\<exists>E"[rotated] by blast
          using "Ordinary.\<exists>E"[rotated] by meson
          by (auto intro!: "&I" dest: "&E" "\<beta>\<rightarrow>C")
          using "\<exists>I" "Ordinary.\<exists>I" by fast
      next
          using "\<exists>E"[rotated] by blast
          using "Ordinary.\<exists>E"[rotated] by meson
          by (auto intro!: "&I" "\<beta>\<leftarrow>C" 0[THEN "\<forall>E"(1)] "F-u[den]"
                   dest: "&E" intro: "cqt:2")
          by (rule "Ordinary.\<exists>I")
          by (rule "\<exists>I")
      qed
    }
  qed
  ultimately AOT_have
    using "\<rightarrow>E" by blast
    by (rule "safe-ext[2]"[axiom_inst, THEN "\<rightarrow>E", OF "&I", rotated]) "cqt:2"
qed

