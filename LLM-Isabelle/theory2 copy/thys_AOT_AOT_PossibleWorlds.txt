theory AOT_PossibleWorlds
  imports AOT_PLM AOT_BasicLogicalObjects AOT_RestrictedVariables
begin



proof(rule "\<rightarrow>I")
    using "T-value"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
    using "tv-p"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
  proof(rule situations[THEN "\<equiv>\<^sub>d\<^sub>fI"]; safe intro!: "&I" GEN "\<rightarrow>I" \<theta>[THEN "&E"(1)])
    fix F
      using \<theta>[THEN "&E"(2), THEN "\<forall>E"(2)[where \<beta>=F], THEN "\<equiv>E"(1)] by argo
      by (metis "\<equiv>\<^sub>d\<^sub>fI" "prop-prop1")
  qed
qed

proof(rule "\<equiv>I"; rule "\<rightarrow>I")
    using situations[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
  proof(rule "KBasic:3"[THEN "\<equiv>E"(2)]; rule "&I")
  next
         (auto simp: "prop-prop1" "\<equiv>Df" "enc-prop-nec:2")
      using 0[THEN "&E"(2)] "\<rightarrow>E" by blast
  qed
       (auto simp: 1 "\<equiv>Df" situations)
next
    using "qml:2"[axiom_inst, THEN "\<rightarrow>E", OF that].
qed

  using "possit-sit:1"
  by (metis "RE\<diamond>" "S5Basic:2" "\<equiv>E"(1) "\<equiv>E"(5) "Commutativity of \<equiv>")

  using "possit-sit:1" "possit-sit:2" by (meson "\<equiv>E"(5))

  by (meson "Act-Basic:5" "Act-Sub:2" "RA[2]" "\<equiv>E"(1) "\<equiv>E"(6) "possit-sit:2")

proof (safe intro!: situations[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" GEN "\<rightarrow>I" "prop-prop1"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
    using "tv-id:2"[THEN "prop-enc"[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(2)]
          "existential:1" "prop-prop2:2" by blast
    by (safe intro!: "encoders-are-abstract"[unvarify x, THEN "\<rightarrow>E"]
                     "t=t-proper:2"[THEN "\<rightarrow>E", OF "ext-p-tv:3"])
next
  fix F
    using "tv-id:1" "rule=E" by fast
    using "\<equiv>E"(1) "desc-nec-encode:1" by fast
    by (metis "Act-Basic:10" "\<equiv>E"(1))
    using "id-act:1"[unvarify \<beta>, THEN "\<equiv>E"(2)] by (metis "prop-prop2:2")
    using "\<exists>I" by fast
qed

proof -
    by (simp add: "A-descriptions" "rule-id-df:1[zero]" "the-true:1")
    using "t=t-proper:1" "vdash-properties:6" by blast
    using "actual-desc:2"[unvarify x, OF true_den, THEN "\<rightarrow>E", OF true_def]
    using "TV-lem2:1"[unvarify x, OF true_den, THEN "RA[2]",
                      THEN "act-cond"[THEN "\<rightarrow>E"], THEN "\<rightarrow>E"]
    by blast
    using "T-sit"[unvarify x, OF true_den, THEN "RA[2]",
                  THEN "act-cond"[THEN "\<rightarrow>E"], THEN "\<rightarrow>E"] by blast
    using "possit-sit:4"[unvarify x, OF true_den, THEN "\<equiv>E"(1)] by blast
qed

proof -
    by (simp add: "A-descriptions" "rule-id-df:1[zero]" "the-true:2")
    using "t=t-proper:1" "vdash-properties:6" by blast
    using "actual-desc:2"[unvarify x, OF true_den, THEN "\<rightarrow>E", OF true_def]
    using "TV-lem2:2"[unvarify x, OF true_den, THEN "RA[2]",
                      THEN "act-cond"[THEN "\<rightarrow>E"], THEN "\<rightarrow>E"]
    by blast
    using "T-sit"[unvarify x, OF true_den, THEN "RA[2]",
                  THEN "act-cond"[THEN "\<rightarrow>E"], THEN "\<rightarrow>E"] by blast
    using "possit-sit:4"[unvarify x, OF true_den, THEN "\<equiv>E"(1)] by blast
qed

AOT_register_rigid_restricted_type
proof
  AOT_modally_strict {
    fix p
      by (metis "instantiation" "p-has-!tv:1")
  }
next
  AOT_modally_strict {
    proof (rule "\<rightarrow>I")
    qed
  }
next
  AOT_modally_strict {
      using "possit-sit:1"[THEN "conventions:3"[THEN "\<equiv>\<^sub>d\<^sub>fE"],
                           THEN "&E"(1)] GEN by fast
  }
qed

AOT_register_variable_names
  Situation: s


notepad
begin
  fix x p q
    by simp
    by simp
    by simp
    by simp
    by simp
    by simp
    by simp
end


proof (rule "\<rightarrow>I"; rule "\<equiv>I"; rule "\<rightarrow>I")
    using "true-in-s"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
next
    using "prop-enc"[THEN "\<equiv>\<^sub>d\<^sub>fI", OF "&I", OF "cqt:2"(1)] by blast
    using "true-in-s"[THEN "\<equiv>\<^sub>d\<^sub>fI"] 1 "&I" by blast
qed

proof -
    by (simp add: Situation.\<psi>)
    using lem1[THEN "\<rightarrow>E", OF sit] by blast
    by (rule "en-eq:2[1]"[unvarify F]) "cqt:2[lambda]"
    using lem1[THEN RM, THEN "\<rightarrow>E", OF "possit-sit:1"[THEN "\<equiv>E"(1), OF sit]]
    by (metis "KBasic:6" "\<equiv>E"(2) "Commutativity of \<equiv>" "\<rightarrow>E")
  finally show ?thesis.
qed

proof -
    using "possit-sit:1"[THEN "\<equiv>E"(1), OF Situation.\<psi>]
          "lem2:1"[THEN "conventions:3"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(1)]]
          RM[OF "\<rightarrow>I", THEN "\<rightarrow>E"] by blast
  thus ?thesis by (metis "B\<diamond>" "S5Basic:13" "T\<diamond>" "\<equiv>I" "\<equiv>E"(1) "\<rightarrow>E")
qed

  using "lem2:1" "lem2:2" by (metis "\<equiv>E"(5))

proof -
    using "possit-sit:1"[THEN "\<equiv>E"(1), OF Situation.\<psi>]
      "lem2:1"[THEN "conventions:3"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(1)]]
      RM[OF "\<rightarrow>I", THEN "\<rightarrow>E"] by blast
  thus ?thesis
    using "sc-eq-fur:2"[THEN "\<rightarrow>E"] by blast
qed

  by (metis "KBasic2:1" "contraposition:1[2]" "\<rightarrow>I" "\<equiv>I" "\<equiv>E"(3) "\<equiv>E"(4) "lem2:2")

proof(rule "\<equiv>I"; rule "\<rightarrow>I")
    by (simp add: "oth-class-taut:3:a" "universal-cor")
    using "rule=E" by fast
next
  proof(safe intro!: "ab-obey:1"[THEN "\<rightarrow>E", THEN "\<rightarrow>E"] "&I" GEN "\<equiv>I" "\<rightarrow>I")
  next
  next
    fix F
      using Situation.\<psi>[THEN situations[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(2),
                        THEN "\<forall>E"(2)[where \<beta>=F], THEN "\<rightarrow>E"]
            "prop-prop1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
      using "\<exists>E" by metis
      using 0 "rule=E" by blast
      using lem1[THEN "\<rightarrow>E", OF Situation.\<psi>, THEN "\<equiv>E"(2)] by blast
      using a[THEN "\<forall>E"(2)[where \<beta>=p], THEN "\<equiv>E"(1)] by blast
      using lem1[THEN "\<rightarrow>E", OF Situation.\<psi>, THEN "\<equiv>E"(1)] by blast
      using F_def[symmetric] "rule=E" by blast
  next
    fix F
      using Situation.\<psi>[THEN situations[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(2),
                        THEN "\<forall>E"(2)[where \<beta>=F], THEN "\<rightarrow>E"]
            "prop-prop1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
      using "\<exists>E" by metis
      using 0 "rule=E" by blast
      using lem1[THEN "\<rightarrow>E", OF Situation.\<psi>, THEN "\<equiv>E"(2)] by blast
      using a[THEN "\<forall>E"(2)[where \<beta>=p], THEN "\<equiv>E"(2)] by blast
      using lem1[THEN "\<rightarrow>E", OF Situation.\<psi>, THEN "\<equiv>E"(1)] by blast
      using F_def[symmetric] "rule=E" by blast
  qed
qed


  by (rule "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
     (safe intro!: "&I" Situation.\<psi> GEN "\<rightarrow>I")

proof(rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2); rule "raa-cor:2")
    using "\<forall>E"(2) "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
    using "\<forall>E"(2) "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
    using a b by (simp add: "\<equiv>I" "universal-cor")
    using "sit-identity"[THEN "\<equiv>E"(2)] by metis
    by (metis "\<equiv>\<^sub>d\<^sub>fE" "=-infix")
    using 1 "&I" by blast
qed

proof(rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2);
      safe intro!: "&I" GEN "\<rightarrow>I" "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fI"] Situation.\<psi>)
  fix p
    using "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2),
                           THEN "\<forall>E"(2)[where \<beta>=p], THEN "\<rightarrow>E"] by blast
    using "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2),
                           THEN "\<forall>E"(2)[where \<beta>=p], THEN "\<rightarrow>E"] by blast
qed

proof (safe intro!: "\<equiv>I" "&I" "\<rightarrow>I")
    using "rule=E" "part:1" that by blast
next
    using "rule=E" "part:1" that[symmetric] by blast
next
    by (metis "\<equiv>\<^sub>d\<^sub>fI" "&E"(1) "&E"(2) "=-infix" "raa-cor:3")
qed

proof(safe intro!: "\<equiv>I" "\<rightarrow>I" Situation.GEN "sit-identity"[THEN "\<equiv>E"(2)]
                   GEN[where 'a=\<o>])
    using "rule=E" that by blast
next
    using "rule=E" id_sym that by blast
next
    using "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2),
              OF that(2)[THEN "Situation.\<forall>E", THEN "\<equiv>E"(1), OF "part:1"],
              THEN "\<forall>E"(2), THEN "\<rightarrow>E", OF that(1)].
next
    using "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2),
          OF that(2)[THEN "Situation.\<forall>E", THEN "\<equiv>E"(2), OF "part:1"],
          THEN "\<forall>E"(2), THEN "\<rightarrow>E", OF that(1)].
qed


  by (safe intro!: GEN[where 'a=\<o>] Situation.GEN persistent[THEN "\<equiv>\<^sub>d\<^sub>fI"] "\<rightarrow>I")
     (simp add: "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"])



  AOT_modally_strict {
    proof (safe intro!: "\<equiv>I" "\<rightarrow>I" "df-null-trivial:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"]
                dest!: "df-null-trivial:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"])
        using 0[THEN "&E"(1), THEN situations[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(1)].
        using 0[THEN "&E"(1), THEN situations[THEN "\<equiv>\<^sub>d\<^sub>fE"],
                THEN "&E"(2), THEN "\<forall>E"(2)]
        by (metis "\<equiv>\<^sub>d\<^sub>fE" "\<rightarrow>I" "prop-prop1" "\<rightarrow>E")
      proof (safe intro!: "&I" 1 GEN "\<equiv>I" "\<rightarrow>I")
        fix F
          using calculation 2[THEN "\<rightarrow>E"] "\<exists>E"[rotated] by blast
          by (metis "rule=E")
          using lem1[THEN "\<rightarrow>E", OF 0[THEN "&E"(1)], THEN "\<equiv>E"(2)] by blast
          by (rule "\<exists>I")
          using 0[THEN "&E"(2)] "raa-cor:1" "&I" by blast
      next
          by (simp add: "id-eq:1")
      qed
    next
        using "\<forall>E" "&E" by blast
        using "\<equiv>\<^sub>d\<^sub>fE" "id-eq:1" "=-infix" "reductio-aa:1" "\<equiv>E"(1) by blast
      proof (safe intro!: "&I" situations[THEN "\<equiv>\<^sub>d\<^sub>fI"] 0[THEN "&E"(1)] GEN "\<rightarrow>I")
          using that 1 "&I" "raa-cor:1" by fast
      next
        proof(rule "raa-cor:2")
            using "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) "\<equiv>E"(1) lem1 "modus-tollens:1"
                  "raa-cor:3" "true-in-s" by fast
            by (rule 1[unvarify F]) "cqt:2[lambda]"
        qed
      qed
    qed
  }
next
    by (simp add: "A-objects!")
qed


  AOT_modally_strict {
    proof (safe intro!: "\<equiv>I" "\<rightarrow>I" "df-null-trivial:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"]
                 dest!: "df-null-trivial:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"])
        using 0[THEN "&E"(1), THEN situations[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(1)].
        using 0[THEN "&E"(1), THEN situations[THEN "\<equiv>\<^sub>d\<^sub>fE"],
                THEN "&E"(2), THEN "\<forall>E"(2)]
        by (metis "\<equiv>\<^sub>d\<^sub>fE" "deduction-theorem" "prop-prop1" "\<rightarrow>E")
      proof (safe intro!: "&I" 1 GEN "\<equiv>I" "\<rightarrow>I" 2)
        fix F
          using "\<exists>E"[rotated] by blast
          using 0[THEN "&E"(2)] "\<forall>E" by blast
          by (metis 0 "rule=E" "&E"(1) id_sym "\<equiv>E"(2) lem1
                    "Commutativity of \<equiv>" "\<rightarrow>E")
      qed
    next
        using "\<forall>E" "&E" by blast
      proof (safe intro!: "&I" situations[THEN "\<equiv>\<^sub>d\<^sub>fI"] 0[THEN "&E"(1)] GEN "\<rightarrow>I")
          using 1[THEN "\<equiv>E"(1), OF that]
          by (metis "\<equiv>\<^sub>d\<^sub>fI" "prop-prop1")
      qed
      proof (safe intro!: "&I" 2 0[THEN "&E"(1)] GEN "\<rightarrow>I")
          by (rule 1[unvarify F, where \<tau>="\<guillemotleft>[\<lambda>y p]\<guillemotright>"]) "cqt:2[lambda]"
          by (rule "\<exists>I"(2)[where \<beta>=p])
             (simp add: "rule=I:1" "prop-prop2:2")
          by (metis "2" "\<equiv>E"(2) lem1 "\<rightarrow>E")
      qed
    qed
  }
next
    by (simp add: "A-objects!")
qed

  by (meson "A-Exists:2" "RA[2]" "\<equiv>E"(2) "thm-null-trivial:1")

  using "A-Exists:2" "RA[2]" "\<equiv>E"(2) "thm-null-trivial:2" by blast



proof(safe intro!: "\<rightarrow>I" dest!: "df-null-trivial:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"];
      frule "&E"(1); drule "&E"(2))
  proof(rule "raa-cor:1")
      by (metis "\<equiv>\<^sub>d\<^sub>fI" "conventions:5")
      by (metis "\<equiv>E"(1) "lem2:2"[unconstrain s, THEN "\<rightarrow>E", OF 0])
  qed
    by (metis "KBasic:3" "&I" "\<equiv>E"(2))
       (auto simp: "df-null-trivial:1" "\<equiv>Df" 2)
qed


proof(safe intro!: "\<rightarrow>I" dest!: "df-null-trivial:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"];
      frule "&E"(1); drule "&E"(2))
    using "\<forall>E" by blast
    using  0 "\<equiv>E"(1) "lem2:1"[unconstrain s, THEN "\<rightarrow>E"] by blast
    by (rule GEN)
    by (rule BF[THEN "\<rightarrow>E"])
    using 1 by (metis "KBasic:3" "&I" "\<equiv>E"(2))
       (auto simp: "df-null-trivial:2" "\<equiv>Df" 2)
qed

  by (safe intro!: "df-the-null-sit:1"[THEN "=\<^sub>d\<^sub>fI"(2)] "thm-null-trivial:3"
       "rule=I:1"[OF "thm-null-trivial:3"]
       "!box-desc:2"[THEN "\<rightarrow>E", THEN "\<rightarrow>E", rotated, OF "thm-null-trivial:1",
                     OF "\<forall>I", OF "null-triv-sc:1", THEN "\<forall>E"(1), THEN "\<rightarrow>E"])

  by (safe intro!: "df-the-null-sit:2"[THEN "=\<^sub>d\<^sub>fI"(2)] "thm-null-trivial:4"
       "rule=I:1"[OF "thm-null-trivial:4"]
       "!box-desc:2"[THEN "\<rightarrow>E", THEN "\<rightarrow>E", rotated, OF "thm-null-trivial:2",
                     OF "\<forall>I", OF "null-triv-sc:2", THEN "\<forall>E"(1), THEN "\<rightarrow>E"])

proof (safe intro!: "\<equiv>I" "\<rightarrow>I" "df-null-uni:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"]
                    "df-null-trivial:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"]
            dest!: "df-null-uni:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "df-null-trivial:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"])
    using 0[THEN "&E"(1), THEN situations[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(2), THEN "\<forall>E"(2)]
    by (metis "\<equiv>\<^sub>d\<^sub>fE" "deduction-theorem" "prop-prop1" "\<rightarrow>E")
  proof (safe intro!: "&I" 0[THEN "&E"(1), THEN situations[THEN "\<equiv>\<^sub>d\<^sub>fE"],
                             THEN "&E"(1)];
         rule "raa-cor:2")
      using "\<exists>E"[rotated] by blast
      using 1[THEN "\<rightarrow>E"] by blast
      using "\<exists>E"[rotated] by blast
      by (metis "rule=E" F_prop)
      using lem1[THEN "\<rightarrow>E", OF 0[THEN "&E"(1)], THEN "\<equiv>E"(2)] by blast
      by (rule "\<exists>I")
      using 0[THEN "&E"(2)] "&I" by blast
  qed
next
    apply (rule situations[THEN "\<equiv>\<^sub>d\<^sub>fI", OF "&I", OF 0[THEN "&E"(1)]]; rule GEN)
    using 0[THEN "&E"(2)] by (metis "\<rightarrow>I" "existential:2[const_var]" "raa-cor:3") 
  proof (rule "raa-cor:2")
  qed
qed

  apply (rule "=\<^sub>d\<^sub>fI"(2)[OF "df-the-null-sit:1"])
   apply (fact "thm-null-trivial:3")
  apply (rule "=\<^sub>d\<^sub>fI"(2)[OF "df-null-uni-terms:1"])
   apply (fact "null-uni-uniq:3")
  apply (rule "equiv-desc-eq:3"[THEN "\<rightarrow>E"])
  apply (rule "&I")
   apply (fact "thm-null-trivial:3")
  by (rule RN; rule GEN; rule "null-triv-facts:1")

proof(rule "=-infix"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
    by (simp add: "null-uni-facts:4")
    using "df-null-uni:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" "\<forall>E"(1)
    by (metis "cqt:5:a" "vdash-properties:10" "vdash-properties:1[2]")
  proof(rule "raa-cor:2")
      using "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) "df-null-trivial:2" "null-triv-sc:4" by blast
      by (metis "\<equiv>\<^sub>d\<^sub>fE" "&E"(2) situations)
      using "\<forall>E"(1)[rotated, OF "oa-exist:2"] "\<rightarrow>E" by blast
      using "prop-in-f:4:d" "&I" by blast
  qed
  proof (rule "raa-cor:2")
  qed
qed


  ("CONDITION'_ON'_PROPOSITIONAL'_PROPERTIES'(_')")

AOT_theorem "cond-prop[E]":
  using assms[unfolded "cond-prop"] by auto

AOT_theorem "cond-prop[I]":
  using assms "cond-prop" by metis

AOT_theorem "pre-comp-sit":
proof(rule "\<equiv>I"; rule "\<rightarrow>I")
    using "&E" situations[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&I" by blast
next
  proof (safe intro!: situations[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I")
  next
    proof(rule GEN; rule "\<rightarrow>I")
      fix F
        using 0[THEN "&E"(2)] "\<forall>E" "\<equiv>E" by blast
        using "cond-prop[E]"[OF assms] "\<forall>E" "\<rightarrow>E" by blast
    qed
  next
  qed
qed

AOT_theorem "comp-sit:1":
     (auto simp: "pre-comp-sit"[OF assms] "A-objects"[where \<phi>=\<phi>, axiom_inst])

AOT_theorem "comp-sit:2":
     (auto simp: assms "pre-comp-sit"  "pre-comp-sit"[OF assms] "A-objects!")

AOT_theorem "can-sit-desc:1":
  using "comp-sit:2"[OF assms] "A-Exists:2" "RA[2]" "\<equiv>E"(2) by blast

AOT_theorem "can-sit-desc:2":
  by (auto intro!: "equiv-desc-eq:2"[THEN "\<rightarrow>E", OF "&I",
                                     OF "can-sit-desc:1"[OF assms]]
                   "RA[2]" GEN "pre-comp-sit"[OF assms])

AOT_theorem "strict-sit":
  using "rule=E"[rotated, OF "can-sit-desc:2"[OF assms(2), symmetric]]
        "box-phi-a:2"[OF assms(1)] "\<rightarrow>E" "\<rightarrow>I" "&E" by fast



proof -
    by (metis "\<equiv>\<^sub>d\<^sub>fE" "instantiation" "cont-tf:1" "cont-tf-thm:1")
  proof (safe intro!: "comp-sit:1" "cond-prop[I]" GEN "\<rightarrow>I")
    AOT_modally_strict {
        using "\<equiv>\<^sub>d\<^sub>fI" "existential:2[const_var]" "prop-prop1" that by fastforce
    }
  qed
    using "Situation.\<exists>E"[rotated] by meson
  proof(safe intro!: actual[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" GEN "\<rightarrow>I" s_prop Situation.\<psi>)
    fix p
      by (metis "\<equiv>\<^sub>d\<^sub>fE" "&E"(2) "prop-enc" "true-in-s")
      by (rule s_prop[THEN "\<forall>E"(1), THEN "\<equiv>E"(1), rotated]) "cqt:2[lambda]"
  qed
  proof(rule "raa-cor:1"; drule "KBasic:12"[THEN "\<equiv>E"(2)])
      using actual[THEN "\<equiv>Df", THEN "conventions:3"[THEN "\<equiv>\<^sub>d\<^sub>fE"],
                   THEN "&E"(1), THEN RM, THEN "\<rightarrow>E"] by blast
      by (metis "RM:1" "Conjunction Simplification"(2) "\<rightarrow>E")
      by (metis "CBF" "vdash-properties:10")
      using "\<forall>E" by blast
      by (metis "\<rightarrow>E" "qml:1" "vdash-properties:1[2]")
      using s_prop[THEN "\<forall>E"(1), THEN "\<equiv>E"(2),
                   THEN lem1[THEN "\<rightarrow>E", OF Situation.\<psi>, THEN "\<equiv>E"(2)]]
            "rule=I:1" "prop-prop2:2" by blast
      using "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) "\<equiv>E"(1) "lem2:1" "true-in-s" "\<rightarrow>E" by fast
      using "KBasic:12"[THEN "\<equiv>E"(1)] q\<^sub>1_prop[THEN "&E"(2)] "&I" by blast
  qed
    using s_prop "&I" by blast
  thus ?thesis
    by (rule "Situation.\<exists>I")
qed

proof -
    using "act-and-not-pos" "Situation.\<exists>E"[rotated] by meson
  thus ?thesis by (rule "Situation.\<exists>I")
qed

    using "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) "df-null-trivial:2" "null-triv-sc:4" by blast
next
  proof(rule "raa-cor:2")
      by (metis "\<exists>E" "\<exists>I"(1) "log-prop-prop:2" "non-contradiction")
      using "null-triv-sc:4"[THEN "\<equiv>\<^sub>d\<^sub>fE"[OF "df-null-trivial:2"], THEN "&E"(2)]
            "\<forall>E" by blast
      using 0[THEN actual[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"]
      by blast
  qed
next
    using "df-the-null-sit:2" "rule-id-df:2:b[zero]" "thm-null-trivial:4" by blast
qed

proof -
    by (metis "\<exists>E" "\<exists>I"(1) "log-prop-prop:2" "non-contradiction")
  proof (rule Situation.GEN; rule "\<rightarrow>I"; rule "raa-cor:2")
    fix s
      using actual[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"] by blast
      using notp\<^sub>1 "&I" by simp
  qed
  thus ?thesis by (rule "\<exists>I")
qed

AOT_theorem comp:
proof -
  proof(safe intro!: "cond-prop[I]" GEN "oth-class-taut:8:c"[THEN "\<rightarrow>E", THEN "\<rightarrow>E"];
        rule "\<rightarrow>I")
    AOT_modally_strict {
      fix F
        by (simp add: Situation.restricted_var_condition)
        using "situations"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2), THEN "\<forall>E"(2)] by blast
        using "\<rightarrow>E" by blast
    }
  next
    AOT_modally_strict {
      fix F
        by (simp add: Situation.restricted_var_condition)
        using "situations"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2), THEN "\<forall>E"(2)] by blast
        using "\<rightarrow>E" by blast
    }
  qed
    using "comp-sit:1"[OF cond_prop] "Situation.\<exists>E"[rotated] by meson
  proof(safe intro!: "&I" "\<equiv>\<^sub>d\<^sub>fI"[OF "true-in-s"] "\<equiv>\<^sub>d\<^sub>fI"[OF "prop-enc"]
                     "Situation.GEN" "GEN"[where 'a=\<o>] "\<rightarrow>I"
                     "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fI"]
                     Situation.\<psi> "cqt:2[const_var]"[axiom_inst])
    fix p
      by (metis "&E"(2) "prop-enc" "\<equiv>\<^sub>d\<^sub>fE" "true-in-s")
      using \<theta>[THEN "\<forall>E"(1),OF "prop-prop2:2", THEN "\<equiv>E"(2), OF "\<or>I"(1)] by blast
  next
    fix p
      by (metis "&E"(2) "prop-enc" "\<equiv>\<^sub>d\<^sub>fE" "true-in-s")
      using \<theta>[THEN "\<forall>E"(1),OF "prop-prop2:2", THEN "\<equiv>E"(2), OF "\<or>I"(2)] by blast
  next
    fix s p
      by (metis "&E"(2) "prop-enc" "\<equiv>\<^sub>d\<^sub>fE" "true-in-s")
      using \<theta>[THEN "\<forall>E"(1),OF "prop-prop2:2", THEN "\<equiv>E"(1)] by blast
    moreover {
        by (safe intro!: "prop-enc"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "true-in-s"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I"
                         Situation.\<psi> "cqt:2[const_var]"[axiom_inst])
        using "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)] 0[THEN "&E"(1)]
              "\<forall>E"(2) by blast
        using "\<rightarrow>E" by blast
        using "true-in-s"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "prop-enc"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
    }
    moreover {
        by (safe intro!: "prop-enc"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "true-in-s"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I"
                         Situation.\<psi> "cqt:2[const_var]"[axiom_inst])
        using "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)] 0[THEN "&E"(2)]
              "\<forall>E"(2) by blast
        using "\<rightarrow>E" by blast
        using "true-in-s"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "prop-enc"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
    }
      by (metis "\<or>E"(1) "\<rightarrow>I")
  qed
  thus ?thesis
    using "Situation.\<exists>I" by fast
qed

proof (safe intro!: "\<rightarrow>I")
    using actual[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"] that by blast
  ultimately AOT_have p by blast
    by (safe intro!: "\<beta>\<leftarrow>C"(1) "cqt:2")
qed

AOT_theorem "act-sit:2":
proof(rule "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
  proof (safe intro!: "cond-prop[I]"  "\<forall>I" "\<rightarrow>I" "prop-prop1"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
    AOT_modally_strict {
      fix \<beta>
    }
  qed
  proof(safe intro!: "strict-can:1[I]" "\<rightarrow>I" GEN)
    AOT_modally_strict {
      fix F
        using "\<exists>E"[rotated] by blast
        using "&E"(1) "id-nec:2" "vdash-properties:10" by blast
      proof(rule "\<or>E"; (rule "\<rightarrow>I"; rule "KBasic:15"[THEN "\<rightarrow>E"])?)
      next
          apply (rule "\<or>I"(1))
          using "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) "\<equiv>E"(1) "lem2:1" that "true-in-s" by blast
      next
          apply (rule "\<or>I"(2))
          using "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) "\<equiv>E"(1) "lem2:1" that "true-in-s" by blast
      qed
        by (metis "KBasic:3" "&I" "\<equiv>E"(2))
        using Buridan[THEN "\<rightarrow>E"] by fast
    }
  qed

    by (rule "can-sit-desc:1"[OF "cond-prop"])
  AOT_obtain x\<^sub>0
    by (metis (no_types, lifting) "\<exists>E" "rule=I:1" desc_den "\<exists>I"(1) id_sym)
    using "actual-desc:3"[THEN "\<rightarrow>E"] "Act-Basic:2" "&E"(1) "\<equiv>E"(1)
          "possit-sit:4" by blast

    using "strict-sit"[OF rigid, OF "cond-prop", THEN "\<rightarrow>E", OF x\<^sub>0_prop1].
  proof (rule "\<equiv>I"; rule "\<rightarrow>I")
      using 1[THEN "\<forall>E"(1)[where \<tau>="\<guillemotleft>[\<lambda>y p]\<guillemotright>"], OF "prop-prop2:2", THEN "\<equiv>E"(1)]
            "\<exists>E"[rotated] by blast
      by (metis "rule=E" "&E"(1) "&E"(2) "\<or>I"(1) "\<or>I"(2)
                "\<or>E"(1) "deduction-theorem" id_sym "\<equiv>E"(2) "p-identity-thm2:3")
  next
      by (metis "rule=I:1" "&I" "prop-prop2:2") 
      by (rule "\<exists>I")
      using 1[THEN "\<forall>E"(1), OF "prop-prop2:2", THEN "\<equiv>E"(2)] by blast
      by (metis "\<equiv>\<^sub>d\<^sub>fI" "&I" "ex:1:a" "prop-enc" "rule-ui:2[const_var]"
                x\<^sub>0_sit "true-in-s")
  qed

  proof(safe intro!: "\<rightarrow>I" "&I" "\<exists>I"(1) actual[THEN "\<equiv>\<^sub>d\<^sub>fI"] x\<^sub>0_sit GEN
                     "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fI"])
    fix p
      using 2 "\<equiv>E"(1) by metis
      using act_s' act_s''
            actual[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"]
      by (metis "\<or>E"(3) "reductio-aa:1")
  next
      using 2[THEN "\<equiv>E"(2), OF "\<or>I"(1), OF that].
  next
      using 2[THEN "\<equiv>E"(2), OF "\<or>I"(2), OF that].
  next
      using act_s'[THEN actual[THEN "\<equiv>\<^sub>d\<^sub>fE"]] "&E" by blast
  next
      using act_s''[THEN actual[THEN "\<equiv>\<^sub>d\<^sub>fE"]] "&E" by blast
  qed
    by (rule "\<exists>I")
qed


proof(safe intro!: "\<rightarrow>I" cons[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" Situation.\<psi>
            dest!: actual[THEN "\<equiv>\<^sub>d\<^sub>fE"]; frule "&E"(1); drule "&E"(2))
  proof (rule "raa-cor:2")
      using "\<exists>E"[rotated] by blast
            0[THEN "\<forall>E"(2)[where \<beta>=p], THEN "\<rightarrow>E"] "&E" "&I" by blast
  qed
qed

proof (rule "\<equiv>I"; rule "\<rightarrow>I")
    using cons[THEN "\<equiv>\<^sub>d\<^sub>fI", OF "&I", OF Situation.\<psi>]
    by (metis "raa-cor:3")
    using "\<exists>E"[rotated] by blast
    using "&E"(1) "\<equiv>E"(1) "lem2:1" by blast
    using p_prop "T\<diamond>" "&E" "\<equiv>E"(1)
      "modus-tollens:1" "raa-cor:3" "lem2:3"[unvarify p]
      "log-prop-prop:2" by metis
    by (metis "KBasic:3" "&I" "\<equiv>E"(2))
    by (rule "\<exists>I")
    by (metis Buridan "vdash-properties:10") 
    apply (rule "qml:1"[axiom_inst, THEN "\<rightarrow>E", THEN "\<rightarrow>E", rotated])
    apply (rule RN)
    using "\<equiv>\<^sub>d\<^sub>fE" "&E"(2) cons "deduction-theorem" "raa-cor:3" by blast
next
qed

proof(rule "\<equiv>I"; rule "\<rightarrow>I")
     using cons "\<equiv>E"(2) "Commutativity of \<equiv>" "\<equiv>Df" apply blast
    by (simp add: 0)
    using "RM\<diamond>" "Conjunction Simplification"(1) "Conjunction Simplification"(2)
          "modus-tollens:1" "raa-cor:3" by blast+
    using 2 using 1 "KBasic:11" "\<equiv>E"(2) by blast
  proof (rule "raa-cor:1")
      using 0 "\<equiv>\<^sub>d\<^sub>fE" "conventions:5" 2 "cons-rigid:1"[unconstrain s, THEN "\<rightarrow>E"]
            "modus-tollens:1" "raa-cor:3" "\<equiv>E"(4) by meson
      using "\<exists>E"[rotated] "&E" by blast
      by (metis "2" "\<equiv>E"(1) "lem2:1"[unconstrain s, THEN "\<rightarrow>E"])
      using 4 "lem2:1"[unconstrain s, unvarify p, THEN "\<rightarrow>E"]
      by (metis 2 "\<equiv>E"(1) "log-prop-prop:2")
      by (metis "KBasic:3" "&I" "\<equiv>E"(3) "raa-cor:3")
      by (metis "existential:1" "log-prop-prop:2")
      by (metis Buridan "vdash-properties:10")
      using 3 "&I"  by (metis "raa-cor:3")
  qed
next
    using "T\<diamond>" that "vdash-properties:10" by blast
qed


  apply(rule "\<rightarrow>I"; rule pos[THEN "\<equiv>\<^sub>d\<^sub>fI"]; rule "&I")
  apply (meson "\<equiv>\<^sub>d\<^sub>fE" actual "&E"(1))
  using "T\<diamond>" "vdash-properties:10" by blast

proof(rule "\<rightarrow>I")
    using "\<exists>E"[rotated] by blast
    using "&E" by (metis "T\<diamond>" "\<equiv>E"(1) "lem2:3" "vdash-properties:10")
    using a[THEN "&E"(2)] by (metis "KBasic2:1" "\<equiv>E"(2))
    by (metis "KBasic:3" "&I" "\<equiv>E"(3) "raa-cor:3")
    by (rule "\<exists>I")
    by (metis Buridan "vdash-properties:10")
     apply (simp add: "oth-class-taut:1:a")
    by (auto simp: "conventions:4" "df-rules-formulas[3]" "df-rules-formulas[4]" "\<equiv>I" 1)
    by (metis "\<equiv>\<^sub>d\<^sub>fE" "conventions:5" "raa-cor:3")
     apply (simp add: pos "\<equiv>Df")
     using actual "\<equiv>Df" apply presburger
    by (metis "0" "KBasic2:3" "&E"(2) "raa-cor:3" "vdash-properties:10")
qed

  by (auto simp: "sit-cons"[THEN "RM\<diamond>", THEN "\<rightarrow>E",
                            THEN "cons-rigid:2"[THEN "\<equiv>E"(1)]]
           intro!: "\<rightarrow>I" dest!: pos[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E"(2))

proof -
    using "\<equiv>\<^sub>d\<^sub>fE" "instantiation" "cont-tf:1" "cont-tf-thm:1" by blast
    by (auto intro!: "cond-prop[I]" GEN "\<rightarrow>I" "prop-prop1"[THEN "\<equiv>\<^sub>d\<^sub>fI"]
    by (auto intro!: "strict-can:1[I]" GEN "\<rightarrow>I" simp: "id-nec:2"[THEN "\<rightarrow>E"])

    using "ex:1:b"[THEN "\<forall>E"(1), OF "can-sit-desc:1", OF "cond-prop"]
          "\<exists>E"[rotated] by blast    
    using "\<rightarrow>E" "actual-desc:2" by blast
    using "strict-sit"[OF rigid, OF "cond-prop", THEN "\<rightarrow>E", OF x_prop].
    using "\<forall>E"(1)[rotated, OF "prop-prop2:2"]
          "rule=I:1"[OF "prop-prop2:2"] "\<equiv>E" by blast
    using lem1[THEN "\<rightarrow>E", OF s_sit, unvarify p, THEN "\<equiv>E"(2), OF "log-prop-prop:2"]
    by blast
    using "lem2:1"[unconstrain s, THEN "\<rightarrow>E", OF s_sit, unvarify p,
                   OF "log-prop-prop:2", THEN "\<equiv>E"(1)] by blast
  proof(rule RN; rule "\<rightarrow>I"; rule "raa-cor:2")
    AOT_modally_strict {
        using actual[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)] by blast
        using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] "\<rightarrow>E" by metis
    }
  qed
    using "qml:1"[axiom_inst, THEN "\<rightarrow>E", THEN "\<rightarrow>E"] by blast
  proof (rule "raa-cor:2")
      using "\<exists>E"[rotated] by blast
      using lem1[unvarify p, THEN "\<rightarrow>E", OF "log-prop-prop:2",
                 OF s_sit, THEN "\<equiv>E"(1)] "&I" "&E" by metis
      by (auto intro!: "prop-prop2:2" s_enc_prop[THEN "\<forall>E"(1), THEN "\<equiv>E"(1)]
               elim: "&E")
    {
        by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" 0)
        using "\<beta>\<rightarrow>C"(1) by auto
    }
    moreover {
        by (auto intro!: "\<beta>\<leftarrow>C"(1) "cqt:2" 0)
        using "\<beta>\<rightarrow>C"(1) by auto
    }
  qed
  proof(rule "raa-cor:2")
      by (metis "\<equiv>\<^sub>d\<^sub>fE" "&E"(2) pos)
      using "\<equiv>\<^sub>d\<^sub>fE" "conventions:5" "reductio-aa:2" by blast
  qed
  show ?thesis
    by(rule "\<exists>I"(2)[where \<beta>=x]; safe intro!: "&I" 2 s_sit cons[THEN "\<equiv>\<^sub>d\<^sub>fI"] 1)
qed

proof(rule "\<rightarrow>I"; rule GEN)
  fix q
    using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast+
    by (metis "deduction-theorem" "\<equiv>I" "\<equiv>E"(1) "\<equiv>E"(2) "\<equiv>E"(4))
qed

AOT_theorem "sit-classical:2":
proof(rule "\<rightarrow>I"; rule GEN; rule GEN)
  fix q r
    using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast+
  proof (safe intro!: "\<equiv>I" "\<rightarrow>I")
      using \<theta> \<xi> \<zeta> by (metis "\<equiv>E"(1) "\<equiv>E"(2) "vdash-properties:10")
  next
      using \<theta> \<xi> \<zeta> by (metis "deduction-theorem" "\<equiv>E"(1) "\<equiv>E"(2) "\<rightarrow>E") 
  qed
qed

AOT_theorem "sit-classical:3":
proof (rule "\<rightarrow>I")
    using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast+
  proof (safe intro!: "\<equiv>I" "\<rightarrow>I" GEN)
    fix \<alpha>
  next
  qed
qed

proof(rule "\<rightarrow>I"; rule GEN; rule "\<rightarrow>I")
  fix q
    using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast+
qed

AOT_theorem "sit-classical:5":
proof (rule "\<rightarrow>I")
    by (metis "&E"(1) "&E"(2) "\<equiv>\<^sub>d\<^sub>fE" "instantiation" "cont-tf:1" "cont-tf-thm:1")
    using "KBasic:11" "\<equiv>E"(2) by blast
    using "\<forall>E"(2) A "\<equiv>E"(2) by blast
    using "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) "\<equiv>E"(1) "lem2:1" "true-in-s" by blast
    using asm[THEN "\<forall>E"(1)[rotated, OF "log-prop-prop:2"], THEN "\<equiv>E"(2)] B by blast
    using "sit-classical:1"[THEN "\<rightarrow>E", OF asm,
              THEN "\<forall>E"(1)[rotated, OF "log-prop-prop:2"], THEN "\<equiv>E"(1)] by blast
    using 1 "&I" by blast
    by (rule "\<exists>I")
qed

AOT_theorem "sit-classical:6":
proof -
  proof (safe intro!: "cond-prop[I]" GEN "\<rightarrow>I")
    fix F
    AOT_modally_strict {
        using "\<exists>E"[rotated] by blast
        using "&E" by blast
        by (rule "\<exists>I")
        by (metis "\<equiv>\<^sub>d\<^sub>fI" "prop-prop1")
    }
  qed
    using "comp-sit:1"[OF "cond-prop"].
    using "Situation.\<exists>E"[rotated] by meson
  proof(safe intro!: GEN "\<equiv>I" "\<rightarrow>I")
    fix p
      using lem1[THEN "\<rightarrow>E", OF Situation.\<psi>, THEN "\<equiv>E"(1)] by blast
      using s\<^sub>0_prop[THEN "\<forall>E"(1)[rotated, OF "prop-prop2:2"], THEN "\<equiv>E"(1)] by blast
      using "\<exists>E"[rotated] by blast
      by (metis "&E"(2) "\<equiv>E"(2) "p-identity-thm2:3")
      using q\<^sub>1_prop[THEN "&E"(1)] "rule=E" id_sym by fast
  next
    fix p
      by (simp add: "rule=I:1"[OF "prop-prop2:2"])
      using "&I" by blast
      by (rule "\<exists>I")
      using s\<^sub>0_prop[THEN "\<forall>E"(1)[rotated, OF "prop-prop2:2"], THEN "\<equiv>E"(2)] by blast
      using lem1[THEN "\<rightarrow>E", OF Situation.\<psi>, THEN "\<equiv>E"(2)] by blast
  qed
    using "&I" by blast
    by (rule "Situation.\<exists>I")
qed


proof -
    using "sit-classical:6" "Situation.\<exists>E"[rotated] by meson
  proof(safe intro!: GEN "\<equiv>I" "\<rightarrow>I")
    fix p
      using s_prop[THEN "\<forall>E"(2), THEN "\<equiv>E"(1)] by blast
  next
    fix p
      using s_prop[THEN "\<forall>E"(2), THEN "\<equiv>E"(2)] by blast
  qed
    by (metis "T\<diamond>"[THEN "\<rightarrow>E"])
    using s_prop "&I" by blast
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] Situation.\<psi> "&I" by blast
    by (rule "\<exists>I")
qed

proof (rule "\<rightarrow>I")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast
    by (metis "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) situations)
    by (metis "russell-axiom[exe,1].\<psi>_denotes_asm")
qed

proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
    by (metis "S5Basic:1" "&I" "&E"(1) "&E"(2) "\<equiv>E"(1) "possit-sit:1")
    by (metis "KBasic:3" "\<equiv>E"(2))
       (auto simp: "\<equiv>Df" "world:1" 0)
next
    using that "qml:2"[axiom_inst, THEN "\<rightarrow>E"] by blast
qed

  using "rigid-pw:1"
  by (meson "RE\<diamond>" "S5Basic:2" "\<equiv>E"(2) "\<equiv>E"(6) "Commutativity of \<equiv>")

  using "rigid-pw:1" "rigid-pw:2" by (meson "\<equiv>E"(5))

  by (metis "Act-Sub:3" "\<rightarrow>I" "\<equiv>I" "\<equiv>E"(6) "nec-imp-act" "rigid-pw:1" "rigid-pw:2")

AOT_register_rigid_restricted_type
proof
  AOT_modally_strict {
  }
next
  AOT_modally_strict {
  }
next
  AOT_modally_strict {
      by (meson GEN "\<rightarrow>I" "\<equiv>E"(1) "rigid-pw:1")
  }
qed
AOT_register_variable_names
  PossibleWorld: w

proof (safe intro!: "\<equiv>\<^sub>d\<^sub>fE"[OF "world:1", OF PossibleWorld.\<psi>, THEN "&E"(1)]
                    pos[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" )
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>, THEN "&E"(2)].
  proof (rule "RM\<diamond>"[THEN "\<rightarrow>E", rotated]; safe intro!: "\<rightarrow>I" GEN)
    AOT_modally_strict {
      fix p
      ultimately AOT_show p using "\<equiv>E"(1) by blast
    }
  qed
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>, THEN "&E"(1),
                    THEN "possit-sit:1"[THEN "\<equiv>E"(1)]]
    by (metis "KBasic:16" "&I" "vdash-properties:10")
       (auto simp: actual "\<equiv>Df" 0)
qed

  using "world-pos"
  using "pos-cons-sit:1"[unconstrain s, THEN "\<rightarrow>E", THEN "\<rightarrow>E"]
  by (meson "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) pos)

proof(rule "raa-cor:2")
    using "df-null-trivial:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast
    using "&E"
    by (metis "Buridan\<diamond>" "T\<diamond>" "&E"(2) "\<equiv>E"(1) "lem2:3"[unconstrain s, THEN "\<rightarrow>E"]
              "log-prop-prop:2" "rule-ui:1" "universal-cor" "\<rightarrow>E")
    using PossibleWorld.\<psi> "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)] by metis
    using "Buridan\<diamond>"[THEN "\<rightarrow>E"] by blast
    by (metis "log-prop-prop:2" "rule-ui:1")
    using "RM\<diamond>"[THEN "\<rightarrow>E"] "\<rightarrow>I" "\<equiv>E"(1) by meson
    by (metis "KBasic2:4" "\<equiv>E"(1) "\<rightarrow>E")
    by (metis "instantiation" "KBasic2:1" RN "\<equiv>E"(1) "raa-cor:2")
    using "&I" by blast
qed

  using "lem2:1"[unconstrain s, THEN "\<rightarrow>E",
                 OF PossibleWorld.\<psi>[THEN "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(1)]].

  using "lem2:2"[unconstrain s, THEN "\<rightarrow>E",
                 OF PossibleWorld.\<psi>[THEN "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(1)]].

  using "lem2:3"[unconstrain s, THEN "\<rightarrow>E",
                 OF PossibleWorld.\<psi>[THEN "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(1)]].

  using "lem2:4"[unconstrain s, THEN "\<rightarrow>E",
                 OF PossibleWorld.\<psi>[THEN "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(1)]].

  using "lem2:5"[unconstrain s, THEN "\<rightarrow>E",
                 OF PossibleWorld.\<psi>[THEN "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(1)]].


proof(safe intro!: PossibleWorld.\<psi>[THEN "\<equiv>\<^sub>d\<^sub>fE"[OF "world:1"], THEN "&E"(1)]
                   GEN "\<equiv>\<^sub>d\<^sub>fI"[OF max] "&I" )
  fix q
  proof(rule "RM\<diamond>"[THEN "\<rightarrow>E"]; (rule "\<rightarrow>I")?)
    AOT_modally_strict {
        using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast+
        by (metis "\<or>I"(1) "\<or>I"(2) "\<equiv>E"(3) "reductio-aa:1")
    }
  next
      using PossibleWorld.\<psi>[THEN "\<equiv>\<^sub>d\<^sub>fE"[OF "world:1"], THEN "&E"(2)].
  qed
    using "KBasic2:2"[THEN "\<equiv>E"(1)] by blast
    using "lem2:2"[unconstrain s, THEN "\<rightarrow>E", unvarify p,
                   OF PossibleWorld.\<psi>[THEN "\<equiv>\<^sub>d\<^sub>fE"[OF "world:1"], THEN "&E"(1)],
                   THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by (metis "\<or>I"(1) "\<or>I"(2) "\<or>E"(3) "raa-cor:2")
qed

       safe intro!: max "\<equiv>Df" "\<rightarrow>I"; frule "&E"(1); drule "&E"(2))
    by (metis "\<equiv>E"(1) "possit-sit:1")
    using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast
    using "lem2:1"[unconstrain s, THEN "\<rightarrow>E", OF sit_x, unvarify p,
                   OF "log-prop-prop:2", THEN "\<equiv>E"(1)]
    by (metis "\<or>I"(1) "\<or>I"(2) "\<or>E"(2) "raa-cor:1")
    by (metis "KBasic:15" "\<rightarrow>E")
    by (rule GEN)
    by (rule BF[THEN "\<rightarrow>E"])
    using nec_sit_x by (metis "KBasic:3" "&I" "\<equiv>E"(2))
qed

proof(safe intro!: "\<equiv>I" "\<rightarrow>I" "&I" "world-pos"[unconstrain w, THEN "\<rightarrow>E"]
                   "world-max"[unconstrain w, THEN "\<rightarrow>E"];
      frule "&E"(2); drule "&E"(1))
     using actual "\<equiv>Df" apply presburger
    using "\<equiv>\<^sub>d\<^sub>fE" "&E"(2) pos pos_x by blast
    by (metis "KBasic2:3" "&E"(2) "vdash-properties:6")
  proof(safe intro!: "\<rightarrow>I" RM GEN)
    AOT_modally_strict {
      fix p
      proof(safe intro!: "\<equiv>I" "\<rightarrow>I" 1[THEN "\<forall>E"(2), THEN "\<rightarrow>E"]; rule "raa-cor:1")
          using 0[THEN "\<equiv>\<^sub>d\<^sub>fE"[OF max], THEN "&E"(2), THEN "\<forall>E"(2)]
                1 by (metis "\<or>E"(2))
          using 1[THEN "\<forall>E"(1), OF "log-prop-prop:2", THEN "\<rightarrow>E"] by blast
        moreover AOT_assume p
      qed
    }
  qed
    using "\<rightarrow>E" by blast
    by (metis "KBasic:13"[THEN "\<rightarrow>E"])
    using 0 "\<rightarrow>E" by blast
    using "\<equiv>\<^sub>d\<^sub>fI"[OF "world:1", OF "&I", OF sit_x] by blast
qed


proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
    using "nec-impl-p:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" by blast+
    using "nec-impl-p:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"] by blast+
next
    using "KBasic:4" "&E" "\<equiv>E"(1) by blast+
    using "nec-impl-p:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] by blast+
    using "nec-impl-p:2"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" by blast
qed

AOT_theorem world_closed_lem_1_a:
proof(safe intro!: "\<rightarrow>I")
    using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast+
    by (metis "&I" "&E"(1) "&E"(2) "\<equiv>E"(1) "\<equiv>E"(2))
qed

AOT_theorem world_closed_lem_1_b:
proof(safe intro!: "\<rightarrow>I")
    using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast
    by (metis "&E"(1) "&E"(2) "\<equiv>E"(1) "\<equiv>E"(2) "\<rightarrow>E")
qed

AOT_theorem world_closed_lem_1_c:
proof(safe intro!: "\<rightarrow>I")
    using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast
    by (metis "&E"(1) "&E"(2) "\<equiv>E"(1) "\<equiv>E"(2) "\<rightarrow>E")
qed

AOT_theorem "world-closed-lem:1[0]":
  by (meson "\<rightarrow>I" "\<equiv>E"(2) "log-prop-prop:2" "rule-ui:1")

AOT_theorem "world-closed-lem:1[1]":
  using world_closed_lem_1_b.

AOT_theorem "world-closed-lem:1[2]":
  using world_closed_lem_1_b world_closed_lem_1_a
  by (metis (full_types) "&I" "&E" "\<rightarrow>I" "\<rightarrow>E")

AOT_theorem "world-closed-lem:1[3]":
  using world_closed_lem_1_b world_closed_lem_1_a
  by (metis (full_types) "&I" "&E" "\<rightarrow>I" "\<rightarrow>E")

AOT_theorem "world-closed-lem:1[4]":
  using world_closed_lem_1_b world_closed_lem_1_a
  by (metis (full_types) "&I" "&E" "\<rightarrow>I" "\<rightarrow>E")

proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
  proof(rule "raa-cor:2")
      using "world-cons:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"[OF cons], THEN "&E"(2)].
      using "&I" by blast
  qed
next
    using "world-max"[THEN "\<equiv>\<^sub>d\<^sub>fE"[OF max], THEN "&E"(2)]
    by (metis "\<or>E"(2) "log-prop-prop:2" "rule-ui:1")
qed

  by (metis "coherent:1" "deduction-theorem" "\<equiv>I" "\<equiv>E"(1) "\<equiv>E"(2) "raa-cor:3")

proof -
    using "sit-classical:6" "Situation.\<exists>E"[rotated] by meson
    by (metis "T\<diamond>" "vdash-properties:10")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] Situation.\<psi> "&I" by blast
    using "&I" s_prop by blast
  thus ?thesis by (rule "\<exists>I")
qed

proof -
    using "act-world:1" "PossibleWorld.\<exists>E"[rotated] by meson
    using PossibleWorld.\<psi> "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(1)] by blast
  show ?thesis
  proof (safe intro!: "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "\<exists>I"(2) "&I" GEN "\<rightarrow>I"
                      PossibleWorld.\<psi> actual[THEN "\<equiv>\<^sub>d\<^sub>fI"] sit_s
                      "sit-identity"[unconstrain s, unconstrain s', THEN "\<rightarrow>E",
                                     THEN "\<rightarrow>E", THEN "\<equiv>E"(2)] "\<equiv>I"
                      w_prop[THEN "\<forall>E"(2), THEN "\<equiv>E"(1)])
  next
      by (simp add: sit_s)
  next
    fix y p
      using w_prop[THEN "\<forall>E"(2), THEN "\<equiv>E"(1)] by blast
    proof(rule "raa-cor:1")
        by (metis "coherent:1"[unconstrain w, THEN "\<rightarrow>E"] "&E"(1) "\<equiv>E"(2) w_asm)
        using w_asm[THEN "&E"(2), THEN actual[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(2),
                    THEN "\<forall>E"(1), rotated, OF "log-prop-prop:2"]
              "\<rightarrow>E" by blast
    qed
  next
      using that(2)[THEN "&E"(2), THEN actual[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(2),
                    THEN "\<forall>E"(2), THEN "\<rightarrow>E", OF that(1)]
            w_prop[THEN "\<forall>E"(2), THEN "\<equiv>E"(2)] by blast
  next
      using that[THEN "&E"(1)] "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(1)] by blast
  next
      using sit_s by blast
  qed(simp)
qed

  using "A-Exists:2" "RA[2]" "act-world:2" "\<equiv>E"(2) by blast


proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
    by (simp add: "A-descriptions" "rule-id-df:1[zero]" "the-true:1")
    using "t=t-proper:1" "vdash-properties:6" by blast
  {
      by (metis "\<equiv>\<^sub>d\<^sub>fE" "con-dis-i-e:2:b" "prop-enc" "true-in-s")
      using "rule=E" true_def true_den by fast
      using "\<equiv>E"(1) "desc-nec-encode:1"[unvarify F] "prop-prop2:2" by fast
      by (metis "Act-Basic:10" "\<equiv>E"(1))
      using "\<exists>E"[rotated] by blast
      using "Act-Basic:2" "intro-elim:3:a" "&E" by blast+
      using "id-act:1"[unvarify \<alpha> \<beta>, THEN "\<equiv>E"(2)] "prop-prop2:2" by blast
      by (metis "intro-elim:3:b" "p-identity-thm2:3")
      using actq "rule=E" id_sym by blast
  }
  {
      by (auto intro!: "Act-Basic:2"[THEN "\<equiv>E"(2)] "&I"
               intro: "RA[2]" "=I"(1)[OF "prop-prop2:2"])
      using "\<exists>I" by fast
      by (metis "Act-Basic:10" "\<equiv>E"(2))
      using "\<equiv>E"(2) "desc-nec-encode:1"[unvarify F] "prop-prop2:2" by fast
      using "rule=E" true_def true_den id_sym by fast
      by (safe intro!: "true-in-s"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "possit-sit:6"
                       "prop-enc"[THEN "\<equiv>\<^sub>d\<^sub>fI"] true_den)
  }
qed

proof -
    using "Situation.res-var:3" "possit-sit:6" "\<rightarrow>E" by blast
  proof (safe intro!: "logic-actual-nec:3"[axiom_inst, THEN "\<equiv>E"(2)] GEN
                      "logic-actual-nec:2"[axiom_inst, THEN "\<equiv>E"(2)] "\<rightarrow>I")
    fix p
      using "lem2:4"[unconstrain s, unvarify \<beta>, OF true_den,
                     THEN "\<rightarrow>E", OF "possit-sit:6"] "\<equiv>E"(1) by blast
  qed
    using actual[THEN "\<equiv>Df", THEN "conventions:3"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)],
                 THEN "RA[2]", THEN "act-cond"[THEN "\<rightarrow>E"]].
    using "possit-sit:4"[unvarify x, OF true_den, THEN "\<equiv>E"(2), OF "possit-sit:6"]
          "Act-Basic:2"[THEN "\<equiv>E"(2), OF "&I"] "\<rightarrow>E" by blast
    by (safe intro!: pos[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "possit-sit:6")
  proof (safe intro!: max[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" "possit-sit:6" GEN)
    fix p
      by (simp add: "Act-Basic:1")
        using that true_in_truth_act_true[THEN "\<equiv>E"(2)] by blast
      using that true_in_truth_act_true[unvarify p, THEN "\<equiv>E"(2)]
            "log-prop-prop:2" by blast
      using "\<or>I"(3) "\<rightarrow>I" by blast
  qed
    by (safe intro!: "world=maxpos:2"[unvarify x, OF true_den, THEN "\<equiv>E"(2)] "&I")
    using "rigid-pw:4"[unvarify x, OF true_den, THEN "\<equiv>E"(2)] by blast
    using act_act_true "Act-Basic:2" "df-simplify:2" "intro-elim:3:b" by blast
    using "rule-id-df:1[zero]"[OF "w-alpha", OF "pre-walpha"] by simp
    using calculation "t=t-proper:1" "\<rightarrow>E" by blast
    using "nec-hintikka-scheme"[unvarify x] "\<equiv>E"(1) "&E" by blast
    using "\<forall>E"(1)[rotated, OF true_den] 1 "\<rightarrow>E" by blast
qed

  by (metis "rule=E" "T-world" "deduction-theorem" "ext-p-tv:3" id_sym "\<equiv>I"
            "\<equiv>E"(1) "\<equiv>E"(2) "q-True:1")

proof -
    using "&E"(1) "pre-walpha" "rule-id-df:2:b[zero]" "\<rightarrow>E"
          "w-alpha" "y-in:3" by blast
    by (metis "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) "world:1")
    using "pre-walpha" "rule-id-df:2:b[zero]" "w-alpha" by blast
    using "q-True:3" by force
    using "T-world" by auto
    using "rule=E" by fast
    using lem1[unvarify x, OF w_alpha_den, THEN "\<rightarrow>E", OF sit_w_alpha]
    using "\<equiv>S"(1) "\<equiv>E"(1) "Commutativity of \<equiv>" "\<equiv>Df" sit_w_alpha "true-in-s" by blast
    by (metis "\<equiv>E"(5))
qed

proof -
    using "pre-walpha" "rule-id-df:1[zero]" "w-alpha" by blast
    by (metis "t=t-proper:1" "vdash-properties:6")
    by (rule "actual-desc:2"[unvarify x, OF walpha_den, THEN "\<rightarrow>E"]) (fact 0)
    by (metis "Act-Basic:2" "&E"(1) "\<equiv>E"(1))
    using "rigid-pw:4"[unvarify x, OF walpha_den, THEN "\<equiv>E"(1)]
    by blast
qed

proof -
    using "pre-walpha" "rule-id-df:2:b[zero]" "w-alpha" by blast
    by (metis "instantiation" "rule=I:1" "existential:1" id_sym)
qed

proof -
    using "pre-walpha" "rule-id-df:1[zero]" "w-alpha" by blast
    by (metis "t=t-proper:1" "vdash-properties:6")
    by (rule "actual-desc:2"[unvarify x, OF walpha_den, THEN "\<rightarrow>E"]) (fact 0)
    by (meson "\<equiv>\<^sub>d\<^sub>fE" "alpha-world:2" "&E"(1) max)
  {
    fix p
      using "lem2:4"[unconstrain s] by blast
      using 2[unvarify x, OF walpha_den, THEN "\<rightarrow>E", OF walpha_sit, THEN "\<equiv>E"(2)]
      by argo
      using "1" "Act-Basic:2" "&E"(2) "\<equiv>E"(1) by blast
       using actual "\<equiv>Df" apply blast
      by (fact 3)
      using "logic-actual-nec:3"[axiom_inst, THEN "\<equiv>E"(1)] by blast
  }
    using "\<equiv>\<^sub>d\<^sub>fE" "alpha-world:2" "&E"(1) max by blast
  show ?thesis
  proof(safe intro!: "\<equiv>I" "\<rightarrow>I" 2)
    proof(rule "raa-cor:1")
        using "alpha-world:2"[THEN max[THEN "\<equiv>\<^sub>d\<^sub>fE"], THEN "&E"(2),
                              THEN "\<forall>E"(1), OF "log-prop-prop:2"]
        by (metis "\<or>E"(2))
        using 2[unvarify p, OF "log-prop-prop:2", THEN "\<rightarrow>E"] by blast
    qed
  qed
qed

proof (rule "\<rightarrow>I"; rule "raa-cor:2")
    using "pre-walpha" "rule-id-df:2:b[zero]" "w-alpha" by blast
    using "\<equiv>\<^sub>d\<^sub>fE" "alpha-world:2" "&E"(1) max by blast
    using "sit-identity"[unconstrain s', unconstrain s, THEN "\<rightarrow>E", OF w_sit]
    by blast
  proof(safe intro!: GEN sid[unvarify x', OF walpha_den, THEN "\<rightarrow>E",
                             OF walpha_sit, THEN "\<equiv>E"(2)] "\<equiv>I" "\<rightarrow>I")
    fix p
      using actual[THEN "\<equiv>\<^sub>d\<^sub>fE", OF act_w, THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"]
      by blast
      by (metis "RA[1]")
      using "t-at-alpha-strict"[THEN "\<equiv>E"(2)] by blast
  next
    fix p
      using "t-at-alpha-strict"[THEN "\<equiv>E"(1)] by blast
      using "logic-actual"[act_axiom_inst, THEN "\<rightarrow>E"] by blast
    proof(rule "raa-cor:1")
        by (metis "coherent:1" "\<equiv>E"(2))
        using actual[THEN "\<equiv>\<^sub>d\<^sub>fE", OF act_w, THEN "&E"(2), THEN "\<forall>E"(1),
                     OF "log-prop-prop:2", THEN "\<rightarrow>E"] by blast
    qed
  qed
qed

proof(safe intro!: "\<equiv>I" "\<rightarrow>I" "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fI"] "&I" GEN
           dest!:  "sit-part-whole"[THEN "\<equiv>\<^sub>d\<^sub>fE"])
    using "\<equiv>\<^sub>d\<^sub>fE" actual "&E"(1) that by blast
next
    using "\<equiv>\<^sub>d\<^sub>fE" "alpha-world:2" "&E"(1) max by blast
next
  fix p
    using actual[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2), THEN "\<forall>E"(2), THEN "\<rightarrow>E"] by blast
     by (metis "\<equiv>E"(1) "truth-at-alpha:2")
next
    using "&E" "\<forall>E"(2) by blast
    by (metis "\<rightarrow>I" "\<equiv>E"(2) "truth-at-alpha:2" "\<rightarrow>E")
    using actual[THEN "\<equiv>\<^sub>d\<^sub>fI", OF "&I", OF 0[THEN "&E"(1), THEN "&E"(1)]] by blast
qed

   apply (rule "beta-C-meta"[THEN "\<rightarrow>E", OF "prop-prop2:2", unvarify \<nu>\<^sub>1\<nu>\<^sub>n])
  using "pre-walpha" "rule-id-df:2:b[zero]" "w-alpha" apply blast
  using "\<equiv>E"(2) "Commutativity of \<equiv>" "truth-at-alpha:2" by blast

proof -
    apply (rule "beta-C-meta"[THEN "\<rightarrow>E", OF "prop-prop2:2",
                              unvarify \<nu>\<^sub>1\<nu>\<^sub>n, symmetric])
    using "pre-walpha" "rule-id-df:2:b[zero]" "w-alpha" by blast
    by (meson "log-prop-prop:2" "rule-ui:1" "truth-at-alpha:2" "universal-cor")
  finally show ?thesis.
qed

proof (rule "RM\<diamond>"; rule "\<rightarrow>I"; rule "raa-cor:1")
  AOT_modally_strict {
      using "act-world:1" "PossibleWorld.\<exists>E"[rotated] by meson
      apply (metis "&I" "&E"(1) "&E"(2) "\<rightarrow>I" "\<equiv>I" "modus-tollens:2")
      using "0" "cqt-further:4" "vdash-properties:10" by blast
      using PossibleWorld.\<psi> "rule-ui:3" "\<rightarrow>E" by blast
      using w_prop[THEN "\<forall>E"(2), THEN "\<equiv>E"(2)] 
      by (metis "raa-cor:3")
      using p "&I" by blast
  }
qed

proof (rule "\<rightarrow>I")
    using "PossibleWorld.res-var-bound-reas[BF\<diamond>]"[THEN "\<rightarrow>E"] by auto
    using "PossibleWorld.\<exists>E"[rotated] by meson
    by (metis "\<equiv>\<^sub>d\<^sub>fE" "&E"(1) pos "world-pos")
    using "lem2:2"[unconstrain s, THEN "\<rightarrow>E"]  "\<equiv>E" by blast
    by (rule "PossibleWorld.\<exists>I")
qed

proof(safe intro!: "\<rightarrow>I" Situation.GEN)
  fix s
    using "\<forall>E"(2) "\<equiv>E"(2) by blast
qed

  using "fund-lem:3" by (rule RM)

proof(safe intro!: "\<rightarrow>I" Situation.GEN)
  fix s
    using "Situation.res-var-bound-reas[CBF]"[THEN "\<rightarrow>E"] by blast
    using "Situation.\<forall>E" by fast
qed

proof(safe intro!: "\<rightarrow>I" PossibleWorld.GEN)
  fix w
    using "PossibleWorld.res-var-bound-reas[CBF]"[THEN "\<rightarrow>E"] by blast
    using "PossibleWorld.\<forall>E" by fast
qed

proof(rule "\<rightarrow>I")
    using "\<forall>E"(2) by blast
  proof(rule "raa-cor:1")
      by (metis "KBasic:11" "\<equiv>E"(1))
      apply (rule "RM\<diamond>"[THEN "\<rightarrow>E", rotated])
      by (simp add: "cqt-further:2")
      by (metis "BF\<diamond>" "vdash-properties:10")
      using "\<exists>E"[rotated] by blast
       apply (meson "\<equiv>E"(6) "oth-class-taut:1:b" "oth-class-taut:3:a")
      by(fact x_prop)
      by (metis "KBasic2:3" "vdash-properties:10")
      using "&E"(1) "\<equiv>E"(1) "rigid-pw:2" by blast
      using 2[THEN "&E"(2)]  1[unconstrain w, THEN "\<rightarrow>E"] "\<rightarrow>E"
            "rigid-truth-at:1"[unconstrain w, THEN "\<rightarrow>E"]
      by (metis "\<equiv>E"(1))
      using 2[THEN "&E"(2)] by (metis "\<not>\<not>I" "KBasic:12" "\<equiv>E"(4))
      by (metis "raa-cor:3")
  qed
qed

proof(rule RM; rule "\<rightarrow>I")
  AOT_modally_strict {
      using "act-world:1" "PossibleWorld.\<exists>E"[rotated] by meson
      using "PossibleWorld.\<forall>E" by fast
      using w_prop[THEN "\<forall>E"(2), THEN "\<equiv>E"(1)] by blast
  }
qed

proof (rule "\<equiv>I"; rule "\<rightarrow>I")
    by (metis "fund-lem:1" "fund-lem:2" "\<rightarrow>E")
next
    using "PossibleWorld.\<exists>E"[rotated] by meson
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)] PossibleWorld.\<psi> "&E" by blast
    by (metis "Buridan\<diamond>" "\<rightarrow>E")
    by (metis "log-prop-prop:2" "rule-ui:1")
     apply (meson "conventions:3" "\<equiv>E"(6) "oth-class-taut:3:a" "\<equiv>Df")
    by (fact 1)
    by (metis "RM\<diamond>" "Conjunction Simplification"(1) "\<rightarrow>E")
    using w_prop by (metis "\<equiv>E"(1) "rigid-truth-at:1")
    by (metis "KBasic2:4" "\<equiv>E"(1) "\<rightarrow>E")
qed

proof -
    apply (rule PossibleWorld.GEN)
    using "coherent:1" by blast
    using "fund:1"[unvarify p, OF "log-prop-prop:2"] by blast
  proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
      using "PossibleWorld.\<exists>E"[rotated] by meson
      using 0[THEN "PossibleWorld.\<forall>E", THEN "\<equiv>E"(1)] "&E" by blast
      by (rule "PossibleWorld.\<exists>I")
  next
      using "PossibleWorld.\<exists>E"[rotated] by meson
      using 0[THEN "\<forall>E"(2), THEN "\<rightarrow>E", THEN "\<equiv>E"(1)] "&E"
      by (metis "coherent:1" "\<equiv>E"(2))
      by (rule "PossibleWorld.\<exists>I")
  qed
    by (meson "\<equiv>E"(1) "oth-class-taut:4:b")
    by (metis "KBasic:12" "\<equiv>E"(5))
  proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
      by (metis "cqt-further:4" "\<rightarrow>E")
       using "oth-class-taut:1:a" apply presburger
      by (fact 0)
  next
         (auto simp: "oth-class-taut:1:a" 0)
      by (metis "\<exists>E" "raa-cor:3" "rule-ui:3")
  qed
qed

  by (metis (full_types) "contraposition:1[1]" "\<rightarrow>I" "fund:1" "\<equiv>I" "\<equiv>E"(1,2))

  by (auto simp add: "oth-class-taut:1:a" "conventions:4" "\<equiv>Df" RN
                     "fund:2" "rule-sub-lem:1:a")

proof -
    using "S5Basic:2" by blast
    using "fund:1"[unvarify p, OF "log-prop-prop:2"] by blast
  finally show ?thesis.
qed

proof -
    using 4 "qml:2"[axiom_inst] "\<equiv>I" by blast
    using "fund:2"[unvarify p, OF "log-prop-prop:2"] by blast
  finally show ?thesis.
qed

proof -
    by (simp add: "4\<diamond>" "T\<diamond>" "\<equiv>I")
    using "fund:1"[unvarify p, OF "log-prop-prop:2"] by blast
  finally show ?thesis.
qed

proof -
    by (simp add: "S5Basic:1")
    using "fund:2"[unvarify p, OF "log-prop-prop:2"] by blast
  finally show ?thesis.
qed

proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
    using "rigid-truth-at:1"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I")
        using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast+
        by (metis "&I" "&E"(1) "&E"(2) "\<equiv>E"(1) "\<equiv>E"(2))
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    by (metis 0 "KBasic2:3" "KBasic2:4" "\<equiv>E"(1) "vdash-properties:10")
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
          "&E" "&I" by meson
next
    using "rigid-truth-at:1"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
          "&E" "&I" by blast
    by (metis "KBasic:3" "\<equiv>E"(2))
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I")
        using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast+
        by (metis "&I" "&E"(1) "&E"(2) "\<equiv>E"(1) "\<equiv>E"(2))
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    using "\<rightarrow>E" by blast
    by (metis 0 "KBasic2:4" "\<equiv>E"(1) "vdash-properties:10")
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
qed

proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
    using "rigid-truth-at:1"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
    by (metis "T\<diamond>" "\<equiv>E"(1) "rigid-truth-at:3" "\<rightarrow>E")
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I")
        using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast+
        by (metis "\<equiv>E"(1) "\<equiv>E"(2) "\<rightarrow>E")
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    using "\<rightarrow>E" by blast
    by (metis 0 "KBasic2:4" "\<equiv>E"(1) "\<rightarrow>E")
    by (metis 1 "KBasic2:4" "\<equiv>E"(1) "\<rightarrow>E")
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
          "&E" "&I" by meson
next
    by (metis "\<or>I"(1) "\<or>I"(2) "reductio-aa:1" "\<rightarrow>E")
    by (metis "coherent:1" "\<or>I"(1) "\<or>I"(2) "\<or>E"(2) "\<equiv>E"(2) "reductio-aa:1")
    using "rigid-truth-at:1"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by (metis "KBasic:15" "\<or>I"(1) "\<or>I"(2) "\<or>E"(2) "reductio-aa:1" "\<rightarrow>E")
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I")
        by (metis "\<or>E"(2) "\<rightarrow>I" "\<equiv>E"(1) "\<equiv>E"(2) "log-prop-prop:2"
                  "reductio-aa:1" "rule-ui:1")
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    using "\<rightarrow>E" by blast
    by (metis 0 "KBasic2:4" "\<equiv>E"(1) "\<rightarrow>E")
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
qed

proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
    using "rigid-truth-at:1"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I")
        using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast+
        by (metis "\<or>I"(1) "\<or>I"(2) "\<or>E"(3) "\<equiv>E"(1) "\<equiv>E"(2) "reductio-aa:1")
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    by (metis 0 "KBasic2:4" "\<equiv>E"(1) "vdash-properties:10")
    using "KBasic2:2"[THEN "\<equiv>E"(1)] by blast
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by (metis "\<or>I"(1) "\<or>I"(2) "\<or>E"(2) "reductio-aa:1")
next
    using "rigid-truth-at:1"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by (metis "KBasic:15" "\<or>I"(1) "\<or>I"(2) "\<or>E"(2) "reductio-aa:1" "\<rightarrow>E")
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I")
        by (metis "\<or>I"(1) "\<or>I"(2) "\<or>E"(2) "\<equiv>E"(1) "\<equiv>E"(2)
                  "log-prop-prop:2" "reductio-aa:1" "rule-ui:1")
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    using "\<rightarrow>E" by blast
    by (metis 0 "KBasic2:4" "\<equiv>E"(1) "\<rightarrow>E")
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
qed

proof(rule "\<equiv>I"; rule "\<rightarrow>I")
    using "rigid-truth-at:1"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I")
        using "\<forall>E"(1)[rotated, OF "log-prop-prop:2"] by blast+
        by (metis "\<equiv>E"(2) "\<equiv>E"(5) "Commutativity of \<equiv>")
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    using "\<rightarrow>E" by blast
    by (metis 0 "KBasic2:4" "\<equiv>E"(1) "vdash-properties:10")
     apply (meson "\<equiv>\<^sub>d\<^sub>fE" "conventions:3" "\<rightarrow>I" "df-rules-formulas[4]" "\<equiv>I")
    by (fact 1)
    by (metis "KBasic2:3" "vdash-properties:10")
      apply (simp add: "oth-class-taut:1:c")
     apply (fact 2[THEN "&E"(1)])
     apply (simp add: "oth-class-taut:1:c")
    by (fact 2[THEN "&E"(2)])
    using "KBasic2:2" "\<equiv>E"(1) by blast+
    by (metis "KBasic:11" "\<or>I"(1) "\<or>I"(2) "\<or>E"(2) "\<equiv>E"(2) "raa-cor:1")+
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by (metis "\<not>\<not>I" "T\<diamond>" "\<or>E"(2) "\<rightarrow>I" "\<equiv>I" "\<equiv>E"(1) "rigid-truth-at:3")
next
    using "\<equiv>E"(1) "rigid-pw:1" PossibleWorld.\<psi> by blast
  moreover {
    fix p
    AOT_modally_strict {
        using "rigid-truth-at:1" "\<rightarrow>I"
        by (metis "\<equiv>E"(1))
    }
      by (rule RM)
  }
    by (metis "\<rightarrow>E")
    using "sc-eq-box-box:5"[THEN "\<rightarrow>E", THEN "qml:2"[axiom_inst, THEN "\<rightarrow>E"],
                            THEN "\<rightarrow>E", OF "&I"]
          by (metis "1")
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I")
        by (metis "\<equiv>E"(2) "\<equiv>E"(6) "log-prop-prop:2" "rule-ui:1")
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    using "\<rightarrow>E" by blast
    by (metis 0 "KBasic2:4" "\<equiv>E"(1) "\<rightarrow>E")
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
qed

proof(safe intro!: "\<equiv>I" "\<rightarrow>I" GEN)
    using "rigid-truth-at:1"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I" GEN)
        by (metis "\<equiv>E"(1) "\<equiv>E"(2) "log-prop-prop:2" "rule-ui:1" "rule-ui:3")
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    by (metis 0 "KBasic2:4" "\<equiv>E"(1) "\<rightarrow>E")
    by (metis "Buridan\<diamond>" "\<rightarrow>E")
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
          "\<forall>E"(2) by blast
next
    using "rigid-truth-at:1"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
          "&E" "&I" by blast
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I")
        by (metis "\<equiv>E"(1) "\<equiv>E"(2) "log-prop-prop:2" "rule-ui:1"
                  "rule-ui:3" "universal-cor")
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    using "\<rightarrow>E" by blast
    by (metis 0 "KBasic2:4" "\<equiv>E"(1) "\<rightarrow>E")
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
qed

proof(safe intro!: "\<equiv>I" "\<rightarrow>I" GEN)
    using "rigid-truth-at:1"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I" GEN)
        by (metis "\<exists>E" "\<exists>I"(2) "\<equiv>E"(1,2) "log-prop-prop:2" "rule-ui:1") 
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    by (metis 0 "KBasic2:4" "\<equiv>E"(1) "\<rightarrow>E")
    by (metis "BF\<diamond>" "\<rightarrow>E")
    using "\<exists>E"[rotated] by blast
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"] by blast
next
    using "rigid-truth-at:1"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
          "&E" "&I" by blast
    by (rule "\<exists>I")
    by (metis Buridan "\<rightarrow>E")
  AOT_modally_strict {
    proof(safe intro!: "\<rightarrow>I")
        using "\<exists>E"[rotated] by blast
        by (metis "\<exists>I"(2) "\<equiv>E"(1,2) "log-prop-prop:2" "rule-ui:1")
    qed
  }
    by (rule "RM\<diamond>")
    using "world:1"[THEN "\<equiv>\<^sub>d\<^sub>fE", OF PossibleWorld.\<psi>] "&E" by blast
    using "\<rightarrow>E" by blast
    by (metis 0 "KBasic2:4" "\<equiv>E"(1) "\<rightarrow>E")
    using "rigid-truth-at:2"[unvarify p, THEN "\<equiv>E"(1), OF "log-prop-prop:2"]
    by blast
qed

proof(rule "\<rightarrow>I")
    by blast
    by (metis "5\<diamond>" "\<rightarrow>E")
    by (metis "S5Basic:6" "\<equiv>E"(1))
       (auto simp add: "fund:2" 1)
    using "fund-lem:5[world]"[THEN "\<rightarrow>E"] by simp
    using "\<rightarrow>E" "PossibleWorld.\<forall>E" by fast
qed

proof -
    by (metis "&E"(1) "&E"(2) "\<equiv>\<^sub>d\<^sub>fE" "\<exists>E" "cont-tf:1" "cont-tf-thm:1")
    by (metis "KBasic:11" "\<equiv>E"(2))
    using A "T\<diamond>"[THEN "\<rightarrow>E"] by simp
    using "fund:1"[THEN "\<equiv>E"(1)] by blast
    using "PossibleWorld.\<exists>E"[rotated] by meson
    by (metis "T\<diamond>" "\<equiv>E"(1) "rigid-truth-at:3" "vdash-properties:10")
  proof(rule "raa-cor:2")
      by (rule "PossibleWorld.\<exists>I")
      by (metis "\<equiv>E"(2) "nec-dia-w:1")
      using B "&I" by blast
  qed
    by (rule "&I")
    by (rule "\<exists>I")
  thus ?thesis
    by (rule "PossibleWorld.\<exists>I")
qed

proof(rule "\<rightarrow>I"; rule "raa-cor:1")
    by (metis "\<equiv>E"(1) "rigid-truth-at:2")
    using "coherent:1"[unvarify p, THEN "\<equiv>E"(2), OF "log-prop-prop:2"] by blast
    using "T\<diamond>"[THEN "contraposition:1[1]", THEN RN]
          "fund:2"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(1), THEN "\<forall>E"(2),
                   THEN "\<rightarrow>E", rotated, OF PossibleWorld.\<psi>]
          by blast
    using "conj-dist-w:2"[unvarify p q, OF "log-prop-prop:2", OF "log-prop-prop:2",
                          THEN "\<equiv>E"(1), THEN "\<rightarrow>E"]
    by blast
    by (metis "coherent:1" "Conjunction Simplification"(1,2) "\<equiv>E"(4)
              "modus-tollens:1" "raa-cor:3")
qed

proof -
    using "act-world:1" "PossibleWorld.\<exists>E"[rotated] by meson
    using "cont-tf-thm:2" "cont-tf:2"[THEN "\<equiv>\<^sub>d\<^sub>fE"] "&E" "\<exists>E"[rotated] by metis
    using w[THEN "\<forall>E"(1), OF "log-prop-prop:2", THEN "\<equiv>E"(2)] by blast+
  thus ?thesis by (rule "PossibleWorld.\<exists>I")
qed

proof(rule "\<rightarrow>I")
    using "\<exists>E"[rotated] by blast
    by (metis "\<equiv>\<^sub>d\<^sub>fE" "cont-tf:1")
    using "fund:1"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(1)] "&E" by blast
    using "PossibleWorld.\<exists>E"[rotated] by meson
  proof(rule "raa-cor:2")
      using p[THEN "&E"(1)] actual[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)]
      by (metis "log-prop-prop:2" "raa-cor:3" "rule-ui:1" "\<rightarrow>E" w)
      by (metis "coherent:1" "\<equiv>E"(4) "reductio-aa:2" w) 
      using "&I" by blast
  qed
    by (rule "PossibleWorld.\<exists>I")
qed


proof(rule "\<rightarrow>I")
    using "\<exists>E"[rotated] by blast
    by (metis "\<equiv>\<^sub>d\<^sub>fE" "cont-tf:2")
    using "fund:1"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(1)] "&E" by blast
    using "PossibleWorld.\<exists>E"[rotated] by meson
  proof(rule "raa-cor:2")
      using p[THEN "&E"(1)] actual[THEN "\<equiv>\<^sub>d\<^sub>fE", THEN "&E"(2)]
      by (metis "log-prop-prop:2" "raa-cor:3" "rule-ui:1" "\<rightarrow>E" w)
      using calculation by (metis "coherent:1" "\<equiv>E"(4) "reductio-aa:2") 
      using "&I" w by metis
  qed
    by (rule "PossibleWorld.\<exists>I")
qed

  using "cont-tf-thm:1" "two-worlds-exist:1" "\<rightarrow>E" by blast

proof -
    using "act-world:2"[THEN "uniqueness:1"[THEN "\<equiv>\<^sub>d\<^sub>fE"],
                        THEN "cqt-further:5"[THEN "\<rightarrow>E"]]
          "PossibleWorld.\<exists>E"[rotated] "&E"
    by blast
    using "two-worlds-exist:3" "PossibleWorld.\<exists>E"[rotated] by meson
  proof(rule "raa-cor:2")
      using w w' "&E" by (metis "rule=E" "raa-cor:3")
  qed
    by (metis "\<equiv>\<^sub>d\<^sub>fI" "=-infix")
    by (rule "PossibleWorld.\<exists>I")
  thus ?thesis
    by (rule "PossibleWorld.\<exists>I")
qed


proof(rule "\<rightarrow>I")
    by (metis "exist-nec" "\<rightarrow>E")
  moreover AOT_have
  proof (rule RM; rule "\<rightarrow>I"; rule GEN; rule GEN; rule "\<rightarrow>I")
    AOT_modally_strict {
      fix x y
        using "&E" "kirchner-thm-cor:1"[THEN "\<rightarrow>E"] by blast
        using "\<forall>E"(2) by blast
        using "\<rightarrow>E" by blast
        using "fund:2"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(1)] by blast
        using "\<forall>E"(2) using PossibleWorld.\<psi> "\<rightarrow>E" by blast
        using "conj-dist-w:4"[unvarify p q, OF "log-prop-prop:2",
                              OF "log-prop-prop:2", THEN "\<equiv>E"(1)] by blast
    }
  qed
    using "\<rightarrow>E" by blast
    using "kirchner-thm:1"[THEN "\<equiv>E"(2)] by fast
qed

proof(rule "\<rightarrow>I")
    by (metis "exist-nec" "\<rightarrow>E")
  proof (rule RM; rule "\<rightarrow>I"; rule GEN; rule GEN; rule "\<rightarrow>I")
    AOT_modally_strict {
      fix x\<^sub>1x\<^sub>n y\<^sub>1y\<^sub>n
        using "&E" "kirchner-thm-cor:2"[THEN "\<rightarrow>E"] by blast
        using "\<forall>E"(2) by blast
        using "\<rightarrow>E" by blast
        using "fund:2"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(1)] by blast
        using "\<forall>E"(2) using PossibleWorld.\<psi> "\<rightarrow>E" by blast
        using "conj-dist-w:4"[unvarify p q, OF "log-prop-prop:2",
                              OF "log-prop-prop:2", THEN "\<equiv>E"(1)] by blast
    }
  qed
    using "\<rightarrow>E" by blast
    using "kirchner-thm:2"[THEN "\<equiv>E"(2)] by fast
qed

  by (rule "w-rel:2"[THEN "\<rightarrow>E"]) "cqt:2[lambda]"


  "df-rigid-rel:1":

  "df-rigid-rel:2":

  apply (rule "rule-id-df:2:b[2]"[where \<tau>="\<lambda> (\<Pi>, \<kappa>). \<guillemotleft>[\<Pi>]\<^sub>\<kappa>\<guillemotright>" and
                                        \<sigma>="\<lambda>(\<Pi>, \<kappa>). \<guillemotleft>[\<lambda>x\<^sub>1...x\<^sub>n \<kappa> \<Turnstile> [\<Pi>]x\<^sub>1...x\<^sub>n]\<guillemotright>",
                                  simplified, OF "w-index"])
   apply (fact "w-rel:3")
  apply (rule "beta-C-meta"[THEN "\<rightarrow>E"])
  by (fact "w-rel:3")

proof(safe intro!: "\<equiv>\<^sub>d\<^sub>fI"[OF "df-rigid-rel:1"] "&I")
    by (rule "rule-id-df:2:b[2]"[where \<tau>="\<lambda> (\<Pi>, \<kappa>). \<guillemotleft>[\<Pi>]\<^sub>\<kappa>\<guillemotright>" and
                                       \<sigma>="\<lambda>(\<Pi>, \<kappa>). \<guillemotleft>[\<lambda>x\<^sub>1...x\<^sub>n \<kappa> \<Turnstile> [\<Pi>]x\<^sub>1...x\<^sub>n]\<guillemotright>",
                                 simplified, OF "w-index"])
       (fact "w-rel:3")+
next
  proof(rule RN; safe intro!: "\<rightarrow>I" GEN)
    AOT_modally_strict {
        using "\<equiv>E"(1) "rigid-pw:1" by blast
      fix x\<^sub>1x\<^sub>n
        using "rule-id-df:2:a[2]"[where \<tau>="\<lambda> (\<Pi>, \<kappa>). \<guillemotleft>[\<Pi>]\<^sub>\<kappa>\<guillemotright>" and
                                        \<sigma>="\<lambda>(\<Pi>, \<kappa>). \<guillemotleft>[\<lambda>x\<^sub>1...x\<^sub>n \<kappa> \<Turnstile> [\<Pi>]x\<^sub>1...x\<^sub>n]\<guillemotright>",
                                        simplified, OF "w-index", OF "w-rel:3"]
        by fast
        by (metis "\<beta>\<rightarrow>C"(1))
        using "rigid-truth-at:1"[unvarify p, OF "log-prop-prop:2", THEN "\<equiv>E"(1)]
        by blast
      proof (rule RM; rule "\<rightarrow>I")
        AOT_modally_strict {
            by (auto intro!: "\<beta>\<leftarrow>C"(1) simp: "w-rel:3" "cqt:2")
        }
      qed
        using "\<rightarrow>E" by blast
        by (rule "rule-id-df:2:b[2]"[where \<tau>="\<lambda> (\<Pi>, \<kappa>). \<guillemotleft>[\<Pi>]\<^sub>\<kappa>\<guillemotright>" and
                                           \<sigma>="\<lambda>(\<Pi>, \<kappa>). \<guillemotleft>[\<lambda>x\<^sub>1...x\<^sub>n \<kappa> \<Turnstile> [\<Pi>]x\<^sub>1...x\<^sub>n]\<guillemotright>",
                                     simplified, OF "w-index"])
           (auto simp: 1 "w-rel:3")
    }
  qed
    using "\<rightarrow>E" by blast
qed

proof -
    using "act-world:1" "PossibleWorld.\<exists>E"[rotated] by meson
  show ?thesis
    proof(safe intro!: "\<equiv>\<^sub>d\<^sub>fI"[OF "df-rigid-rel:2"] "&I" GEN)
        using "rigid-der:2" by blast
    next
      fix x\<^sub>1x\<^sub>n
      proof(rule "\<equiv>I"; rule "\<rightarrow>I")
          by (rule "rule-id-df:2:a[2]"
                      [where \<tau>="\<lambda> (\<Pi>, \<kappa>). \<guillemotleft>[\<Pi>]\<^sub>\<kappa>\<guillemotright>" and
                             \<sigma>="\<lambda>(\<Pi>, \<kappa>). \<guillemotleft>[\<lambda>x\<^sub>1...x\<^sub>n \<kappa> \<Turnstile> [\<Pi>]x\<^sub>1...x\<^sub>n]\<guillemotright>",
                       simplified, OF "w-index", OF "w-rel:3"])
      next
          by (rule "rule-id-df:2:b[2]"
                      [where \<tau>="\<lambda> (\<Pi>, \<kappa>). \<guillemotleft>[\<Pi>]\<^sub>\<kappa>\<guillemotright>" and
                             \<sigma>="\<lambda>(\<Pi>, \<kappa>). \<guillemotleft>[\<lambda>x\<^sub>1...x\<^sub>n \<kappa> \<Turnstile> [\<Pi>]x\<^sub>1...x\<^sub>n]\<guillemotright>",
                       simplified, OF "w-index", OF "w-rel:3"])
      qed
        by (rule "beta-C-meta"[THEN "\<rightarrow>E"])
           (fact "w-rel:3")
        using w[THEN "\<forall>E"(1), OF "log-prop-prop:2"] by blast
    qed
  next
      by (rule "rule-id-df:2:b[2]"[where \<tau>="\<lambda> (\<Pi>, \<kappa>). \<guillemotleft>[\<Pi>]\<^sub>\<kappa>\<guillemotright>"
                                     and \<sigma>="\<lambda>(\<Pi>, \<kappa>). \<guillemotleft>[\<lambda>x\<^sub>1...x\<^sub>n \<kappa> \<Turnstile> [\<Pi>]x\<^sub>1...x\<^sub>n]\<guillemotright>",
                                   simplified, OF "w-index"])
         (auto simp: "w-rel:3")
  qed
qed

AOT_theorem "rigid-rel-thms:1":
proof(safe intro!: "\<equiv>I" "\<rightarrow>I" GEN)
  fix x\<^sub>1x\<^sub>n
    by (metis "\<rightarrow>E" GEN RM "cqt-orig:3")
    using "\<forall>E"(2) by blast
    by (metis "\<equiv>E"(1) "sc-eq-box-box:1")
    using "\<rightarrow>E" by blast
next
    using "\<forall>E"(2) by blast
    by (metis "\<equiv>E"(2) "sc-eq-box-box:1")
    by (rule GEN)
    using "BF" "vdash-properties:10" by blast
qed

AOT_theorem "rigid-rel-thms:2":
proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
    using CBF[THEN "\<rightarrow>E"] by blast
  proof(rule GEN)
    fix x\<^sub>1x\<^sub>n
      using 0[THEN "\<forall>E"(2)].
      using "B\<diamond>" "Hypothetical Syllogism" "K\<diamond>" "vdash-properties:10" by blast
      using "exc-mid".
    moreover {
        using 1[THEN "qml:2"[axiom_inst, THEN "\<rightarrow>E"], THEN "\<rightarrow>E"] by blast
    }
    moreover {
      proof(rule "raa-cor:1")
          by (AOT_subst_def "conventions:5")
          using 3 "&I" by blast
      qed
    }
      by (metis "\<or>I"(1,2) "raa-cor:1")
  qed
next
  {
    fix x\<^sub>1x\<^sub>n
    moreover {
        using "S5Basic:6"[THEN "\<equiv>E"(1)] by blast
        using "KBasic:1"[THEN "\<rightarrow>E"] by blast
    }
    moreover {
        using "KBasic:2"[THEN "\<rightarrow>E"] by blast
    }
      using "con-dis-i-e:4:b" "raa-cor:1" by blast
  }
    by (rule GEN)
    using BF[THEN "\<rightarrow>E"] by fast
qed

  by (AOT_subst_thm "df-rigid-rel:1"[THEN "\<equiv>Df", THEN "\<equiv>S"(1), OF "cqt:2"(1)];
      AOT_subst_thm "rigid-rel-thms:2")
     (simp add: "oth-class-taut:3:a")

end
