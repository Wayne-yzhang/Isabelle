theory FOL_Axiomatic_Variant imports "HOL-Library.Countable" begin


datatype 'f tm

datatype ('f, 'p) fm







  by (simp add: shift_def)



  by (simp add: shift_def)

  by (simp add: shift_def)

  by (simp add: shift_def)

proof
  fix m
    unfolding shift_def by (cases m) simp_all
qed


primrec vars_tm where

primrec vars_fm where



  by (induct xs) auto

  by (induct t) (auto cong: map_cong)

  unfolding shift_def by fastforce

  by (induct xss) (auto simp: max_list_append)

  by (induct xs) auto

proof (induct p arbitrary: E n)
  case (Pre P ts)
    using Pre.prems max_list_concat by simp
    using max_list_in by blast
    by simp
  ultimately show ?case
    using upd_vars_tm by (metis list.map_cong semantics_fm.simps(2))
next
  case (Uni p)
    by (simp add: fun_upd_def)
    by (simp add: shift_upd_commute)
  finally show ?case
    using Uni by fastforce
qed (auto simp: max_list_append cong: map_cong)






  by (induct t) (auto cong: map_cong)

  by (induct t) (auto cong: map_cong)

  by (induct p arbitrary: E m t) (auto cong: map_cong)



primrec size_fm where

lemma size_inst_fm [simp]:
  by (induct p arbitrary: m t) auto


primrec boolean where


  by simp

proof
  fix p
    by (induct p) simp_all
qed

  using boolean_semantics by metis

  by (metis boolean.simps(4) fm.simps(36) semantics_fm.simps(1,3,4))




lemmas
  TA[simp]
  MP[trans, dest]
  GR[intro]





proof (induct p arbitrary: E F rule: Axiomatic.induct)
  case (GR q p n)
    by blast
    by simp
    using GR.hyps(3-4) by simp
    by blast
    by simp
    using shift_upd_commute by (metis zero_le)
    using GR.hyps(3) by (simp add: max_list_append)
    using upd_vars_fm by simp
  then show ?case
    by simp
qed (auto simp: tautology)

  using soundness by fastforce


  by auto

  by auto

  by auto

lemma contraposition:
  by (auto intro: TA)

proof -
    using * contraposition(1) by fast
    by (meson AK AS MP Neg)
    using n by auto
    using contraposition(1) by fast
  then show ?thesis
    by (meson AK AS MP Neg)
qed

  by auto

  by (induct ps) (auto intro: Imp3 MP)

  using imply_ImpE by fast

  by (auto intro: MP AK)

proof (induct ps)
  case (Cons q ps)
  then show ?case
    by (metis AK MP' imply.simps(1-2))
qed auto

lemma imply_lift_Imp [simp]:
  using assms MP MP' imply_head by (metis imply.simps(2))

  using MP imply_head by (auto simp del: TA)

proof (induct ps)
  case (Cons q ps)
  then show ?case
    by (metis imply_Cons imply_head set_ConsD)
qed simp

  by (meson MP' imply_Cons imply_head)

  by (induct ps) simp_all

proof (induct qs arbitrary: ps)
  case (Cons q qs)
  then show ?case
    by (metis deduct1 imply.simps(2) imply_append)
qed simp

  by (metis imply.simps(1-2) imply_append imply_swap_append)

lemmas deduct [iff] = deduct1 deduct2

  by (meson MP' deduct(2) imply_Cons)

  by (meson MP' Neg add_imply deduct(2))

proof (induct ps arbitrary: q)
  case (Cons p ps)
  then show ?case
    by (metis MP' deduct(2) imply_mem insert_subset list.simps(15))
qed simp



lemma UN_finite_bound:
  using assms
proof (induct rule: finite_induct)
  case (insert x A)
    by fast
    by fastforce
    using insert(4) by blast
    by auto
  then show ?case
    by blast
qed simp

lemma split_list:
  using assms by auto

  by (induct ps) auto

lemma inconsistent_fm:
proof -
    using assms unfolding consistent_def by blast
    using split_list by metis
  then show ?thesis
    using that S'' S'(1)
    by (metis Diff_insert_absorb Diff_subset_conv list.simps(15))
qed


proof (induct xs)
  case Nil
  then show ?case
    by simp
next
  case (Cons x xs)
  then show ?case
    by (metis linorder_not_less list.set_intros(1-2) max.absorb2 max.absorb3
        max_list.simps(1-2) max_nat.right_neutral)
qed

  by (induct xs) auto

  unfolding max_set_def using max_list_in_Cons
  by (metis (mono_tags, lifting) Max_ge bot.extremum_uniqueI bot_nat_0.extremum max_list.simps(1)
      set_empty subsetD)

lemma consistent_add_witness:
  unfolding consistent_def
proof
    using assms inconsistent_fm unfolding consistent_def by metis
    by simp
    using assms(2-4) max_list_in_set by fastforce
    by (meson Union_upper image_eqI order_le_less_trans subsetD)
    using assms(4) by (induct S') (auto simp: max_list_append)
    unfolding imply_vars_fm max_list_append by simp
    using GR' unfolding max_list_append by auto
    by simp
  ultimately show False
    using assms(1) unfolding consistent_def by blast
qed

lemma consistent_add_instance:
  unfolding consistent_def
proof
    using assms inconsistent_fm unfolding consistent_def by blast
    using IA by blast
    by (meson add_imply cut deduct(1))
  ultimately show False
    using assms(1) unfolding consistent_def by blast
qed


fun witness where

primrec extend where


  unfolding Extend_def by (metis Union_upper extend.simps(1) range_eqI)

  by (induct m) (simp_all add: atMost_Suc Let_def)

  by (induct used p rule: witness.induct) simp_all

  by (induct n) (simp_all add: Let_def)

  using max_list_max max_list_in_Cons
  by (metis less_nat_zero_code linorder_not_le max_list.simps(1) subset_code(1))

lemma consistent_witness:
  using assms
proof (induct used p rule: witness.induct)
  case (1 used p)
    by blast
    by (metis someI_ex witness.simps(1))
    using 1(3-4) max_list_mono order_le_less_trans
    by (metis (no_types, lifting) Max.subset_imp bot.extremum_uniqueI less_nat_zero_code linorder_neqE_nat max_set_def)
    using 1(3-4) infinite_super by blast
  ultimately show ?case
    using 1 n(1) consistent_add_witness by metis
qed (auto simp: assms)

lemma consistent_extend:
  using assms
proof (induct n)
  case (Suc n)
  then show ?case
qed simp

lemma consistent_Extend:
  unfolding consistent_def
proof
    unfolding consistent_def by blast
    unfolding Extend_def using UN_finite_bound by (metis List.finite_set)
    using extend_bound by blast
    using assms consistent_extend by blast
  ultimately show False
qed



lemma maximal_exactly_one:
proof
  proof
      by blast
    ultimately show False
  qed
next
    using Boole by blast
    unfolding consistent_def
  proof
      using assms inconsistent_fm unfolding consistent_def by blast
    ultimately show False
  qed
qed

lemma maximal_Extend:
proof (rule ccontr)
  then obtain p where
    unfolding maximal_def using assms consistent_Extend by blast
    using k by (auto simp: Let_def)
    unfolding Extend_def by blast
    unfolding consistent_def by auto
  then show False
qed



lemma saturated_Extend:
proof (rule ccontr)
    unfolding saturated_def by blast

    unfolding Extend_def by auto
    using assms(1) p(1) unfolding consistent_def by blast
    using k by (auto simp: Let_def)
    unfolding Extend_def by blast
  ultimately show False
    using p(2) by auto
qed


locale Hintikka =
  assumes



lemma semantics_tm_id [simp]:
  by (induct t) (auto cong: map_cong)

  by (auto cong: map_cong)

theorem Hintikka_model:
  case 1
  then show ?case ..
next
  case (2 x)
  proof (cases x; safe)
    case Falsity
    then have False
      using assms Hintikka.NoFalsity by fast
  next
    case Falsity
    then have False
      by simp
  next
    case (Pre P ts)
      by simp
  next
    case (Pre P ts)
      by simp
  next
    case (Imp p q)
      using assms Hintikka.ImpP by blast
      using 2 Imp by simp
      by simp
  next
    case (Imp p q)
      by simp
      using 2 Imp by simp
      using assms Hintikka.ImpN by blast
  next
    case (Uni p)
      using assms Hintikka.UniP by metis
      using 2 Uni by simp
      by simp
  next
    case (Uni p)
      by simp
      using 2 Uni by simp
      using assms Hintikka.UniN by blast
  qed
qed


lemma inconsistent_head:
  using assms inconsistent_fm unfolding consistent_def maximal_def by metis

lemma inconsistent_parts [simp]:
  using assms unfolding consistent_def by blast

lemma Hintikka_Extend:
proof
  proof
      by blast
    then show False
  qed
next
  fix p q
  proof safe
      using assms inconsistent_head by metis

      using assms maximal_exactly_one by blast
      using assms inconsistent_head by metis

      by simp
      by blast+
      using Hp'(1) Hq'(1) deduct imply_weaken by metis+
      using Boole imply_Cons imply_head MP' cut by metis
    ultimately show False
      using assms unfolding consistent_def by blast
  qed
next
  fix p q
  proof (safe, rule ccontr)
      using assms inconsistent_head by metis
      by auto
      by blast
      using *(1) S'(2) assms maximal_exactly_one by auto
    ultimately show False
      using assms unfolding consistent_def by blast
  next
      using assms maximal_exactly_one by blast
      using assms inconsistent_head by metis
      by auto
      by blast
      using *(1) H'(2) assms maximal_exactly_one by auto
    ultimately show False
      using assms unfolding consistent_def by blast
  qed
next
  fix p
    using assms consistent_add_instance unfolding maximal_def by blast
next
  fix p
    using assms maximal_exactly_one unfolding saturated_def by fast
qed


instance tm :: (countable) countable
  by countable_datatype

instance fm :: (countable, countable) countable
  by countable_datatype


theorem strong_completeness:
proof (rule ccontr)
    using Boole by blast


    using * by (metis consistent_def imply_Cons inconsistent_fm)
    using assms by simp
    using assms consistent_Extend maximal_Extend surj_from_nat by blast+
    using saturated_Extend by fastforce
    using assms Hintikka_Extend by blast

    by fastforce+
    using assms(1) by blast
  ultimately show False
    by simp
qed

theorem completeness:

corollary
  using completeness assms .



  using completeness soundness by blast

end
