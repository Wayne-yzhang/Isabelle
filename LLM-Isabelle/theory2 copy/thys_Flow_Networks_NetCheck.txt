theory NetCheck
imports 
  "Lib/Refine_Add_Fofu"
  Network
  Graph_Impl
  DFS_Framework.Reachable_Nodes
begin

  declare [[coercion_delete int]]
  declare [[coercion_delete "real::nat\<Rightarrow>real"]]


  type_synonym edge_list = "(node \<times> node \<times> capacity_impl) list"

  definition ln_invar :: "edge_list \<Rightarrow> bool" where 
    "ln_invar el \<equiv> 
      distinct (map (\<lambda>(u, v, _). (u,v)) el) 
    \<and> (\<forall>(u,v,c)\<in>set el. c>0) 
    "
  definition ln_\<alpha> :: "edge_list \<Rightarrow> capacity_impl graph" where 
    "ln_\<alpha> el \<equiv> \<lambda>(u,v). 
      if \<exists>c. (u, v, c) \<in> set el \<and> c \<noteq> 0 then 
        SOME c. (u, v, c) \<in> set el \<and> c \<noteq> 0
      else 0"

  definition "ln_rel \<equiv> br ln_\<alpha> ln_invar"
  
  lemma ln_equivalence: "(el, c') \<in> ln_rel \<longleftrightarrow> ln_invar el \<and> c' = ln_\<alpha> el"
    unfolding ln_rel_def br_def by auto 

  definition ln_N :: "(node\<times>node\<times>_) list \<Rightarrow> nat" 
    where "ln_N el \<equiv> Max ((fst`set el) \<union> ((fst o snd)`set el)) + 1"

  lemma ln_\<alpha>_imp_in_set: "\<lbrakk>ln_\<alpha> el (u,v)\<noteq>(0)\<rbrakk> \<Longrightarrow> (u,v,ln_\<alpha> el (u,v))\<in>set el"
    apply (auto simp: ln_\<alpha>_def split: if_split_asm)
    apply (metis (mono_tags, lifting) someI_ex)
    done

  lemma ln_N_correct: "Graph.V (ln_\<alpha> el) \<subseteq> {0..<ln_N el}"  
    apply (clarsimp simp: Graph.V_def Graph.E_def)
    apply (safe dest!: ln_\<alpha>_imp_in_set)
    apply (fastforce simp: ln_N_def less_Suc_eq_le intro: Max_ge)
    apply (force simp: ln_N_def less_Suc_eq_le intro: Max_ge)
    done


  record pre_network =
    pn_c :: "capacity_impl graph"
    pn_V :: "nat set"
    pn_succ :: "nat \<Rightarrow> nat list"
    pn_pred :: "nat \<Rightarrow> nat list"
    pn_adjmap :: "nat \<Rightarrow> nat list"
    pn_s_node :: bool
    pn_t_node :: bool

  fun read :: "edge_list \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> pre_network option" 
  where
    "read [] _ _ = Some \<lparr>
      pn_c = (\<lambda> _. 0), 
      pn_V = {}, 
      pn_succ = (\<lambda> _. []),
      pn_pred = (\<lambda> _. []),
      pn_adjmap = (\<lambda> _. []), 
      pn_s_node = False, 
      pn_t_node = False
    \<rparr>"
  | "read ((u, v, c) # es) s t = ((case (read es s t) of 
      Some x \<Rightarrow>
        (if (pn_c x) (u, v) = 0 \<and> (pn_c x) (v, u) = 0 \<and> c > 0 then
          (if u = v \<or> v = s \<or> u = t then
            None
          else
            Some (x\<lparr> 
              pn_c := (pn_c x) ((u, v) := c),
              pn_V := insert u (insert v (pn_V x)),
              pn_succ := (pn_succ x) (u := v # ((pn_succ x) u)),
              pn_pred := (pn_pred x) (v := u # ((pn_pred x) v)),
              pn_adjmap := (pn_adjmap x) (
                u := v # (pn_adjmap x) u, 
                v := u # (pn_adjmap x) v),
              pn_s_node := pn_s_node x \<or> u = s,
              pn_t_node := pn_t_node x \<or> v = t
            \<rparr>))
        else
          None)
    | None \<Rightarrow> None))"
      
  lemma read_correct1: "read es s t = Some \<lparr>pn_c = c, pn_V = V, pn_succ = succ, 
    pn_pred = pred , pn_adjmap = adjmap, pn_s_node = s_n, pn_t_node = t_n\<rparr> \<Longrightarrow> 
    (es, c) \<in> ln_rel \<and> Graph.V c = V \<and> finite V \<and> 
    (s_n \<longrightarrow> s \<in> V) \<and> (t_n \<longrightarrow> t \<in> V) \<and> (\<not>s_n \<longrightarrow> s \<notin> V) \<and> (\<not>t_n \<longrightarrow> t \<notin> V) \<and>
    (\<forall>u v. c (u,v) \<ge> 0) \<and>
    (\<forall>u. c(u, u) = 0) \<and> (\<forall>u. c (u, s) = 0) \<and> (\<forall>u. c (t, u) = 0) \<and>
    (\<forall>u v. c (u, v) \<noteq> 0 \<longrightarrow> c (v, u) = 0) \<and> 
    (\<forall>u. set (succ u) = Graph.E c``{u} \<and> distinct (succ u)) \<and> 
    (\<forall>u. set (pred u) = (Graph.E c)\<inverse>``{u} \<and> distinct (pred u)) \<and> 
    (\<forall>u. set (adjmap u) = Graph.E c``{u} \<union> (Graph.E c)\<inverse>``{u} 
      \<and> distinct (adjmap u))"
    proof (induction es arbitrary: c V succ pred adjmap s_n t_n)
      case Nil
        thus ?case 
          unfolding Graph.V_def Graph.E_def ln_rel_def br_def 
            ln_\<alpha>_def ln_invar_def 
          by auto
    next
      case (Cons e es)
        obtain u1 v1 c1 where obt1: "e = (u1, v1, c1)" by (meson prod_cases3)
        obtain x where obt2: "read es s t = Some x"
          using Cons.prems obt1 by (auto split: option.splits)
        have fct0: "(pn_c x) (u1, v1) = 0 \<and> (pn_c x) (v1, u1) = 0 \<and> c1 > 0"
          using Cons.prems obt1 obt2 by (auto split: option.splits if_splits)
        have fct1: "c1 > 0 \<and> u1 \<noteq> v1 \<and> v1 \<noteq> s \<and> u1 \<noteq> t"
          using Cons.prems obt1 obt2 by (auto split: option.splits if_splits)
        
        obtain c' V' sc' ps' pd' s_n' t_n' where obt3: 
          "x = \<lparr>pn_c = c', pn_V = V',
                pn_succ = sc', pn_pred = pd',  pn_adjmap = ps', 
                pn_s_node = s_n', pn_t_node = t_n'\<rparr>" 
          apply (cases x) by auto
        then have "read es s t = Some \<lparr>pn_c = c', pn_V = V', 
          pn_succ = sc', pn_pred = pd',
          pn_adjmap = ps', pn_s_node = s_n', pn_t_node = t_n'\<rparr>" 
          using obt2 by blast
        note fct = Cons.IH[OF this]
        have fct2: "s_n = (s_n' \<or> u1 = s)" 
          using fct0 fct1 Cons.prems obt1 obt2 obt3 by simp
        have fct3: "t_n = (t_n' \<or> v1 = t)"
          using fct0 fct1 Cons.prems obt1 obt2 obt3 by simp
        have fct4: "c = c' ((u1, v1) := c1)"
          using fct0 fct1 Cons.prems obt1 obt2 obt3 by simp
        have fct5: "V = V' \<union> {u1, v1}" 
          using fct0 fct1 Cons.prems obt1 obt2 obt3 by simp
        have fct6: "succ = sc' (u1 := v1 # sc' u1)" 
          using fct0 fct1 Cons.prems obt1 obt2 obt3 by simp
        have fct7: "pred = pd' (v1 := u1 # pd' v1)"
          using fct0 fct1 Cons.prems obt1 obt2 obt3 by simp
        have fct8: "adjmap = (ps' (u1 := v1 # ps' u1)) (v1 := u1 # ps' v1)"
          using fct0 fct1 Cons.prems obt1 obt2 obt3 by simp
        
          
        {
          have "(es, c') \<in> ln_rel" using fct by blast
          then have "ln_invar es" and "c' = ln_\<alpha> es" 
            unfolding ln_rel_def br_def by auto
          
          have "ln_invar (e # es)"
            proof (rule ccontr)
              assume "\<not> ?thesis"
              have f1: "\<forall>(u, v, c) \<in> set (e # es). c>0" 
                unfolding ln_invar_def by auto
              have f2: "distinct (map (\<lambda>(u, v, _). (u,v)) es)" 
                unfolding ln_invar_def by auto
              
              have "\<exists>c1'. (u1, v1, c1') \<in> (set es) \<and> c1' \<noteq> 0"
                proof (rule ccontr)
                  assume "\<not> ?thesis"
                  then have "\<forall>c1'. (u1, v1, c1') \<notin> (set es) \<or> c1' = 0" by blast
                  then have "distinct (map (\<lambda>(u, v, _). (u,v)) (e # es))" 
                    using obt1 f2 f1 by auto
                  then have "ln_invar (e # es)" 
                    unfolding ln_invar_def using f1 by simp
                qed
              then obtain c1' where "(u1, v1, c1') \<in> (set es) \<and> c1' \<noteq> 0" 
                by blast
              then have "c' (u1, v1) = (SOME c. (u1, v1, c) \<in> set es \<and> c \<noteq> 0)"
              then have "c' (u1, v1) \<noteq> 0" 
                by (metis (mono_tags, lifting) tfl_some)
              thus "False" using fct0 obt3 by simp
            qed
          moreover {
            {
              fix a
              have f1: "distinct (map (\<lambda>(u, v, _). (u,v)) (e # es))"
                and f2: "\<forall>u v. (u, v, 0) \<notin> set (e # es)"
              have "c a = ln_\<alpha> (e # es) a"
                proof (cases "a = (u1, v1)")
                  case True
                    have "c a = c1" using fct4 True by simp
                    moreover {
                      have "(ln_\<alpha> (e # es)) a 
                        = (SOME c. (u1, v1, c) \<in> set (e # es) \<and> c \<noteq> 0)"
                        (is "?L = ?R") 
                        unfolding ln_\<alpha>_def using obt1 fct0 True by auto
                      moreover have "?R = c1"
                        proof (rule ccontr)
                          assume "\<not> ?thesis"
                          then obtain c1' where 
                            "(u1, v1, c1') \<in> set (e # es) \<and> c1' \<noteq> 0 \<and> c1' \<noteq> c1" 
                            using fct0 obt1 by auto
                          then have 
                            "\<not>distinct (map (\<lambda>(u, v, _). (u,v)) (e # es))" 
                            using obt1 
                            by (metis (mono_tags, lifting) Pair_inject 
                              distinct_map_eq list.set_intros(1) split_conv) 
                          thus "False" using f1 by blast
                        qed
                      ultimately have "?L = c1" by blast
                    }
                    ultimately show ?thesis by simp
                next
                  case False
                    have f1: 
                      "\<forall>u1' v1' c1'. u1' \<noteq> u1 \<or> v1' \<noteq> v1 
                      \<longrightarrow> ((u1', v1', c1') \<in> set (e # es)
                            \<longleftrightarrow> (u1', v1', c1') \<in> set es)" 
                      using obt1 by auto
                    obtain u1' v1' where "a = (u1', v1')" by (cases a)
                    {
                      have "(ln_\<alpha> (e # es)) (u1', v1') = (ln_\<alpha> es) (u1', v1')"
                        proof (cases 
                            "\<exists> c1'. (u1', v1', c1') \<in> set (e # es) \<and> c1' \<noteq> 0")
                          case True
                            thus ?thesis unfolding ln_\<alpha>_def 
                        next
                          case False
                            thus ?thesis unfolding ln_\<alpha>_def by auto
                        qed
                      then have "(ln_\<alpha> (e # es)) a = (ln_\<alpha> es) a" 
                    }
                    moreover have "c a = c' a" using False fct4 by simp
                      by simp
                    ultimately show ?thesis by simp
                qed
            }
            then have "c = ln_\<alpha> (e # es)" by auto
          }
          ultimately have "(e # es, c) \<in> ln_rel" unfolding ln_rel_def br_def 
            by simp
        }
        moreover {
          have "Graph.V c = Graph.V c' \<union> {u1, v1}" 
            unfolding Graph.V_def Graph.E_def using fct0 fct4 by auto
          moreover have "Graph.V c' = V'" using fct by blast
          ultimately have "Graph.V c = V" using fct5 by auto
        }
        moreover {
          have "finite V'" using fct by blast
          then have "finite V" using fct5 by auto
        }
        moreover {
          assume "s_n"
          then have "s_n' \<or> u1 = s" using fct2 by blast
          then have "s \<in> V"
            proof
              assume "s_n'"
                thus ?thesis using fct fct5 by auto
            next
              assume "u1 = s"
                thus ?thesis using fct5 by simp
            qed
        }
        moreover {
          assume "t_n"
          then have "t_n' \<or> v1 = t" using fct3 by blast
          then have "t \<in> V"
            proof
              assume "t_n'"
                thus ?thesis using fct fct5 by auto
            next
              assume "v1 = t"
                thus ?thesis using fct5 by simp
            qed
        }
        moreover {
          assume "\<not>s_n"
          then have "\<not>s_n' \<and> u1 \<noteq> s" using fct2 by blast
          then have "s \<notin> V" using fct fct5 fct1  by auto
        }
        moreover {
          assume "\<not>t_n"
          then have "\<not>t_n' \<and> v1 \<noteq> t" using fct3 by blast
          then have "t \<notin> V" using fct fct5 fct1  by auto
        }
        moreover have "\<forall>u v. (c (u, v) \<ge> 0)" using fct fct4 fct1 fct0 by auto
        moreover have "\<forall>u. c (u, u) = 0" using fct fct4 fct1 fct0 by auto
        moreover have "\<forall>u. c (u, s) = 0" using fct fct4 fct1 fct0 by auto
        moreover have "\<forall>u. c (t, u) = 0" using fct fct4 fct1 fct0 by auto
        moreover {
          fix a b
          assume "c (a, b) \<noteq> 0"
          have "c (b, a) = 0"
            proof (cases "(a, b) = (u1, v1)")
              case True
                moreover have "c' (v1, u1) = 0" using fct0 obt3 by auto
                ultimately show ?thesis by simp
            next
              case False
                thus ?thesis
                  proof (cases "(b, a) = (u1, v1)")
                    case True
                        by auto
                      moreover have "c' (v1, u1) = 0" using fct0 obt3 by auto
                  next
                    case False
                      then have "c (b, a) = c' (b, a)" using fct4 by auto
                      moreover have "c (a, b) = c' (a, b)" 
                  qed
            qed
        } note n_fct = this
        moreover {
          {
            fix a
            assume "a \<noteq> u1"
            then have "succ a = sc' a" using fct6 by simp
            moreover have "set (sc' a) = Graph.E c' `` {a} \<and> distinct (sc' a)"
              using fct by blast
            ultimately have "set (succ a) = Graph.E c``{a} \<and> distinct (succ a)"
          }
          moreover {
            fix a
            assume "a = u1"
            have "set (succ a) = Graph.E c``{a} \<and> distinct (succ a)"
              proof (cases "c' (u1, v1) = 0")
                case True
                  have fct: "set (sc' a) = Graph.E c' `` {a} \<and> distinct (sc' a)"
                    using fct by blast
                  
                  moreover have "Graph.E c = Graph.E c' \<union> {(u1, v1)}" 
                    unfolding Graph.E_def using fct4 fct0 by auto
                  moreover have "v1 \<notin> set (sc' a)"
                    proof (rule ccontr)
                      assume "\<not> ?thesis"
                      then have "c' (a, v1) \<noteq> 0" 
                        using fct unfolding Graph.E_def by auto
                    qed
              next
                case False
                  thus ?thesis using fct0 obt3 by auto
              qed
        }
        ultimately have 
          "\<forall>u. set (succ u) = Graph.E c `` {u} \<and> distinct (succ u)" 
          by metis
      }
        moreover {
          {
            fix a
            assume "a \<noteq> v1"
            then have "pred a = pd' a" using fct7 by simp
            moreover have 
              "set (pd' a) = (Graph.E c')\<inverse> `` {a} \<and> distinct (pd' a)"
              using fct by blast
            ultimately have 
              "set (pred a) = (Graph.E c)\<inverse>``{a} \<and> distinct (pred a)"
          }
          moreover {
            fix a
            assume "a = v1"
            have "set (pred a) = (Graph.E c)\<inverse>``{a} \<and> distinct (pred a)"
              proof (cases "c' (u1, v1) = 0")
                case True
                  have fct: 
                    "set (pd' a) = (Graph.E c')\<inverse> `` {a} \<and> distinct (pd' a)"
                    using fct by blast
                  
                  moreover have "Graph.E c = Graph.E c' \<union> {(u1, v1)}" 
                    unfolding Graph.E_def using fct4 fct0 by auto
                  moreover have "u1 \<notin> set (pd' a)"
                    proof (rule ccontr)
                      assume "\<not> ?thesis"
                      then have "c' (u1, a) \<noteq> 0" 
                        using fct unfolding Graph.E_def by auto
                    qed
              next
                case False
                  thus ?thesis using fct0 obt3 by auto
              qed
        }
        ultimately have 
          "\<forall>u. set (pred u) = (Graph.E c)\<inverse>`` {u} \<and> distinct (pred u)" 
          by metis
      }
      moreover {
        {
          fix a
          assume "a \<noteq> u1 \<and> a \<noteq> v1"
          then have "adjmap a = ps' a" using fct8 by simp
            moreover have "set (ps' a) = 
              Graph.E c'``{a} \<union> (Graph.E c')\<inverse>``{a} \<and> distinct (ps' a)" 
              using fct by blast
            ultimately have 
              "set (adjmap a) = Graph.E c``{a} \<union> (Graph.E c)\<inverse>``{a} 
                \<and> distinct (adjmap a)" 
        }
        moreover {
          fix a
          assume "a = u1 \<or> a = v1"
          then have 
            "set (adjmap a) = Graph.E c``{a} \<union> (Graph.E c)\<inverse>``{a} 
              \<and> distinct (adjmap a)"
            proof
              assume "a = u1"
              show ?thesis
                proof (cases "c' (u1, v1) = 0 \<and> c' (v1, u1) = 0")
                  case True
                    have fct: 
                      "set (ps' a) = Graph.E c' `` {a} \<union> (Graph.E c')\<inverse> `` {a} 
                      \<and> distinct (ps' a)" 
                      using fct by blast
                    
                    have "adjmap a = v1 # ps' a" 
                    moreover have "Graph.E c = Graph.E c' \<union> {(u1, v1)}" 
                      unfolding Graph.E_def using fct4 fct0 by auto
                    moreover have "v1 \<notin> set (ps' a)"
                      proof (rule ccontr)
                        assume "\<not> ?thesis"
                        then have "c' (a, v1) \<noteq> 0 \<or> c' (v1, a) \<noteq> 0"
                          using fct unfolding Graph.E_def by auto
                      qed
                next
                  case False
                    thus ?thesis using fct0 obt3 by auto 
                qed
            next
              assume "a = v1"
              show ?thesis
                proof (cases "c' (u1, v1) = 0 \<and> c' (v1, u1) = 0")
                  case True
                    have fct: 
                      "set (ps' a) = Graph.E c' `` {a} \<union> (Graph.E c')\<inverse> `` {a} 
                      \<and> distinct (ps' a)" 
                      using fct by blast
                    
                    have "adjmap a = u1 # ps' a" 
                    moreover have "Graph.E c = Graph.E c' \<union> {(u1, v1)}" 
                      unfolding Graph.E_def using fct4 fct0 by auto
                    moreover have "u1 \<notin> set (ps' a)"
                      proof (rule ccontr)
                        assume "\<not> ?thesis"
                        then have "c' (u1, a) \<noteq> 0 \<or> c' (a, u1) \<noteq> 0"
                          using fct unfolding Graph.E_def by auto
                      qed
                next
                  case False
                    thus ?thesis using fct0 obt3 by auto
                qed
            qed
        }
        ultimately have 
          "\<forall>u. set (adjmap u) = Graph.E c``{u} \<union> (Graph.E c)\<inverse>``{u} 
          \<and> distinct (adjmap u)" 
          by metis
      }
      ultimately show ?case by simp  
    qed
    
  lemma read_correct2: "read el s t = None \<Longrightarrow> \<not>ln_invar el 
    \<or> (\<exists>u v c. (u,v,c) \<in> set el \<and> \<not>(c > 0))
    \<or> (\<exists>u c. (u, u, c) \<in> set el \<and> c \<noteq> 0) \<or> 
    (\<exists>u c. (u, s, c) \<in> set el \<and> c \<noteq> 0) \<or> (\<exists>u c. (t, u, c) \<in> set el \<and> c \<noteq> 0) \<or>
    (\<exists>u v c1 c2. (u, v, c1) \<in> set el \<and> (v, u, c2) \<in> set el \<and> c1 \<noteq> 0 \<and> c2 \<noteq> 0)"
    proof (induction el)
      case Nil
        thus ?case by auto
    next
      case (Cons e el)
        thus ?case
          proof (cases "read el s t = None")
            case True
              note Cons.IH[OF this]
              thus ?thesis
                proof
                  assume "\<not>ln_invar el"
                  then have "\<not>distinct (map (\<lambda>(u, v, _). (u,v)) (e # el)) \<or> 
                    (\<exists>(u, v, c) \<in> set (e # el). \<not>(c>0))" 
                    unfolding ln_invar_def by fastforce
                  thus ?thesis unfolding ln_invar_def by fastforce
                next
                  assume "
                    (\<exists>u v c. (u, v, c) \<in> set (el) \<and> \<not>(c > 0)) 
                  \<or> (\<exists>u c. (u, u, c) \<in> set el \<and> c \<noteq> 0) 
                  \<or> (\<exists>u c. (u, s, c) \<in> set el \<and> c \<noteq> 0) 
                  \<or> (\<exists>u c. (t, u, c) \<in> set el \<and> c \<noteq> 0) 
                  \<or> (\<exists>u v c1 c2. (u, v, c1) \<in> set el \<and> (v, u, c2) \<in> set el 
                      \<and> c1 \<noteq> 0 \<and> c2 \<noteq> 0)" 
                  
                  moreover {
                    assume "(\<exists>u v c. (u, v, c) \<in> set el \<and> \<not>(c > 0))"
                    then have "(\<exists>u v c. (u, v, c) \<in> set (e # el) \<and> \<not>(c > 0))" 
                      by auto
                  }
                  moreover {
                    assume "(\<exists>u c. (u, u, c) \<in> set el \<and> c \<noteq> 0)"
                    then have "(\<exists>u c. (u, u, c) \<in> set (e # el) \<and> c \<noteq> 0)" 
                      by auto
                  }
                  moreover {
                    assume "(\<exists>u c. (u, s, c) \<in> set el \<and> c \<noteq> 0)"
                    then have "(\<exists>u c. (u, s, c) \<in> set (e # el) \<and> c \<noteq> 0)" 
                      by auto
                  }
                  moreover {
                    assume "(\<exists>u c. (t, u, c) \<in> set el \<and> c \<noteq> 0)"
                    then have "(\<exists>u c. (t, u, c) \<in> set (e # el) \<and> c \<noteq> 0)" 
                      by auto
                  }
                  moreover {
                    assume "(\<exists>u v c1 c2. 
                      (u, v, c1) \<in> set el \<and> (v, u, c2) \<in> set el 
                        \<and> c1 \<noteq> 0 \<and> c2 \<noteq> 0)"
                    then have "(\<exists>u v c1 c2. (u, v, c1) \<in> set (e # el) \<and>
                      (v, u, c2) \<in> set (e # el) \<and> c1 \<noteq> 0 \<and> c2 \<noteq> 0)" 
                      by auto
                  }
                  ultimately show ?thesis by blast
                qed
          next
            case False
            then obtain x where obt1: "read el s t = Some x" by auto
            obtain u1 v1 c1 where obt2: "e = (u1, v1, c1)" 
              apply (cases e) by auto
            obtain c' V' sc' pd' ps' s_n' t_n' where obt3: "x = 
              \<lparr>
                pn_c = c', pn_V = V', pn_succ = sc',
                pn_pred = pd', pn_adjmap = ps',
                pn_s_node = s_n', pn_t_node = t_n'
              \<rparr>" 
              apply (cases x) by auto 
            then have "(el, c') \<in> ln_rel" using obt1 read_correct1[of el s t] 
              by simp
            then have "c' = ln_\<alpha> el" unfolding ln_rel_def br_def by simp
            

            have "(c' (u1, v1) \<noteq> 0 \<or> c' (v1, u1) \<noteq> 0 \<or> c1 \<le> 0) \<or> 
              (c1 > 0 \<and> (u1 = v1 \<or> v1 = s \<or> u1 = t))"
              using obt1 obt2 obt3 False Cons.prems 
                by (auto split:option.splits if_splits)
            moreover {
              assume "c1 \<le> 0"
              then have "\<not> ln_invar (e # el)" 
                unfolding ln_invar_def using obt2 by auto
            }
            moreover {
              assume "c1 > 0 \<and> u1 = v1"
              then have "(\<exists>u c. (u, u, c) \<in> set (e # el) \<and> c > 0)" 
                using obt2 by auto
            }
            moreover {
              assume "c1 > 0 \<and> v1 = s"
              then have "(\<exists>u c. (u, s, c) \<in> set (e # el) \<and> c > 0)" 
                using obt2 by auto
            }
            moreover {
              assume "c1 > 0 \<and> u1 = t"
              then have "(\<exists>u c. (t, u, c) \<in> set (e # el) \<and> c > 0)" 
                using obt2 by auto
            }
            moreover {
              assume "c' (u1, v1) \<noteq> 0"
              then have "\<exists>c1'. (u1, v1, c1') \<in> set el" 
                by (auto split:if_splits)
              then have "\<not> distinct (map (\<lambda>(u, v, _). (u, v)) (e # el))" 
                using obt2 by force
              then have "\<not>ln_invar (e # el)" unfolding ln_invar_def by auto
            }
            moreover {
              assume "c' (v1, u1) \<noteq> 0"
              then have "\<exists>c1'. (v1, u1, c1') \<in> set el \<and> c1' \<noteq> 0" 
                by (auto split:if_splits)
              then have "\<not>ln_invar (e # el) \<or> (
                \<exists>u v c1 c2.
                  (u, v, c1) \<in> set (e # el) \<and> (v, u, c2) \<in> set (e # el) 
                  \<and> c1 \<noteq> 0 \<and> c2 \<noteq> 0)"
                proof (cases "c1 \<noteq> 0")
                  case True
                    thus ?thesis 
                      by auto
                next
                  case False
                    then have "\<not>ln_invar (e # el)" 
                      unfolding ln_invar_def using obt2 by auto
                    thus ?thesis by blast
                qed
            }
            ultimately show ?thesis by blast
          qed
    qed
    

  record 'capacity::linordered_idom pre_network' =
    pn_c' :: "(nat*nat,'capacity) ArrayHashMap.ahm"
    pn_V' :: "nat ahs"
    pn_succ' :: "(nat,nat list) ArrayHashMap.ahm"
    pn_pred' :: "(nat,nat list) ArrayHashMap.ahm"
    pn_adjmap' :: "(nat,nat list) ArrayHashMap.ahm"
    pn_s_node' :: bool
    pn_t_node' :: bool


  definition "pnet_\<alpha> pn' \<equiv> \<lparr>
      pn_c = the_default 0 o (ahm.\<alpha> (pn_c' pn')), 
      pn_V = ahs_\<alpha> (pn_V' pn'), 
      pn_succ = the_default [] o (ahm.\<alpha> (pn_succ' pn')),
      pn_pred = the_default [] o (ahm.\<alpha> (pn_pred' pn')),
      pn_adjmap = the_default [] o (ahm.\<alpha> (pn_adjmap' pn')), 
      pn_s_node = pn_s_node' pn', 
      pn_t_node = pn_t_node' pn'
  \<rparr>"  

  definition "pnet_rel \<equiv> br pnet_\<alpha> (\<lambda>_. True)"
  
  definition "ahm_ld a ahm k \<equiv> the_default a (ahm.lookup k ahm)"
  abbreviation "cap_lookup \<equiv> ahm_ld 0"
  abbreviation "succ_lookup \<equiv> ahm_ld []"


  fun read' :: "(nat \<times> nat \<times> 'capacity::linordered_idom) list \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow>
    'capacity pre_network' option" where
    "read' [] _ _ = Some \<lparr>
      pn_c' = ahm.empty (), 
      pn_V' = ahs.empty (), 
      pn_succ' = ahm.empty (),
      pn_pred' = ahm.empty (),
      pn_adjmap' = ahm.empty (), 
      pn_s_node' = False, 
      pn_t_node' = False
    \<rparr>"
  | "read' ((u, v, c) # es) s t = ((case (read' es s t) of 
      Some x \<Rightarrow>
        (if 
          cap_lookup (pn_c' x) (u, v) = 0 
          \<and> cap_lookup (pn_c' x) (v, u) = 0 \<and> c > 0 
         then
          (if u = v \<or> v = s \<or> u = t then
            None
          else
            Some (x\<lparr> 
              pn_c' := ahm.update (u, v) c (pn_c' x),
              pn_V' := ahs.ins u (ahs.ins v (pn_V' x)),
              pn_succ' := 
                ahm.update u (v # (succ_lookup (pn_succ' x) u)) (pn_succ' x),
              pn_pred' := 
                ahm.update v (u # (succ_lookup (pn_pred' x) v)) (pn_pred' x),
              pn_adjmap' := ahm.update 
                u (v # (succ_lookup (pn_adjmap' x) u)) (ahm.update 
                v (u # (succ_lookup (pn_adjmap' x) v)) 
                (pn_adjmap' x)),
              pn_s_node' := pn_s_node' x \<or> u = s,
              pn_t_node' := pn_t_node' x \<or> v = t
            \<rparr>))
        else
          None)
    | None \<Rightarrow> None))"

  lemma read'_correct: "read el s t = map_option pnet_\<alpha> (read' el s t)"
    apply (induction el s t rule: read.induct)
    by (auto 
      simp: pnet_\<alpha>_def o_def ahm.correct ahs.correct ahm_ld_def 
    
  lemma read'_correct_alt: "(read' el s t, read el s t) \<in> \<langle>pnet_rel\<rangle>option_rel"
    unfolding pnet_rel_def br_def
    apply (simp add: option_rel_def read'_correct)
    using domIff by force

  export_code read checking SML     
  

  definition "reachable_spec c s \<equiv> RETURN (((Graph.E c)\<^sup>*)``{s}) "
