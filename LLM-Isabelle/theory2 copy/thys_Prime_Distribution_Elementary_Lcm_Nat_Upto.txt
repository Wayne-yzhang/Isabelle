theory Lcm_Nat_Upto
  imports Prime_Number_Theorem.Prime_Counting_Functions
begin

lemma multiplicity_Lcm:
  fixes A :: "'a :: {semiring_Gcd, factorial_semiring_gcd} set"
  assumes "finite A" "A \<noteq> {}" "prime p" "0 \<notin> A"
  shows   "multiplicity p (Lcm A) = Max (multiplicity p ` A)"
  using assms
proof (induction A rule: finite_ne_induct)
  case (insert x A)
  have "Lcm (insert x A) = lcm x (Lcm A)" by simp
  also have "multiplicity p \<dots> = Max (multiplicity p ` insert x A)"
    using insert by (subst multiplicity_lcm) (auto simp: Lcm_0_iff)
  finally show ?case by simp
qed auto

lemma multiplicity_Lcm_atLeast1AtMost_Suc:
  fixes p n :: nat
  assumes p: "prime p" and n: "n > 0"
  shows "multiplicity p (Lcm {1..Suc n}) =
           (if \<exists>k. Suc n = p ^ k then 1 else 0) + multiplicity p (Lcm {1..n})"
proof -
  define k where "k = Max (multiplicity p ` {1..n})"
  define l where "l = multiplicity p (Suc n)"
  have eq: "{1..Suc n} = insert (Suc n) {1..n}" by auto

  have "multiplicity p (Lcm {1..Suc n}) = Max (multiplicity p ` {1..Suc n})"
    using assms by (subst multiplicity_Lcm) auto
  also have "multiplicity p ` {1..Suc n} =
               insert (multiplicity p (Suc n)) (multiplicity p ` {1..n})"
    by (simp only: eq image_insert)
  also have "Max \<dots> = max l k"
    unfolding l_def k_def using assms by (subst Max.insert) auto
  also have "\<dots> = (if \<exists>k. Suc n = p ^ k then 1 else 0) + k"
  proof (cases "\<exists>k. Suc n = p ^ k")
    case False
    have "p ^ l dvd Suc n"
      unfolding l_def by (intro multiplicity_dvd)
    hence "p ^ l \<le> Suc n"
      unfolding l_def by (intro dvd_imp_le multiplicity_dvd) auto
    moreover have "Suc n \<noteq> p ^ l" using False by blast
    ultimately have "p ^ l < Suc n" by linarith
    ultimately have "l = multiplicity p (p ^ l)" and "p ^ l \<in> {1..n}"
    hence "l \<le> k" unfolding k_def by (intro Max.coboundedI) auto
    with False show ?thesis by (simp add: l_def k_def)
  next
    case True
    then obtain x where x: "Suc n = p ^ x" by blast
    have "x = k + 1"
    proof (intro antisym)
      have "p ^ (x - 1) < Suc n"
      moreover have "p ^ (x - 1) > 0"
      ultimately have "multiplicity p (p ^ (x - 1)) = x - 1" and "p ^ (x - 1) \<in> {1..n}"
      hence "x - 1 \<le> k"
        unfolding k_def by (intro Max.coboundedI) force+
      thus "x \<le> k + 1" by linarith
    next
      have "multiplicity p y < x" if "y \<in> {1..n}" for y
      proof -
        have "p ^ multiplicity p y \<le> y"
          using that by (intro dvd_imp_le multiplicity_dvd) auto
        also have "\<dots> < Suc n" using that by simp
        also have "\<dots> = p ^ x" by (fact x)
        finally show "multiplicity p y < x"
      qed
      hence "k < x"
      thus "k + 1 \<le> x" by simp
    qed
    thus ?thesis using True by simp
  qed
  also have "k = multiplicity p (Lcm {1..n})"
  finally show ?thesis .
qed

lemma Lcm_atLeast1AtMost_Suc:
  "Lcm {1..Suc n} = Lcm {1..n} * (if primepow (Suc n) then aprimedivisor (Suc n) else 1)"
proof (cases "n > 0")
  case True
  show ?thesis
  proof (rule multiplicity_eq_nat)
    fix p :: nat assume "prime p"
    define x where "x = (if primepow (Suc n) then aprimedivisor (Suc n) else 1)"
    have "x > 0"
  
    have "multiplicity p (Lcm {1..n} * x) = multiplicity p (Lcm {1..n}) + multiplicity p x"
    also consider "\<exists>k. Suc n = p ^ k" | "primepow (Suc n)" "\<not>(\<exists>k. Suc n = p ^ k)" 
                | "\<not>primepow (Suc n)" by blast
    hence "multiplicity p x = (if \<exists>k. Suc n = p ^ k then 1 else 0)"
    proof cases
      assume "\<exists>k. Suc n = p ^ k"
        by (auto simp: x_def aprimedivisor_prime_power intro!: Nat.gr0I)
    next
      assume *: "primepow (Suc n)" "\<nexists>k. Suc n = p ^ k"
      then obtain q k where qk: "prime q" "Suc n = q ^ k" "k > 0" "q \<noteq> p"
        by (auto simp: primepow_def)
        by (subst *) (auto simp: x_def aprimedivisor_prime_power prime_multiplicity_other)
