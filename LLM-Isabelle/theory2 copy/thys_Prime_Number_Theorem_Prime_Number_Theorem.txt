theory Prime_Number_Theorem
imports 
  Newman_Ingham_Tauberian
  Prime_Counting_Functions
begin

unbundle prime_counting_notation


definition fds_newman where
  "fds_newman = fds (\<lambda>n. complex_of_real (\<MM> n))"

lemma fds_nth_newman:
  "fds_nth fds_newman n = of_real (\<MM> n)"
  by (simp add: fds_newman_def fds_nth_fds)

lemma norm_fds_nth_newman:
  "norm (fds_nth fds_newman n) = \<MM> n"
  unfolding fds_nth_newman norm_of_real
  by (intro abs_of_nonneg sum_nonneg divide_nonneg_pos) (auto dest: prime_ge_1_nat)

lemma bounded_coeffs_newman_minus_deriv_zeta:
  defines "f \<equiv> fds_newman + fds_deriv fds_zeta"
  shows   "Bseq (\<lambda>n. fds_nth f n)"
proof -
  have "(\<lambda>n. \<MM> (real n) - ln (real n)) \<in> O(\<lambda>_. 1)"
    using mertens_bounded by (rule landau_o.big.compose) real_asymp
  from natfun_bigo_1E[OF this, of 1]
    obtain c where c: "c \<ge> 1" "\<And>n. \<bar>\<MM> (real n) - ln (real n)\<bar> \<le> c" by auto

  show ?thesis
  proof (intro BseqI[of c] allI)
    fix n :: nat
    show "norm (fds_nth f n) \<le> c"
    proof (cases "n = 0")
      case False
      hence "fds_nth f n = of_real (\<MM> n - ln n)"
        by (simp add: f_def fds_nth_newman fds_nth_deriv fds_nth_zeta scaleR_conv_of_real)
        using c(2)[of n] by (simp add: in_Reals_norm)
      finally show ?thesis .
    qed (insert c, auto)
  qed (insert c, auto)
qed

lemma abs_conv_abscissa_newman: "abs_conv_abscissa fds_newman \<le> 1"
  and conv_abscissa_newman:     "conv_abscissa fds_newman \<le> 1"
proof -
  define f where "f = fds_newman + fds_deriv fds_zeta"
  have "abs_conv_abscissa f \<le> 1"
    using bounded_coeffs_newman_minus_deriv_zeta unfolding f_def
    by (rule bounded_coeffs_imp_abs_conv_abscissa_le_1)
  hence "abs_conv_abscissa (f - fds_deriv fds_zeta) \<le> 1"
    by (intro abs_conv_abscissa_diff_leI) (auto simp: abs_conv_abscissa_deriv)
  also have "f - fds_deriv fds_zeta = fds_newman" by (simp add: f_def)
  finally show "abs_conv_abscissa fds_newman \<le> 1" .
  from conv_le_abs_conv_abscissa and this show "conv_abscissa fds_newman \<le> 1"
    by (rule order.trans)
qed

lemma eval_fds_newman_conv_infsetsum:
  assumes s: "Re s > 1"
  shows   "eval_fds fds_newman s = (\<Sum>\<^sub>ap | prime p. (ln (real p) / real p) * hurwitz_zeta p s)"
          "(\<lambda>p. ln (real p) / real p * hurwitz_zeta p s) abs_summable_on {p. prime p}"
proof -
  from s have conv: "fds_abs_converges fds_newman s"
    by (intro fds_abs_converges le_less_trans[OF abs_conv_abscissa_newman]) auto
  define f where "f = (\<lambda>n p. ln (real p) / real p / of_nat n powr s)"

  have eq: "(\<Sum>\<^sub>an\<in>{p..}. f n p) = ln (real p) / real p * hurwitz_zeta p s" if "prime p" for p
  proof -
    have "(\<Sum>\<^sub>an\<in>{p..}. f n p) = (\<Sum>\<^sub>ax\<in>{p..}. (ln (real p) / of_nat p) * (1 / of_nat x powr s))"
      by (simp add: f_def)
    also have "\<dots> = (ln (real p) / of_nat p) * (\<Sum>\<^sub>ax\<in>{p..}. 1 / of_nat x powr s)"
      using abs_summable_hurwitz_zeta[of s 0 p] that s
      by (intro infsetsum_cmult_right) (auto dest: prime_gt_0_nat)
    also have "(\<Sum>\<^sub>ax\<in>{p..}. 1 / of_nat x powr s) = hurwitz_zeta p s"
      using s that by (subst hurwitz_zeta_nat_conv_infsetsum(2))
                      (auto dest: prime_gt_0_nat simp: field_simps powr_minus)
    finally show ?thesis .
  qed

  have norm_f: "norm (f n p) = ln p / p / n powr Re s" if "prime p" for n p :: nat
    by (auto simp: f_def norm_divide norm_mult norm_powr_real_powr)
  from conv have "(\<lambda>n. norm (fds_nth fds_newman n / n powr s)) abs_summable_on UNIV"
    by (intro abs_summable_on_normI) (simp add: fds_abs_converges_altdef')
  also have "(\<lambda>n. norm (fds_nth fds_newman n / n powr s)) =
               (\<lambda>n. \<Sum>p | prime p \<and> p \<le> n. norm (f n p))"
    by (auto simp: norm_divide norm_fds_nth_newman sum_divide_distrib primes_M_def
                   prime_sum_upto_def norm_mult norm_f norm_powr_real_powr intro!: sum.cong)
  finally have summable1: "(\<lambda>(n,p). f n p) abs_summable_on (SIGMA n:UNIV. {p. prime p \<and> p \<le> n})"
    using conv by (subst abs_summable_on_Sigma_iff) auto
  also have "?this \<longleftrightarrow> (\<lambda>(p,n). f n p) abs_summable_on
                         (\<lambda>(n,p). (p,n)) ` (SIGMA n:UNIV. {p. prime p \<and> p \<le> n})"
    by (subst abs_summable_on_reindex_iff [symmetric]) (auto simp: case_prod_unfold inj_on_def)
  also have "(\<lambda>(n,p). (p,n)) ` (SIGMA n:UNIV. {p. prime p \<and> p \<le> n}) =
               (SIGMA p:{p. prime p}. {p..})" by auto
  finally have summable2: "(\<lambda>(p,n). f n p) abs_summable_on \<dots>" .
  from abs_summable_on_Sigma_project1'[OF this]
    have "(\<lambda>p. \<Sum>\<^sub>an\<in>{p..}. f n p) abs_summable_on {p. prime p}" by auto
  also have "?this \<longleftrightarrow> (\<lambda>p. ln (real p) / real p * hurwitz_zeta p s) abs_summable_on {p. prime p}"
    by (intro abs_summable_on_cong eq) auto
  finally show \<dots> .

  have "eval_fds fds_newman s =
          (\<Sum>\<^sub>an. \<Sum>p | prime p \<and> p \<le> n. ln (real p) / real p / of_nat n powr s)"
    using conv by (simp add: eval_fds_altdef fds_nth_newman sum_divide_distrib
                             primes_M_def prime_sum_upto_def)
  also have "\<dots> = (\<Sum>\<^sub>an. \<Sum>\<^sub>ap | prime p \<and> p \<le> n. f n p)"
    unfolding f_def by (subst infsetsum_finite) auto
  also have "\<dots> = (\<Sum>\<^sub>a(n, p) \<in> (SIGMA n:UNIV. {p. prime p \<and> p \<le> n}). f n p)"
    using summable1 by (subst infsetsum_Sigma) auto
  also have "\<dots> = (\<Sum>\<^sub>a(p, n) \<in> (\<lambda>(n,p). (p, n)) ` (SIGMA n:UNIV. {p. prime p \<and> p \<le> n}). f n p)"
    by (subst infsetsum_reindex) (auto simp: case_prod_unfold inj_on_def)
  also have "(\<lambda>(n,p). (p, n)) ` (SIGMA n:UNIV. {p. prime p \<and> p \<le> n}) =
               (SIGMA p:{p. prime p}. {p..})" by auto
  also have "(\<Sum>\<^sub>a(p,n)\<in>\<dots>. f n p) = (\<Sum>\<^sub>ap | prime p. \<Sum>\<^sub>an\<in>{p..}. f n p)"
    using summable2 by (subst infsetsum_Sigma) auto
  also have "(\<Sum>\<^sub>ap | prime p. \<Sum>\<^sub>an\<in>{p..}. f n p) =
               (\<Sum>\<^sub>ap | prime p. ln (real p) / real p * hurwitz_zeta p s)"
    by (intro infsetsum_cong eq) auto
  finally show "eval_fds fds_newman s =
                  (\<Sum>\<^sub>ap | prime p. (ln (real p) / real p) * hurwitz_zeta p s)" .
qed



context
  fixes A :: "nat \<Rightarrow> complex \<Rightarrow> complex" and B :: "nat \<Rightarrow> complex \<Rightarrow> complex"
  defines "A \<equiv> (\<lambda>p s. (s - 1) * pre_zeta (real p) s - 
                         of_nat p / (of_nat p powr s * (of_nat p powr s - 1)))"
  defines "B \<equiv> (\<lambda>p s. of_real (ln (real p)) / of_nat p * A p s)"
begin

definition pre_newman :: "complex \<Rightarrow> complex" where
  "pre_newman s = (\<Sum>p. if prime p then B p s else 0)"

definition newman where "newman s = 1 / (s - 1) * (pre_newman s - deriv zeta s / zeta s)"

lemma uniform_limit_pre_newman:
  assumes r: "r \<ge> 0" "Re s - r > 1 / 2"
  shows "uniform_limit (cball s r)
           (\<lambda>n s. \<Sum>p<n. if prime p then B p s else 0) pre_newman at_top"
proof -
  from r have Re: "Re z > 1 / 2" if "dist s z \<le> r" for z
    using abs_Re_le_cmod[of "s - z"] r that
    by (auto simp: dist_norm abs_if split: if_splits)

  from r Re have "x > 1 / 2" by (auto simp: x_def)

      and therefore summable\<close>
      from \<open>x > 1 / 2\<close> have \<epsilon>: "\<epsilon> > 0" "1 + \<epsilon> < 2 * x" "1 + \<epsilon> < x + 1"
    from \<open>p > 1\<close> and x and r have "M p \<ge> 0"
      using pre_zeta_bound'[of z p] p \<open>Re z > 1 / 2\<close>
      unfolding B_def using \<open>p > 1\<close> by (simp add: B_def norm_mult norm_divide)
      unfolding A_def using \<open>p > 1\<close> and \<open>Re z > 1 / 2\<close> and bound
      using \<open>p > 1\<close> by (simp add: field_simps powr_add powr_minus)
      unfolding C_def using r \<open>Re z > 1 / 2\<close> norm_z p x
                 1 / (p powr x * (p powr x - 1))" using \<open>p > 1\<close> x
      using \<open>p > 1\<close> by (simp add: mult_left_mono M_def)
    with \<open>M p \<ge> 0\<close> show "norm (if prime p then B p z else 0) \<le> M p" by simp
text \<open>
  Next, we shall attempt to get rid of the pole by subtracting suitable multiples of $\zeta(s)$
  and $\zeta'(s)$. To this end, we shall first prove the following alternative definition of 
  $\zeta'(s)$:
\<close>
text \<open>
  From this, it follows that $(s - 1) \zeta'(s) - \zeta'(s) / \zeta(s)$ is analytic 
  for $\mathfrak{R}(s) \geq 1$:
\<close>
      qed (use \<open>e > 0\<close> in auto)
text \<open>
  Finally, $f(s) + \zeta'(s) + c\zeta(s)$ is analytic.
\<close>
subsection \<open>The asymptotic expansion of \<open>\<MM>\<close>\<close>
text \<open>
  Our next goal is to show the key result that $\mathfrak{M}(x) = \ln n + c + o(1)$.

  As a first step, we invoke Ingham's Tauberian theorem on the function we have
  just defined and obtain that the sum
  \[\sum\limits_{n=1}^\infty \frac{\mathfrak{M}(n) - \ln n + c}{n}\]
  exists.
\<close>
text \<open>
  Next, we prove a lemma given by Newman stating that if the sum $\sum a_n / n$ exists and
  $a_n + \ln n$ is nondecreasing, then $a_n$ must tend to 0. Unfortunately, the proof is
  rather tedious, but so is the paper version by Newman.
\<close>
      using \<open>0 < M\<close> \<open>M < N\<close> ln_le_minus_one [of "N / M"]
        with \<open>0 < M\<close> have "0 < i" by auto
          using 0 using i \<open>0 < M\<close> by (simp add: frac_le_eq divide_simps mult_left_mono)
        using \<open>M < N\<close>  by (simp add: of_nat_diff field_simps)
        with \<open>0 < M\<close> have "0 < i" by auto
          using i \<open>i > 0\<close> 0 by (intro divide_left_mono_neg) auto
        using \<open>M < N\<close> by (simp add: of_nat_diff)
        using \<open>M < N\<close>  by (simp add: of_nat_diff field_simps)
      using \<open>0 < M\<close> \<open>M < N\<close> \<open>0 \<le> d\<close> by (simp add: field_simps)
    have "0 < (\<epsilon> / 8)\<^sup>2" using \<open>0 < \<epsilon>\<close>  by simp
        using less_le_trans[OF N1, of "n / N1 * \<epsilon> / 4"] \<open>N1 \<noteq> 0\<close> \<epsilon> n by (auto simp: field_simps)
    using * [of "min r (1/5)"] \<open>0 < r\<close> by force
text \<open>
  This leads us to the main intermediate result:
\<close>
subsection \<open>The asymptotics of the prime-counting functions\<close>
text \<open>
  We will now use the above result to prove the asymptotics of the prime-counting functions
  $\vartheta(x) \sim x$, $\psi(x) \sim x$, and $\pi(x) \sim x / \ln x$. The last of these is 
  typically called the Prime Number Theorem, but since these functions can be expressed in terms 
  of one another quite easily, knowing the asymptotics of any of them immediately gives the 
  asymptotics of the other ones.

  In this sense, all of the above are equivalent formulations of the Prime Number Theorem.
  The one we shall tackle first, due to its strong connection to the $\mathfrak{M}$ function, is
  $\vartheta(x) \sim x$.

  We know that $\mathfrak{M}(x)$ has the asymptotic expansion
  $\mathfrak{M}(x) = \ln x + c + o(1)$. We also know that
  \[\vartheta(x) = x\mathfrak{M}(x) - \int\nolimits_2^x \mathfrak{M}(t) \,\mathrm{d}t\ .\]
  Substituting in the above asymptotic equation, we obtain:
  \begin{align*}
  \vartheta(x) &= x\ln x + cx + o(x) - \int\nolimits_2^x \ln t + c + o(1) \,\mathrm{d}t\\
            &= x\ln x + cx + o(x) - (x\ln x - x + cx + o(x))\\
            &= x + o(x)
  \end{align*}
  In conclusion, $\vartheta(x) \sim x$.
\<close>
text \<open>
  The various other forms of the Prime Number Theorem follow as simple corollaries.
\<close>
text \<open>
  The following versions use a little less notation.
\<close>
