theory  OpSemGeneric
  imports AfterTrace
begin

hide_const R



locale OpSemGeneric = 
      and \<tau>_trans_mono_AfterExt:
begin





      we get the following free of charge.\<close>
lemma \<tau>_trans_eq: \<open>P \<leadsto>\<^sub>\<tau> P\<close>
  and \<tau>_trans_NdetR: \<open>P \<sqinter> Q \<leadsto>\<^sub>\<tau> Q\<close>
  and BOT_\<tau>_trans_anything: \<open>\<bottom> \<leadsto>\<^sub>\<tau> P\<close>
  and BOT_event_trans_anything: \<open>\<bottom> \<leadsto>e P\<close>
text \<open>As immediate consequences of the axioms, we prove that event transitions 

  by (meson \<tau>_trans_transitivity)

  using \<tau>_trans_mono_AfterExt \<tau>_trans_transitivity \<tau>_trans_anti_mono_ready_set by blast




  |  trace_Cons_ev_trans :

  apply (induct rule: trace_trans.induct)
  subgoal using \<tau>_trans_transitivity trace_\<tau>_trans by blast
  subgoal using event_trans_\<tau>_trans trace_tick_trans by blast
  using trace_Cons_ev_trans by blast
  
  apply (rotate_tac, induct rule: trace_trans.induct)
  subgoal using \<tau>_trans_transitivity trace_\<tau>_trans by blast
  subgoal using \<tau>_trans_event_trans trace_tick_trans by blast
  using \<tau>_trans_event_trans trace_Cons_ev_trans by blast


proof (induct s arbitrary: P)
    by (simp add: BOT_\<tau>_trans_anything trace_\<tau>_trans)
next
  fix e s P
    by (metis prem butlast.simps(2) front_tickFree_butlast front_tickFree_def tickFree_Cons)
  proof (cases e)
    fix e'
         (rule trace_Cons_ev_trans[OF _ hyp];
          simp add: * AfterExt_BOT BOT_\<tau>_trans_anything ready_set_BOT)
  next
      by (metis prem butlast.simps(2) front_tickFree_butlast tickFree_Cons)
      by (simp add: AfterExt_BOT BOT_\<tau>_trans_anything ready_set_BOT trace_tick_trans)
  qed
qed



lemma trace_trans_imp_F_if_\<tau>_trans_imp_leF:
proof (induct rule: trace_trans.induct)
    by (meson failure_refine_def in_mono Refusals_iff that)
next
    by (metis append_Nil mem_Collect_eq ready_set_def tick_T_F)
next
  fix P e Q s Q'
qed


proof (induct rule: trace_trans.induct)
    by (simp add: Nil_elem_T)
next
    by (simp add: ready_set_def)
next
  fix P e Q s Q'
    by (force simp add: T_AfterExt ready_set_def)
qed


proof (induct s arbitrary: P)
    by (subst (asm) trace_trans.simps, auto) 
       (meson BOT_iff_D divergence_refine_def subsetD that)
next
  fix e s P
    using prem by (cases rule: trace_trans.cases)
                  (auto simp add:  trace_\<tau>_trans intro: \<tau>_trans_trace_trans)
    by (fastforce intro: prem trace_trans.cases simp add: D_AfterExt D_UU split: if_split_asm )
qed




lemma trace_trans_iff :
proof -
    by ((subst trace_trans.simps, auto)[1])+
   
  proof safe
    proof (induct s arbitrary: P)
      case Nil
      thus ?case 
        apply (subst (asm) trace_trans.simps, simp)
        using \<tau>_trans_eq \<tau>_trans_transitivity f1 by blast
    next
      case (Cons e s)
        by (subst (asm) trace_trans.simps)
           (auto simp add:  intro: \<tau>_trans_trace_trans)
      proof (cases e)
        fix e'
          apply simp
          by (rule trace_Cons_ev_trans[OF _ **(1)]) (use * \<tau>_trans_eq in blast)
      next
      qed
    qed
  next
    proof (induct s arbitrary: P Q)
        by (simp add: f1)
           (metis (full_types) \<tau>_trans_eq \<tau>_trans_event_trans event.exhaust 
                               trace_Cons_ev_trans trace_\<tau>_trans trace_tick_trans)
    next
      case (Cons e s)
        by (subst (asm) trace_trans.simps)
           (auto simp add: f1 intro: \<tau>_trans_trace_trans)
      show ?case
      proof (cases e)
        fix e'
          apply simp
          by (rule trace_Cons_ev_trans
                   [OF _ Cons.hyps[OF tickFree_tl[OF Cons.prems(1), simplified] 
                                      *[THEN conjunct2] Cons.prems(3)]])
      next
      qed
    qed
  qed

  proof (induct t arbitrary: Q' rule: rev_induct)
      by (metis \<tau>_trans_eq append.right_neutral trace_trans_\<tau>_trans f1)
  next
    case (snoc e t)
    proof (intro iffI)
        by (metis append.assoc f4 front_tickFree_implies_tickFree snoc.prems)
        by (metis calculation(1) append.assoc front_tickFree_dw_closed snoc.hyps snoc.prems)
        by (metis append_is_Nil_conv f4 front_tickFree_mono list.distinct(1) snoc.prems)
    next
        by (metis append_is_Nil_conv calculation(2) f4
                  front_tickFree_mono list.distinct(1) snoc.prems)
        by (metis append_assoc f4 front_tickFree_implies_tickFree snoc.hyps
                  snoc.prems tickFree_implies_front_tickFree)
    qed
  qed
qed




theorem T_imp_trace_trans_iff_AfterTrace_\<tau>_trans : 
proof (intro iffI)
  proof (induct s arbitrary: P Q rule: rev_induct)
      using trace_trans.cases by auto
  next
    fix s e P Q
      using prems(2) ready_set_AfterTrace by blast
      by (metis AfterTrace_snoc \<tau>_trans_event_trans append_single_T_imp_tickFree 
                hyp is_processT3_ST prems trace_trans_iff(4))
  qed
next
  proof (induct arbitrary: P Q rule: AfterTrace.induct)
      by (simp add: trace_\<tau>_trans)
  next
      by (metis AfterTrace.simps(1, 2) Cons_in_T_imp_elem_ready_set 
                T_AfterTrace append_Cons append_Nil prems(2))
    proof (cases e)
      fix e'
        by (simp add: \<tau>_trans_eq)
        by (subst **, rule trace_Cons_ev_trans[OF _ hyp[OF prems(1)[simplified] 
                                                        *[THEN conjunct2], simplified **]])
    next
                                           is_processT2_TR tickFree_Cons prems(2))
        using * prems(1) trace_tick_trans by force
    qed
  qed
qed



  by (meson F_T F_imp_R_AfterTrace T_imp_trace_trans_iff_AfterTrace_\<tau>_trans \<tau>_trans_eq)

  using F_imp_exists_trace_trans T_F by blast

  by (subst T_imp_trace_trans_iff_AfterTrace_\<tau>_trans, simp add: D_T)
     (metis BOT_iff_D D_AfterTrace \<tau>_trans_eq self_append_conv)
 




lemma \<tau>_trans_imp_leT_imp_STOP_trace_trans_iff: 
  using STOP_T_iff by (subst trace_trans.simps)
                      (auto simp add: ready_set_STOP \<tau>_trans_eq) 


lemma \<tau>_trans_imp_leF_imp_SKIP_trace_trans_iff: 
  using SKIP_F_iff STOP_F_iff by (subst trace_trans.simps)
                                 (auto simp add: AfterExt_SKIP ready_set_SKIP \<tau>_trans_eq)
  
  
lemma \<tau>_trans_imp_leT_imp_trace_trans_ready_set_subset_ready_set_AfterTrace:
  using T_imp_trace_trans_iff_AfterTrace_\<tau>_trans 
        anti_mono_ready_set_T trace_trans_imp_T_if_\<tau>_trans_imp_leT by blast


lemma \<tau>_trans_imp_leT_imp_trace_trans_imp_ready_set:
  using ready_set_AfterTrace trace_trans_imp_T_if_\<tau>_trans_imp_leT by blast


lemma trace_trans_iff_T_and_AfterTrace_\<tau>_trans_if_\<tau>_trans_imp_leT: 
  using T_imp_trace_trans_iff_AfterTrace_\<tau>_trans trace_trans_imp_T_if_\<tau>_trans_imp_leT by blast
  




  by (simp add: AfterExt_SKIP \<tau>_trans_eq ready_set_SKIP)

  by (metis \<tau>_trans_anti_mono_ready_set ready_set_AfterExt ready_set_empty_iff_STOP subset_empty)

  by (metis AfterExt_SKIP SKIP_neq_BOT SKIP_trans_tick empty_iff trace_trans.cases
            ready_set_STOP tick_trans_imp_BOT_L_or_STOP_R trace_trans_iff(1))



proof -
    unfolding failure_divergence_refine_def le_ref_def
    by (auto simp add: F_SKIP D_SKIP subset_iff ready_set_def is_processT6_S2)
       (metis append_Nil tick_T_F)
    by (metis mono_Ndet_FD mono_Ndet_FD_left FD_antisym Ndet_id idem_FD)
qed
 

  using \<tau>_trans_eq by blast



  by (metis AfterExt_BOT BOT_\<tau>_trans_anything SKIP_trans_tick \<tau>_trans_event_trans 
            ready_tick_imp_\<tau>_trans_SKIP tick_trans_imp_BOT_L_or_STOP_R)
 

  by (simp add: ready_set_SKIP)

  by (simp add: ready_set_STOP)




  by (simp add: AfterExt_def After_Mprefix \<tau>_trans_eq ready_set_Mprefix)

  by (simp add: AfterExt_def After_Mndetprefix \<tau>_trans_eq ready_set_Mndetprefix)

  by (metis ev_trans_Mprefix insertI1 write0_def)



  by (metis MultiNdet_insert' \<tau>_trans_NdetL emptyE insert_absorb)

proof -
    by (metis GlobalNdet_factorization_union GlobalNdet_unit
              empty_iff insertI1 insert_absorb insert_is_Un that)
qed
  


  by (metis \<tau>_trans_eq cont_process_rec)


  by (metis AfterExt_Det_is_AfterExt_Ndet Un_iff \<tau>_trans_NdetL \<tau>_trans_event_trans ready_set_Det)
 
  by (metis Det_commute event_trans_DetL)

lemma event_trans_MultiDet:
  by (metis MultiDet_insert' event_trans_DetL insert_absorb)


 
  unfolding Sliding_def
  apply (drule event_trans_DetL[of e P P' Q])
  using \<tau>_trans_NdetL \<tau>_trans_event_trans by blast


  unfolding Sliding_def by (simp add: \<tau>_trans_NdetR)



proof (intro exI)
    by (simp add: SKIP_Seq SKIP_trans_tick STOP_cant_event_trans)
qed



lemma ev_trans_SeqR:
  apply (simp add: AfterExt_Seq ready_set_Seq AfterExt_BOT BOT_Seq)
  using \<tau>_trans_NdetR \<tau>_trans_transitivity by blast
  
 


  by (simp add: SKIP_trans_tick Sync_SKIP_SKIP)

  by (simp add: Sync_SKIP_SKIP \<tau>_trans_eq)


proof -
    by (simp add: AfterExt_def Ndet_is_BOT_iff)
    by (simp add: AfterExt_def BOT_\<tau>_trans_anything \<tau>_trans_eq
                  ready_tick_imp_ready_tick_Hiding that)
qed




proof -
    by (metis AfterExt_Sliding_is_AfterExt_Ndet STOP_Sliding)
    by (simp add: that tick_eq_EvExt AfterExt_def \<tau>_trans_eq
                  ready_set_Renaming BOT_\<tau>_trans_anything)
qed



end

end

