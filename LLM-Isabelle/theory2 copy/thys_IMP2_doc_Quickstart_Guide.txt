theory Quickstart_Guide
imports "../IMP2"
begin


  procedure_spec div_ab (a,b) returns c 
    by vcg_cs
  
    
    
  
    
  
    that map program variables to logical variables,
    which serves as a tag for the VCG, and is defined as the identity (@{thm BB_PROTECT_def}).
    
    The final theorem is declared to the VCG, such that the specification will be 
    used automatically for calls to this procedure.
  \<close>
  procedure_spec use_div_ab(a) returns r assumes \<open>a\<noteq>0\<close> ensures \<open>r=1\<close> defines \<open>r = div_ab(a,a)\<close> by vcg_cs
  subsubsection \<open>Variant and Invariant Annotations\<close>
  text \<open>Loops must be annotated with variants and invariants.\<close>
  procedure_spec mult_ab(a,b) returns c assumes \<open>True\<close> ensures "c=a\<^sub>0*b\<^sub>0"
  defines \<open>
    if (a<0) {a = -a; b = -b};
    c=0;
    while (a>0) 
    {
      c=c+b;
      a=a-1
    }
  \<close>
  text \<open>The variant and invariant can use the program variables.
  
    
      must be added. Otherwise, you'll get an ugly error message directly from Isabelle's type checker!
  \<close>  
  subsubsection \<open>Recursive Procedures\<close>
  text \<open>IMP2 supports mutually recursive procedures. All procedures of a mutually recursive specification
    have to be specified and proved simultaneously. 
    
    Each procedure has to be annotated with a variant over the parameters. 
    On a recursive call, the variant of the callee for the arguments must be smaller than the 
    variant of the caller (for its initial arguments).
    
  \<close>
    odd_imp(n) returns b assumes "n\<ge>0" ensures \<open>b\<noteq>0 \<longleftrightarrow> odd n\<^sub>0\<close> variant \<open>n\<close> 
    defines \<open>if (n==0) b=0 else b=rec even_imp(n-1)\<close>
    even_imp(n) returns b assumes "n\<ge>0" ensures \<open>b\<noteq>0 \<longleftrightarrow> even n\<^sub>0\<close> variant \<open>n\<close> 
    defines \<open>if (n==0) b=1 else b=rec odd_imp(n-1)\<close>
  text \<open>After proving the VCs, constants are defined as usual, and the correctness theorems 
    are lifted and declared to the VCG for future use.\<close>  
  subsection \<open>The VCG\<close>
  text \<open>The VCG is designed to produce human-readable VCs. 
    It takes care of presenting the VCs with reasonable variable names, 
    and a location information from where a VC originates.
  \<close>
  procedure_spec mult_ab'(a,b) returns c assumes \<open>True\<close> ensures "c=a\<^sub>0*b\<^sub>0"
  defines \<open>
    if (a<0) {a = -a; b = -b};
    c=0;
    while (a>0) 
    {
      c=c+b;
      a=a-1
    }
  \<close>
  text \<open>The \<^term>\<open>\<paragraph>xxx\<close> tags in the premises give a hint to the origin of each VC. 
  \<open>relation\<close> annotation. The variant must be a function into the domain of this relation.
  \<^bold>\<open>Pitfall\<close>: You have to ensure, by type annotations, that the most general type of 
      @relation \<open>measure nat\<close>
      @variant \<open>a\<close>
      @invariant \<open>0\<le>a \<and> a\<le>\<bar>a\<^sub>0\<bar> \<and> c = ( \<bar>a\<^sub>0\<bar> - a) * b\<^sub>0 * sgn a\<^sub>0\<close>
    Recursive procedures must always be proved totally correct\<^footnote>\<open>Adding partial correctness for recursion 
      is possible, however, compared to total correctness, showing that the prove rule is sound 
      requires some effort that we have not (yet) invested.\<close>\<close>
  procedure_spec (partial) nonterminating() returns a assumes True ensures \<open>a=0\<close> defines 
    \<open>while (a\<noteq>0) @invariant \<open>True\<close>
    In the specifications, arrays are modeled as functions of type \<^typ>\<open>int\<Rightarrow>int\<close>.
        @variant \<open>h-l\<close>
        @invariant \<open>l\<^sub>0\<le>l \<and> l\<le>h \<and> s = (\<Sum>i=l\<^sub>0..<l. a i)\<close>
    \<^bold>\<open>Pitfall\<close> When extracting auxiliary lemmas, it is too easy to get too general types, which
    over which the algorithm is then specified. For example, an array \<open>a\<close> with a range \<open>l..<h\<close> can 
  forget the \<open>\<^sub>0\<close> suffix when referring to parameter values in (in)variants and postconditions.\<close>
  text \<open>Note the highlighting of unused variables in the following example\<close>
  procedure_spec foo(x1,x2) returns y assumes "x1>x2+x3" ensures "y = x1\<^sub>0+x2" defines \<open>
      y=0;
    while (x1>0)
      {
        x1=x2
      }
  \<close>
  text \<open>Even worse, if the most general type of an annotation becomes too general,
    
    Try replacing the variant or invariant with a free variable in the above example.
  subsubsection \<open>Wrong Annotations\<close>
  text \<open>For total correctness, you must annotate a loop variant and invariant. 
    
    When not following this rule, the VCG will get stuck in an internal state
  \<close>
  procedure_spec (partial) foo () assumes True ensures True defines \<open>
    { n=n-1 }
  \<close>
  subsubsection \<open>Calls to Undefined Procedures\<close>  
  text \<open>Calling an undefined procedure usually results in a type error, as the procedure 
    name gets interpreted as an Isabelle term, e.g., either it refers to an existing constant, 
    or is interpreted as a free variable\<close>
  subsection \<open>Missing Features\<close>
  text \<open>This is an (incomplete) list of missing features.\<close>
  subsubsection \<open>Elaborate Warnings and Errors\<close>
  text \<open>Currently, the IMP2 tools only produce minimal error and warning messages.
    Quite often, the user sees the raw error message as produced by Isabelle unfiltered, 
    including all internal details of the tools. 
  \<close>
  subsubsection \<open>Static Type Checking\<close>
  text \<open>We do no static type checking at all. 
    In particular, we do not check, nor does our semantic enforce, that procedures are called 
    with the same number of arguments as they were declared. 
    Programs that violate this convention may even have provable properties, as argument 
    and parameter passing is modeled as macros on top of the semantics, and the semantics has no
    notion of failure.
  \<close>
  subsubsection \<open>Structure Types\<close>
  text \<open>Every variable is an integer arrays. Plain integer variables are implemented as 
    
    The most urgent addition to increase usability would be record types. 
    With them, we could model encapsulation and data refinement more explicitly, by
    collecting all parts of a data structure in a single (record-typed) variable.

    An easy way of adding record types would follow a similar route as arrays, 
    modeling values of variables as a recursive tree-structured datatype.
    

    However, for modeling the semantics, we most likely want to introduce an explicit error state,
    to distinguish type errors (e.g. accessing a record field of an integer value) from nontermination.
    \<close>
  subsubsection \<open>Function Calls as Expressions\<close>  
  text \<open>Currently, function calls are modeled as statements, and thus, cannot be nested into 
    expressions. Doing so would require to simultaneously specify the semantics of 
    commands and expressions, which makes things more complex. 
    
    As the language is intended to be simple, we have not done this.
  \<close>
  subsubsection \<open>Ghost Variables\<close>  
  text \<open>Ghost variables are a valuable tool for expressing (data) refinement, 
    and hinting the VCG towards the abstract algorithm structure.
    
    We believe that we can add ghost variables with annotations on top of the VCG,
    without actually changing the program semantics.
  \<close>
  subsubsection \<open>Concurrency\<close>
  text \<open>IMP2 is a single threaded language. 
    We have no current plans to add concurrency, as this would greatly complicate both the 
    semantics and the VCG, which is contrary to the goal of a simple language for educational 
    purposes.
  \<close>
  subsubsection \<open>Pointers and Memory\<close>
  text \<open>Adding pointers and memory allocation to IMP2 is theoretically possible, but, again, 
    this would complicate the semantics and the VCG.

    However, as the author has some experience in VCGs using separation logic, he might actually
    add pointers and memory allocation to IMP2 in the near future.
  \<close>
