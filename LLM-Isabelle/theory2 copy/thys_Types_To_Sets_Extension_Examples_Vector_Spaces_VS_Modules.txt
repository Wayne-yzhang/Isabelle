theory VS_Modules
  imports 
    VS_Groups
    Complex_Main
begin




locale module_with = ab_group_add plus\<^sub>M zero\<^sub>M minus\<^sub>M uminus\<^sub>M
  fixes scale :: "['cr1::comm_ring_1, 'm] \<Rightarrow> 'm" (infixr "*s\<^sub>w\<^sub>i\<^sub>t\<^sub>h" 75)
  assumes scale_right_distrib[algebra_simps]: 
    "a *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h (x +\<^sub>M y) = a *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h x +\<^sub>M a *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h y"
    and scale_left_distrib[algebra_simps]:
      "(a + b) *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h x = a *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h x +\<^sub>M b *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h x"
    and scale_scale[simp]: "a *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h (b *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h x) = (a * b) *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h x"
    and scale_one[simp]: "1 *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h x = x"

lemma module_with_overloaded[ud_with]: "module = module_with (+) 0 (-) uminus"
  unfolding module_def module_with_def module_with_axioms_def
  by (simp add: comm_ring_1_axioms ab_group_add_axioms)

locale module_pair_with =
  M\<^sub>1: module_with plus\<^sub>M\<^sub>_\<^sub>1 zero\<^sub>M\<^sub>_\<^sub>1 minus\<^sub>M\<^sub>_\<^sub>1 uminus\<^sub>M\<^sub>_\<^sub>1 scale\<^sub>1 +
  M\<^sub>2: module_with plus\<^sub>M\<^sub>_\<^sub>2 zero\<^sub>M\<^sub>_\<^sub>2 minus\<^sub>M\<^sub>_\<^sub>2 uminus\<^sub>M\<^sub>_\<^sub>2 scale\<^sub>2

lemma module_pair_with_overloaded[ud_with]: 
  "module_pair =
    (
      \<lambda>scale\<^sub>1 scale\<^sub>2.
        module_pair_with (+) 0 (-) uminus scale\<^sub>1 (+) 0 (-) uminus scale\<^sub>2
    )"
  unfolding module_pair_def module_pair_with_def 
  unfolding module_with_overloaded
  ..

locale module_hom_with = 
  M\<^sub>1: module_with plus\<^sub>M\<^sub>_\<^sub>1 zero\<^sub>M\<^sub>_\<^sub>1 minus\<^sub>M\<^sub>_\<^sub>1 uminus\<^sub>M\<^sub>_\<^sub>1 scale\<^sub>1 +
  M\<^sub>2: module_with plus\<^sub>M\<^sub>_\<^sub>2 zero\<^sub>M\<^sub>_\<^sub>2 minus\<^sub>M\<^sub>_\<^sub>2 uminus\<^sub>M\<^sub>_\<^sub>2 scale\<^sub>2
  fixes f :: "'m_1 \<Rightarrow> 'm_2"
  assumes add: "f (b1 +\<^sub>M\<^sub>_\<^sub>1 b2) = f b1 +\<^sub>M\<^sub>_\<^sub>2 f b2"
    and scale: "f (r *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h\<^sub>_\<^sub>1 b) = r *s\<^sub>w\<^sub>i\<^sub>t\<^sub>h\<^sub>_\<^sub>2 f b"
begin

sublocale module_pair_with ..

end

lemma module_hom_with_overloaded[ud_with]: 
  "module_hom =
    (
      \<lambda>scale\<^sub>1 scale\<^sub>2.
        module_hom_with (+) 0 (-) uminus scale\<^sub>1 (+) 0 (-) uminus scale\<^sub>2
    )"
  unfolding 
    module_hom_def module_hom_axioms_def 
    module_hom_with_def module_hom_with_axioms_def
  unfolding module_with_overloaded
  ..
  (
    [1000, 999, 998, 997, 1000, 999] 10
  )

abbreviation independent_with 
  where 
    "(with zero\<^sub>C\<^sub>R\<^sub>1 zero\<^sub>M  scale\<^sub>M plus\<^sub>M : \<guillemotleft>independent\<guillemotright> s) \<equiv>
      \<not>(with zero\<^sub>C\<^sub>R\<^sub>1 zero\<^sub>M scale\<^sub>M plus\<^sub>M : \<guillemotleft>dependent\<guillemotright> s)"

lemma span_with_transfer[transfer_rule]:
  includes lifting_syntax
  assumes [transfer_rule]: "right_total A" "bi_unique A"
  shows 
    "(
      A ===> 
      (A ===> A ===> A) ===>
      ((=) ===> A ===> A) ===> 
      rel_set A ===> 
      rel_set A
    ) span.with span.with"
  unfolding span.with_def
proof(intro rel_funI)
  fix p p' z z' X X' and s s'::"'c \<Rightarrow> _"
  assume transfer_rules[transfer_rule]:   
    "(A ===> A ===> A) p p'" 
    "A z z'" 
    "((=) ===> A ===> A) s s'" 
    "rel_set A X X'"
  have *: "t \<subseteq> X \<Longrightarrow> (\<forall>x\<in>t. Domainp A x)" for t
  note swt = sum_with_transfer
    [
      OF assms(1,2,2), 
      THEN rel_funD, 
      THEN rel_funD, 
      THEN rel_funD,  
      THEN rel_funD,  
      OF transfer_rules(1,2)
    ]
  have DsI: "Domainp A (sum_with p z r t)" 
    if "\<And>x. x \<in> t \<Longrightarrow> Domainp A (r x)" "t \<subseteq> Collect (Domainp A)" for r t
    by (metis that Domainp_sum_with transfer_rules(1,2))
  from Domainp_apply2I[OF transfer_rules(3)]
  have Domainp_sI: "Domainp A x \<Longrightarrow> Domainp A (s y x)" for x y by auto
  show "rel_set A
    {sum_with p z (\<lambda>a. s (r a) a) t |t r. finite t \<and> t \<subseteq> X}
        {sum_with p' z' (\<lambda>a. s' (r a) a) t |t r. finite t \<and> t \<subseteq> X'}"
    apply transfer_prover_start 
    apply transfer_step+
    by (insert *) (auto intro!: DsI Domainp_sI)
  "dependent.with 0 0 (+) (*s) = dependent"
  unfolding dependent_on_def dependent.with_def sum_with ..

