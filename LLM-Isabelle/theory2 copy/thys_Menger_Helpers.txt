theory Helpers imports Main begin


lemma card_finite_less_ex:
  assumes finite_A: "finite A"
      and finite_B: "finite B"
      and card_AB: "card A < card B"
  shows "\<exists>b \<in> B. b \<notin> A"
proof-
  have "card (B - A) > 0" using finite_A finite_B card_AB
    by (meson Diff_eq_empty_iff card_eq_0_iff card_mono finite_Diff gr0I leD)
  then show ?thesis using finite_B
    by (metis Diff_eq_empty_iff card_0_eq finite_Diff neq_iff subsetI)
qed

lemma card_intersect_sum_disjoint:
  assumes "finite B" "finite C" "A = B \<union> C" "B \<inter> C = {}"
    shows "card (A \<inter> X) = card (B \<inter> X) + card (C \<inter> X)"
  by (metis (no_types, lifting) Un_Diff_Int assms card_Un_disjoint finite_Int inf.commute
      inf_sup_distrib2 sup_eq_bot_iff)

lemma set_butlast: "\<lbrakk> x \<in> set xs; x \<noteq> last xs \<rbrakk> \<Longrightarrow> x \<in> set (butlast xs)"
  by (metis butlast.simps(2) in_set_butlast_appendI last.simps last_appendR
      list.set_intros(1) split_list_first)

lemma arg_min_ex:
  fixes P :: "'a \<Rightarrow> bool" and weight :: "'a \<Rightarrow> nat"
  assumes "\<exists>x. P x"
  obtains x where "P x" "\<And>y. P y \<Longrightarrow> weight x \<le> weight y"
proof (cases "\<exists>x. P x \<and> weight x = 0")
  case True then show ?thesis using that by auto
next
  case False then show ?thesis
    using that ex_least_nat_le[of "\<lambda>n. \<exists>x. P x \<and> weight x = n"] assms by (metis not_le_imp_less)
qed

end
