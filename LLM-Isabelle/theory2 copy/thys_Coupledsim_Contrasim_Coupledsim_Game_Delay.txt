theory Coupledsim_Game_Delay
imports
  Coupled_Simulation
  Simple_Game
begin


datatype ('s, 'a) cs_game_node =
  AttackerNode 's 's |
  DefenderStepNode 'a 's 's |
  DefenderCouplingNode 's 's

fun (in lts_tau) cs_game_moves ::
  simulation_visible_challenge:
  simulation_internal_attacker_move:
  simulation_answer:
  coupling_challenge:
  coupling_answer:
  cs_game_moves_no_step:


locale cs_game =
  lts_tau trans \<tau> +
  simple_game cs_game_moves cs_game_defender_node
for
begin



lemma defender_preceded_by_attacker:
  assumes
  shows
proof -
    by (metis list.sel(1) list.sel(3) plays.cases)
    by (metis cs_game_defender_node.elims(2,3) local.cs_game_moves_no_step(1,2,3,6))
qed

lemma defender_only_challenged_by_visible_actions:
  assumes
  shows
  using assms defender_preceded_by_attacker
  by fastforce

lemma strategy_from_coupleddsim_retains_coupledsim:
  assumes
  shows
  using assms(4)
proof (induct arbitrary: p q rule: plays_for_0strategy.induct[OF assms(4)])
  case 1
  fix p q
next
  case 1
  fix p q
  hence False by auto
next
  case (2 n0 play)
  fix p q
  assume subassms:
  then obtain pi qi where 
    using defender_preceded_by_attacker n0play_is_play `cs_game_defender_node n0` assms(3) by blast
    using piqi_def(2) 2(4,5) subassms(1)
    using cs_game_defender_node.elims(2) cs_game_moves.simps(1,3)
      cs_game_moves.simps(4) list.sel(1)
    by metis
  proof safe
    fix a
      unfolding n0_def(1) by auto
      using n0_def(2,3) `R pi qi` `coupled_delay_simulation R`
      unfolding coupled_delay_simulation_def delay_simulation_def by blast
  next
      unfolding n0_def(1) by auto
    with subassms(1) have qp_def:
      using n0_def `R pi qi` `coupled_delay_simulation R`
      unfolding coupled_delay_simulation_def by blast
  qed
next
  case (2 n0 play)
  fix p q
  hence False using 2(4) by auto
next
  case (3 n1 play n1')
  fix p q
   using 3 list.sel(1) 
   by (metis cs_game_defender_node.elims(3) simulation_internal_attacker_move)
    unfolding coupled_delay_simulation_def delay_simulation_def by auto
next
  case (3 n1 play n1')
  fix p q
qed

lemma strategy_from_coupleddsim_sound:
  assumes
  shows
  unfolding sound_0strategy_def
proof clarify
  fix n0 play
  assume subassms:
  then obtain pi qi where
    using defender_preceded_by_attacker `cs_game_defender_node n0` assms(3)
      strategy0_plays_subset by blast
    using strategy_from_coupleddsim_retains_coupledsim[OF assms] list.sel subassms by auto
    by (metis cs_game_defender_node.elims(2)
        coupling_challenge simulation_visible_challenge piqi_def(2) subassms(2))
  proof safe
    fix a p
    assume dsn:
    hence qi_spec:
      by simp
    then obtain qii where qii_spec:
      using dsn `R pi qi` `coupled_delay_simulation R` steps.refl 
      unfolding coupled_delay_simulation_def delay_simulation_def by blast
      using qi_spec qii_spec unfolding dsn(2) by auto
    assume dcn:
    hence qi_spec:
      by simp
    then obtain qii where qii_spec:
      using dcn `R pi qi` `coupled_delay_simulation R`
      unfolding coupled_delay_simulation_def by blast
      using qi_spec qii_spec unfolding dcn by auto
  qed
qed

lemma coupleddsim_implies_winning_strategy:
  assumes
  shows
  unfolding player0_winning_strategy_def
proof (clarify)
  fix play
  assume subassms:
  proof (induct rule: simple_game.plays_for_0strategy.induct[OF subassms(1)])
    case 1
    then show ?case unfolding player1_wins_immediately_def using assms(3) by auto
  next
    case (2 n0 play)
      using cs_game_moves_no_step cs_game_defender_node.elims(2) by metis
      unfolding player1_wins_immediately_def by auto
    thus ?case using 2(6) by auto
  next
    case (3 n1 play n1')
      using cs_game_defender_node.elims(3) by blast
      by auto
      using n1_def `cs_game_moves n1 n1'` coupling_challenge cs_game_moves_no_step(5)
        simulation_visible_challenge "3.prems"(2) cs_game_defender_node.elims(1) list.sel(1)
      unfolding player1_wins_immediately_def
      by metis
    then show ?case
    proof 
      then obtain p1 a where 
        by blast
        using `R p q` `coupled_delay_simulation R`
        unfolding coupled_delay_simulation_def delay_simulation_def by blast
        by auto
      with `player1_wins_immediately (n1' # n1 # play)` show False
        unfolding player1_wins_immediately_def n1'_def
        by (metis list.sel(1))
    next
        using `coupled_delay_simulation R` `R p q`
        unfolding coupled_delay_simulation_def by blast
        by auto
      with `player1_wins_immediately (n1' # n1 # play)` show False
        unfolding player1_wins_immediately_def n1'_def
        by (metis list.sel(1))
    qed
  qed
qed


lemma winning_strategy_implies_coupleddsim:
  assumes
  defines
  shows
  unfolding coupled_delay_simulation_def delay_simulation_def
proof safe
  fix p q p' a
  assume challenge:
    using challenge(1) assms by blast
  then obtain play where
    by (metis list.sel(1) simple_game.plays.cases strategy0_plays_subset)
  hence interplay:
    using game_move by (simp add: simple_game.plays_for_0strategy.p1move)
    unfolding R_def list.sel by force
next
  fix p q p' a
  assume challenge:
    using challenge(1) assms by blast
  then obtain play where
    by (metis list.sel(1) simple_game.plays.cases strategy0_plays_subset)
  hence interplay:
    using game_move by (simp add: simple_game.plays_for_0strategy.p1move)
    using assms(1) unfolding player0_winning_strategy_def by blast
  then obtain n1 where n1_def:
    using interplay assms(2) unfolding player0_winning_strategy_def sound_0strategy_def by simp
  obtain q' where q'_spec:
    using n1_def(2) by (cases n1, auto)
    using interplay n1_def by (simp add: simple_game.plays_for_0strategy.p0move)
next
  fix p q 
  assume challenge:
    using challenge assms by blast
  then obtain play where
    by (metis list.sel(1) simple_game.plays.cases strategy0_plays_subset)
    using game_move by (simp add: simple_game.plays_for_0strategy.p1move)
    using assms(1) unfolding player0_winning_strategy_def by blast
  then obtain n1 where n1_def:
    using interplay assms(2)
    unfolding player0_winning_strategy_def sound_0strategy_def by simp
  obtain q' where q'_spec:
    using n1_def(2) by (cases n1, auto)
    using interplay n1_def by (simp add: simple_game.plays_for_0strategy.p0move)
qed

theorem winning_strategy_iff_coupledsim:
  assumes
  shows 
proof (rule)
  assume
  then obtain f where
    using winning_strategy_implies_coupleddsim by blast
    using assms plays_for_0strategy.init by force
    unfolding coupled_sim_by_eq_coupled_delay_simulation
    by (metis (mono_tags, lifting))
next
  assume
    unfolding coupled_sim_by_eq_coupled_delay_simulation
    using coupleddsim_implies_winning_strategy[OF _ _ assms]
          strategy_from_coupleddsim_sound[OF _ _ assms] by blast
qed

end
end
