    Based on the Jinja theory Compiler/TypeComp.thy by Tobias Nipkow
*)
(*<*)
(*>*)
(*<*)using max_stack1'[OF WT\<^sub>1_nsub_RI] by simp(*>*)
(*<*)by(unfold ty_def) (blast intro: the_equality WT\<^sub>1_unique)(*>*)
(*<*)by (simp add: ty\<^sub>i'_def)(*>*)
(*<*)by(auto simp add:ty\<^sub>l_def hyperset_defs)(*>*)
(*<*)by(auto simp add:ty\<^sub>i'_def hyperset_defs)(*>*)
(*<*)by(auto simp:ty\<^sub>l_def list_all2_conv_all_nth)(*>*)
(*<*)by(auto simp:ty\<^sub>i'_def ty\<^sub>l_def list_all2_conv_all_nth)(*>*)
(*<*)by(auto simp:ty\<^sub>l_def list_all2_conv_all_nth)(*>*)
(*<*)by(auto simp:ty\<^sub>i'_def ty\<^sub>l_def list_all2_conv_all_nth)(*>*)
(*<*)by(auto simp:ty\<^sub>i'_def ty\<^sub>l_def list_all2_conv_all_nth)(*>*)
(*<*)by(auto simp: hyperset_defs ty\<^sub>l_def list_all2_conv_all_nth)(*>*)
(*<*)by(auto simp add:ty\<^sub>l_def intro!:nlistsI dest!: nth_mem)(*>*)
(*<*)by(simp add: compE\<^sub>2_not_Nil' WT\<^sub>1_nsub_RI)(*>*)
(*<*)
(*>*)
(*<*)using compT_sizes' WT\<^sub>1_nsub_RI WTs\<^sub>1_nsub_RIs by auto(*>*)
(*<*)by(induct e and es rule: compT.induct compTs.induct) (simp_all add:after_def)(*>*)
(*<*)by(simp add:ty\<^sub>i'_def)(*>*)
(*<*)by(simp add:ty\<^sub>i'_def)(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by(simp add: JVM_states_unfold)(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by(simp)(*>*)
(*<*)
(*>*)
(*<*)(is "\<And>E T A ST. PROP ?P e E T A ST")(*>*)
(*<*)(is "\<And>E Ts A ST. PROP ?Ps es E Ts A ST")
(*>*)
(*<*)by(induct xt)(auto simp:shift_def)(*>*)
(*<*)by(simp add:shift_def)(*>*)
(*<*)by(simp add:shift_def)(*>*)
(*<*)by(induct xt)(auto simp:shift_def)(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by(simp_all add:shift_compxE\<^sub>2)(*>*)
(*<*)
(*>*)
(*<*) by (simp add: wt_defs) (*>*)
(*<*)by (simp add: Effect.eff_def)(*>*)
(*<*)
(*>*)
(*<*)by (fastforce simp:wt_instr_def app_def)(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by(cases "i") (auto simp add:eff_def norm_eff_def)(*>*)
(*<*)by (simp add: xcpt_app_def) (auto simp add: shift_def)(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by (auto simp add: shift_def pcs_def)(*>*)
(*<*)by (auto simp:wt_instr_def eff_def app_def xcpt_app_pcs xcpt_eff_pcs)(*>*)
(*<*)by (auto simp:wt_instr_def app_def eff_def xcpt_app_pcs xcpt_eff_pcs)(*>*)
(*<*)by(auto simp add:wt_instrs_def wt_instr_appR)(*>*)
(*<*)
(*>*)
(*<*)by(rule wt_instrs_ext)(*>*)
(*<*)by(bestsimp simp:prefix_def elim: wt_instrs_ext dest:wt_instrs_extR)(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)using wt_instrs_app[where ?\<tau>s\<^sub>1.0 = "\<tau> # \<tau>s\<^sub>1"] by simp (*>*)
(*<*)using wt_instrs_app[where ?\<tau>s\<^sub>1.0 = "\<tau> # \<tau>s\<^sub>1"] by simp(*>*)
(*<*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by (simp add: xcpt_app_def relevant_entries_def)(*>*)
(*<*)by (simp add: xcpt_eff_def relevant_entries_def)(*>*)
(*<*)by(simp add:wt_defs ty\<^sub>i'_def)(*>*)
(*<*)by(simp add: ty\<^sub>i'_def wt_defs)(*>*)
(*<*)by(simp add: ty\<^sub>i'_def wt_defs)(*>*)
(*<*)by(simp add: ty\<^sub>i'_def wt_defs)(*>*)
(*<*) by(auto simp:ty\<^sub>i'_def wt_defs elim!: refTE not_refTE) (*>*)
(*<*)by(simp add:ty\<^sub>i'_def wt_defs)(*>*)
(*<*)by(auto simp add:ty\<^sub>i'_def wt_defs ty\<^sub>l_def hyperset_defs)(*>*)
(*<*)
(*>*)
(*<*)by(auto simp: ty\<^sub>i'_def wt_defs dest: sees_field_idemp sees_field_decl_above)(*>*)
(*<*)by(auto simp: ty\<^sub>i'_def wt_defs dest: sees_field_idemp sees_field_decl_above)(*>*)
(*<*)by(auto intro: sees_field_idemp sees_field_decl_above simp: ty\<^sub>i'_def wt_defs)(*>*)
(*<*)by(auto intro: sees_field_idemp sees_field_decl_above simp: ty\<^sub>i'_def wt_defs)(*>*)
(*<*)by(auto simp: ty\<^sub>i'_def wt_defs)(*>*)
(*<*)
(*>*)
(*<*)by(clarsimp simp add: TC2.wt_defs)(*>*)
(*<*)by(fastforce simp add: ty\<^sub>i'_def wt_defs)(*>*)
(*<*)by(fastforce simp add: ty\<^sub>i'_def wt_defs)(*>*)
(*<*)using wt_instrs_app2[where ?xt\<^sub>2.0 = "[]"] by (simp add:shift_def)(*>*)
(*<*)
(*<*)
(*>*)
(*<*)(is "\<turnstile> ?is, xt@[?xte] [::] ?\<tau>s" is "\<turnstile> ?is, ?xt' [::] ?\<tau>s")
(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(* FIXME *)
(*<*) by (simp add: fun_of_def)(*>*)
(*<*)(is "\<And>E T A ST. PROP ?P e E T A ST")(*>*)
(*<*)
(*>*)
(*<*)by auto(*>*)
(*<*)by (simp add: JVM_states_unfold)(*>*)
(*<*)(is "?A = ?B")
(*>*)
(*<*)
(*>*)
(*<*) by (simp add: relevant_entries_def)(*>*)
(*<*)
(*>*)
(*<*)
(*>*)
(*<*)by (rule ext)+ simp(*>*)
(*<*) by (simp add: sup_state_opt_def sup_state_def sup_ty_opt_def)(*>*)
(*<*)by (simp add: wt_instr_def cong: conj_cong)(*>*)
(*<*)(is "wt_method ?P C ?b Ts T\<^sub>r mxs mxl\<^sub>0 ?is ?xt ?\<tau>s")
(*>*)
(*<*)(is "wt_method ?P C ?b Ts T\<^sub>r mxs mxl\<^sub>0 ?is ?xt ?\<tau>s")
(*>*)
(*<*)
(*>*)
(*<*)
