theory Example
imports PSL "HOL-Eisbach.Eisbach" 
begin

strategy Hammer1 = Hammer
lemma "True \<or> False"
find_proof Hammer1
oops

strategy Hammer2 = Hammer1
lemma "True \<or> False"
find_proof Hammer2
oops

strategy Test_POrs = POrs [Fastforce, Hammer]
lemma
  assumes "P" shows "P"
find_proof Test_POrs
oops
strategy Test_PAlts = Thens [PAlts [Fastforce, Hammer], IsSolved]
lemma
 assumes "P" shows "P"
find_proof Test_PAlts
oops

method my_simp = simp
strategy UserSimp = User <my_simp>
lemma "True \<and> True \<or> False"
find_proof UserSimp
oops

strategy IfMatchRuleExt = Thens [User <if_match>, User <rule ext>]

consts "QQ"::"'a \<Rightarrow> 'b"
consts "PP"::"'a \<Rightarrow> 'b"

lemma "QQ = PP"
find_proof IfMatchRuleExt
oops

definition "my_foo \<equiv> True"
strategy UserSimp2 = Thens [User < simp add: my_foo_def(1) >, IsSolved]

lemma "my_foo"
find_proof UserSimp2
oops

strategy CaseTac = Thens [Dynamic (CaseTac), Auto, IsSolved]
lemma "\<And>xs .((case xs of [] \<Rightarrow> [] | y#ys \<Rightarrow> xs) = xs)"
find_proof CaseTac
oops

strategy MultiFF = Thens [Fastforce, IsSolved, Fastforce, IsSolved]
lemma "True" and "True"
apply -
subgoal
find_proof MultiFF
oops

strategy Auto2 = Thens [Subgoal, Auto, IsSolved, Subgoal, Auto, IsSolved]
lemma "True" and "True"
find_proof Auto2
oops

inductive foo::"'a \<Rightarrow> 'a \<Rightarrow> bool" where
  "foo x y"
lemma "foo 8 90"
find_proof Hammer1
try_hard
oops

lemma assumes D shows "B \<longrightarrow> B \<or> C" and "D" and "D"
try_hard
oops

strategy my_strategy = Thens [Skip, Alts [Fail, Ors [Fail, Hammer]]]
lemma
  assumes "B"
  shows "B \<and> (True \<or> False)"
find_proof my_strategy
oops

strategy Simps =  RepeatN ( Ors [Simp, Defer] )
lemma shows "True" and "False" and "True" and "True"
find_proof Simps
oops

strategy Hammer_Or_Defer =  RepeatN ( Ors [Hammer, Thens[Quickcheck, Defer]])
definition "safe_state x y \<equiv> True"
lemma state_safety:"safe_state (x::bool) (y::bool) = True"
apply normalization done

definition "ps_safe (x::bool) (y::bool) \<equiv> safe_state True True"
definition "valid_trans p s s' x \<equiv> undefined"

lemma cnjct2:
shows 1:"ps_safe p s"
 and  2:"valid_trans p s s' x"
 and  3:"ps_safe p s'"
oops

strategy testCut = Thens [Repeat (Cut 10 (Dynamic (Rule))), IsSolved]
lemma "True \<and> True"
find_proof testCut
oops

end
