theory Neumann_Morgenstern_Utility_Theorem
  imports
    "HOL-Probability.Probability"
    "First_Welfare_Theorem.Utility_Functions"
    Lotteries
begin






definition independent_vnm
  where
    "independent_vnm C P =
    (\<forall>p \<in> C. \<forall>q \<in> C. \<forall>r \<in> C. \<forall>(\<alpha>::real) \<in> {0<..1}. p \<succeq>[P] q \<longleftrightarrow> mix_pmf \<alpha> p r \<succeq>[P] mix_pmf \<alpha> q r)"

lemma independent_vnmI1:
  assumes "(\<forall>p \<in> C. \<forall>q \<in> C. \<forall>r \<in> C. \<forall>\<alpha> \<in> {0<..1}. p \<succeq>[P] q \<longleftrightarrow> mix_pmf \<alpha> p r \<succeq>[P] mix_pmf \<alpha> q r)"
  shows "independent_vnm C P"
  using assms independent_vnm_def by blast

lemma independent_vnmI2:
  assumes "\<And>p q r \<alpha>. p \<in> C \<Longrightarrow> q \<in> C \<Longrightarrow> r \<in> C \<Longrightarrow> \<alpha> \<in> {0<..1} \<Longrightarrow> p \<succeq>[P] q \<longleftrightarrow> mix_pmf \<alpha> p r \<succeq>[P] mix_pmf \<alpha> q r"
  shows "independent_vnm C P"
  by (rule independent_vnmI1, standard, standard, standard, 
      standard, simp add: assms) (meson assms greaterThanAtMost_iff)

lemma independent_vnm_alt_def:
  shows "independent_vnm C P \<longleftrightarrow> (\<forall>p \<in> C. \<forall>q \<in> C. \<forall>r \<in> C. \<forall>\<alpha> \<in> {0<..<1}. 
  p \<succeq>[P] q \<longleftrightarrow> mix_pmf \<alpha> p r \<succeq>[P] mix_pmf \<alpha> q r)" (is "?L \<longleftrightarrow> ?R")
proof (rule iffI)
  assume a: "?R"
  have "independent_vnm C P" 
    by(rule independent_vnmI2, simp add: a) (metis a greaterThanLessThan_iff 
        linorder_neqE_linordered_idom not_le pmf_mix_1)
  then show "?L" by auto
qed (simp add: independent_vnm_def)

lemma independece_dest_alt: 
  assumes "independent_vnm C P"
  shows "(\<forall>p \<in> C. \<forall>q \<in> C. \<forall>r \<in> C. \<forall>(\<alpha>::real) \<in> {0<..1}. p \<succeq>[P] q \<longleftrightarrow> mix_pmf \<alpha> p r \<succeq>[P] mix_pmf \<alpha> q r)"
proof (standard, standard, standard, standard)
  fix p q r \<alpha>
  assume as1: "p \<in> C" 
  assume as2: "q \<in> C"
  assume as3: "r \<in> C"
  assume as4: "(\<alpha>::real) \<in> {0<..1}"
  then show "p \<succeq>[P] q = mix_pmf \<alpha> p r \<succeq>[P] mix_pmf \<alpha> q r"
    using as1 as2 as3 assms(1) independent_vnm_def by blast
qed

lemma independent_vnmD1:
  assumes "independent_vnm C P"
  shows "(\<forall>p \<in> C. \<forall>q \<in> C. \<forall>r \<in> C. \<forall>\<alpha> \<in> {0<..1}. p \<succeq>[P] q \<longleftrightarrow> mix_pmf \<alpha> p r \<succeq>[P] mix_pmf \<alpha> q r)"
  using assms independent_vnm_def by blast

lemma independent_vnmD2:
  fixes p q r \<alpha>
  assumes "\<alpha> \<in> {0<..1}"
    and "p \<in> C"
    and "q \<in> C"
    and "r \<in> C"
  assumes "independent_vnm C P"
  assumes "p \<succeq>[P] q"
  shows "mix_pmf \<alpha> p r \<succeq>[P] mix_pmf \<alpha> q r"
  using assms independece_dest_alt  by blast

lemma independent_vnmD3:
  fixes p q r \<alpha>
  assumes "\<alpha> \<in> {0<..1}"
    and "p \<in> C"
    and "q \<in> C"
    and "r \<in> C"
  assumes "independent_vnm C P" 
  assumes "mix_pmf \<alpha> p r \<succeq>[P] mix_pmf \<alpha> q r"
  shows "p \<succeq>[P] q"
  using assms independece_dest_alt by blast

lemma independent_vnmD4:
  assumes "independent_vnm C P"
  assumes "refl_on C P"
  assumes "p \<in> C" 
    and "q \<in> C" 
    and "r \<in> C"
    and "\<alpha> \<in> {0..1}" 
    and "p \<succeq>[P] q" 
  shows "mix_pmf \<alpha> p r \<succeq>[P] mix_pmf \<alpha> q r"
  using assms
  by (cases "\<alpha> = 0 \<or> \<alpha> \<in> {0<..1}",metis assms(1,2,3,4) 
      independece_dest_alt pmf_mix_0 refl_onD, auto)

lemma approx_indep_ge:
  assumes "x \<approx>[\<R>] y"
  assumes "\<alpha> \<in> {0..(1::real)}"
  assumes rpr: "rational_preference (lotteries_on outcomes) \<R>"
    and ind: "independent_vnm (lotteries_on outcomes) \<R>"
  shows "\<forall>r \<in> lotteries_on outcomes. (mix_pmf \<alpha> y r) \<succeq>[\<R>] (mix_pmf \<alpha> x r)"
proof
  fix r
  assume a: "r \<in> lotteries_on outcomes" (is "r \<in> ?lo")
  have clct: "y \<succeq>[\<R>] x \<and> independent_vnm ?lo \<R> \<and> y \<in> ?lo \<and> x \<in> ?lo \<and> r \<in> ?lo"
    by (meson  a assms(1) assms(2) atLeastAtMost_iff greaterThanAtMost_iff 
        ind preference_def rational_preference_def rpr)
  then have in_lo: "mix_pmf \<alpha> y r \<in> ?lo" "(mix_pmf \<alpha> x r) \<in> ?lo"
    by (metis  assms(2) atLeastAtMost_iff greaterThanLessThan_iff
        less_eq_real_def mix_pmf_in_lotteries pmf_mix_0 pmf_mix_1 a)+
  have "0 = \<alpha> \<or> 0 < \<alpha>"
    using assms by auto
  then show "mix_pmf \<alpha> y r \<succeq>[\<R>] mix_pmf \<alpha> x r"
    using in_lo(2) rational_preference.compl rpr
    by (auto,blast) (meson assms(2) atLeastAtMost_iff clct
        greaterThanAtMost_iff independent_vnmD2)
qed

lemma approx_imp_approx_ind:
  assumes "x \<approx>[\<R>] y"
  assumes "\<alpha> \<in> {0..(1::real)}"
  assumes rpr: "rational_preference (lotteries_on outcomes) \<R>"
    and ind: "independent_vnm (lotteries_on outcomes) \<R>"
  shows "\<forall>r \<in> lotteries_on outcomes. (mix_pmf \<alpha> y r) \<approx>[\<R>] (mix_pmf \<alpha> x r)"
  using approx_indep_ge assms(1) assms(2) ind rpr by blast

lemma geq_imp_mix_geq_right:
  assumes "x \<succeq>[\<R>] y"
  assumes rpr: "rational_preference (lotteries_on outcomes) \<R>"
  assumes ind: "independent_vnm (lotteries_on outcomes) \<R>"
  assumes "\<alpha> \<in> {0..(1::real)}"
  shows "(mix_pmf \<alpha> x y) \<succeq>[\<R>] y"
proof -
  have xy_p: "x \<in> (lotteries_on outcomes)" "y \<in> (lotteries_on outcomes)"
    by (meson assms(1) preference.not_outside rational_preference_def rpr)
      (meson assms(1) preference_def rational_preference_def rpr)
  have "(mix_pmf \<alpha> x y) \<in> (lotteries_on outcomes)" (is "?mpf \<in> ?lot")
    using mix_pmf_in_lotteries [of x outcomes y \<alpha>] xy_p assms(2)
    by (meson approx_indep_ge assms(4) ind preference.not_outside 
        rational_preference.compl rational_preference_def)
  have all: "\<forall>r \<in> ?lot. (mix_pmf \<alpha> x r) \<succeq>[\<R>] (mix_pmf \<alpha> y r)"
    by (metis assms assms(2) atLeastAtMost_iff greaterThanAtMost_iff independece_dest_alt 
        less_eq_real_def pmf_mix_0 rational_preference.compl rpr ind xy_p)
  thus ?thesis      
    by (metis all assms(4) set_pmf_mix_eq xy_p(2))
qed

lemma geq_imp_mix_geq_left:
  assumes "x \<succeq>[\<R>] y"
  assumes rpr: "rational_preference (lotteries_on outcomes) \<R>"
  assumes ind: "independent_vnm (lotteries_on outcomes) \<R>"
  assumes "\<alpha> \<in> {0..(1::real)}"
  shows "(mix_pmf \<alpha> y x) \<succeq>[\<R>] y"
proof -
  define \<beta> where
    b: "\<beta> = 1 - \<alpha>"
  have "\<beta> \<in> {0..1}"
    using assms(4) b by auto
  then have "mix_pmf \<beta> x y \<succeq>[\<R>] y" 
    using geq_imp_mix_geq_right[OF assms] assms(1) geq_imp_mix_geq_right ind rpr by blast
  moreover have "mix_pmf \<beta> x y = mix_pmf \<alpha> y x"
    by (metis assms(4) b pmf_inverse_switch_eqals)
  ultimately show ?thesis 
    by simp
qed

lemma sg_imp_mix_sg:
  assumes "x \<succ>[\<R>] y"
  assumes rpr: "rational_preference (lotteries_on outcomes) \<R>"
  assumes ind: "independent_vnm (lotteries_on outcomes) \<R>"
  assumes "\<alpha> \<in> {0<..(1::real)}"
  shows "(mix_pmf \<alpha> x y) \<succ>[\<R>] y"
proof -
  have xy_p: "x \<in> (lotteries_on outcomes)" "y \<in> (lotteries_on outcomes)"
    by (meson assms(1) preference.not_outside rational_preference_def rpr)
      (meson assms(1) preference_def rational_preference_def rpr)
  have "(mix_pmf \<alpha> x y) \<in> (lotteries_on outcomes)" (is "?mpf \<in> ?lot")
    using mix_pmf_in_lotteries [of x outcomes y \<alpha>] xy_p assms(2)
    using assms(4) by fastforce
  have all: "\<forall>r \<in> ?lot. (mix_pmf \<alpha> x r) \<succeq>[\<R>] (mix_pmf \<alpha> y r)"
    by (metis assms(1,3,4)  independece_dest_alt ind xy_p)
  have "(mix_pmf \<alpha> x y) \<succeq>[\<R>] y"
    by (metis all assms(4) atLeastAtMost_iff greaterThanAtMost_iff 
        less_eq_real_def set_pmf_mix_eq xy_p(2))
  have all2: "\<forall>r \<in> ?lot. (mix_pmf \<alpha> x r) \<succ>[\<R>] (mix_pmf \<alpha> y r)"
    using assms(1) assms(4) ind independece_dest_alt xy_p(1) xy_p(2) by blast
  then show ?thesis 
    by (metis assms(4) atLeastAtMost_iff greaterThanAtMost_iff 
        less_eq_real_def set_pmf_mix_eq xy_p(2))
qed




definition continuous_vnm
  where
    "continuous_vnm C P = (\<forall>p \<in> C. \<forall>q \<in> C. \<forall>r \<in> C. p \<succeq>[P] q \<and> q \<succeq>[P] r \<longrightarrow> 
    (\<exists>\<alpha> \<in> {0..1}. (mix_pmf \<alpha> p r) \<approx>[P] q))"

lemma continuous_vnmD:
  assumes "continuous_vnm C P"
  shows "(\<forall>p \<in> C. \<forall>q \<in> C. \<forall>r \<in> C. p \<succeq>[P] q \<and> q \<succeq>[P] r \<longrightarrow>
    (\<exists>\<alpha> \<in> {0..1}. (mix_pmf \<alpha> p r) \<approx>[P] q))"
  using continuous_vnm_def assms by blast

lemma continuous_vnmI:
  assumes "\<And>p q r. p \<in> C \<Longrightarrow> q \<in> C \<Longrightarrow> r \<in> C \<Longrightarrow> p \<succeq>[P] q \<and> q \<succeq>[P] r \<Longrightarrow> 
    \<exists>\<alpha> \<in> {0..1}. (mix_pmf \<alpha> p r) \<approx>[P] q"
  shows "continuous_vnm C P"
  by (simp add: assms continuous_vnm_def)

lemma mix_in_lot:
  assumes "x \<in> lotteries_on outcomes"
    and "y \<in> lotteries_on outcomes"
    and "\<alpha> \<in> {0..1}"
  shows "(mix_pmf \<alpha> x y) \<in> lotteries_on outcomes"
  using assms(1) assms(2) assms(3) less_eq_real_def mix_pmf_in_lotteries by fastforce


lemma non_unique_continuous_unfolding:
  assumes cnt: "continuous_vnm (lotteries_on outcomes) \<R>"
  assumes "rational_preference (lotteries_on outcomes) \<R>"
  assumes "p \<succeq>[\<R>] q"
    and "q \<succeq>[\<R>] r"
    and "p \<succ>[\<R>] r"
  shows "\<exists>\<alpha> \<in> {0..1}. q \<approx>[\<R>] mix_pmf \<alpha> p r"
  using assms(1) assms(2) cnt continuous_vnmD assms
proof -
  have "\<forall>p q. p\<in> (lotteries_on outcomes) \<and> q \<in> (lotteries_on outcomes) \<longleftrightarrow> p \<succeq>[\<R>] q \<or> q \<succeq>[\<R>] p"
    using assms rational_preference.compl[of "lotteries_on outcomes" \<R>]
    by (metis (no_types, opaque_lifting) preference_def rational_preference_def)
  then show ?thesis
    using continuous_vnmD[OF assms(1)] by (metis assms(3) assms(4))
qed



context
  fixes outcomes :: "'a set"
  fixes \<R>
  assumes rpr: "rational_preference (lotteries_on outcomes) \<R>"
  assumes ind: "independent_vnm (lotteries_on outcomes) \<R>"
begin

abbreviation "\<P> \<equiv> lotteries_on outcomes"

lemma relation_in_carrier:
  "x \<succeq>[\<R>] y \<Longrightarrow> x \<in> \<P> \<and> y \<in> \<P>"
  by (meson preference_def rational_preference_def rpr)

lemma mix_pmf_preferred_independence:
  assumes "r \<in> \<P>"
    and "\<alpha> \<in> {0..1}"
  assumes "p \<succeq>[\<R>] q"
  shows "mix_pmf \<alpha> p r \<succeq>[\<R>] mix_pmf \<alpha> q r"
  using ind by (metis relation_in_carrier antisym_conv1 assms atLeastAtMost_iff 
      greaterThanAtMost_iff independece_dest_alt pmf_mix_0 
      rational_preference.no_better_thansubset_rel rpr subsetI)

lemma mix_pmf_strict_preferred_independence:
  assumes "r \<in> \<P>"
    and "\<alpha> \<in> {0<..1}"
  assumes "p \<succ>[\<R>] q"
  shows "mix_pmf \<alpha> p r \<succ>[\<R>] mix_pmf \<alpha> q r"
  by (meson assms(1) assms(2) assms(3) ind independent_vnmD2 
      independent_vnmD3 relation_in_carrier)

lemma mix_pmf_preferred_independence_rev:
  assumes "p \<in> \<P>"
    and "q \<in> \<P>"
    and "r \<in> \<P>"
    and "\<alpha> \<in> {0<..1}"
  assumes "mix_pmf \<alpha> p r \<succeq>[\<R>] mix_pmf \<alpha> q r"
  shows "p \<succeq>[\<R>] q"
proof -
  have "mix_pmf \<alpha> p r \<in> \<P>"
    using assms mix_in_lot relation_in_carrier by blast
  moreover have "mix_pmf \<alpha> q r \<in> \<P>"
    using assms mix_in_lot assms(2) relation_in_carrier by blast
  ultimately show ?thesis 
    using ind independent_vnmD3[of \<alpha> p \<P> q r \<R>] assms by blast
qed

lemma x_sg_y_sg_mpmf_right:
  assumes "x \<succ>[\<R>] y"
  assumes "b \<in> {0<..(1::real)}"
  shows "x \<succ>[\<R>] mix_pmf b y x"
proof -
  consider "b = 1" | "b \<noteq> 1"
    by blast
  then show ?thesis 
  proof (cases)
    case 2
    have sg: "(mix_pmf b x y) \<succ>[\<R>] y"
      using assms(1) assms(2) assms ind rpr sg_imp_mix_sg "2" by fastforce
    have "mix_pmf b x y \<in> \<P>"
      by (meson sg preference_def rational_preference_def rpr)
    have "mix_pmf b x x \<in> \<P>"
      using relation_in_carrier assms(2) mix_in_lot assms by fastforce
    have "b \<in> {0<..<1}"
      using "2" assms(2)  by auto
    have "mix_pmf b x x \<succ>[\<R>] mix_pmf b y x"
      using mix_pmf_preferred_independence[of x b] assms
          independece_dest_alt less_eq_real_def preference_def 
          rational_preference.axioms(1) relation_in_carrier rpr)
    then show ?thesis
      using mix_pmf_preferred_independence
      by (metis assms(2) atLeastAtMost_iff greaterThanAtMost_iff less_eq_real_def set_pmf_mix_eq)
  qed (simp add: assms(1))
qed

lemma neumann_3B_b:
  assumes "u \<succ>[\<R>] v"
  assumes "\<alpha> \<in> {0<..<1}"
  shows "u \<succ>[\<R>] mix_pmf \<alpha> u v"
proof -
  have *: "preorder_on \<P> \<R> \<and> rational_preference_axioms \<P> \<R>"
    by (metis (no_types) preference_def rational_preference_def rpr)
  have "1 - \<alpha> \<in> {0<..1}"
    using assms(2) by auto
  then show ?thesis
    using * assms by (metis atLeastAtMost_iff greaterThanLessThan_iff 
        less_eq_real_def pmf_inverse_switch_eqals x_sg_y_sg_mpmf_right)
qed

lemma neumann_3B_b_non_strict:
  assumes "u \<succeq>[\<R>] v"
  assumes "\<alpha> \<in> {0..1}"
  shows "u \<succeq>[\<R>] mix_pmf \<alpha> u v"
proof -
  have f2: "mix_pmf \<alpha> (u::'a pmf) v = mix_pmf (1 - \<alpha>) v u"
    using pmf_inverse_switch_eqals assms(2) by auto
  have "1 - \<alpha> \<in> {0..1}"
    using assms(2) by force
  then show ?thesis
    using f2 relation_in_carrier 
    by (metis (no_types) assms(1) mix_pmf_preferred_independence set_pmf_mix_eq)
qed

lemma greater_mix_pmf_greater_step_1_aux: 
  assumes "v \<succ>[\<R>] u"
  assumes "\<alpha> \<in> {0<..<(1::real)}"
    and "\<beta> \<in> {0<..<(1::real)}"
  assumes "\<beta> > \<alpha>"
  shows "(mix_pmf \<beta> v u) \<succ>[\<R>] (mix_pmf \<alpha> v u)"
proof -
  define t where
    t: "t = mix_pmf \<beta> v u"
  obtain \<gamma> where
    g: "\<alpha> = \<beta> * \<gamma>"
    by (metis assms(2) assms(4) greaterThanLessThan_iff 
        mult.commute nonzero_eq_divide_eq not_less_iff_gr_or_eq)
  have g1: "\<gamma> > 0 \<and> \<gamma> < 1"
    by (metis (full_types) assms(2) assms(4) g greaterThanLessThan_iff 
        less_trans mult.right_neutral mult_less_cancel_left_pos not_le 
        sgn_le_0_iff sgn_pos zero_le_one zero_le_sgn_iff zero_less_mult_iff)
  have t_in: "mix_pmf \<beta> v u \<in> \<P>"
    by (meson assms(1) assms(3) mix_pmf_in_lotteries preference_def rational_preference_def rpr)
  have "v \<succ>[\<R>] mix_pmf (1 - \<beta>) v u"
    using x_sg_y_sg_mpmf_right[of u v "1-\<beta>"] assms
    by (metis atLeastAtMost_iff greaterThanAtMost_iff greaterThanLessThan_iff 
        less_eq_real_def pmf_inverse_switch_eqals x_sg_y_sg_mpmf_right)
  have "t \<succ>[\<R>] u"
    using assms(1) assms(3) ind rpr sg_imp_mix_sg t by fastforce
  hence t_s: "t \<succ>[\<R>] (mix_pmf \<gamma> t u)" 
  proof -
    have "(mix_pmf \<gamma> t u) \<in> \<P>"
      by (metis assms(1) assms(3) atLeastAtMost_iff g1 mix_in_lot mix_pmf_in_lotteries 
          not_less order.asym preference_def rational_preference_def rpr t)
    have "t \<succ>[\<R>] mix_pmf \<gamma> (mix_pmf \<beta> v u) u"
      using neumann_3B_b[of t u \<gamma>] assms t g1
      by (meson greaterThanAtMost_iff greaterThanLessThan_iff 
          ind less_eq_real_def rpr sg_imp_mix_sg)
    thus ?thesis
      using t by blast
  qed
  from product_mix_pmf_prob_distrib[of _ \<beta> v u] assms
  have "mix_pmf \<beta> v u \<succ>[\<R>] mix_pmf \<alpha> v u"
    by (metis t_s atLeastAtMost_iff g g1 greaterThanLessThan_iff less_eq_real_def mult.commute t)
  then show ?thesis by blast
qed


lemma step_1_most_general:
  assumes "x \<succ>[\<R>] y"
  assumes "\<alpha> \<in> {0..(1::real)}"
    and "\<beta> \<in> {0..(1::real)}"
  assumes "\<alpha> > \<beta>"
  shows "(mix_pmf \<alpha> x y) \<succ>[\<R>] (mix_pmf \<beta> x y)"
proof -
  consider (ex) "\<alpha> = 1 \<and> \<beta> = 0" | (m) "\<alpha> \<noteq> 1 \<or> \<beta> \<noteq> 0"
    by blast
  then show ?thesis
  proof (cases)
    case m
    consider  "\<beta> = 0" |  "\<beta> \<noteq> 0"
      by blast
    then show ?thesis
    proof (cases)
      case 1
      then show ?thesis
        using assms(1) assms(2) assms(4) ind rpr sg_imp_mix_sg by fastforce
    next
      case 2
      let ?d = "(\<beta>/\<alpha>)"
      have sg: "(mix_pmf \<alpha> x y) \<succ>[\<R>] y"
        using assms(1) assms(2) assms(3) assms(4) ind rpr sg_imp_mix_sg by fastforce
      have a: "\<alpha> > 0"
        using assms(3) assms(4) by auto
      then have div_in: "?d \<in> {0<..1}"
        using assms(3) assms(4) 2 by auto
      have mx_p: "(mix_pmf \<alpha> x y) \<in> \<P>"
        by (meson sg preference_def rational_preference_def rpr)
      have y_P: "y \<in> \<P>"
        by (meson assms(1) preference_def rational_preference_def rpr)
      hence "(mix_pmf ?d (mix_pmf \<alpha> x y) y) \<in> \<P>"
        using div_in mx_p by (simp add: mix_in_lot)
      have " mix_pmf \<beta> (mix_pmf \<alpha> x y) y \<succ>[\<R>] y"
        using sg_imp_mix_sg[of "(mix_pmf \<alpha> x y)" y \<R> outcomes \<beta>] sg div_in rpr ind
          a assms(2) "2" assms(3) by auto
      have al1: "\<forall>r \<in> \<P>. (mix_pmf \<alpha> x r) \<succ>[\<R>] (mix_pmf \<alpha> y r)"
        by (meson a assms(1) assms(2) atLeastAtMost_iff greaterThanAtMost_iff ind 
            independece_dest_alt preference.not_outside rational_preference_def rpr y_P)
      then show ?thesis 
        using greater_mix_pmf_greater_step_1_aux assms
        by (metis a div_in divide_less_eq_1_pos greaterThanAtMost_iff 
            greaterThanLessThan_iff mix_pmf_comp_with_dif_equiv neumann_3B_b sg)
    qed 
  qed (simp add: assms(1))
qed


lemma approx_remains_after_same_comp:
  assumes "p \<approx>[\<R>] q"
    and "r \<in> \<P>"
    and "\<alpha> \<in> {0..1}"
  shows "mix_pmf \<alpha> p r \<approx>[\<R>] mix_pmf \<alpha> q r"
  using approx_indep_ge assms(1) assms(2) assms(3) ind rpr by blast

lemma approx_remains_after_same_comp_left:
  assumes "p \<approx>[\<R>] q"
    and "r \<in> \<P>"
    and "\<alpha> \<in> {0..1}"
  shows "mix_pmf \<alpha> r p \<approx>[\<R>] mix_pmf \<alpha> r q"
proof -
  have 1: "\<alpha> \<le> 1 \<and> \<alpha> \<ge> 0" "1 - \<alpha> \<in> {0..1}"
    using assms(3) by auto+
  have fst: "mix_pmf \<alpha> r p \<approx>[\<R>] mix_pmf (1-\<alpha>) p r"
    using assms  by (metis mix_in_lot pmf_inverse_switch_eqals 
    rational_preference.compl relation_in_carrier rpr)
  moreover have "mix_pmf \<alpha> r p \<approx>[\<R>] mix_pmf \<alpha> r q"
    using approx_remains_after_same_comp[of _ _ _ \<alpha>] pmf_inverse_switch_eqals[of \<alpha> p q] 1 
      pmf_inverse_switch_eqals rpr mix_pmf_preferred_independence[of _ \<alpha> _ _]
    by (metis assms(1) assms(2) assms(3) mix_pmf_preferred_independence)
  thus ?thesis
    by blast
qed

lemma mix_of_preferred_is_preferred:
  assumes "p \<succeq>[\<R>] w"
  assumes "q \<succeq>[\<R>] w"
  assumes "\<alpha> \<in> {0..1}"
  shows "mix_pmf \<alpha> p q \<succeq>[\<R>] w"
proof -
  consider "p \<succeq>[\<R>] q" | "q \<succeq>[\<R>] p"
    using rpr assms(1) assms(2) rational_preference.compl relation_in_carrier by blast
  then show ?thesis
  proof (cases)
    case 1
    have "mix_pmf \<alpha> p q \<succeq>[\<R>] q"
      using "1" assms(3) geq_imp_mix_geq_right ind rpr by blast
    moreover have "q \<succeq>[\<R>] w" 
      using assms by auto
    ultimately show ?thesis using rpr preference.transitivity[of \<P> \<R>]
      by (meson rational_preference_def transE)
  next
    case 2
    have "mix_pmf \<alpha> p q \<succeq>[\<R>] p"      
      using "2" assms geq_imp_mix_geq_left ind rpr by blast
    moreover have "p \<succeq>[\<R>] w" 
      using assms by auto
    ultimately show ?thesis using rpr preference.transitivity[of \<P> \<R>]
      by (meson rational_preference_def transE)
  qed
qed

lemma mix_of_not_preferred_is_not_preferred:
  assumes "w \<succeq>[\<R>] p"
  assumes "w \<succeq>[\<R>] q"
  assumes "\<alpha> \<in> {0..1}"
  shows "w \<succeq>[\<R>] mix_pmf \<alpha> p q"
proof -
  consider "p \<succeq>[\<R>] q" | "q \<succeq>[\<R>] p"
    using rpr assms(1) assms(2) rational_preference.compl relation_in_carrier by blast
  then show ?thesis
  proof (cases)
    case 1
    moreover have "p \<succeq>[\<R>] mix_pmf \<alpha> p q"
      using assms(3) neumann_3B_b_non_strict calculation by blast
    moreover show ?thesis
      using rpr preference.transitivity[of \<P> \<R>]
      by (meson assms(1) calculation(2) rational_preference_def transE)
  next
    case 2
    moreover have "q \<succeq>[\<R>] mix_pmf \<alpha> p q"
      using assms(3) neumann_3B_b_non_strict calculation
      by (metis mix_pmf_preferred_independence relation_in_carrier set_pmf_mix_eq)
    moreover show ?thesis
      using rpr preference.transitivity[of \<P> \<R>]
      by (meson assms(2) calculation(2) rational_preference_def transE)
  qed
qed

private definition degenerate_lotteries where
  "degenerate_lotteries = {x \<in> \<P>. card (set_pmf x) = 1}"

private definition best where
  "best = {x \<in> \<P>. (\<forall>y \<in> \<P>. x \<succeq>[\<R>] y)}"

private definition worst where
  "worst = {x \<in> \<P>. (\<forall>y \<in> \<P>. y \<succeq>[\<R>] x)}"

lemma degenerate_total: 
  "\<forall>e \<in> degenerate_lotteries. \<forall>m \<in> \<P>. e \<succeq>[\<R>] m \<or> m \<succeq>[\<R>] e"
  using degenerate_lotteries_def rational_preference.compl rpr by fastforce

lemma degen_outcome_cardinalities:
  "card degenerate_lotteries = card outcomes"
  using card_degen_lotteries_equals_outcomes degenerate_lotteries_def by auto

lemma degenerate_lots_subset_all: "degenerate_lotteries \<subseteq> \<P>"
  by (simp add: degenerate_lotteries_def)

lemma alt_definition_of_degenerate_lotteries[iff]:
  "{return_pmf x |x. x\<in> outcomes} = degenerate_lotteries"
proof (standard, goal_cases)
  case 1
  have "\<forall>x \<in> {return_pmf x |x. x \<in> outcomes}. x \<in> degenerate_lotteries"
  proof
    fix x
    assume a: "x \<in> {return_pmf x |x. x \<in> outcomes}"
    then have "card (set_pmf x) = 1"
      by auto
    moreover have "set_pmf x \<subseteq> outcomes"
      using a set_pmf_subset_singleton by auto
    moreover have "x \<in> \<P>"
      by (simp add: lotteries_on_def calculation)
    ultimately show "x \<in> degenerate_lotteries"
      by (simp add: degenerate_lotteries_def)
  qed
  then show ?case by blast
next
  case 2
  have "\<forall>x \<in> degenerate_lotteries. x \<in> {return_pmf x |x. x \<in> outcomes}"
  proof
    fix x
    assume a: "x \<in> degenerate_lotteries"
    hence "card (set_pmf x) = 1"
      using degenerate_lotteries_def by blast
    moreover have "set_pmf x \<subseteq> outcomes"
      by (meson a degenerate_lots_subset_all subset_iff support_in_outcomes)
    moreover obtain e where "{e} = set_pmf x"
      using calculation
      by (metis card_1_singletonE)
    moreover have "e \<in> outcomes"
      using calculation(2) calculation(3) by blast
    moreover have "x = return_pmf e"
      using calculation(3) set_pmf_subset_singleton by fast
    ultimately show "x \<in> {return_pmf x |x. x \<in> outcomes}"
      by blast
  qed
  then show ?case by blast
qed

lemma best_indifferent:
  "\<forall>x \<in> best. \<forall>y \<in> best. x \<approx>[\<R>] y"
  by (simp add: best_def)

lemma worst_indifferent:
  "\<forall>x \<in> worst. \<forall>y \<in> worst. x \<approx>[\<R>] y"
  by (simp add: worst_def)

lemma best_worst_indiff_all_indiff:
  assumes "b \<in> best"
    and "w \<in> worst"
    and "b \<approx>[\<R>] w"
  shows "\<forall>e \<in> \<P>. e \<approx>[\<R>] w" "\<forall>e \<in> \<P>. e \<approx>[\<R>] b"
proof -
  show "\<forall>e \<in> \<P>. e \<approx>[\<R>] w"
  proof (standard)
    fix e 
    assume a: "e \<in> \<P>"
    then have "b \<succeq>[\<R>] e"
      using a best_def assms  by blast
    moreover have "e \<succeq>[\<R>] w"
      using a assms worst_def by auto
    moreover have "b \<succeq>[\<R>] e"
      by (simp add: calculation(1))
    moreover show "e \<approx>[\<R>] w"
    proof (rule ccontr)
      assume "\<not> e \<approx>[\<R>] w"
      then consider "e \<succ>[\<R>] w" | "w \<succ>[\<R>] e"
        by (simp add: calculation(2))
      then show False 
      proof (cases)
        case 2
        then show ?thesis
          using calculation(2) by blast
      qed (meson assms(3) calculation(1) 
          rational_preference.strict_is_neg_transitive relation_in_carrier rpr)
    qed
  qed
  then show "\<forall>e\<in>local.\<P>. e \<approx>[\<R>] b"
    using assms  by (meson rational_preference.compl 
        rational_preference.strict_is_neg_transitive relation_in_carrier rpr)
qed  

lemma mix_pmf_pref_iff_more_likely [iff]: 
  assumes "b \<succ>[\<R>] w"
  assumes "\<alpha> \<in> {0..1}"
    and "\<beta> \<in> {0..1}"
  shows "\<alpha> > \<beta> \<longleftrightarrow> mix_pmf \<alpha> b w \<succ>[\<R>] mix_pmf \<beta> b w" (is "?L \<longleftrightarrow> ?R")
  using assms step_1_most_general[of b w \<alpha> \<beta>]
  by (metis linorder_neqE_linordered_idom step_1_most_general)

lemma better_worse_good_mix_preferred[iff]: 
  assumes "b \<succeq>[\<R>] w"
  assumes "\<alpha> \<in> {0..1}"
    and "\<beta> \<in> {0..1}"
  assumes "\<alpha> \<ge> \<beta>" 
  shows "mix_pmf \<alpha> b w \<succeq>[\<R>] mix_pmf \<beta> b w"
proof-
  have "(0::real) \<le> 1"
    by simp
  then show ?thesis
    by (metis (no_types) assms assms(1) assms(2) assms(3) atLeastAtMost_iff 
        less_eq_real_def mix_of_not_preferred_is_not_preferred 
        mix_of_preferred_is_preferred mix_pmf_preferred_independence 
        pmf_mix_0 relation_in_carrier step_1_most_general)
qed

context
  assumes fnt: "finite outcomes"
  assumes nempty: "outcomes \<noteq> {}"
begin

lemma finite_degenerate_lotteries: 
  "finite degenerate_lotteries"
  using degen_outcome_cardinalities fnt nempty by fastforce

lemma degenerate_has_max_preferred:
  "{x \<in> degenerate_lotteries. (\<forall>y \<in> degenerate_lotteries. x \<succeq>[\<R>] y)} \<noteq> {}" (is "?l \<noteq> {}")
proof
  assume a: "?l = {}"
  let ?DG = "degenerate_lotteries"
  obtain R where
    R: "rational_preference ?DG R" "R \<subseteq> \<R>"
    using degenerate_lots_subset_all rational_preference.all_carrier_ex_sub_rel rpr by blast
  then have "\<exists>e \<in> ?DG. \<forall>e' \<in> ?DG. e \<succeq>[\<R>] e'"
    by (metis R(1) R(2) card_0_eq degen_outcome_cardinalities 
        finite_degenerate_lotteries fnt nempty subset_eq
        rational_preference.finite_nonempty_carrier_has_maximum )
  then show False
    using a by auto
qed

lemma degenerate_has_min_preferred:
  "{x \<in> degenerate_lotteries. (\<forall>y \<in> degenerate_lotteries. y \<succeq>[\<R>] x)} \<noteq> {}" (is "?l \<noteq> {}")
proof
  assume a: "?l = {}"
  let ?DG = "degenerate_lotteries"
  obtain R where
    R: "rational_preference ?DG R" "R \<subseteq> \<R>"
    using degenerate_lots_subset_all rational_preference.all_carrier_ex_sub_rel rpr by blast
  have "\<exists>e \<in> ?DG. \<forall>e' \<in> ?DG. e' \<succeq>[\<R>] e"
    by (metis R(1) R(2) card_0_eq degen_outcome_cardinalities 
        finite_degenerate_lotteries fnt nempty subset_eq
        rational_preference.finite_nonempty_carrier_has_minimum )
  then show False
    using a by auto
qed

lemma exists_best_degenerate:
  "\<exists>x \<in> degenerate_lotteries. \<forall>y \<in> degenerate_lotteries. x \<succeq>[\<R>] y"
  using degenerate_has_max_preferred by blast

lemma exists_worst_degenerate:
  "\<exists>x \<in> degenerate_lotteries. \<forall>y \<in> degenerate_lotteries. y \<succeq>[\<R>] x"
  using degenerate_has_min_preferred by blast

lemma best_degenerate_in_best_overall: 
  "\<exists>x \<in> degenerate_lotteries. \<forall>y \<in> \<P>. x \<succeq>[\<R>] y"
proof -
  obtain b where
    b: "b \<in> degenerate_lotteries" "\<forall>y \<in> degenerate_lotteries. b \<succeq>[\<R>] y"
    using exists_best_degenerate by blast
  have asm: "finite outcomes" "set_pmf b \<subseteq> outcomes"
    by (simp add: fnt) (meson b(1) degenerate_lots_subset_all subset_iff support_in_outcomes)
  obtain B where B: "set_pmf b = {B}"
    using b card_1_singletonE degenerate_lotteries_def by blast
  have deg: "\<forall>d\<in>outcomes. b \<succeq>[\<R>] return_pmf d"
    using alt_definition_of_degenerate_lotteries b(2) by blast
  define P where
    "P = (\<lambda>p. p \<in> \<P> \<longrightarrow> return_pmf B \<succeq>[\<R>] p)"
  have "P p" for p
  proof -
    consider "set_pmf p \<subseteq> outcomes" | "\<not>set_pmf p \<subseteq> outcomes"
      by blast
    then show ?thesis 
    proof (cases)
      case 1
      have "finite outcomes" "set_pmf p \<subseteq> outcomes"
        by (auto simp: 1 asm) 
      then show ?thesis
      proof (induct  rule: pmf_mix_induct')
        case (degenerate x)
        then show ?case
          using B P_def deg set_pmf_subset_singleton by fastforce
      qed (simp add: P_def lotteries_on_def mix_of_not_preferred_is_not_preferred
               mix_of_not_preferred_is_not_preferred[of b p q a])
    qed  (simp add: lotteries_on_def P_def)
  qed
  moreover have "\<forall>e \<in> \<P>. b \<succeq>[\<R>] e"
    using calculation B P_def set_pmf_subset_singleton by fastforce
  ultimately show ?thesis
    using b degenerate_lots_subset_all by blast
qed

lemma worst_degenerate_in_worst_overall: 
  "\<exists>x \<in> degenerate_lotteries. \<forall>y \<in> \<P>. y \<succeq>[\<R>] x"
proof -
  obtain b where
    b: "b \<in> degenerate_lotteries" "\<forall>y \<in> degenerate_lotteries. y \<succeq>[\<R>] b"
    using exists_worst_degenerate by blast
  have asm: "finite outcomes" "set_pmf b \<subseteq> outcomes"
    by (simp add: fnt) (meson b(1) degenerate_lots_subset_all subset_iff support_in_outcomes)
  obtain B where B: "set_pmf b = {B}"
    using b card_1_singletonE degenerate_lotteries_def by blast
  have deg: "\<forall>d\<in>outcomes. return_pmf d \<succeq>[\<R>] b"
    using alt_definition_of_degenerate_lotteries b(2) by blast
  define P where
    "P = (\<lambda>p. p \<in> \<P> \<longrightarrow> p \<succeq>[\<R>] return_pmf B)"
  have "P p" for p
  proof -
    consider "set_pmf p \<subseteq> outcomes" | "\<not>set_pmf p \<subseteq> outcomes"
      by blast
    then show ?thesis 
    proof (cases)
      case 1
      have "finite outcomes" "set_pmf p \<subseteq> outcomes"
        by (auto simp: 1 asm) 
      then show ?thesis
      proof (induct rule: pmf_mix_induct')
        case (degenerate x)
        then show ?case
          using B P_def deg set_pmf_subset_singleton by fastforce
      next
      qed (simp add: P_def lotteries_on_def mix_of_preferred_is_preferred
          mix_of_not_preferred_is_not_preferred[of b p])
    qed (simp add: lotteries_on_def P_def)
  qed
  moreover have "\<forall>e \<in> \<P>. e \<succeq>[\<R>] b"
    using calculation B P_def set_pmf_subset_singleton by fastforce
  ultimately show ?thesis
    using b degenerate_lots_subset_all by blast
qed 

lemma overall_best_nonempty:
  "best \<noteq> {}"
  using best_def best_degenerate_in_best_overall degenerate_lots_subset_all by blast

lemma overall_worst_nonempty:
  "worst \<noteq> {}"
  using degenerate_lots_subset_all worst_def worst_degenerate_in_worst_overall by auto


lemma trans_approx:
  assumes "x\<approx>[\<R>] y" 
    and " y \<approx>[\<R>] z" 
  shows "x \<approx>[\<R>] z"
  using preference.indiff_trans[of \<P> \<R> x y z] assms rpr rational_preference_def by blast



private definition some_best where
  "some_best = (SOME x. x \<in> degenerate_lotteries \<and> x \<in> best)"

private definition some_worst where
  "some_worst = (SOME x. x \<in> degenerate_lotteries \<and> x \<in> worst)"

private definition my_U :: "'a pmf \<Rightarrow> real"
  where
    "my_U p = (SOME \<alpha>. \<alpha>\<in>{0..1} \<and> p \<approx>[\<R>] mix_pmf \<alpha> some_best some_worst)"

lemma exists_best_and_degenerate: "degenerate_lotteries \<inter> best \<noteq> {}"
  using best_def best_degenerate_in_best_overall degenerate_lots_subset_all by blast


lemma exists_worst_and_degenerate: "degenerate_lotteries \<inter> worst \<noteq> {}"
  using worst_def worst_degenerate_in_worst_overall degenerate_lots_subset_all by blast

lemma some_best_in_best: "some_best \<in> best"
  using exists_best_and_degenerate some_best_def
  by (metis (mono_tags, lifting) Int_emptyI some_eq_ex)

lemma some_worst_in_worst: "some_worst \<in> worst"
  using exists_worst_and_degenerate some_worst_def
  by (metis (mono_tags, lifting) Int_emptyI some_eq_ex)


lemma best_always_at_least_as_good_mix:
  assumes "\<alpha> \<in> {0..1}"
    and "p \<in> \<P>"
  shows "mix_pmf \<alpha> some_best p \<succeq>[\<R>] p"
  using assms(1) assms(2) best_def mix_of_preferred_is_preferred 
    rational_preference.compl rpr some_best_in_best by fastforce

lemma geq_mix_imp_weak_pref:
  assumes "\<alpha> \<in> {0..1}"
    and "\<beta> \<in> {0..1}"
  assumes "\<alpha> \<ge> \<beta>"
  shows "mix_pmf \<alpha> some_best some_worst \<succeq>[\<R>] mix_pmf \<beta> some_best some_worst"
  using assms(1) assms(2) assms(3) best_def some_best_in_best some_worst_in_worst worst_def by auto

lemma gamma_inverse:
  assumes "\<alpha> \<in> {0<..<1}"
    and "\<beta> \<in> {0<..<1}"
  shows "(1::real) - (\<alpha> - \<beta>) / (1 - \<beta>) = (1 - \<alpha>) / (1 - \<beta>)"
proof - 
  have "1 - (\<alpha> - \<beta>) / (1 - \<beta>) =  (1 - \<beta>)/(1 - \<beta>) - (\<alpha> - \<beta>) / (1 - \<beta>)"
    using assms(2) by auto
  also have "... = (1 - \<beta> - (\<alpha> - \<beta>)) / (1 - \<beta>)"
    by (metis diff_divide_distrib)
  also have "... = (1 - \<alpha>) / (1 - \<beta>)"
    by simp
  finally show ?thesis .
qed

lemma all_mix_pmf_indiff_indiff_best_worst:
  assumes "l \<in> \<P>"
  assumes "b \<in> best"
  assumes "w \<in> worst"
  assumes "b \<approx>[\<R>] w"
  shows "\<forall>\<alpha> \<in>{0..1}. l \<approx>[\<R>] mix_pmf \<alpha> b w"
  by (meson assms best_worst_indiff_all_indiff(1) mix_of_preferred_is_preferred
      best_worst_indiff_all_indiff(2) mix_of_not_preferred_is_not_preferred)

lemma indiff_imp_same_utility_value:
  assumes "some_best \<succ>[\<R>] some_worst"
  assumes "\<alpha> \<in> {0..1}"
  assumes "\<beta> \<in> {0..1}"
  assumes "mix_pmf \<beta> some_best some_worst \<approx>[\<R>] mix_pmf \<alpha> some_best some_worst"
  shows "\<beta> = \<alpha>"
  using assms(1) assms(2) assms(3) assms(4) linorder_neqE_linordered_idom by blast

lemma leq_mix_imp_weak_inferior:
  assumes "some_best \<succ>[\<R>] some_worst"
  assumes "\<alpha> \<in> {0..1}"
    and "\<beta> \<in> {0..1}"
  assumes "mix_pmf \<beta> some_best some_worst \<succeq>[\<R>] mix_pmf \<alpha> some_best some_worst"
  shows "\<beta> \<ge> \<alpha>"
proof -
  have *: "mix_pmf \<beta> some_best some_worst \<approx>[\<R>] mix_pmf \<alpha> some_best some_worst \<Longrightarrow> \<alpha> \<le> \<beta>"
    using assms(1) assms(2) assms(3) indiff_imp_same_utility_value by blast
  consider "mix_pmf \<beta> some_best some_worst \<succ>[\<R>] mix_pmf \<alpha> some_best some_worst" |
    "mix_pmf \<beta> some_best some_worst \<approx>[\<R>] mix_pmf \<alpha> some_best some_worst"
    using assms(4) by blast
  then show ?thesis
    by(cases) (meson assms(2) assms(3) geq_mix_imp_weak_pref le_cases *)+
end  (* continuous *)
end(* finite outcomes *)
end (* system U *)
