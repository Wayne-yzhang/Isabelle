theory PAC_Polynomials
  imports PAC_Specification Finite_Map_Multiset
begin





lemma poly_embed_EX:
     (auto intro!: infinite_UNIV_listI)

type_synonym mset_polynomial =


lemma normalized_poly_simps[simp]:
  by (auto simp: normalized_poly_def)

lemma normalized_poly_mono:
  unfolding normalized_poly_def
  by (auto intro: distinct_mset_mono image_mset_subseteq_mono)











lemma add_to_coefficient_simps:
  add_to_coefficient_simps_If:
  by (auto simp: add_to_coefficient_def)

proof -
  have [iff]:
    by auto
    unfolding add_to_coefficient_def
    by standard
     (auto intro!: ext simp: filter_filter_mset ac_simps add_eq_0_iff)
qed

lemma normalized_poly_normalize_poly[simp]:
  unfolding normalize_poly_def
  apply (induction p)
  subgoal by auto
  subgoal for x p
    by (cases x)
      (auto simp: add_to_coefficient_simps_If
      intro: normalized_poly_mono)
  done



add_new_coeff_r:
add_new_coeff_l:
add_same_coeff_l:
add_same_coeff_r:
rem_0_coeff:


lemmas add_poly_p_induct =
  add_poly_p.induct[split_format(complete)]

lemma add_poly_p_empty_l:
  apply (induction p arbitrary: r)
  subgoal by auto
  subgoal
    by (metis (no_types, lifting) add_new_coeff_l r_into_rtranclp
      rtranclp_trans union_mset_add_mset_left union_mset_add_mset_right)
  done

lemma add_poly_p_empty_r:
  apply (induction q arbitrary: r)
  subgoal by auto
  subgoal
    by (metis (no_types, lifting) add_new_coeff_r r_into_rtranclp
      rtranclp_trans union_mset_add_mset_left union_mset_add_mset_right)
  done

lemma add_poly_p_sym:
  apply (rule iffI)
  subgoal
    by (cases rule: add_poly_p.cases, assumption)
      (auto intro: add_poly_p.intros)
  subgoal
    by (cases rule: add_poly_p.cases, assumption)
      (auto intro: add_poly_p.intros)
  done

lemma wf_if_measure_in_wf:
  by (metis in_inv_image wfE_min wfI_min wf_inv_image)

lemma lexn_n:
  apply (cases n)
   apply simp
  by (auto simp: map_prod_def image_iff lex_prod_def)

lemma wf_add_poly_p:
    (auto simp: add_poly_p.simps wf_lexn
     simp: lexn_n simp del: lexn.simps(2))

lemma mult_poly_by_monom_simps[simp]:
proof -
    by standard auto
  show
    by (induction ps)
      (auto simp: mult_poly_by_monom_def)
  show
    by (auto simp: mult_poly_by_monom_def)
qed

  for q :: mset_polynomial where
mult_step:


lemmas mult_poly_p_induct = mult_poly_p.induct[split_format(complete)]


rem_0_coeff[simp, intro]:
merge_dup_coeff[simp, intro]:
same[simp, intro]:
keep_coeff[simp, intro]:


locale poly_embed =
begin

definition poly_of_vars :: "term_poly \<Rightarrow> ('a :: {comm_semiring_1}) mpoly" where

lemma poly_of_vars_simps[simp]:
  shows
proof -
    by standard
      (auto simp: algebra_simps ac_simps
         Var_def times_monomial_monomial intro!: ext)

  show ?A
    by (auto simp: poly_of_vars_def comp_fun_commute_axioms fold_mset_fusion
      ac_simps)
  show ?B
    apply (auto simp: poly_of_vars_def ac_simps)
    by (simp add: local.comp_fun_commute_axioms local.fold_mset_fusion
      semiring_normalization_rules(18))
qed


definition mononom_of_vars where

  by standard
    (auto simp: algebra_simps ac_simps mononom_of_vars_def
       Var_def times_monomial_monomial intro!: ext)

lemma [simp]:
  by (auto simp: poly_of_vars_def)

lemma mononom_of_vars_add[simp]:
  by (cases xs)
    (auto simp: ac_simps mononom_of_vars_def)


lemma polynomial_of_mset_append[simp]:
  by (auto simp: ac_simps Const_def polynomial_of_mset_def)

lemma polynomial_of_mset_Cons[simp]:
  by (cases x)
    (auto simp: ac_simps polynomial_of_mset_def mononom_of_vars_def)

lemma polynomial_of_mset_empty[simp]:
  by (auto simp: polynomial_of_mset_def)

lemma polynomial_of_mset_mult_poly_by_monom[simp]:
 by (induction ys)
   (auto simp: Const_mult algebra_simps)

lemma polynomial_of_mset_mult_poly_raw[simp]:
  unfolding mult_poly_raw_def
  by (induction xs arbitrary: ys)
   (auto simp: Const_mult algebra_simps)

lemma polynomial_of_mset_uminus:
  by (induction za)
    auto


lemma X2_X_polynomial_bool_mult_in:
  by (auto simp: right_diff_distrib ac_simps power2_eq_square)


lemma polynomial_of_list_remove_powers_polynomial_bool:
proof (induction xs)
  case empty
next
  case (add x xs)
    apply (subst (2) ideal.span_add_eq[symmetric,
    apply (drule multi_member_split)
    apply (auto simp: X2_X_polynomial_bool_mult_in)
    done

    by (induction x)
     (auto simp: remove_powers_def ideal.span_zero H1
      simp flip: right_diff_distrib intro!: ideal.span_scale)
    by (metis add_diff_add diff ideal.scale_right_diff_distrib ideal.span_add ideal.span_scale)
  show ?case
    using add
    apply (cases x)
    subgoal for ys y
      by (auto simp: remove_powers_def right_diff_distrib
        ideal.span_diff ideal.span_add field_simps)
    done
qed

lemma add_poly_p_polynomial_of_mset:
  apply (induction rule: add_poly_p_induct)
  subgoal
    by auto
  subgoal
    by auto
  subgoal
    by (auto simp: algebra_simps Const_add)
  subgoal
    by (auto simp: algebra_simps Const_add)
  subgoal
    by (auto simp: algebra_simps Const_add)
  done

lemma rtranclp_add_poly_p_polynomial_of_mset:
    (auto dest: add_poly_p_polynomial_of_mset)


lemma rtranclp_add_poly_p_polynomial_of_mset_full:
  by (drule rtranclp_add_poly_p_polynomial_of_mset)
    (auto simp: ac_simps add_eq_0_iff)

lemma poly_of_vars_remdups_mset:
  apply (induction xs)
  subgoal by (auto simp: ideal.span_zero)
  subgoal for x xs
     apply (metis (no_types, lifting) X2_X_polynomial_bool_mult_in diff_add_cancel diff_diff_eq2
        ideal.span_diff insert_DiffM poly_of_vars_simps(1) remdups_mset_singleton_sum)
    by (metis (no_types, lifting) ideal.span_scale poly_of_vars_simps(1) remdups_mset_singleton_sum
        right_diff_distrib)
  done

lemma polynomial_of_mset_mult_map:
proof (induction q)
  case empty
  then show ?case by (auto simp: algebra_simps ideal.span_zero)
next
  case (add x q)
    using ideal.span_neg by blast
    by (auto simp: Const_mult simp flip: right_diff_distrib' poly_of_vars_simps
        intro!: ideal.span_scale poly_of_vars_remdups_mset)
  then show ?case
    apply (subst ideal.span_add_eq2[symmetric, OF uP])
    apply (cases x)
    apply (auto simp: field_simps Const_mult  simp flip:
        intro!: ideal.span_scale poly_of_vars_remdups_mset)
    done
qed

lemma mult_poly_p_mult_ideal:
proof (induction rule: mult_poly_p_induct)
  case (mult_step xs n p r)
  show ?case
    by (auto simp: algebra_simps polynomial_of_mset_mult_map)
qed

lemma rtranclp_mult_poly_p_mult_ideal:
  subgoal
    by (auto simp: ideal.span_zero)
  subgoal for a b aa ba
    apply (drule mult_poly_p_mult_ideal)
    apply (drule ideal.span_add)
    apply assumption
    by (auto simp: group_add_class.diff_add_eq_diff_diff_swap
        add.inverse_distrib_swap ac_simps add_diff_eq
      simp flip:  diff_add_eq_diff_diff_swap)
  done

lemma rtranclp_mult_poly_p_mult_ideal_final:
  by (drule rtranclp_mult_poly_p_mult_ideal) auto

lemma normalize_poly_p_poly_of_mset:
  apply (induction rule: normalize_poly_p.induct)
  apply (auto simp: Const_add algebra_simps)
  done


lemma rtranclp_normalize_poly_p_poly_of_mset:
  by (induction rule: rtranclp_induct)
    (auto simp: normalize_poly_p_poly_of_mset)

end


locale poly_embed_bij = poly_embed +
  fixes V N
begin


lemma \<phi>'_\<phi>[simp]:
  using \<phi>_bij unfolding \<phi>'_def
  by (meson bij_betw_imp_inj_on the_inv_into_f_f)

lemma \<phi>_\<phi>'[simp]:
  using \<phi>_bij unfolding \<phi>'_def
  by (meson f_the_inv_into_f_bij_betw)

end

end

