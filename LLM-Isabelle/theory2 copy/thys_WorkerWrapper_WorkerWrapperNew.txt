theory WorkerWrapperNew
imports
  HOLCF
  FixedPointTheorems
  WorkerWrapper
begin



lemma worker_wrapper_fusion_new:
  fixes wrap :: "'b::pcpo \<rightarrow> 'a::pcpo"
  fixes unwrap :: "'a \<rightarrow> 'b"
  fixes body' :: "'b \<rightarrow> 'b"
  assumes wrap_unwrap: "wrap oo unwrap = (ID :: 'a \<rightarrow> 'a)"
  assumes unwrap_strict: "unwrap\<cdot>\<bottom> = \<bottom>"
  assumes body_body': "unwrap oo body oo wrap = body' oo (unwrap oo wrap)"
  shows "fix\<cdot>body = wrap\<cdot>(fix\<cdot>body')"
proof -
  from body_body'
  have "unwrap oo body oo (wrap oo unwrap) = (body' oo unwrap oo (wrap oo unwrap))"
    by (simp add: assoc_oo)
  with wrap_unwrap have "unwrap oo body = body' oo unwrap"
    by simp
  with unwrap_strict have "unwrap\<cdot>(fix\<cdot>body) = fix\<cdot>body'"
    by (rule lfp_fusion)
  hence "(wrap oo unwrap)\<cdot>(fix\<cdot>body) = wrap\<cdot>(fix\<cdot>body')"
    by simp
  with wrap_unwrap show ?thesis by simp
qed


lemma worker_wrapper_fusion_new_general:
  fixes wrap :: "'b::pcpo \<rightarrow> 'a::pcpo"
  fixes unwrap :: "'a \<rightarrow> 'b"
  assumes wrap_unwrap: "wrap oo unwrap = (ID :: 'a \<rightarrow> 'a)"
  assumes unwrap_strict: "unwrap\<cdot>\<bottom> = \<bottom>"
  assumes body_body': "\<And>r. (unwrap oo wrap)\<cdot>r = r
                        \<Longrightarrow> (unwrap oo body oo wrap)\<cdot>r = body'\<cdot>r"
  shows "fix\<cdot>body = wrap\<cdot>(fix\<cdot>body')"
proof -
  let ?P = "\<lambda>(x, y). x = y \<and> unwrap\<cdot>(wrap\<cdot>x) = x"
  have "?P (fix\<cdot>(unwrap oo body oo wrap), (fix\<cdot>body'))"
  proof(induct rule: parallel_fix_ind)
    case 2 with retraction_strict unwrap_strict wrap_unwrap show "?P (\<bottom>, \<bottom>)"
      by (bestsimp simp add: cfun_eq_iff)
    case (3 x y)
    hence xy: "x = y" and unwrap_wrap: "unwrap\<cdot>(wrap\<cdot>x) = x" by auto
    from body_body' xy unwrap_wrap
    have "(unwrap oo body oo wrap)\<cdot>x = body'\<cdot>y"
      by simp
    moreover
    from wrap_unwrap
    have "unwrap\<cdot>(wrap\<cdot>((unwrap oo body oo wrap)\<cdot>x)) = (unwrap oo body oo wrap)\<cdot>x"
      by (simp add: cfun_eq_iff)
    ultimately show ?case by simp
  qed simp
  thus ?thesis
    using worker_wrapper_id[OF wrap_unwrap refl] by simp
qed


end
