theory Card_Equiv_Relations
imports
  Card_Partitions.Card_Partitions
  Bell_Numbers_Spivey.Bell_Numbers
begin




lemma equiv_quotient_eq_quotient_on_UNIV:
  assumes "equiv A R"
  shows "A // R = (UNIV // R) - {{}}"
proof
  show "UNIV // R - {{}} \<subseteq> A // R"
  proof
    fix X
    assume "X \<in> UNIV // R - {{}}"
    from this obtain x where "X = R `` {x}" and "X \<noteq> {}"
      by (auto elim!: quotientE)
    from this have "x \<in> A"
      by (auto intro!: quotientI)
  qed
next
  show "A // R \<subseteq> UNIV // R - {{}}"
  proof
    fix X
    assume "X \<in> A // R"
    from this have "X \<noteq> {}"
      by (metis UNIV_I assms proj_Eps proj_preserves)
    ultimately show "X \<in> UNIV // R - {{}}" by simp
  qed
qed


lemma equiv_relation_of_partition_of:
  assumes "equiv A R"
  shows "{(x, y). \<exists>X\<in>A // R. x \<in> X \<and> y \<in> X} = R"
proof
  show "{(x, y). \<exists>X\<in>A // R. x \<in> X \<and> y \<in> X} \<subseteq> R"
  proof
    fix xy
    assume "xy \<in> {(x, y). \<exists>X\<in>A // R. x \<in> X \<and> y \<in> X}"
    from this obtain x y and X where "xy = (x, y)"
      and "X \<in> A // R" and "x \<in> X" "y \<in> X"
      by auto
      by (auto elim: quotientE)
    show "xy \<in> R"
      by (simp add: equiv_class_eq_iff)
  qed
next
  show "R \<subseteq> {(x, y). \<exists>X\<in>A // R. x \<in> X \<and> y \<in> X}"
  proof
    fix xy
    assume "xy \<in> R"
    obtain x y where "xy = (x, y)" by fastforce
    have "R `` {x} \<in> A // R"
      by (simp add: equiv_class_eq_iff quotientI)
    moreover have "x \<in> R `` {x}"
      by (meson equiv_class_eq_iff equiv_class_self)
    moreover have "y \<in> R `` {x}"
    ultimately have "(x, y) \<in> {(x, y). \<exists>X\<in>A // R. x \<in> X \<and> y \<in> X}"
      by auto
    from this show "xy \<in> {(x, y). \<exists>X\<in>A // R. x \<in> X \<and> y \<in> X}"
  qed
qed


lemma bij_betw_partition_of:
  "bij_betw (\<lambda>R. A // R) {R. equiv A R} {P. partition_on A P}"
proof (rule bij_betw_byWitness[where f'="\<lambda>P. {(x, y). \<exists>X\<in>P. x \<in> X \<and> y \<in> X}"])
  show "\<forall>R\<in>{R. equiv A R}. {(x, y). \<exists>X\<in>A // R. x \<in> X \<and> y \<in> X} = R"
    by (simp add: equiv_relation_of_partition_of)
  show "\<forall>P\<in>{P. partition_on A P}. A // {(x, y). \<exists>X\<in>P. x \<in> X \<and> y \<in> X} = P"
    by (simp add: partition_on_eq_quotient)
  show "(\<lambda>R. A // R) ` {R. equiv A R} \<subseteq> {P. partition_on A P}"
    using partition_on_quotient by auto
  show "(\<lambda>P. {(x, y). \<exists>X\<in>P. x \<in> X \<and> y \<in> X}) ` {P. partition_on A P} \<subseteq> {R. equiv A R}"
    using equiv_partition_on by auto
qed

lemma bij_betw_partition_of_equiv_with_k_classes:
  "bij_betw (\<lambda>R. A // R) {R. equiv A R \<and> card (A // R) = k} {P. partition_on A P \<and> card P = k}"
proof (rule bij_betw_byWitness[where f'="\<lambda>P. {(x, y). \<exists>X\<in>P. x \<in> X \<and> y \<in> X}"])
  show "\<forall>R\<in>{R. equiv A R \<and> card (A // R) = k}. {(x, y). \<exists>X\<in>A // R. x \<in> X \<and> y \<in> X} = R"
    by (auto simp add: equiv_relation_of_partition_of)
  show "\<forall>P\<in>{P. partition_on A P \<and> card P = k}. A // {(x, y). \<exists>X\<in>P. x \<in> X \<and> y \<in> X} = P"
    by (auto simp add: partition_on_eq_quotient)
  show "(\<lambda>R. A // R) ` {R. equiv A R \<and> card (A // R) = k} \<subseteq> {P. partition_on A P \<and> card P = k}"
    using partition_on_quotient by auto
  show "(\<lambda>P. {(x, y). \<exists>X\<in>P. x \<in> X \<and> y \<in> X}) ` {P. partition_on A P \<and> card P = k} \<subseteq> {R. equiv A R \<and> card (A // R) = k}"
    using equiv_partition_on by (auto simp add: partition_on_eq_quotient)
qed


lemma finite_equiv:
  assumes "finite A"
  shows "finite {R. equiv A R}"
proof -
  have "bij_betw (\<lambda>R. A // R) {R. equiv A R} {P. partition_on A P}"
    by (rule bij_betw_partition_of)
  from this show "finite {R. equiv A R}"
qed


theorem card_equiv_rel_eq_card_partitions:
  "card {R. equiv A R} = card {P. partition_on A P}"
proof -
  have "bij_betw (\<lambda>R. A // R) {R. equiv A R} {P. partition_on A P}"
    by (rule bij_betw_partition_of)
  from this show "card {R. equiv A R} = card {P. partition_on A P}"
    by (rule bij_betw_same_card)
qed

corollary card_equiv_rel_eq_Bell:
  assumes "finite A"
  shows "card {R. equiv A R} = Bell (card A)"
using assms Bell_altdef card_equiv_rel_eq_card_partitions by force

corollary card_equiv_rel_eq_sum_Stirling:
  assumes "finite A"
  shows "card {R. equiv A R} = sum (Stirling (card A)) {..card A}"
using assms card_equiv_rel_eq_Bell Bell_Stirling_eq by simp

theorem card_equiv_k_classes_eq_card_partitions_k_parts:
  "card {R. equiv A R \<and> card (A // R) = k} = card {P. partition_on A P \<and> card P = k}"
proof -
  have "bij_betw (\<lambda>R. A // R) {R. equiv A R \<and> card (A // R) = k} {P. partition_on A P \<and> card P = k}"
    by (rule bij_betw_partition_of_equiv_with_k_classes)
  from this show "card {R. equiv A R \<and> card (A // R) = k} = card {P. partition_on A P \<and> card P = k}"
    by (rule bij_betw_same_card)
qed

corollary
  assumes "finite A"
  shows "card {R. equiv A R \<and> card (A // R) = k} = Stirling (card A) k"
using card_equiv_k_classes_eq_card_partitions_k_parts

end
