theory GlobalNdet                                               
  imports MultiNdet
begin 




proof -
      by (erule_tac x = STOP in allE) (simp add: Ndet_is_STOP_iff)
    with * have False
      by (erule_tac x = SKIP in allE) 
         (metis mono_Ndet_FD_right Ndet_commute 
                SKIP_FD_iff SKIP_Neq_STOP idem_FD)
  }
  thus ?thesis by blast
qed



proof -
  proof (split if_split, intro conjI impI)
      by (simp add: is_process_REP_STOP)
  next
      unfolding is_process_def FAILURES_def DIVERGENCES_def fst_conv snd_conv
    proof (intro conjI allI impI)
    next
        using is_processT2 by blast
    next
        using is_processT3 by blast
    next
        using is_processT4 by blast
    next
        using is_processT5 by simp blast
    next
        using is_processT6 by blast
    next
        using is_processT7 by blast
    next
        using is_processT8 by blast
    next
        using is_processT9 by blast
    qed
  qed
qed
  
  


translations  "\<sqinter> p \<in> A. P " \<rightleftharpoons> "CONST GlobalNdet A (\<lambda>p. P)"

     is different from the multi-non-deterministic prefix
     its choice via an internal prefix operator.

     It is also subtly different from the multi-non-deterministic choice

  by (simp add: GlobalNdet.abs_eq STOP_def)




lemma F_GlobalNdet:
  by (simp add: Failures_def FAILURES_def GlobalNdet.rep_eq)

lemma D_GlobalNdet:
  by (simp add: Divergences_def DIVERGENCES_def GlobalNdet.rep_eq)

lemma T_GlobalNdet:
  by (auto simp add: Traces_def TRACES_def Failures_def[symmetric] 
                     F_GlobalNdet intro: F_T T_F)
 

lemma mono_GlobalNdet_eq:
  by (subst Process_eq_spec, simp add: F_GlobalNdet D_GlobalNdet)

lemma mono_GlobalNdet_eq2:
  by (subst Process_eq_spec, simp add: F_GlobalNdet D_GlobalNdet)





lemma GlobalNdet_factorization_union:
  by (subst Process_eq_spec) (simp add: F_GlobalNdet D_GlobalNdet F_Ndet D_Ndet)
 




  using is_processT2
  by (subst Process_eq_spec)
     (auto simp add: F_GlobalNdet D_GlobalNdet F_UU D_UU D_imp_front_tickFree)


  by (simp add: BOT_iff_D D_GlobalNdet)
  



  by (subst Process_eq_spec) (simp add: F_GlobalNdet D_GlobalNdet)




  by(auto simp : Process_eq_spec F_GlobalNdet D_GlobalNdet)


lemma GlobalNdet_distrib_unit:
  by (metis GlobalNdet_factorization_union GlobalNdet_unit 
            empty_not_insert insert_Diff_single insert_is_Un)




lemma GlobalNdet_Ndet:
  by (auto simp add: Process_eq_spec F_GlobalNdet D_GlobalNdet F_Ndet D_Ndet)




lemma GlobalNdet_sets_commute:
  by (auto simp add: Process_eq_spec F_GlobalNdet D_GlobalNdet 
                     F_Ndet D_Ndet F_STOP D_STOP)




lemma inj_on_mapping_over_GlobalNdet: 
  by (simp add: Process_eq_spec F_GlobalNdet D_GlobalNdet
                F_Ndet D_Ndet F_STOP D_STOP)







lemma GlobalNdet_cartprod_\<sigma>s_set_\<sigma>s_set:
  apply (subst Process_eq_spec, simp add: F_GlobalNdet D_GlobalNdet)
  by safe auto


lemma GlobalNdet_cartprod_s_set_\<sigma>s_set:
  apply (subst Process_eq_spec, simp add: F_GlobalNdet D_GlobalNdet)
  by safe auto


lemma GlobalNdet_cartprod_s_set_s_set:
  apply (subst Process_eq_spec, simp add: F_GlobalNdet D_GlobalNdet)
  by safe auto


  apply (subst Process_eq_spec, simp add: F_GlobalNdet D_GlobalNdet)
  by safe auto
  

  


lemma finite_GlobalNdet_is_MultiNdet:
  by (simp add: Process_eq_spec F_GlobalNdet F_MultiNdet D_GlobalNdet D_MultiNdet)


      (and this is a necessary hypothesis for continuity).\<close>
  \<open>\<lbrakk>finite A; \<forall>x. cont (f x)\<rbrakk> \<Longrightarrow> cont (\<lambda>y. (\<sqinter> z \<in> A. (f z y)))\<close>
section \<open>Link with \<^const>\<open>Mndetprefix\<close>\<close>
text \<open>This is a trick to make proof of \<^const>\<open>Mndetprefix\<close> using
      \<^const>\<open>GlobalNdet\<close> as it has an easier denotational definition.\<close>
lemma Mndetprefix_GlobalNdet: \<open>\<sqinter> x \<in> A \<rightarrow> P x = \<sqinter> x \<in> A. (x \<rightarrow> P x)\<close>
  apply (cases \<open>A = {}\<close>, simp)
  \<open>A \<noteq> {} \<Longrightarrow> (\<sqinter> x\<in>A. (a \<rightarrow> P x)) = (a \<rightarrow> (\<sqinter> x\<in>A. P x))\<close>
section \<open>Properties\<close>
  \<open>A \<noteq> {} \<Longrightarrow> (\<sqinter> a \<in> A. P a) \<box> Q = \<sqinter> a \<in> A. P a \<box> Q\<close>
lemma Mndetprefix_STOP: \<open>A \<subseteq> C \<Longrightarrow> (\<sqinter> a \<in> A \<rightarrow> P a) \<lbrakk>C\<rbrakk> STOP = STOP\<close>
  show \<open>s \<in> {[]} \<Longrightarrow> s \<in> \<T> (Mndetprefix A P \<lbrakk>C\<rbrakk> STOP)\<close> for s
  show \<open>A \<subseteq> C \<Longrightarrow> s \<in> \<T> (Mndetprefix A P \<lbrakk>C\<rbrakk> STOP) \<Longrightarrow> s \<in> {[]}\<close> for s
  \<open>A \<noteq> {} \<Longrightarrow> (\<sqinter> x \<in> A. P x) \<lbrakk> C \<rbrakk> Q = \<sqinter> x \<in> A. (P x \<lbrakk> C \<rbrakk> Q)\<close>
                    F_GlobalNdet D_GlobalNdet D_Sync F_Sync) \<comment> \<open>takes some seconds\<close>
  \<open>\<lbrakk>A \<subseteq> B; B \<subseteq> C\<rbrakk> \<Longrightarrow> (\<sqinter> a \<in> A \<rightarrow> P a) \<lbrakk> C \<rbrakk> (\<box> b \<in> B \<rightarrow> Q b) =
                      \<sqinter> a \<in> A \<rightarrow> (P a \<lbrakk> C \<rbrakk> Q a)\<close>
  \<comment> \<open>does not hold in general when \<^term>\<open>A \<subseteq> C\<close>\<close>
  apply (cases \<open>A = {}\<close>, simp,
  apply (cases \<open>B = {}\<close>, simp add: Mprefix_STOP Mndetprefix_STOP)
  \<open>A \<subseteq> B \<Longrightarrow> ((\<sqinter> a \<in> A \<rightarrow> P a) || (\<box> b \<in> B \<rightarrow> Q b)) = \<sqinter> a \<in> A \<rightarrow> P a || Q a\<close>
  \<open>(\<sqinter> a \<in> A \<rightarrow> (P a \<lbrakk> C \<rbrakk> (\<sqinter> b \<in> B \<rightarrow> Q b))) \<box>
   (\<sqinter> b \<in> B \<rightarrow> ((\<sqinter> a \<in> A \<rightarrow> P a) \<lbrakk> C \<rbrakk> Q b))
   \<sqsubseteq>\<^sub>F\<^sub>D (\<sqinter> a \<in> A \<rightarrow> P a) \<lbrakk> C \<rbrakk> (\<sqinter> b \<in> B \<rightarrow> Q b)\<close>
  if set_hyps : \<open>A \<noteq> {}\<close> \<open>B \<noteq> {}\<close> \<open>A \<inter> C = {}\<close> \<open>B \<inter> C = {}\<close>
   \<comment> \<open>both surprising: equality does not hold + deterministic choice\<close>
    \<open>\<And>P Q A. \<forall>x \<in> A. P x \<sqsubseteq>\<^sub>F\<^sub>D Q x \<Longrightarrow> GlobalNdet A P \<sqsubseteq>\<^sub>F\<^sub>D GlobalNdet A Q\<close>
  have * : \<open>a \<in> A \<Longrightarrow> b \<in> B \<Longrightarrow>
           (\<sqinter>b \<in> B.  (a \<rightarrow> (P a \<lbrakk>C\<rbrakk> (b \<rightarrow> Q b)))) \<box>
           (\<sqinter>a \<in> A.  (b \<rightarrow> ((a \<rightarrow> P a) \<lbrakk>C\<rbrakk> Q b))) \<sqsubseteq>\<^sub>F\<^sub>D
           (a \<rightarrow> P a) \<lbrakk>C\<rbrakk> (b \<rightarrow> Q b)\<close> for a b
    apply (subst Mprefix_Sync_distr_indep[of \<open>{a}\<close> C \<open>{b}\<close>, unfolded Mprefix_singl])
  have \<open>(\<sqinter>a \<in> A. \<sqinter>b \<in> B. (a \<rightarrow> (P a \<lbrakk>C\<rbrakk> (b \<rightarrow> Q b)))) \<box>
        (\<sqinter>b \<in> B. \<sqinter>a \<in> A. (b \<rightarrow> ((a \<rightarrow> P a) \<lbrakk>C\<rbrakk> Q b))) \<sqsubseteq>\<^sub>F\<^sub>D
        \<sqinter>b \<in> B. \<sqinter>a \<in> A.  ((a \<rightarrow> P a) \<lbrakk>C\<rbrakk> (b \<rightarrow> Q b))\<close>
  \<open>A \<noteq> {} \<Longrightarrow> (\<sqinter> a \<in> A. \<box> b \<in> B \<rightarrow> P a b) = \<box> b \<in> B \<rightarrow> (\<sqinter> a \<in> A. P a b)\<close>
  \<open>(\<sqinter> a \<in> A. P a \<box> Q a) = (\<sqinter> a \<in> A. P a) \<box> (\<sqinter> a \<in> A. Q a)\<close>
  if \<open>\<exists>Q' b. \<forall>a. Q a = (b \<rightarrow> Q' a)\<close>
  from that obtain b Q' where \<open>\<forall>a. (Q a = (b \<rightarrow> Q' a))\<close> by blast
    apply (cases \<open>A = {}\<close>, simp add: Det_STOP)
