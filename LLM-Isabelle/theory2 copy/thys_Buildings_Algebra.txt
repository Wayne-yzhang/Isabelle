  In this section, we develop the necessary algebra for developing the theory of Coxeter systems,
  including groups, quotient groups, free groups, group presentations, and words in a group over a
  set of generators.
\<close>
subsection \<open>Miscellaneous algebra facts\<close>
subsection \<open>The type of permutations of a type\<close>
text \<open>
  Here we construct a type consisting of all bijective functions on a type. This is the
  prototypical example of a group, where the group operation is composition, and every group can
  be embedded into such a type. It is for this purpose that we construct this type, so that we may
  confer upon suitable subsets of types that are not of class @{class group_add} the properties of
  that class, via a suitable injective correspondence to this permutation type.
\<close>
subsection \<open>Natural action of @{typ nat} on types of class @{class monoid_add}\<close>
subsubsection \<open>Translation from class @{class power}.\<close>
text \<open>
  Here we translate the @{class power} class to apply to types of class @{class monoid_add}.
\<close>
subsubsection \<open>Additive order of an element\<close>
subsection \<open>Partial sums of a list\<close>
text \<open>
  Here we construct a list that collects the results of adding the elements of a given list
  together one-by-one.
\<close>
subsection \<open>Sums of alternating lists\<close>
subsection \<open>Conjugation in @{class group_add}\<close>
subsubsection \<open>Abbreviations and basic facts\<close>
subsubsection \<open>The conjugation sequence\<close>
text \<open>
  Given a list in @{class group_add}, we create a new list by conjugating each term by all the
  previous terms. This sequence arises in Coxeter systems.
\<close>
subsubsection \<open>The action on signed @{class group_add} elements\<close>
text \<open>
  Here we construct an action of a group on itself by conjugation, where group elements are
  endowed with an auxiliary sign by pairing with a boolean element. In multiple applications of
  this action, the auxiliary sign helps keep track of how many times the elements conjugating and
  being conjugated are the same. This action arises in exploring reduced expressions of group
  elements as words in a set of generators of order two (in particular, in a Coxeter group).
\<close>
  \<comment> \<open>so the sign of @{term x} is flipped precisely when its first component is equal to
@{term s}\<close>
subsection \<open>Cosets\<close>
subsubsection \<open>Basic facts\<close>
\<comment> \<open>lemma @{text "Set_Algebras.set_zero_plus"} is restricted to types of class
@{class comm_monoid_add}; here is a version in @{class monoid_add}.\<close>
subsubsection \<open>The supset order on cosets\<close>
subsubsection \<open>The afforded partition\<close>
subsection \<open>Groups\<close>
text \<open>We consider groups as closed sets in a type of class @{class group_add}.\<close>
subsubsection \<open>Locale definition and basic facts\<close>
subsubsection \<open>Sets with a suitable binary operation\<close>
text \<open>
  We have chosen to only consider groups in types of class @{class group_add} so that we can take
  advantage of all the algebra lemmas already proven in @{theory HOL.Groups}, as well as
  constructs like @{const sum_list}. The following locale builds a bridge between this restricted
  view of groups and the usual notion of a binary operation on a set satisfying the group axioms,
  by constructing an injective map into type @{type permutation} (which is of class
  @{class group_add} with respect to the composition operation) that respects the group operation.
  This bridge will be necessary to define quotient groups, in particular.
\<close>
abbreviation "\<pp> \<equiv> Abs_G_perm" \<comment> \<open>the injection into type @{type permutation}\<close>
abbreviation "\<ii>\<pp> \<equiv> the_inv_into G \<pp>" \<comment> \<open>the reverse correspondence\<close>
abbreviation "pG \<equiv> \<pp>`G" \<comment> \<open>the resulting @{const Group} of type @{type permutation}\<close>
subsubsection \<open>Cosets of a @{const Group}\<close>
subsubsection \<open>The @{const Group} generated by a set\<close>
      genby_0_closed     : "0\<in>\<langle>S\<rangle>"  \<comment> \<open>just in case @{term S} is empty\<close>
subsubsection \<open>Homomorphisms and isomorphisms\<close>
text \<open>
  In a @{const BinOpSetGroup}, any map from the set into a type of class @{class group_add} that respects the
  binary operation induces a @{const GroupHom}.
\<close>
subsubsection \<open>Normal subgroups\<close>
subsubsection \<open>Quotient groups\<close>
text \<open>
  Here we use the bridge built by @{const BinOpSetGroup} to make the quotient of a @{const Group}
  by a normal subgroup into a @{const Group} itself.
\<close>
subsubsection \<open>The induced homomorphism on a quotient group\<close>
text \<open>
  A normal subgroup contained in the kernel of a homomorphism gives rise to a homomorphism on the
  quotient group by that subgroup. When the subgroup is the kernel itself (which is always normal),
  we obtain an isomorphism on the quotient.
\<close>
subsection \<open>Free groups\<close>
subsubsection \<open>Words in letters of @{type signed} type\<close>
paragraph \<open>Definitions and basic fact\<close>
text \<open>
  We pair elements of some type with type @{typ bool}, where the @{typ bool} part of the pair
  indicates inversion.
\<close>
text \<open>
  A word in such pairs will be considered proper if it does not contain consecutive letters that
  have opposite signs (and so are considered inverse), since such consecutive letters would be
  cancelled in a group.
\<close>
paragraph \<open>Algebra\<close>
text \<open>
  Addition is performed by appending words and recursively removing any newly created adjacent
  pairs of inverse letters. Since we will only ever be adding proper words, we only need to care
  about newly created adjacent inverse pairs in the middle.
\<close>
subsubsection \<open>The collection of proper signed lists as a type\<close>
text \<open>
  Here we create a type out of the collection of proper signed lists. This type will be of class
  @{class group_add}, with the empty list as zero, the modified append operation
  @{const prappend_signed_list} as addition, and inversion performed by flipping the signs of the
  elements in the list and then reversing the order.
\<close>
paragraph \<open>Type definition, instantiations, and instances\<close>
text \<open>Here we define the type and instantiate it with respect to various type classes.\<close>
text \<open>
  These two functions act as the natural injections of letters and words in the letter type into
  the @{type freeword} type.
\<close>
paragraph \<open>Basic algebra and transfer facts in the @{type freeword} type\<close>
text \<open>
  Here we record basic algebraic manipulations for the @{type freeword} type as well as various
  transfer facts for dealing with representations of elements of @{type freeword} type as lists of
  signed letters.
\<close>
subsubsection \<open>Lifts of functions on the letter type\<close>
text \<open>
  Here we lift functions on the letter type to type @{type freeword}. In particular, we are
  interested in the case where the function being lifted has codomain of class @{class group_add}.
\<close>
paragraph \<open>The universal property\<close>
text \<open>
  The universal property for free groups says that every function from the letter type to some
  @{class group_add} type gives rise to a unique homomorphism.
\<close>
paragraph \<open>Properties of homomorphisms afforded by the universal property\<close>
text \<open>
  The lift of a function on the letter set is the unique additive function on @{type freeword}
  that agrees with the original function on letters.
\<close>
subsubsection \<open>Free groups on a set\<close>
text \<open>
  We now take the free group on a set to be the set in the @{type freeword} type with letters
  restricted to the given set.
\<close>
paragraph \<open>Definition and basic facts\<close>
text \<open>
  Here we define the set of elements of the free group over a set of letters, and record basic
  facts about that set.
\<close>
paragraph \<open>Lifts of functions from the letter set to some type of class @{class group_add}\<close>
text \<open>
  We again obtain a universal property for functions from the (restricted) letter set to some type
  of class @{class group_add}.
\<close>
subsubsection \<open>Group presentations\<close>
text \<open>
  We now define a group presentation to be the quotient of a free group by the subgroup generated by
  all conjugates of a set of relators. We are most concerned with lifting functions on the letter
  set to the free group and with the associated induced homomorphisms on the quotient.
\<close>
paragraph \<open>A first group presentation locale and basic facts\<close>
text \<open>
  Here we define a locale that provides a way to construct a group by providing sets of generators
  and relator words.
\<close>
  fixes   S :: "'a set"  \<comment> \<open>the set of generators\<close>
  and     P :: "'a signed list set" \<comment> \<open>the set of relator words\<close>
abbreviation "P' \<equiv> Abs_freeword ` P" \<comment> \<open>the set of relators\<close>
\<comment> \<open>the normal subgroup generated by relators inside the free group\<close>
paragraph \<open>Functions on the quotient induced from lifted functions\<close>
text \<open>
  A function on the generator set into a type of class @{class group_add} lifts to a unique
  homomorphism on the free group. If this lift is trivial on relators, then it factors to a
  homomorphism of the group described by the generators and relators.
\<close>
  and     P :: "'a signed list set" \<comment> \<open>the set of relator words\<close>
  \<comment> \<open>the @{const restrict0} operation is really only necessary to make
@{const GroupByPresentationInducedFun.induced_hom} a @{const GroupHom}\<close>
\<comment> \<open>algebraic properties of the induced homomorphism could be proved using its properties as a group
  homomorphism, but it's generally easier to prove them using the algebraic properties of the lift
  via this lemma\<close>
paragraph \<open>Groups affording a presentation\<close>
text \<open>
  The locale @{const GroupByPresentation} allows the construction of a @{const Group} out of any
  type from a set of generating letters and a set of relator words in (signed) letters. The
  following locale concerns the question of when the @{const Group} generated by a set in class
  @{class group_add} is isomorphic to a group presentation.
\<close>
  fixes S :: "'g::group_add set" \<comment> \<open>the set of generators\<close>
  and   R :: "'g list set" \<comment> \<open>the set of relator words\<close>
\<comment> \<open>this maps R onto P'\<close>
text \<open>
  Here we record that the lift of the identity map to the free group on @{term S} induces a
  homomorphic surjection onto the group generated by @{term S} from the group presentation on
  @{term S}, subject to the same relations as the elements of @{term S}.
\<close>
  for S :: "'g::group_add set" \<comment> \<open>the set of generators\<close>
  and R :: "'g list set" \<comment> \<open>the set of relator words\<close>
subsection \<open>Words over a generating set\<close>
text \<open>
  Here we gather the necessary constructions and facts for studying a group generated by some set
  in terms of words in the generators.
\<close>
  \<comment> \<open>will be empty if @{term a} is not in the set generated by @{term A}\<close>
