theory Sequent_Calculus_Verifier imports Sequent1 SeCaV begin

primrec from_tm and from_tm_list where

primrec from_fm where

primrec to_tm and to_tm_list where

primrec to_fm where

  by (induct t and ts rule: from_tm.induct from_tm_list.induct) simp_all

  by (induct p) simp_all

  using AlphaImp Basic Ext ext.simps member.simps(2) by metis

lemma paramst [simp]:
  by (induct t and l rule: FOL_Fitting.paramst.induct FOL_Fitting.paramsts.induct) simp_all

  by (induct p) simp_all

  by (induct z) simp_all

lemma liftt [simp]:
  by (induct t and l rule: FOL_Fitting.liftt.induct FOL_Fitting.liftts.induct) simp_all

lemma substt [simp]:
  by (induct t and l rule: FOL_Fitting.substt.induct FOL_Fitting.substts.induct) simp_all

  by (induct A arbitrary: t s) simp_all

  by (induct rule: SC.induct) (force intro: sequent_calculus.intros)+

lemma evalt [simp]:
  by (induct t and ts rule: from_tm.induct from_tm_list.induct) simp_all

  unfolding shift_def FOL_Fitting.shift_def by simp

  by (induct p arbitrary: e) simp_all

abbreviation valid ("\<then> _" 0) where

  by (metis to_from_fm sim semantics list.map SC_completeness) (use sound in force)

  using complete_sound by fast



end
