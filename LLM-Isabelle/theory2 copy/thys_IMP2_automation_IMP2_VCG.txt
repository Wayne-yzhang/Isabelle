theory IMP2_VCG
imports IMP2_Basic_Simpset IMP2_Program_Analysis IMP2_Var_Postprocessor IMP2_Var_Abs
begin


  lemma HT'_I[vcg_preprocess_rules]:
    assumes "\<And>\<ss>\<^sub>0. \<lbrakk> P \<ss>\<^sub>0 \<rbrakk> \<Longrightarrow> wp \<pi> (c \<ss>\<^sub>0) (Q \<ss>\<^sub>0) \<ss>\<^sub>0"
    shows "HT' \<pi> P c Q"
    using assms
    unfolding BB_PROTECT_def HT'_def by auto
  
  lemma HT'_partial_I[vcg_preprocess_rules]:
    assumes "\<And>\<ss>\<^sub>0. \<lbrakk> P \<ss>\<^sub>0 \<rbrakk> \<Longrightarrow> wlp \<pi> (c \<ss>\<^sub>0) (Q \<ss>\<^sub>0) \<ss>\<^sub>0"
    shows "HT'_partial \<pi> P c Q"
    using assms
    unfolding BB_PROTECT_def HT'_partial_def by auto
  
    
  lemmas [vcg_preprocess_rules] = allI impI conjI
    
  method i_vcg_preprocess = 
    (intro vcg_preprocess_rules)?



  
  definition GOAL_INDICATION :: "'a \<Rightarrow> bool" ("\<paragraph>_" [1000])
    where "GOAL_INDICATION _ \<equiv> True"
  
  lemma move_goal_indication_to_front[simp, named_ss vcg_bb]: 
    "NO_MATCH (\<paragraph>x) P \<Longrightarrow> (P\<Longrightarrow>\<paragraph>n\<Longrightarrow>PROP Q) \<equiv> (\<paragraph>n \<Longrightarrow> P \<Longrightarrow> PROP Q)"  
    by (rule swap_prems_eq)
