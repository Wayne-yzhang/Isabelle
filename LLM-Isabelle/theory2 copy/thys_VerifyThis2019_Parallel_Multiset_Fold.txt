theory Parallel_Multiset_Fold
  imports "HOL-Library.Multiset"
begin



lemma (in comp_fun_commute) fold_mset_rewr: "fold_mset f a (mset l) = fold f l a" 
  by (induction l arbitrary: a; clarsimp; metis fold_mset_fun_left_comm)

lemma finite_set_of_finite_maps:
  fixes A :: "'a set"
    and B :: "'b set"
  assumes "finite A"
    and "finite B"
  shows "finite {m. dom m \<subseteq> A \<and> ran m \<subseteq> B}"
proof -
  have "{m. dom m \<subseteq> A \<and> ran m \<subseteq> B} \<subseteq> (\<Union> S \<in> {S. S \<subseteq> A}. {m. dom m = S \<and> ran m \<subseteq> B})"
    by auto
  moreover have "finite \<dots>"
    using assms by (auto intro!: finite_set_of_finite_maps intro: finite_subset)
  ultimately show ?thesis
    by (rule finite_subset)
qed

lemma wf_rtranclp_ev_induct[consumes 1, case_names step]:
  assumes "wf {(x, y). R y x}" and step: "\<And> x. R\<^sup>*\<^sup>* a x \<Longrightarrow> P x \<or> (\<exists> y. R x y)"
  shows "\<exists>x. P x \<and> R\<^sup>*\<^sup>* a x"
proof -
  have "\<exists>y. P y \<and> R\<^sup>*\<^sup>* x y" if "R\<^sup>*\<^sup>* a x" for x
    using assms(1) that
  proof induction
    case (less x)
    then show ?case
    proof
      assume "P x"
      then show ?case
        by auto
    next
      assume "\<exists>y. R x y"
      then obtain y where "R x y" ..
      with less(1)[of y] less(2) show ?thesis
        by simp (meson converse_rtranclp_into_rtranclp rtranclp.rtrancl_into_rtrancl)
    qed
  qed
  then show ?thesis
    by blast
qed

type_synonym ('a, 's) state = "'a list \<times> (nat \<rightharpoonup> 'a) \<times> 's"

context comp_fun_commute
begin

context
  assumes n_gt_0[simp, intro]: "n > 0"
begin

