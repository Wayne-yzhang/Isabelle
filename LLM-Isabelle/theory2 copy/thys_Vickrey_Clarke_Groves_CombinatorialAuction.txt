theory CombinatorialAuction

imports
UniformTieBreaking

begin


abbreviation "participants b == Domain (Domain b)"

abbreviation "goods == sorted_list_of_set o Union o Range o Domain"

abbreviation "seller == (0::integer)"

abbreviation "allAllocations' N \<Omega> == 
  injectionsUniverse \<inter> {a. Domain a \<subseteq> N & Range a \<in> all_partitions \<Omega>}" 

abbreviation "allAllocations'' N \<Omega> == allocationsUniverse \<inter> {a. Domain a \<subseteq> N & \<Union>(Range a) = \<Omega>}"

lemma allAllocationsEquivalence: 
  "allAllocations N \<Omega> = allAllocations' N \<Omega> & allAllocations N \<Omega> = allAllocations'' N \<Omega>" 
  using allocationInjectionsUnivervseProperty allAllocationsIntersection by metis

lemma allAllocationsVarCharacterization: 
  "(a \<in> allAllocations'' N \<Omega>) = (a \<in> allocationsUniverse& Domain a \<subseteq> N & \<Union>(Range a) = \<Omega>)" 
  by force

abbreviation "soldAllocations N \<Omega> == (Outside' {seller}) ` (allAllocations (N \<union> {seller}) \<Omega>)"

abbreviation "soldAllocations' N \<Omega> == (Outside' {seller}) ` (allAllocations' (N \<union> {seller}) \<Omega>)"
abbreviation "soldAllocations'' N \<Omega> == (Outside' {seller}) ` (allAllocations'' (N \<union> {seller}) \<Omega>)"
abbreviation "soldAllocations''' N \<Omega> == 
  allocationsUniverse \<inter> {aa. Domain aa\<subseteq>N-{seller} & \<Union>(Range aa)\<subseteq>\<Omega>}"
lemma soldAllocationsEquivalence: 
  "soldAllocations N \<Omega> = soldAllocations' N \<Omega> & 
   soldAllocations' N \<Omega> = soldAllocations'' N \<Omega>"
  using allAllocationsEquivalence by metis

corollary soldAllocationsEquivalenceVariant: 
  "soldAllocations = soldAllocations'  & 
   soldAllocations' = soldAllocations'' & 
   soldAllocations = soldAllocations''" 
  using soldAllocationsEquivalence by metis

lemma allocationSellerMonotonicity: 
  "soldAllocations (N-{seller}) \<Omega> \<subseteq> soldAllocations N \<Omega>" 
  using Outside_def by simp

lemma allocationsUniverseCharacterization: 
  "(a \<in> allocationsUniverse) = (a \<in> allAllocations'' (Domain a) (\<Union>(Range a)))"
  by blast

lemma allocationMonotonicity: 
  assumes "N1 \<subseteq> N2" 
  shows "allAllocations'' N1 \<Omega> \<subseteq> allAllocations'' N2 \<Omega>" 
  using assms by auto

lemma allocationWithOneParticipant: 
  assumes "a \<in> allAllocations'' N \<Omega>" 
  shows "Domain (a -- x) \<subseteq> N-{x}" 
  using assms Outside_def by fastforce

lemma soldAllocationIsAllocation: 
  assumes "a \<in> soldAllocations N \<Omega>" 
  shows "a \<in> allocationsUniverse"
proof -
obtain aa where "a  =aa -- seller & aa \<in> allAllocations (N\<union>{seller}) \<Omega>"
  using assms by blast
then have "a \<subseteq> aa & aa \<in> allocationsUniverse" 
  unfolding Outside_def using allAllocationsIntersectionSubset by blast
then show ?thesis using subsetAllocation by blast
qed

lemma soldAllocationIsAllocationVariant: 
  assumes "a \<in> soldAllocations N \<Omega>" 
  shows "a \<in> allAllocations'' (Domain a) (\<Union>(Range a))"
proof - 
  show ?thesis using assms soldAllocationIsAllocation
  by auto blast+
qed

lemma onlyGoodsAreSold: 
  assumes "a \<in> soldAllocations'' N \<Omega>" 
  shows "\<Union> (Range a) \<subseteq> \<Omega>" 
  using assms Outside_def by blast

lemma soldAllocationIsRestricted: 
  "a \<in> soldAllocations'' N \<Omega> = 
   (\<exists>aa. aa -- (seller) = a  \<and>  aa \<in> allAllocations'' (N \<union> {seller}) \<Omega>)" 
  by blast

lemma restrictionConservation:
  "(R +* ({x}\<times>Y)) -- x = R -- x" 
  unfolding Outside_def paste_def by blast

lemma allocatedToBuyerMeansSold: 
  assumes "a \<in> allocationsUniverse" "Domain a \<subseteq> N-{seller}" "\<Union> (Range a) \<subseteq> \<Omega>" 
  shows "a \<in> soldAllocations'' N \<Omega>"
proof -
  let ?i = "seller" 
  let ?Y = "{\<Omega>-\<Union> (Range a)}-{{}}" 
  let ?b = "{?i}\<times>?Y" 
  let ?aa = "a\<union>?b"
  let ?aa' = "a +* ?b" 
  have
  1: "a \<in> allocationsUniverse" using assms(1) by fast 
  have "?b \<subseteq> {(?i,\<Omega>-\<Union>(Range a))} - {(?i, {})}" by fastforce 
  then have 
  2: "?b \<in> allocationsUniverse" 
    using allocationUniverseProperty subsetAllocation by (metis(no_types))
  have 
  3: "\<Union> (Range a) \<inter> \<Union> (Range ?b) = {}" by blast 
  have 
  4: "Domain a \<inter> Domain ?b ={}" using assms by fast
  have "?aa \<in> allocationsUniverse" using 1 2 3 4 by (rule allocationUnion)
  then have "?aa \<in> allAllocations'' (Domain ?aa) (\<Union> (Range ?aa))" 
    unfolding allocationsUniverseCharacterization by metis 
  then have "?aa \<in> allAllocations'' (N\<union>{?i}) (\<Union> (Range ?aa))" 
    using allocationMonotonicity assms paste_def by auto
  moreover have "Range ?aa = Range a \<union> ?Y" by blast 
  then moreover have "\<Union> (Range ?aa) = \<Omega>" 
    using Un_Diff_cancel Un_Diff_cancel2 Union_Un_distrib Union_empty Union_insert  
    by (metis (lifting, no_types) assms(3) cSup_singleton subset_Un_eq) 
  moreover have "?aa' = ?aa" using 4 by (rule paste_disj_domains)
  ultimately have "?aa' \<in> allAllocations'' (N\<union>{?i}) \<Omega>" by simp
  moreover have "Domain ?b \<subseteq> {?i}" by fast 
  have "?aa' -- ?i = a -- ?i" by (rule restrictionConservation)
  moreover have "... = a" using Outside_def assms(2) by auto 
  ultimately show ?thesis using soldAllocationIsRestricted by auto
qed

lemma allocationCharacterization: 
  "a \<in> allAllocations N \<Omega>  =  
   (a \<in> injectionsUniverse & Domain a \<subseteq> N & Range a \<in> all_partitions \<Omega>)" 
  by (metis (full_types) posssibleAllocationsRelCharacterization)

lemma lm01: 
  assumes "a \<in> soldAllocations'' N \<Omega>" 
  shows "Domain a \<subseteq> N-{seller} & a \<in> allocationsUniverse"  
proof -
  let ?i = "seller" 
  obtain aa where
  0: "a = aa -- ?i & aa \<in> allAllocations'' (N \<union> {?i}) \<Omega>" 
    using assms(1) soldAllocationIsRestricted by blast
  then have "Domain aa \<subseteq> N \<union> {?i}" using allocationCharacterization by blast
  then have "Domain a \<subseteq> N - {?i}" using 0 Outside_def by blast
  moreover have "a \<in> soldAllocations N \<Omega>" using assms soldAllocationsEquivalenceVariant by metis
  then moreover have "a \<in> allocationsUniverse" using soldAllocationIsAllocation by blast
  ultimately show ?thesis by blast
qed

corollary lm02: 
  assumes "a \<in> soldAllocations'' N \<Omega>" 
  shows "a \<in> allocationsUniverse & Domain a \<subseteq> N-{seller} & \<Union> (Range a) \<subseteq> \<Omega>"
proof -
  have "a \<in> allocationsUniverse" using assms lm01 [of a] by blast
  moreover have "Domain a \<subseteq> N-{seller}" using assms lm01 by blast
  moreover have "\<Union> (Range a) \<subseteq> \<Omega>" using assms onlyGoodsAreSold by blast
  ultimately show ?thesis by blast
qed

corollary lm03:
  "(a \<in> soldAllocations'' N \<Omega>) =
   (a \<in> allocationsUniverse & a \<in> {aa. Domain aa \<subseteq> N-{seller} & \<Union> (Range aa) \<subseteq> \<Omega>})" 
  (is "?L = ?R") 
proof -
  have "(a\<in>soldAllocations'' N \<Omega>) =
        (a\<in>allocationsUniverse& Domain a \<subseteq> N-{seller} & \<Union> (Range a) \<subseteq> \<Omega>)" 
  using lm02 allocatedToBuyerMeansSold by (metis (mono_tags))
  then have "?L = (a\<in>allocationsUniverse& Domain a \<subseteq> N-{seller} & \<Union> (Range a) \<subseteq> \<Omega>)" by fast
  moreover have "... = ?R" using mem_Collect_eq by (metis (lifting, no_types))
  ultimately show ?thesis by auto
qed

corollary lm04: 
  "a \<in> soldAllocations'' N \<Omega> =
   (a\<in> (allocationsUniverse \<inter> {aa. Domain aa \<subseteq> N-{seller} & \<Union> (Range aa) \<subseteq> \<Omega>}))" 
  using lm03 by (metis (mono_tags) Int_iff)

corollary soldAllocationVariantEquivalence: 
  "soldAllocations'' N \<Omega> = soldAllocations''' N \<Omega>" 
  (is "?L=?R") 
proof - 
  {
   fix a 
   have "a \<in> ?L = (a \<in> ?R)" by (rule lm04)
  } 
  thus ?thesis by blast 
qed

lemma lm05: 
  assumes "a \<in> soldAllocations''' N \<Omega>" 
  shows "a -- n \<in> soldAllocations''' (N-{n}) \<Omega>"
proof -
  let ?bb = seller 
  let ?d = Domain 
  let ?r = Range 
  let ?X1 = "{aa. ?d aa \<subseteq> N-{n}-{?bb} & \<Union>(?r aa)\<subseteq>\<Omega>}" 
  let ?X2 = "{aa. ?d aa \<subseteq> N-{?bb} & \<Union>(?r aa) \<subseteq> \<Omega>}" 
  have "a\<in>?X2" using assms(1) by fast  
  then have 
  0: "?d a \<subseteq> N-{?bb} & \<Union>(?r a) \<subseteq> \<Omega>" by blast 
  then have "?d (a--n) \<subseteq> N-{?bb}-{n}" 
    using outside_reduces_domain by (metis Diff_mono subset_refl) 
  moreover have "... = N-{n}-{?bb}" by fastforce 
  ultimately have "?d (a--n) \<subseteq> N-{n}-{?bb}" by blast 
  moreover have "\<Union> (?r (a--n)) \<subseteq> \<Omega>" 
    unfolding Outside_def using 0 by blast 
  ultimately have "a -- n \<in> ?X1" by fast 
  moreover have "a--n \<in> allocationsUniverse" 
    using assms(1) Int_iff allocationsUniverseOutside by (metis(lifting,mono_tags)) 
  ultimately show ?thesis by blast
qed

lemma allAllocationsEquivalenceExtended: 
  "soldAllocations =  soldAllocations' & 
   soldAllocations' = soldAllocations'' &
   soldAllocations'' = soldAllocations'''" 
  using soldAllocationVariantEquivalence soldAllocationsEquivalenceVariant by metis

corollary soldAllocationRestriction: 
  assumes "a \<in> soldAllocations N \<Omega>" 
  shows "a -- n \<in> soldAllocations (N-{n}) \<Omega>"
proof - 
  let ?A' = soldAllocations''' 
  have "a \<in> ?A' N \<Omega>" using assms allAllocationsEquivalenceExtended by metis 
  then have "a -- n \<in> ?A' (N-{n}) \<Omega>" by (rule lm05) 
  thus ?thesis using allAllocationsEquivalenceExtended by metis 
qed

corollary allocationGoodsMonotonicity: 
  assumes "\<Omega>1 \<subseteq> \<Omega>2" 
  shows "soldAllocations''' N \<Omega>1 \<subseteq> soldAllocations''' N \<Omega>2"
  using assms by blast

corollary allocationGoodsMonotonicityVariant: 
  assumes "\<Omega>1 \<subseteq> \<Omega>2" 
  shows "soldAllocations'' N \<Omega>1 \<subseteq> soldAllocations'' N \<Omega>2" 
proof -
  have "soldAllocations'' N \<Omega>1 = soldAllocations''' N \<Omega>1" 
    by (rule soldAllocationVariantEquivalence)
  moreover have "... \<subseteq> soldAllocations''' N \<Omega>2" 
    using assms(1) by (rule allocationGoodsMonotonicity)
  moreover have "... = soldAllocations'' N \<Omega>2" using soldAllocationVariantEquivalence by metis
  ultimately show ?thesis by auto
qed

abbreviation "maximalStrictAllocations N \<Omega> b == argmax (sum b) (allAllocations ({seller}\<union>N) \<Omega>)"

abbreviation "randomBids N \<Omega> b random == resolvingBid (N\<union>{seller}) \<Omega> b random"

abbreviation "vcgas N \<Omega> b r  == 
  Outside' {seller} `((argmax\<circ>sum) (randomBids N \<Omega> b r)
                                      ((argmax\<circ>sum) b (allAllocations (N \<union> {seller}) (set \<Omega>))))"

abbreviation "vcga N \<Omega> b r == the_elem (vcgas N \<Omega> b r)"

abbreviation "vcga' N \<Omega> b r == 
  (the_elem (argmax (sum (randomBids N \<Omega> b r)) 
                    (maximalStrictAllocations N (set \<Omega>) b)))
  -- seller"

lemma lm06: 
  assumes "card ((argmax\<circ>sum) (randomBids N \<Omega> b r) 
                                 ((argmax\<circ>sum) b (allAllocations (N\<union>{seller}) (set \<Omega>)))) = 1" 
  shows "vcga N \<Omega> b r = 
         (the_elem ((argmax\<circ>sum) (randomBids N \<Omega> b r) 
                                    ((argmax\<circ>sum) b (allAllocations ({seller}\<union>N) (set \<Omega>))))) 
          -- seller"
  using assms cardOneTheElem by auto

corollary lm07: 
  assumes "card ((argmax\<circ>sum) (randomBids N \<Omega> b r) 
                                 ((argmax\<circ>sum) b (allAllocations (N\<union>{seller}) (set \<Omega>)))) = 1"
  shows "vcga N \<Omega> b r = vcga' N \<Omega> b r" 
  (is "?l = ?r")
proof -
  have "?l = (the_elem ((argmax\<circ>sum) (randomBids N \<Omega> b r) 
                                        ((argmax\<circ>sum) b (allAllocations ({seller}\<union>N) (set \<Omega>)))))
              -- seller"
    using assms by (rule lm06) 
  moreover have "... = ?r" by force 
  ultimately show ?thesis by blast
qed

lemma lm08: 
  assumes "distinct \<Omega>" "set \<Omega> \<noteq> {}" "finite N" 
  shows "card ((argmax\<circ>sum) (randomBids N \<Omega> bids random)
                               ((argmax\<circ>sum) bids (allAllocations (N\<union>{seller}) (set \<Omega>)))) = 1"
  (is "card ?l=_")
proof - 
  let ?N = "N\<union>{seller}" 
  let ?b' = "randomBids N \<Omega> bids random" 
  let ?s = sum 
  let ?a = argmax 
  let ?f = "?a \<circ> ?s"
  have 
  1: "?N\<noteq>{}" by auto 
  have 
  2: "finite ?N" using assms(3) by simp
  have "?a (?s ?b') (?a (?s bids) (allAllocations ?N (set \<Omega>))) =
        {chosenAllocation ?N \<Omega> bids random}" (is "?L=?R")
  using 1 assms(1) assms(2) 2 by (rule winningAllocationUniqueness)
  moreover have "?L= ?f ?b' (?f bids (allAllocations ?N (set \<Omega>)))" by auto
  ultimately have "?l = {chosenAllocation ?N \<Omega> bids random}" by simp
  moreover have "card ...=1" by simp ultimately show ?thesis by simp 
qed

lemma vcgaEquivalence: 
  assumes "distinct \<Omega>" "set \<Omega> \<noteq> {}" "finite N" 
  shows "vcga N \<Omega> b r = vcga' N \<Omega> b r"
  using assms lm07 lm08 by blast

theorem vcgaDefiniteness: 
  assumes "distinct \<Omega>" "set \<Omega> \<noteq> {}" "finite N" 
  shows "card (vcgas N \<Omega> b r) = 1"
proof -
  have "card ((argmax\<circ>sum) (randomBids N \<Omega> b r) 
                              ((argmax\<circ>sum) b (allAllocations (N\<union>{seller}) (set \<Omega>)))) =
        1" 
  (is "card ?X = _") using assms lm08 by blast
  moreover have "(Outside'{seller}) ` ?X = vcgas N \<Omega> b r" by blast
  ultimately show ?thesis using cardOneImageCardOne by blast
qed

lemma vcgaDefinitenessVariant: 
  assumes "distinct \<Omega>" "set \<Omega> \<noteq> {}" "finite N" 
  shows  "card (argmax (sum (randomBids N \<Omega> b r)) 
                       (maximalStrictAllocations N (set \<Omega>) b)) =
          1"
  (is "card ?L=_")
proof -
  let ?n = "{seller}" 
  have 
  1: "(?n \<union> N)\<noteq>{}" by simp 
  have 
  2: "finite (?n\<union>N)" using assms(3) by fast 
  have "terminatingAuctionRel (?n\<union>N) \<Omega> b r = {chosenAllocation (?n\<union>N) \<Omega> b r}" 
    using 1 assms(1) assms(2) 2 by (rule winningAllocationUniqueness) 
  moreover have "?L = terminatingAuctionRel (?n\<union>N) \<Omega> b r" by auto
  ultimately show ?thesis by auto
qed

theorem winningAllocationIsMaximal:
  assumes "distinct \<Omega>" "set \<Omega> \<noteq> {}" "finite N" 
  shows "the_elem (argmax (sum (randomBids N \<Omega> b r)) 
                          (maximalStrictAllocations N (set \<Omega>) b)) \<in>
         (maximalStrictAllocations N (set \<Omega>) b)" 
  (is "the_elem ?X \<in> ?R") 
proof -
  have "card ?X=1" using assms by (rule vcgaDefinitenessVariant) 
  moreover have "?X \<subseteq> ?R" by auto
  ultimately show ?thesis using cardinalityOneTheElem by blast
qed

corollary winningAllocationIsMaximalWithoutSeller: 
  assumes "distinct \<Omega>" "set \<Omega> \<noteq> {}" "finite N" 
  shows "vcga' N \<Omega> b r \<in> (Outside' {seller})`(maximalStrictAllocations N (set \<Omega>) b)"
  using assms winningAllocationIsMaximal by blast

lemma maximalAllactionWithoutSeller: 
  "(Outside' {seller})`(maximalStrictAllocations N \<Omega> b) \<subseteq> soldAllocations N \<Omega>"
  using Outside_def by force

lemma onlyGoodsAreAllocatedAuxiliary: 
  assumes "distinct \<Omega>" "set \<Omega> \<noteq> {}" "finite N" 
  shows "vcga' N \<Omega> b r \<in> soldAllocations N (set \<Omega>)" 
  (is "?a \<in> ?A") 
proof - 
  have "?a \<in> (Outside' {seller})`(maximalStrictAllocations N (set \<Omega>) b)" 
    using assms by (rule winningAllocationIsMaximalWithoutSeller) 
  thus ?thesis using maximalAllactionWithoutSeller  by fastforce 
qed

theorem onlyGoodsAreAllocated: 
  assumes "distinct \<Omega>" "set \<Omega> \<noteq> {}" "finite N" 
  shows "vcga N \<Omega> b r \<in> soldAllocations N (set \<Omega>)" 
  (is "_\<in>?r") 
proof - 
  have "vcga' N \<Omega> b r \<in> ?r" using assms by (rule onlyGoodsAreAllocatedAuxiliary) 
  then show ?thesis using assms vcgaEquivalence by blast 
qed

corollary neutralSeller: 
  assumes "\<forall>X. X \<in> Range a \<longrightarrow>b (seller, X)=0" "finite a" 
  shows "sum b a = sum b (a--seller)"
proof -
  let ?n = seller 
  have "finite (a||{?n})" using assms restrict_def by (metis finite_Int) 
  moreover have "\<forall>z \<in> a||{?n}. b z=0" using assms restrict_def by fastforce
  ultimately have "sum b (a||{?n}) = 0" using assms by (metis sum.neutral)
  thus ?thesis using sumOutside assms(2) by (metis add.comm_neutral) 
qed

corollary neutralSellerVariant: 
  assumes "\<forall>a\<in>A. finite a & (\<forall> X. X\<in>Range a \<longrightarrow> b (seller, X)=0)"
  shows "{sum b a| a. a\<in>A} = {sum b (a -- seller)| a. a\<in>A}" 
  using assms neutralSeller by (metis (lifting, no_types))

lemma vcgaIsMaximalAux1: 
  assumes "distinct \<Omega>" "set \<Omega> \<noteq> {}" "finite N" 
  shows "\<exists>a. ((a \<in> (maximalStrictAllocations N (set \<Omega>) b))  \<and>  (vcga' N \<Omega> b r = a -- seller)  &
                (a \<in> argmax (sum b) (allAllocations ({seller}\<union>N) (set \<Omega>))))" 
  using assms winningAllocationIsMaximalWithoutSeller by fast

lemma vcgaIsMaximalAux2: 
  assumes "distinct \<Omega>" "set \<Omega> \<noteq> {}" "finite N" 
  "\<forall>a \<in> allAllocations ({seller}\<union>N) (set \<Omega>). \<forall> X \<in> Range a. b (seller, X)=0"
  (is "\<forall>a\<in>?X. _") 
  shows "sum b (vcga' N \<Omega> b r) = Max{sum b a| a. a \<in> soldAllocations N (set \<Omega>)}"
proof -
  let ?n = seller 
  let ?s = sum 
  let ?a = "vcga' N \<Omega> b r" 
  obtain a where 
  0: "a \<in> maximalStrictAllocations N (set \<Omega>) b & 
      ?a = a--?n & 
      (a \<in> argmax (sum b) (allAllocations({seller}\<union>N)(set \<Omega>)))"
  (is "_ & ?a=_ & a\<in>?Z")
    using assms(1,2,3) vcgaIsMaximalAux1 by blast
  have 
  1: "\<forall>a \<in> ?X. finite a & (\<forall> X. X\<in>Range a \<longrightarrow> b (?n, X)=0)" 
    using assms(4) List.finite_set allocationFinite by metis 
  have 
  2: "a \<in> ?X" using 0 by auto have "a \<in> ?Z" using 0 by fast 
  then have "a \<in> ?X\<inter>{x. ?s b x = Max (?s b ` ?X)}" using injectionsUnionCommute by simp
  then have "a \<in> {x. ?s b x = Max (?s b ` ?X)}" using injectionsUnionCommute by simp
  moreover have "?s b ` ?X = {?s b a| a. a\<in>?X}" by blast
  ultimately have "?s b a = Max {?s b a| a. a\<in>?X}" by auto
  moreover have "{?s b a| a. a\<in>?X} = {?s b (a--?n)| a. a\<in>?X}" 
    using 1 by (rule neutralSellerVariant)
  moreover have "... = {?s b a| a. a \<in> Outside' {?n}`?X}" by blast
  moreover have "... = {?s b a| a. a \<in> soldAllocations N (set \<Omega>)}" by simp
  ultimately have "Max {?s b a| a. a \<in> soldAllocations N (set \<Omega>)} = ?s b a" by simp
  moreover have "... = ?s b (a--?n)" using 1 2 neutralSeller by (metis (lifting, no_types))
  ultimately show "?s b ?a=Max{?s b a| a. a \<in> soldAllocations N (set \<Omega>)}" using 0 by simp
qed

