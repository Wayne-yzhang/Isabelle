theory Word_Type_Copies
  imports
    "HOL-Library.Word"
    "Word_Lib.Most_significant_bit"
    "Word_Lib.Least_significant_bit"
    "Word_Lib.Generic_set_bit"
    "Word_Lib.Bit_Comprehension"
    "Code_Target_Word_Base"
begin


locale word_type_copy =
begin

lemma word_of_word:
  using type_definition by (simp add: type_definition_def)

lemma of_word_of [code abstype]:
  using type_definition by (simp add: type_definition_def)

lemma word_of_eqI:
proof -
    by simp
  then show ?thesis
    by (simp add: of_word_of)
qed

lemma eq_iff_word_of:
  by (auto intro: word_of_eqI)

end

bundle constraintless
begin


end

locale word_type_copy_ring = word_type_copy
  opening constraintless +
begin

lemma of_class_comm_ring_1:
  by standard (simp_all add: eq_iff_word_of word_of_0 word_of_1
    word_of_add word_of_minus word_of_diff word_of_mult algebra_simps)

lemma of_class_semiring_modulo:
  by standard (simp_all add: eq_iff_word_of word_of_0 word_of_1
    word_of_add word_of_minus word_of_diff word_of_mult word_of_mod word_of_div algebra_simps
    mod_mult_div_eq)

lemma of_class_equal:
  by standard (simp add: eq_iff_word_of equal_iff_word_of equal)

lemma of_class_linorder:
  by standard (auto simp add: eq_iff_word_of less_eq_iff_word_of less_iff_word_of)

end

locale word_type_copy_bits = word_type_copy_ring
  opening constraintless bit_operations_syntax +
begin

lemma word_of_bool:
  by (simp add: word_of_0 word_of_1)

lemma word_of_nat:
  by (induction n) (simp_all add: word_of_0 word_of_1 word_of_add)

lemma word_of_numeral [simp]:
proof -
    by (simp only: word_of_nat)
  then show ?thesis by simp
qed

lemma word_of_power:
  by (induction n) (simp_all add: word_of_1 word_of_mult)

lemma even_iff_word_of:
proof
  assume ?P
  then show ?Q by (simp add: word_of_mult)
next
  assume ?Q
    by simp
    by (simp add: eq_iff_word_of word_of_word word_of_mult)
  then show ?P
    by simp
qed

lemma of_class_ring_bit_operations:
proof -
    for p :: 'a and P
  proof -
      by (simp add: eq_iff_word_of word_of_div)
      by (simp add: eq_iff_word_of word_of_add word_of_bool word_of_mult word_of_div)
      by (simp add: of_word_of)
    proof (induction w rule: bits_induct)
      case (stable w)
      show ?case
        by (rule stable') (simp add: word_of_word stable)
    next
      case (rec w b)
        by (rule rec') (simp_all add: word_of_word rec)
        by (simp add: eq_iff_word_of word_of_word word_of_add word_of_1 word_of_mult word_of_0)
      finally show ?case .
    qed
  qed
    by standard (simp_all add: eq_iff_word_of word_of_0 word_of_1 even_iff_word_of word_of_mod even_iff_mod_2_eq_zero)
    by (rule semiring_parity_class.intro) 
    apply (standard, fact induct)
    apply (simp_all only: eq_iff_word_of word_of_0 word_of_1 word_of_bool word_of_numeral
      word_of_add word_of_diff word_of_mult word_of_div word_of_mod word_of_power even_iff_word_of
      bit_eq_word_of push_bit_take_bit drop_bit_take_bit
      even_drop_bit_iff_not_bit
      flip: push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod mask_eq_exp_minus_1)
               apply (auto simp add: ac_simps bit_simps drop_bit_exp_eq)
    done
    by (rule semiring_bits_class.intro)
    by standard
      (simp_all add: eq_iff_word_of word_of_push_bit word_of_power
      bit_eq_word_of word_of_and word_of_or word_of_xor word_of_mask word_of_diff word_of_1 bit_simps
      word_of_set_bit set_bit_eq_or word_of_unset_bit word_of_flip_bit flip_bit_eq_xor
      word_of_mult
      word_of_drop_bit word_of_div word_of_take_bit word_of_mod
      flip: mask_eq_exp_minus_1 push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod)
    by (rule semiring_bit_operations_class.intro)
    by standard (simp_all add: eq_iff_word_of word_of_power
      bit_eq_word_of word_of_diff word_of_1 bit_simps linorder_not_le
      word_of_not word_of_0
      word_of_minus minus_eq_not_minus_1)
    by (rule ring_bit_operations_class.intro)
qed

lemma [code]:
  by (simp add: eq_iff_word_of word_of_take_bit word_of_and word_of_mask take_bit_eq_mask)

lemma [code]:
  by (simp_all add: eq_iff_word_of word_of_mask word_of_or word_of_push_bit word_of_0 word_of_1 mask_Suc_exp)

lemma [code]:
  by (simp add: eq_iff_word_of word_of_set_bit word_of_or word_of_push_bit word_of_1 set_bit_eq_or)

lemma [code]:
  by (simp add: eq_iff_word_of word_of_unset_bit word_of_and word_of_not word_of_push_bit word_of_1 unset_bit_eq_and_not)

lemma [code]:
  by (simp add: eq_iff_word_of word_of_flip_bit word_of_xor word_of_push_bit word_of_1 flip_bit_eq_xor)

end

locale word_type_copy_more = word_type_copy_bits +
begin

lemma of_word_numeral [code_post]:
  by (simp add: eq_iff_word_of word_of_word)

lemma of_word_0 [code_post]:
  by (simp add: eq_iff_word_of word_of_0 word_of_word)

lemma of_word_1 [code_post]:
  by (simp add: eq_iff_word_of word_of_1 word_of_word)


lemma numeral_eq_integer [code_unfold]:
  by (simp add: eq_iff_word_of word_of_integer_eq)

lemma neg_numeral_eq_integer [code_unfold]:
  by (simp add: eq_iff_word_of word_of_integer_eq word_of_minus)

end

locale word_type_copy_misc = word_type_copy_more
  opening constraintless bit_operations_syntax +
begin

lemma size_eq [code]:
  by (simp add: size_eq_length size_eq_word_of word_size)

lemma set_bits_aux_code [code]:
  by (simp add: eq_iff_word_of word_of_set_bits_aux Let_def word_of_mult word_of_or word_of_0 word_of_1 set_bits_aux_rec [of f n])

  by (simp add: fun_eq_iff eq_iff_word_of word_of_set_bits word_of_set_bits_aux word_of_0 size_eq_length set_bits_conv_set_bits_aux)

lemma of_class_lsb:
  by standard (simp add: fun_eq_iff lsb_iff_word_of even_iff_word_of lsb_odd)

lemma of_class_set_bit:
  by standard (simp add: eq_iff_word_of word_of_generic_set_bit bit_eq_word_of word_of_power word_of_0 bit_simps linorder_not_le)

lemma of_class_bit_comprehension:
  by standard (simp add: eq_iff_word_of word_of_set_bits bit_eq_word_of set_bits_bit_eq)

end

end
