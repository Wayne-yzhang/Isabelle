theory TAO_9_PLM
imports 
  TAO_8_Definitions 
  "HOL-Eisbach.Eisbach_Tools"
begin


declare meta_defs[no_atp] meta_aux[no_atp]

locale PLM = Axioms
begin


  named_theorems PLM
  named_theorems PLM_intro
  named_theorems PLM_elim
  named_theorems PLM_dest
  named_theorems PLM_subst

  method PLM_solver declares PLM_intro PLM_elim PLM_subst PLM_dest PLM
        | fact PLM | rule PLM_intro | subst PLM_subst | subst (asm) PLM_subst
        | fastforce | safe | drule PLM_dest | erule PLM_elim); (PLM_solver)?)


  lemma modus_ponens[PLM]:
    "\<lbrakk>[\<phi> in v]; [\<phi> \<^bold>\<rightarrow> \<psi> in v]\<rbrakk> \<Longrightarrow> [\<psi> in v]"
    by (simp add: Semantics.T5)


  interpretation Axioms .
  declare axiom[PLM]
  declare conn_defs[PLM]


  lemma vdash_properties_6[no_atp]:
    "\<lbrakk>[\<phi> in v]; [\<phi> \<^bold>\<rightarrow> \<psi> in v]\<rbrakk> \<Longrightarrow> [\<psi> in v]"
    using modus_ponens .
  lemma vdash_properties_9[PLM]:
    "[\<phi> in v] \<Longrightarrow> [\<psi> \<^bold>\<rightarrow> \<phi> in v]"
    using modus_ponens pl_1[axiom_instance] by blast
  lemma vdash_properties_10[PLM]:
    "[\<phi> \<^bold>\<rightarrow> \<psi> in v] \<Longrightarrow> ([\<phi> in v] \<Longrightarrow> [\<psi> in v])"
    using vdash_properties_6 .



  lemma rule_gen[PLM]:
    "\<lbrakk>\<And>\<alpha> . [\<phi> \<alpha> in v]\<rbrakk> \<Longrightarrow> [\<^bold>\<forall>\<alpha> . \<phi> \<alpha> in v]"
    by (simp add: Semantics.T8)

  lemma RN_2[PLM]:
    "(\<And> v . [\<psi> in v] \<Longrightarrow> [\<phi> in v]) \<Longrightarrow> ([\<^bold>\<box>\<psi> in v] \<Longrightarrow> [\<^bold>\<box>\<phi> in v])"
    by (simp add: Semantics.T6)

  lemma RN[PLM]:
    "(\<And> v . [\<phi> in v]) \<Longrightarrow> [\<^bold>\<box>\<phi> in v]"
    using qml_3[axiom_necessitation, axiom_instance] RN_2 by blast


  lemma if_p_then_p[PLM]:
    "[\<phi> \<^bold>\<rightarrow> \<phi> in v]"
    using pl_1 pl_2 vdash_properties_10 axiom_instance by blast

  lemma deduction_theorem[PLM,PLM_intro]:
    "\<lbrakk>[\<phi> in v] \<Longrightarrow> [\<psi> in v]\<rbrakk> \<Longrightarrow> [\<phi> \<^bold>\<rightarrow> \<psi> in v]"
    by (simp add: Semantics.T5)
  lemmas CP = deduction_theorem

  lemma ded_thm_cor_3[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<rightarrow> \<psi> in v]; [\<psi> \<^bold>\<rightarrow> \<chi> in v]\<rbrakk> \<Longrightarrow> [\<phi> \<^bold>\<rightarrow> \<chi> in v]"
    by (meson pl_2 vdash_properties_10 vdash_properties_9 axiom_instance)
  lemma ded_thm_cor_4[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<rightarrow> (\<psi> \<^bold>\<rightarrow> \<chi>) in v]; [\<psi> in v]\<rbrakk> \<Longrightarrow> [\<phi> \<^bold>\<rightarrow> \<chi> in v]"
    by (meson pl_2 vdash_properties_10 vdash_properties_9 axiom_instance)

  lemma useful_tautologies_1[PLM]:
    "[\<^bold>\<not>\<^bold>\<not>\<phi> \<^bold>\<rightarrow> \<phi> in v]"
    by (meson pl_1 pl_3 ded_thm_cor_3 ded_thm_cor_4 axiom_instance)
  lemma useful_tautologies_2[PLM]:
    "[\<phi> \<^bold>\<rightarrow> \<^bold>\<not>\<^bold>\<not>\<phi> in v]"
    by (meson pl_1 pl_3 ded_thm_cor_3 useful_tautologies_1
              vdash_properties_10 axiom_instance)
  lemma useful_tautologies_3[PLM]:
    "[\<^bold>\<not>\<phi> \<^bold>\<rightarrow> (\<phi> \<^bold>\<rightarrow> \<psi>) in v]"
    by (meson pl_1 pl_2 pl_3 ded_thm_cor_3 ded_thm_cor_4 axiom_instance)
  lemma useful_tautologies_4[PLM]:
    "[(\<^bold>\<not>\<psi> \<^bold>\<rightarrow> \<^bold>\<not>\<phi>) \<^bold>\<rightarrow> (\<phi> \<^bold>\<rightarrow> \<psi>) in v]"
    by (meson pl_1 pl_2 pl_3 ded_thm_cor_3 ded_thm_cor_4 axiom_instance)
  lemma useful_tautologies_5[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>\<rightarrow> (\<^bold>\<not>\<psi> \<^bold>\<rightarrow> \<^bold>\<not>\<phi>) in v]"
    by (metis CP useful_tautologies_4 vdash_properties_10)
  lemma useful_tautologies_6[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> \<^bold>\<not>\<psi>) \<^bold>\<rightarrow> (\<psi> \<^bold>\<rightarrow> \<^bold>\<not>\<phi>) in v]"
    by (metis CP useful_tautologies_4 vdash_properties_10)
  lemma useful_tautologies_7[PLM]:
    "[(\<^bold>\<not>\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>\<rightarrow> (\<^bold>\<not>\<psi> \<^bold>\<rightarrow> \<phi>) in v]"
    using ded_thm_cor_3 useful_tautologies_4 useful_tautologies_5
          useful_tautologies_6 by blast
  lemma useful_tautologies_8[PLM]:
    "[\<phi> \<^bold>\<rightarrow> (\<^bold>\<not>\<psi> \<^bold>\<rightarrow> \<^bold>\<not>(\<phi> \<^bold>\<rightarrow> \<psi>)) in v]"
    by (meson ded_thm_cor_3 CP useful_tautologies_5)
  lemma useful_tautologies_9[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>\<rightarrow> ((\<^bold>\<not>\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>\<rightarrow> \<psi>) in v]"
    by (metis CP useful_tautologies_4 vdash_properties_10)
  lemma useful_tautologies_10[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> \<^bold>\<not>\<psi>) \<^bold>\<rightarrow> ((\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>\<rightarrow> \<^bold>\<not>\<phi>) in v]"
    by (metis ded_thm_cor_3 CP useful_tautologies_6)

  lemma modus_tollens_1[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<rightarrow> \<psi> in v]; [\<^bold>\<not>\<psi> in v]\<rbrakk> \<Longrightarrow> [\<^bold>\<not>\<phi> in v]"
    by (metis ded_thm_cor_3 ded_thm_cor_4 useful_tautologies_3
              useful_tautologies_7 vdash_properties_10)
  lemma modus_tollens_2[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<rightarrow> \<^bold>\<not>\<psi> in v]; [\<psi> in v]\<rbrakk> \<Longrightarrow> [\<^bold>\<not>\<phi> in v]"
    using modus_tollens_1 useful_tautologies_2
          vdash_properties_10 by blast

  lemma contraposition_1[PLM]:
    "[\<phi> \<^bold>\<rightarrow> \<psi> in v] = [\<^bold>\<not>\<psi> \<^bold>\<rightarrow> \<^bold>\<not>\<phi> in v]"
    using useful_tautologies_4 useful_tautologies_5
          vdash_properties_10 by blast
  lemma contraposition_2[PLM]:
    "[\<phi> \<^bold>\<rightarrow> \<^bold>\<not>\<psi> in v] = [\<psi> \<^bold>\<rightarrow> \<^bold>\<not>\<phi> in v]"
    using contraposition_1 ded_thm_cor_3
          useful_tautologies_1 by blast

  lemma reductio_aa_1[PLM]:
    "\<lbrakk>[\<^bold>\<not>\<phi> in v] \<Longrightarrow> [\<^bold>\<not>\<psi> in v]; [\<^bold>\<not>\<phi> in v] \<Longrightarrow> [\<psi> in v]\<rbrakk> \<Longrightarrow> [\<phi> in v]"
    using CP modus_tollens_2 useful_tautologies_1
          vdash_properties_10 by blast
  lemma reductio_aa_2[PLM]:
    "\<lbrakk>[\<phi> in v] \<Longrightarrow> [\<^bold>\<not>\<psi> in v]; [\<phi> in v] \<Longrightarrow> [\<psi> in v]\<rbrakk> \<Longrightarrow> [\<^bold>\<not>\<phi> in v]"
    by (meson contraposition_1 reductio_aa_1)
  lemma reductio_aa_3[PLM]:
    "\<lbrakk>[\<^bold>\<not>\<phi> \<^bold>\<rightarrow> \<^bold>\<not>\<psi> in v]; [\<^bold>\<not>\<phi> \<^bold>\<rightarrow> \<psi> in v]\<rbrakk> \<Longrightarrow> [\<phi> in v]"
    using reductio_aa_1 vdash_properties_10 by blast
  lemma reductio_aa_4[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<rightarrow> \<^bold>\<not>\<psi> in v]; [\<phi> \<^bold>\<rightarrow> \<psi> in v]\<rbrakk> \<Longrightarrow> [\<^bold>\<not>\<phi> in v]"
    using reductio_aa_2 vdash_properties_10 by blast

  lemma raa_cor_1[PLM]:
    "\<lbrakk>[\<phi> in v]; [\<^bold>\<not>\<psi> in v] \<Longrightarrow> [\<^bold>\<not>\<phi> in v]\<rbrakk> \<Longrightarrow> ([\<phi> in v] \<Longrightarrow> [\<psi> in v])"
    using reductio_aa_1 vdash_properties_9 by blast
  lemma raa_cor_2[PLM]:
    "\<lbrakk>[\<^bold>\<not>\<phi> in v]; [\<^bold>\<not>\<psi> in v] \<Longrightarrow> [\<phi> in v]\<rbrakk> \<Longrightarrow> ([\<^bold>\<not>\<phi> in v] \<Longrightarrow> [\<psi> in v])"
    using reductio_aa_1 vdash_properties_9 by blast
  lemma raa_cor_3[PLM]:
    "\<lbrakk>[\<phi> in v]; [\<^bold>\<not>\<psi> \<^bold>\<rightarrow> \<^bold>\<not>\<phi> in v]\<rbrakk> \<Longrightarrow> ([\<phi> in v] \<Longrightarrow> [\<psi> in v])"
    using raa_cor_1 vdash_properties_10 by blast
  lemma raa_cor_4[PLM]:
    "\<lbrakk>[\<^bold>\<not>\<phi> in v]; [\<^bold>\<not>\<psi> \<^bold>\<rightarrow> \<phi> in v]\<rbrakk> \<Longrightarrow> ([\<^bold>\<not>\<phi> in v] \<Longrightarrow> [\<psi> in v])"
    using raa_cor_2 vdash_properties_10 by blast


  lemma intro_elim_1[PLM]:
    "\<lbrakk>[\<phi> in v]; [\<psi> in v]\<rbrakk> \<Longrightarrow> [\<phi> \<^bold>& \<psi> in v]"
    unfolding conj_def using ded_thm_cor_4 if_p_then_p modus_tollens_2 by blast
  lemmas "\<^bold>&I" = intro_elim_1
  lemma intro_elim_2_a[PLM]:
    "[\<phi> \<^bold>& \<psi> in v] \<Longrightarrow> [\<phi> in v]"
    unfolding conj_def using CP reductio_aa_1 by blast
  lemma intro_elim_2_b[PLM]:
    "[\<phi> \<^bold>& \<psi> in v] \<Longrightarrow> [\<psi> in v]"
    unfolding conj_def using pl_1 CP reductio_aa_1 axiom_instance by blast
  lemmas "\<^bold>&E" = intro_elim_2_a intro_elim_2_b
  lemma intro_elim_3_a[PLM]:
    "[\<phi> in v] \<Longrightarrow> [\<phi> \<^bold>\<or> \<psi> in v]"
    unfolding disj_def using ded_thm_cor_4 useful_tautologies_3 by blast
  lemma intro_elim_3_b[PLM]:
    "[\<psi> in v] \<Longrightarrow> [\<phi> \<^bold>\<or> \<psi> in v]"
    by (simp only: disj_def vdash_properties_9)
  lemmas "\<^bold>\<or>I" = intro_elim_3_a intro_elim_3_b
  lemma intro_elim_4_a[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<or> \<psi> in v]; [\<phi> \<^bold>\<rightarrow> \<chi> in v]; [\<psi> \<^bold>\<rightarrow> \<chi> in v]\<rbrakk> \<Longrightarrow> [\<chi> in v]"
    unfolding disj_def by (meson reductio_aa_2 vdash_properties_10)
  lemma intro_elim_4_b[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<or> \<psi> in v]; [\<^bold>\<not>\<phi> in v]\<rbrakk> \<Longrightarrow> [\<psi> in v]"
    unfolding disj_def using vdash_properties_10 by blast
  lemma intro_elim_4_c[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<or> \<psi> in v]; [\<^bold>\<not>\<psi> in v]\<rbrakk> \<Longrightarrow> [\<phi> in v]"
    unfolding disj_def using raa_cor_2 vdash_properties_10 by blast
  lemma intro_elim_4_d[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<or> \<psi> in v]; [\<phi> \<^bold>\<rightarrow> \<chi> in v]; [\<psi> \<^bold>\<rightarrow> \<Theta> in v]\<rbrakk> \<Longrightarrow> [\<chi> \<^bold>\<or> \<Theta> in v]"
    unfolding disj_def using contraposition_1 ded_thm_cor_3 by blast
  lemma intro_elim_4_e[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<or> \<psi> in v]; [\<phi> \<^bold>\<equiv> \<chi> in v]; [\<psi> \<^bold>\<equiv> \<Theta> in v]\<rbrakk> \<Longrightarrow> [\<chi> \<^bold>\<or> \<Theta> in v]"
    unfolding equiv_def using "\<^bold>&E"(1) intro_elim_4_d by blast
  lemmas "\<^bold>\<or>E" = intro_elim_4_a intro_elim_4_b intro_elim_4_c intro_elim_4_d
  lemma intro_elim_5[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<rightarrow> \<psi> in v]; [\<psi> \<^bold>\<rightarrow> \<phi> in v]\<rbrakk> \<Longrightarrow> [\<phi> \<^bold>\<equiv> \<psi> in v]"
    by (simp only: equiv_def "\<^bold>&I")
  lemmas "\<^bold>\<equiv>I" = intro_elim_5
  lemma intro_elim_6_a[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<equiv> \<psi> in v]; [\<phi> in v]\<rbrakk> \<Longrightarrow> [\<psi> in v]"
    unfolding equiv_def using "\<^bold>&E"(1) vdash_properties_10 by blast
  lemma intro_elim_6_b[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<equiv> \<psi> in v]; [\<psi> in v]\<rbrakk> \<Longrightarrow> [\<phi> in v]"
    unfolding equiv_def using "\<^bold>&E"(2) vdash_properties_10 by blast
  lemma intro_elim_6_c[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<equiv> \<psi> in v]; [\<^bold>\<not>\<phi> in v]\<rbrakk> \<Longrightarrow> [\<^bold>\<not>\<psi> in v]"
    unfolding equiv_def using "\<^bold>&E"(2) modus_tollens_1 by blast
  lemma intro_elim_6_d[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<equiv> \<psi> in v]; [\<^bold>\<not>\<psi> in v]\<rbrakk> \<Longrightarrow> [\<^bold>\<not>\<phi> in v]"
    unfolding equiv_def using "\<^bold>&E"(1) modus_tollens_1 by blast
  lemma intro_elim_6_e[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<equiv> \<psi> in v]; [\<psi> \<^bold>\<equiv> \<chi> in v]\<rbrakk> \<Longrightarrow> [\<phi> \<^bold>\<equiv> \<chi> in v]"
    by (metis equiv_def ded_thm_cor_3 "\<^bold>&E" "\<^bold>\<equiv>I")
  lemma intro_elim_6_f[PLM]:
    "\<lbrakk>[\<phi> \<^bold>\<equiv> \<psi> in v]; [\<phi> \<^bold>\<equiv> \<chi> in v]\<rbrakk> \<Longrightarrow> [\<chi> \<^bold>\<equiv> \<psi> in v]"
    by (metis equiv_def ded_thm_cor_3 "\<^bold>&E" "\<^bold>\<equiv>I")
  lemmas "\<^bold>\<equiv>E" = intro_elim_6_a intro_elim_6_b intro_elim_6_c
                intro_elim_6_d intro_elim_6_e intro_elim_6_f
  lemma intro_elim_7[PLM]:
    "[\<phi> in v] \<Longrightarrow> [\<^bold>\<not>\<^bold>\<not>\<phi> in v]"
    using if_p_then_p modus_tollens_2 by blast
  lemmas "\<^bold>\<not>\<^bold>\<not>I" = intro_elim_7
  lemma intro_elim_8[PLM]:
    "[\<^bold>\<not>\<^bold>\<not>\<phi> in v] \<Longrightarrow> [\<phi> in v]"
    using if_p_then_p raa_cor_2 by blast
  lemmas "\<^bold>\<not>\<^bold>\<not>E" = intro_elim_8

  context
  begin
    private lemma NotNotI[PLM_intro]:
      "[\<phi> in v] \<Longrightarrow> [\<^bold>\<not>(\<^bold>\<not>\<phi>) in v]"
      by (simp add: "\<^bold>\<not>\<^bold>\<not>I")
    private lemma NotNotD[PLM_dest]:
      "[\<^bold>\<not>(\<^bold>\<not>\<phi>) in v] \<Longrightarrow> [\<phi> in v]"
      using "\<^bold>\<not>\<^bold>\<not>E" by blast

    private lemma ImplI[PLM_intro]:
      "([\<phi> in v] \<Longrightarrow> [\<psi> in v]) \<Longrightarrow> [\<phi> \<^bold>\<rightarrow> \<psi> in v]"
      using CP .
    private lemma ImplE[PLM_elim, PLM_dest]:
      "[\<phi> \<^bold>\<rightarrow> \<psi> in v] \<Longrightarrow> ([\<phi> in v] \<Longrightarrow> [\<psi> in v])"
      using modus_ponens .
    private lemma ImplS[PLM_subst]:
      "[\<phi> \<^bold>\<rightarrow> \<psi> in v] = ([\<phi> in v] \<longrightarrow> [\<psi> in v])"
      using ImplI ImplE by blast

    private lemma NotI[PLM_intro]:
      "([\<phi> in v] \<Longrightarrow> (\<And>\<psi> .[\<psi> in v])) \<Longrightarrow> [\<^bold>\<not>\<phi> in v]"
      using CP modus_tollens_2 by blast
    private lemma NotE[PLM_elim,PLM_dest]:
      "[\<^bold>\<not>\<phi> in v] \<Longrightarrow> ([\<phi> in v] \<longrightarrow> (\<forall>\<psi> .[\<psi> in v]))"
      using "\<^bold>\<or>I"(2) "\<^bold>\<or>E"(3) by blast
    private lemma NotS[PLM_subst]:
      "[\<^bold>\<not>\<phi> in v] = ([\<phi> in v] \<longrightarrow> (\<forall>\<psi> .[\<psi> in v]))"
      using NotI NotE by blast

    private lemma ConjI[PLM_intro]:
      "\<lbrakk>[\<phi> in v]; [\<psi> in v]\<rbrakk> \<Longrightarrow> [\<phi> \<^bold>& \<psi> in v]"
      using "\<^bold>&I" by blast
    private lemma ConjE[PLM_elim,PLM_dest]:
      "[\<phi> \<^bold>& \<psi> in v] \<Longrightarrow> (([\<phi> in v] \<and> [\<psi> in v]))"
      using CP "\<^bold>&E" by blast
    private lemma ConjS[PLM_subst]:
      "[\<phi> \<^bold>& \<psi> in v] = (([\<phi> in v] \<and> [\<psi> in v]))"
      using ConjI ConjE by blast

    private lemma DisjI[PLM_intro]:
      "[\<phi> in v] \<or> [\<psi> in v] \<Longrightarrow> [\<phi> \<^bold>\<or> \<psi> in v]"
      using "\<^bold>\<or>I" by blast
    private lemma DisjE[PLM_elim,PLM_dest]:
      "[\<phi> \<^bold>\<or> \<psi> in v] \<Longrightarrow> [\<phi> in v] \<or> [\<psi> in v]"
      using CP "\<^bold>\<or>E"(1) by blast
    private lemma DisjS[PLM_subst]:
      "[\<phi> \<^bold>\<or> \<psi> in v] = ([\<phi> in v] \<or> [\<psi> in v])"
      using DisjI DisjE by blast

    private lemma EquivI[PLM_intro]:
      "\<lbrakk>[\<phi> in v] \<Longrightarrow> [\<psi> in v];[\<psi> in v] \<Longrightarrow> [\<phi> in v]\<rbrakk> \<Longrightarrow> [\<phi> \<^bold>\<equiv> \<psi> in v]"
      using CP "\<^bold>\<equiv>I" by blast
    private lemma EquivE[PLM_elim,PLM_dest]:
      "[\<phi> \<^bold>\<equiv> \<psi> in v] \<Longrightarrow> (([\<phi> in v] \<longrightarrow> [\<psi> in v]) \<and> ([\<psi> in v] \<longrightarrow> [\<phi> in v]))"
      using "\<^bold>\<equiv>E"(1) "\<^bold>\<equiv>E"(2) by blast
    private lemma EquivS[PLM_subst]:
      "[\<phi> \<^bold>\<equiv> \<psi> in v] = ([\<phi> in v] \<longleftrightarrow> [\<psi> in v])"
      using EquivI EquivE by blast

    private lemma NotOrD[PLM_dest]:
      "\<not>[\<phi> \<^bold>\<or> \<psi> in v] \<Longrightarrow> \<not>[\<phi> in v] \<and> \<not>[\<psi> in v]"
      using "\<^bold>\<or>I" by blast
    private lemma NotAndD[PLM_dest]:
      "\<not>[\<phi> \<^bold>& \<psi> in v] \<Longrightarrow> \<not>[\<phi> in v] \<or> \<not>[\<psi> in v]"
      using "\<^bold>&I" by blast
    private lemma NotEquivD[PLM_dest]:
      "\<not>[\<phi> \<^bold>\<equiv> \<psi> in v] \<Longrightarrow> [\<phi> in v] \<noteq> [\<psi> in v]"
      by (meson NotI contraposition_1 "\<^bold>\<equiv>I" vdash_properties_9)

    private lemma BoxI[PLM_intro]:
      "(\<And> v . [\<phi> in v]) \<Longrightarrow> [\<^bold>\<box>\<phi> in v]"
      using RN by blast
    private lemma NotBoxD[PLM_dest]:
      "\<not>[\<^bold>\<box>\<phi> in v] \<Longrightarrow> (\<exists> v . \<not>[\<phi> in v])"
      using BoxI by blast

    private lemma AllI[PLM_intro]:
      "(\<And> x . [\<phi> x in v]) \<Longrightarrow> [\<^bold>\<forall> x . \<phi> x in v]"
      using rule_gen by blast
    lemma NotAllD[PLM_dest]:
      "\<not>[\<^bold>\<forall> x . \<phi> x in v] \<Longrightarrow> (\<exists> x . \<not>[\<phi> x in v])"
      using AllI by fastforce
  end

  lemma oth_class_taut_1_a[PLM]:
    "[\<^bold>\<not>(\<phi> \<^bold>& \<^bold>\<not>\<phi>) in v]"
    by PLM_solver
  lemma oth_class_taut_1_b[PLM]:
    "[\<^bold>\<not>(\<phi> \<^bold>\<equiv> \<^bold>\<not>\<phi>) in v]"
    by PLM_solver
  lemma oth_class_taut_2[PLM]:
    "[\<phi> \<^bold>\<or> \<^bold>\<not>\<phi> in v]"
    by PLM_solver
  lemma oth_class_taut_3_a[PLM]:
    "[(\<phi> \<^bold>& \<phi>) \<^bold>\<equiv> \<phi> in v]"
    by PLM_solver
  lemma oth_class_taut_3_b[PLM]:
    "[(\<phi> \<^bold>& \<psi>) \<^bold>\<equiv> (\<psi> \<^bold>& \<phi>) in v]"
    by PLM_solver
  lemma oth_class_taut_3_c[PLM]:
    "[(\<phi> \<^bold>& (\<psi> \<^bold>& \<chi>)) \<^bold>\<equiv> ((\<phi> \<^bold>& \<psi>) \<^bold>& \<chi>) in v]"
    by PLM_solver
  lemma oth_class_taut_3_d[PLM]:
    "[(\<phi> \<^bold>\<or> \<phi>) \<^bold>\<equiv> \<phi> in v]"
    by PLM_solver
  lemma oth_class_taut_3_e[PLM]:
    "[(\<phi> \<^bold>\<or> \<psi>) \<^bold>\<equiv> (\<psi> \<^bold>\<or> \<phi>) in v]"
    by PLM_solver
  lemma oth_class_taut_3_f[PLM]:
    "[(\<phi> \<^bold>\<or> (\<psi> \<^bold>\<or> \<chi>)) \<^bold>\<equiv> ((\<phi> \<^bold>\<or> \<psi>) \<^bold>\<or> \<chi>) in v]"
    by PLM_solver
  lemma oth_class_taut_3_g[PLM]:
    "[(\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<equiv> (\<psi> \<^bold>\<equiv> \<phi>) in v]"
    by PLM_solver
  lemma oth_class_taut_3_i[PLM]:
    "[(\<phi> \<^bold>\<equiv> (\<psi> \<^bold>\<equiv> \<chi>)) \<^bold>\<equiv> ((\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<equiv> \<chi>) in v]"
    by PLM_solver
  lemma oth_class_taut_4_a[PLM]:
    "[\<phi> \<^bold>\<equiv> \<phi> in v]"
    by PLM_solver
  lemma oth_class_taut_4_b[PLM]:
    "[\<phi> \<^bold>\<equiv> \<^bold>\<not>\<^bold>\<not>\<phi> in v]"
    by PLM_solver
  lemma oth_class_taut_5_a[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>\<equiv> \<^bold>\<not>(\<phi> \<^bold>& \<^bold>\<not>\<psi>) in v]"
    by PLM_solver
  lemma oth_class_taut_5_b[PLM]:
    "[\<^bold>\<not>(\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>\<equiv> (\<phi> \<^bold>& \<^bold>\<not>\<psi>) in v]"
    by PLM_solver
  lemma oth_class_taut_5_c[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>\<rightarrow> ((\<psi> \<^bold>\<rightarrow> \<chi>) \<^bold>\<rightarrow> (\<phi> \<^bold>\<rightarrow> \<chi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_5_d[PLM]:
    "[(\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<equiv> (\<^bold>\<not>\<phi> \<^bold>\<equiv> \<^bold>\<not>\<psi>) in v]"
    by PLM_solver
  lemma oth_class_taut_5_e[PLM]:
    "[(\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<rightarrow> ((\<phi> \<^bold>\<rightarrow> \<chi>) \<^bold>\<equiv> (\<psi> \<^bold>\<rightarrow> \<chi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_5_f[PLM]:
    "[(\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<rightarrow> ((\<chi> \<^bold>\<rightarrow> \<phi>) \<^bold>\<equiv> (\<chi> \<^bold>\<rightarrow> \<psi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_5_g[PLM]:
    "[(\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<rightarrow> ((\<phi> \<^bold>\<equiv> \<chi>) \<^bold>\<equiv> (\<psi> \<^bold>\<equiv> \<chi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_5_h[PLM]:
    "[(\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<rightarrow> ((\<chi> \<^bold>\<equiv> \<phi>) \<^bold>\<equiv> (\<chi> \<^bold>\<equiv> \<psi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_5_i[PLM]:
    "[(\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<equiv> ((\<phi> \<^bold>& \<psi>) \<^bold>\<or> (\<^bold>\<not>\<phi> \<^bold>& \<^bold>\<not>\<psi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_5_j[PLM]:
    "[(\<^bold>\<not>(\<phi> \<^bold>\<equiv> \<psi>)) \<^bold>\<equiv> ((\<phi> \<^bold>& \<^bold>\<not>\<psi>) \<^bold>\<or> (\<^bold>\<not>\<phi> \<^bold>& \<psi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_5_k[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>\<equiv> (\<^bold>\<not>\<phi> \<^bold>\<or> \<psi>) in v]"
    by PLM_solver

  lemma oth_class_taut_6_a[PLM]:
    "[(\<phi> \<^bold>& \<psi>) \<^bold>\<equiv> \<^bold>\<not>(\<^bold>\<not>\<phi> \<^bold>\<or> \<^bold>\<not>\<psi>) in v]"
    by PLM_solver
  lemma oth_class_taut_6_b[PLM]:
    "[(\<phi> \<^bold>\<or> \<psi>) \<^bold>\<equiv> \<^bold>\<not>(\<^bold>\<not>\<phi> \<^bold>& \<^bold>\<not>\<psi>) in v]"
    by PLM_solver
  lemma oth_class_taut_6_c[PLM]:
    "[\<^bold>\<not>(\<phi> \<^bold>& \<psi>) \<^bold>\<equiv> (\<^bold>\<not>\<phi> \<^bold>\<or> \<^bold>\<not>\<psi>) in v]"
    by PLM_solver
  lemma oth_class_taut_6_d[PLM]:
    "[\<^bold>\<not>(\<phi> \<^bold>\<or> \<psi>) \<^bold>\<equiv> (\<^bold>\<not>\<phi> \<^bold>& \<^bold>\<not>\<psi>) in v]"
    by PLM_solver

  lemma oth_class_taut_7_a[PLM]:
    "[(\<phi> \<^bold>& (\<psi> \<^bold>\<or> \<chi>)) \<^bold>\<equiv> ((\<phi> \<^bold>& \<psi>) \<^bold>\<or> (\<phi> \<^bold>& \<chi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_7_b[PLM]:
    "[(\<phi> \<^bold>\<or> (\<psi> \<^bold>& \<chi>)) \<^bold>\<equiv> ((\<phi> \<^bold>\<or> \<psi>) \<^bold>& (\<phi> \<^bold>\<or> \<chi>)) in v]"
    by PLM_solver

  lemma oth_class_taut_8_a[PLM]:
    "[((\<phi> \<^bold>& \<psi>) \<^bold>\<rightarrow> \<chi>) \<^bold>\<rightarrow> (\<phi> \<^bold>\<rightarrow> (\<psi> \<^bold>\<rightarrow> \<chi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_8_b[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> (\<psi> \<^bold>\<rightarrow> \<chi>)) \<^bold>\<rightarrow> ((\<phi> \<^bold>& \<psi>) \<^bold>\<rightarrow> \<chi>) in v]"
    by PLM_solver

  lemma oth_class_taut_9_a[PLM]:
    "[(\<phi> \<^bold>& \<psi>) \<^bold>\<rightarrow> \<phi> in v]"
    by PLM_solver
  lemma oth_class_taut_9_b[PLM]:
    "[(\<phi> \<^bold>& \<psi>) \<^bold>\<rightarrow> \<psi> in v]"
    by PLM_solver

  lemma oth_class_taut_10_a[PLM]:
    "[\<phi> \<^bold>\<rightarrow> (\<psi> \<^bold>\<rightarrow> (\<phi> \<^bold>& \<psi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_10_b[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> (\<psi> \<^bold>\<rightarrow> \<chi>)) \<^bold>\<equiv> (\<psi> \<^bold>\<rightarrow> (\<phi> \<^bold>\<rightarrow> \<chi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_10_c[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>\<rightarrow> ((\<phi> \<^bold>\<rightarrow> \<chi>) \<^bold>\<rightarrow> (\<phi> \<^bold>\<rightarrow> (\<psi> \<^bold>& \<chi>))) in v]"
    by PLM_solver
  lemma oth_class_taut_10_d[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> \<chi>) \<^bold>\<rightarrow> ((\<psi> \<^bold>\<rightarrow> \<chi>) \<^bold>\<rightarrow> ((\<phi> \<^bold>\<or> \<psi>) \<^bold>\<rightarrow> \<chi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_10_e[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>\<rightarrow> ((\<chi> \<^bold>\<rightarrow> \<Theta>) \<^bold>\<rightarrow> ((\<phi> \<^bold>& \<chi>) \<^bold>\<rightarrow> (\<psi> \<^bold>& \<Theta>))) in v]"
    by PLM_solver
  lemma oth_class_taut_10_f[PLM]:
    "[((\<phi> \<^bold>& \<psi>) \<^bold>\<equiv> (\<phi> \<^bold>& \<chi>)) \<^bold>\<equiv> (\<phi> \<^bold>\<rightarrow> (\<psi> \<^bold>\<equiv> \<chi>)) in v]"
    by PLM_solver
  lemma oth_class_taut_10_g[PLM]:
    "[((\<phi> \<^bold>& \<psi>) \<^bold>\<equiv> (\<chi> \<^bold>& \<psi>)) \<^bold>\<equiv> (\<psi> \<^bold>\<rightarrow> (\<phi> \<^bold>\<equiv> \<chi>)) in v]"
    by PLM_solver







  

  lemma id_eq_prop_prop_1[PLM]:
    "[(F::\<Pi>\<^sub>1) \<^bold>= F in v]"
    unfolding identity_defs by PLM_solver 
  lemma id_eq_prop_prop_2[PLM]:
    "[((F::\<Pi>\<^sub>1) \<^bold>= G) \<^bold>\<rightarrow> (G \<^bold>= F) in v]"
    by (meson id_eq_prop_prop_1 CP ded_thm_cor_3 l_identity[axiom_instance])
  lemma id_eq_prop_prop_3[PLM]:
    "[(((F::\<Pi>\<^sub>1) \<^bold>= G) \<^bold>& (G \<^bold>= H)) \<^bold>\<rightarrow> (F \<^bold>= H) in v]"
    by (metis l_identity[axiom_instance] ded_thm_cor_4 CP "\<^bold>&E")
  lemma id_eq_prop_prop_4_a[PLM]:
    "[(F::\<Pi>\<^sub>2) \<^bold>= F in v]"
    unfolding identity_defs by PLM_solver
  lemma id_eq_prop_prop_4_b[PLM]:
    "[(F::\<Pi>\<^sub>3) \<^bold>= F in v]"
    unfolding identity_defs by PLM_solver
  lemma id_eq_prop_prop_5_a[PLM]:
    "[((F::\<Pi>\<^sub>2) \<^bold>= G) \<^bold>\<rightarrow> (G \<^bold>= F) in v]"
    by (meson id_eq_prop_prop_4_a CP ded_thm_cor_3 l_identity[axiom_instance])
  lemma id_eq_prop_prop_5_b[PLM]:
    "[((F::\<Pi>\<^sub>3) \<^bold>= G) \<^bold>\<rightarrow> (G \<^bold>= F) in v]"
    by (meson id_eq_prop_prop_4_b CP ded_thm_cor_3 l_identity[axiom_instance])
  lemma id_eq_prop_prop_6_a[PLM]:
    "[(((F::\<Pi>\<^sub>2) \<^bold>= G) \<^bold>& (G \<^bold>= H)) \<^bold>\<rightarrow> (F \<^bold>= H) in v]"
    by (metis l_identity[axiom_instance] ded_thm_cor_4 CP "\<^bold>&E")
  lemma id_eq_prop_prop_6_b[PLM]:
    "[(((F::\<Pi>\<^sub>3) \<^bold>= G) \<^bold>& (G \<^bold>= H)) \<^bold>\<rightarrow> (F \<^bold>= H) in v]"
    by (metis l_identity[axiom_instance] ded_thm_cor_4 CP "\<^bold>&E")
  lemma id_eq_prop_prop_7[PLM]:
    "[(p::\<Pi>\<^sub>0) \<^bold>= p in v]"
    unfolding identity_defs by PLM_solver
  lemma id_eq_prop_prop_7_b[PLM]:
    "[(p::\<o>) \<^bold>= p in v]"
    unfolding identity_defs by PLM_solver
  lemma id_eq_prop_prop_8[PLM]:
    "[((p::\<Pi>\<^sub>0) \<^bold>= q) \<^bold>\<rightarrow> (q \<^bold>= p) in v]"
    by (meson id_eq_prop_prop_7 CP ded_thm_cor_3 l_identity[axiom_instance])
  lemma id_eq_prop_prop_8_b[PLM]:
    "[((p::\<o>) \<^bold>= q) \<^bold>\<rightarrow> (q \<^bold>= p) in v]"
    by (meson id_eq_prop_prop_7_b CP ded_thm_cor_3 l_identity[axiom_instance])
  lemma id_eq_prop_prop_9[PLM]:
    "[(((p::\<Pi>\<^sub>0) \<^bold>= q) \<^bold>& (q \<^bold>= r)) \<^bold>\<rightarrow> (p \<^bold>= r) in v]"
    by (metis l_identity[axiom_instance] ded_thm_cor_4 CP "\<^bold>&E")
  lemma id_eq_prop_prop_9_b[PLM]:
    "[(((p::\<o>) \<^bold>= q) \<^bold>& (q \<^bold>= r)) \<^bold>\<rightarrow> (p \<^bold>= r) in v]"
    by (metis l_identity[axiom_instance] ded_thm_cor_4 CP "\<^bold>&E")

  lemma eq_E_simple_1[PLM]:
    "[(x \<^bold>=\<^sub>E y) \<^bold>\<equiv> (\<lparr>O!,x\<rparr> \<^bold>& \<lparr>O!,y\<rparr> \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F . \<lparr>F,x\<rparr> \<^bold>\<equiv> \<lparr>F,y\<rparr>)) in v]"
    proof (rule "\<^bold>\<equiv>I"; rule CP)
      assume 1: "[x \<^bold>=\<^sub>E y in v]"
      have "[\<^bold>\<forall> x y . ((x\<^sup>P) \<^bold>=\<^sub>E (y\<^sup>P)) \<^bold>\<equiv> (\<lparr>O!,x\<^sup>P\<rparr> \<^bold>& \<lparr>O!,y\<^sup>P\<rparr>
              \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F . \<lparr>F,x\<^sup>P\<rparr> \<^bold>\<equiv> \<lparr>F,y\<^sup>P\<rparr>)) in v]"
        unfolding identity\<^sub>E_infix_def identity\<^sub>E_def
        apply (rule lambda_predicates_2_2[axiom_universal, axiom_universal, axiom_instance])
        by show_proper
      moreover have "[\<^bold>\<exists> \<alpha> . (\<alpha>\<^sup>P) \<^bold>= x in v]"
        apply (rule cqt_5_mod[where \<psi>="\<lambda> x . x \<^bold>=\<^sub>E y", axiom_instance,deduction])
        unfolding identity\<^sub>E_infix_def
        apply (rule SimpleExOrEnc.intros)
        using 1 unfolding identity\<^sub>E_infix_def by auto
      moreover have "[\<^bold>\<exists> \<beta> . (\<beta>\<^sup>P) \<^bold>= y in v]"
        apply (rule cqt_5_mod[where \<psi>="\<lambda> y . x \<^bold>=\<^sub>E y",axiom_instance,deduction])
        unfolding identity\<^sub>E_infix_def
        apply (rule SimpleExOrEnc.intros) using 1
        unfolding identity\<^sub>E_infix_def by auto
      ultimately have "[(x \<^bold>=\<^sub>E y) \<^bold>\<equiv> (\<lparr>O!,x\<rparr> \<^bold>& \<lparr>O!,y\<rparr>
                        \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F . \<lparr>F,x\<rparr> \<^bold>\<equiv> \<lparr>F,y\<rparr>)) in v]"
        using cqt_1_\<kappa>[axiom_instance,deduction, deduction] by meson
      thus "[(\<lparr>O!,x\<rparr> \<^bold>& \<lparr>O!,y\<rparr> \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F . \<lparr>F,x\<rparr> \<^bold>\<equiv> \<lparr>F,y\<rparr>)) in v]"
        using 1 "\<^bold>\<equiv>E"(1) by blast
    next
      assume 1: "[\<lparr>O!,x\<rparr> \<^bold>& \<lparr>O!,y\<rparr> \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F. \<lparr>F,x\<rparr> \<^bold>\<equiv> \<lparr>F,y\<rparr>) in v]"
      have "[\<^bold>\<forall> x y . ((x\<^sup>P) \<^bold>=\<^sub>E (y\<^sup>P)) \<^bold>\<equiv> (\<lparr>O!,x\<^sup>P\<rparr> \<^bold>& \<lparr>O!,y\<^sup>P\<rparr>
              \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F . \<lparr>F,x\<^sup>P\<rparr> \<^bold>\<equiv> \<lparr>F,y\<^sup>P\<rparr>)) in v]"
        unfolding identity\<^sub>E_def identity\<^sub>E_infix_def
        apply (rule lambda_predicates_2_2[axiom_universal, axiom_universal, axiom_instance])
        by show_proper
      moreover have "[\<^bold>\<exists> \<alpha> . (\<alpha>\<^sup>P) \<^bold>= x in v]"
        apply (rule cqt_5_mod[where \<psi>="\<lambda> x . \<lparr>O!,x\<rparr>",axiom_instance,deduction])
        apply (rule SimpleExOrEnc.intros)
        using 1[conj1,conj1] by auto
      moreover have "[\<^bold>\<exists> \<beta> . (\<beta>\<^sup>P) \<^bold>= y in v]"
        apply (rule cqt_5_mod[where \<psi>="\<lambda> y . \<lparr>O!,y\<rparr>",axiom_instance,deduction])
         apply (rule SimpleExOrEnc.intros)
        using 1[conj1,conj2] by auto
      ultimately have "[(x \<^bold>=\<^sub>E y) \<^bold>\<equiv> (\<lparr>O!,x\<rparr> \<^bold>& \<lparr>O!,y\<rparr>
                        \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F . \<lparr>F,x\<rparr> \<^bold>\<equiv> \<lparr>F,y\<rparr>)) in v]"
      using cqt_1_\<kappa>[axiom_instance,deduction, deduction] by meson
      thus "[(x \<^bold>=\<^sub>E y) in v]" using 1 "\<^bold>\<equiv>E"(2) by blast
    qed
  lemma eq_E_simple_2[PLM]:
    "[(x \<^bold>=\<^sub>E y) \<^bold>\<rightarrow> (x \<^bold>= y) in v]"
    unfolding identity_defs by PLM_solver
  lemma eq_E_simple_3[PLM]:
    "[(x \<^bold>= y) \<^bold>\<equiv> ((\<lparr>O!,x\<rparr> \<^bold>& \<lparr>O!,y\<rparr> \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F . \<lparr>F,x\<rparr> \<^bold>\<equiv> \<lparr>F,y\<rparr>))
               \<^bold>\<or> (\<lparr>A!,x\<rparr> \<^bold>& \<lparr>A!,y\<rparr> \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F. \<lbrace>x,F\<rbrace> \<^bold>\<equiv> \<lbrace>y,F\<rbrace>))) in v]"
    using eq_E_simple_1
    apply - unfolding identity_defs
    by PLM_solver

  lemma id_eq_obj_1[PLM]: "[(x\<^sup>P) \<^bold>= (x\<^sup>P) in v]"
    proof -
      have "[(\<^bold>\<diamond>\<lparr>E!, x\<^sup>P\<rparr>) \<^bold>\<or> (\<^bold>\<not>\<^bold>\<diamond>\<lparr>E!, x\<^sup>P\<rparr>) in v]"
        using PLM.oth_class_taut_2 by simp
      hence "[(\<^bold>\<diamond>\<lparr>E!, x\<^sup>P\<rparr>) in v] \<or> [(\<^bold>\<not>\<^bold>\<diamond>\<lparr>E!, x\<^sup>P\<rparr>) in v]"
        using CP "\<^bold>\<or>E"(1) by blast
      moreover {
        assume "[(\<^bold>\<diamond>\<lparr>E!, x\<^sup>P\<rparr>) in v]"
        hence "[\<lparr>\<^bold>\<lambda>x. \<^bold>\<diamond>\<lparr>E!,x\<^sup>P\<rparr>,x\<^sup>P\<rparr> in v]"
          apply (rule lambda_predicates_2_1[axiom_instance, equiv_rl, rotated])
          by show_proper
        hence "[\<lparr>\<^bold>\<lambda>x. \<^bold>\<diamond>\<lparr>E!,x\<^sup>P\<rparr>,x\<^sup>P\<rparr> \<^bold>& \<lparr>\<^bold>\<lambda>x. \<^bold>\<diamond>\<lparr>E!,x\<^sup>P\<rparr>,x\<^sup>P\<rparr>
                \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F. \<lparr>F,x\<^sup>P\<rparr> \<^bold>\<equiv> \<lparr>F,x\<^sup>P\<rparr>) in v]"
          apply - by PLM_solver
        hence "[(x\<^sup>P) \<^bold>=\<^sub>E (x\<^sup>P) in v]"
          using eq_E_simple_1[equiv_rl] unfolding Ordinary_def by fast
      }
      moreover {
        assume "[(\<^bold>\<not>\<^bold>\<diamond>\<lparr>E!, x\<^sup>P\<rparr>) in v]"
        hence "[\<lparr>\<^bold>\<lambda>x. \<^bold>\<not>\<^bold>\<diamond>\<lparr>E!,x\<^sup>P\<rparr>,x\<^sup>P\<rparr> in v]"
          apply (rule lambda_predicates_2_1[axiom_instance, equiv_rl, rotated])
          by show_proper
        hence "[\<lparr>\<^bold>\<lambda>x. \<^bold>\<not>\<^bold>\<diamond>\<lparr>E!,x\<^sup>P\<rparr>,x\<^sup>P\<rparr> \<^bold>& \<lparr>\<^bold>\<lambda>x. \<^bold>\<not>\<^bold>\<diamond>\<lparr>E!,x\<^sup>P\<rparr>,x\<^sup>P\<rparr>
                \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F. \<lbrace>x\<^sup>P,F\<rbrace> \<^bold>\<equiv> \<lbrace>x\<^sup>P,F\<rbrace>) in v]"
          apply - by PLM_solver
      }
      ultimately show ?thesis unfolding identity_defs Ordinary_def Abstract_def
        using "\<^bold>\<or>I" by blast
    qed
  lemma id_eq_obj_2[PLM]:
    "[((x\<^sup>P) \<^bold>= (y\<^sup>P)) \<^bold>\<rightarrow> ((y\<^sup>P) \<^bold>= (x\<^sup>P)) in v]"
    by (meson l_identity[axiom_instance] id_eq_obj_1 CP ded_thm_cor_3)
  lemma id_eq_obj_3[PLM]:
    "[((x\<^sup>P) \<^bold>= (y\<^sup>P)) \<^bold>& ((y\<^sup>P) \<^bold>= (z\<^sup>P)) \<^bold>\<rightarrow> ((x\<^sup>P) \<^bold>= (z\<^sup>P)) in v]"
    by (metis l_identity[axiom_instance] ded_thm_cor_4 CP "\<^bold>&E")
end


class id_eq = quantifiable_and_identifiable +
  assumes id_eq_1: "[(x :: 'a) \<^bold>= x in v]"
  assumes id_eq_2: "[((x :: 'a) \<^bold>= y) \<^bold>\<rightarrow> (y \<^bold>= x) in v]"
  assumes id_eq_3: "[((x :: 'a) \<^bold>= y) \<^bold>& (y \<^bold>= z) \<^bold>\<rightarrow> (x \<^bold>= z) in v]"

instantiation \<nu> :: id_eq
begin
  instance proof
    fix x :: \<nu> and v
    show "[x \<^bold>= x in v]"
      using PLM.id_eq_obj_1
      by (simp add: identity_\<nu>_def)
  next
    fix x y::\<nu> and v
    show "[x \<^bold>= y \<^bold>\<rightarrow> y \<^bold>= x in v]"
      using PLM.id_eq_obj_2
      by (simp add: identity_\<nu>_def)
  next
    fix x y z::\<nu> and v
    show "[((x \<^bold>= y) \<^bold>& (y \<^bold>= z)) \<^bold>\<rightarrow> x \<^bold>= z in v]"
      using PLM.id_eq_obj_3
      by (simp add: identity_\<nu>_def)
  qed
end

instantiation \<o> :: id_eq
begin
  instance proof
    fix x :: \<o> and v
    show "[x \<^bold>= x in v]"
      using PLM.id_eq_prop_prop_7 .
  next
    fix x y :: \<o> and v
    show "[x \<^bold>= y \<^bold>\<rightarrow> y \<^bold>= x in v]"
      using PLM.id_eq_prop_prop_8 .
  next
    fix x y z :: \<o> and v
    show "[((x \<^bold>= y) \<^bold>& (y \<^bold>= z)) \<^bold>\<rightarrow> x \<^bold>= z in v]"
      using PLM.id_eq_prop_prop_9 .
  qed
end

instantiation \<Pi>\<^sub>1 :: id_eq
begin
  instance proof
    fix x :: \<Pi>\<^sub>1 and v
    show "[x \<^bold>= x in v]"
      using PLM.id_eq_prop_prop_1 .
  next
    fix x y :: \<Pi>\<^sub>1 and v
    show "[x \<^bold>= y \<^bold>\<rightarrow> y \<^bold>= x in v]"
      using PLM.id_eq_prop_prop_2 .
  next
    fix x y z :: \<Pi>\<^sub>1 and v
    show "[((x \<^bold>= y) \<^bold>& (y \<^bold>= z)) \<^bold>\<rightarrow> x \<^bold>= z in v]"
      using PLM.id_eq_prop_prop_3 .
  qed
end

instantiation \<Pi>\<^sub>2 :: id_eq
begin
  instance proof
    fix x :: \<Pi>\<^sub>2 and v
    show "[x \<^bold>= x in v]"
      using PLM.id_eq_prop_prop_4_a .
  next
    fix x y :: \<Pi>\<^sub>2 and v
    show "[x \<^bold>= y \<^bold>\<rightarrow> y \<^bold>= x in v]"
      using PLM.id_eq_prop_prop_5_a .
  next
    fix x y z :: \<Pi>\<^sub>2 and v
    show "[((x \<^bold>= y) \<^bold>& (y \<^bold>= z)) \<^bold>\<rightarrow> x \<^bold>= z in v]"
      using PLM.id_eq_prop_prop_6_a .
  qed
end

instantiation \<Pi>\<^sub>3 :: id_eq
begin
  instance proof
    fix x :: \<Pi>\<^sub>3 and v
    show "[x \<^bold>= x in v]"
      using PLM.id_eq_prop_prop_4_b .
  next
    fix x y :: \<Pi>\<^sub>3 and v
    show "[x \<^bold>= y \<^bold>\<rightarrow> y \<^bold>= x in v]"
      using PLM.id_eq_prop_prop_5_b .
  next
    fix x y z :: \<Pi>\<^sub>3 and v
    show "[((x \<^bold>= y) \<^bold>& (y \<^bold>= z)) \<^bold>\<rightarrow> x \<^bold>= z in v]"
      using PLM.id_eq_prop_prop_6_b .
  qed
end

context PLM
begin
  lemma id_eq_1[PLM]:
    "[(x::'a::id_eq) \<^bold>= x in v]"
    using id_eq_1 .
  lemma id_eq_2[PLM]:
    "[((x::'a::id_eq) \<^bold>= y) \<^bold>\<rightarrow> (y \<^bold>= x) in v]"
    using id_eq_2 .
  lemma id_eq_3[PLM]:
    "[((x::'a::id_eq) \<^bold>= y) \<^bold>& (y \<^bold>= z) \<^bold>\<rightarrow> (x \<^bold>= z) in v]"
    using id_eq_3 .



  lemma all_self_eq_1[PLM]:
    "[\<^bold>\<box>(\<^bold>\<forall> \<alpha> :: 'a::id_eq . \<alpha> \<^bold>= \<alpha>) in v]"
    by PLM_solver
  lemma all_self_eq_2[PLM]:
    "[\<^bold>\<forall>\<alpha> :: 'a::id_eq . \<^bold>\<box>(\<alpha> \<^bold>= \<alpha>) in v]"
    by PLM_solver

  lemma t_id_t_proper_1[PLM]:
    "[\<tau> \<^bold>= \<tau>' \<^bold>\<rightarrow> (\<^bold>\<exists> \<beta> . (\<beta>\<^sup>P) \<^bold>= \<tau>) in v]"
    proof (rule CP)
      assume "[\<tau> \<^bold>= \<tau>' in v]"
      moreover {
        assume "[\<tau> \<^bold>=\<^sub>E \<tau>' in v]"
        hence "[\<^bold>\<exists> \<beta> . (\<beta>\<^sup>P) \<^bold>= \<tau> in v]"
          apply -
          apply (rule cqt_5_mod[where \<psi>="\<lambda> \<tau> . \<tau> \<^bold>=\<^sub>E \<tau>'", axiom_instance, deduction])
           subgoal unfolding identity_defs by (rule SimpleExOrEnc.intros)
          by simp
      }
      moreover {
        assume "[\<lparr>A!,\<tau>\<rparr> \<^bold>& \<lparr>A!,\<tau>'\<rparr> \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F. \<lbrace>\<tau>,F\<rbrace> \<^bold>\<equiv> \<lbrace>\<tau>',F\<rbrace>) in v]"
        hence "[\<^bold>\<exists> \<beta> . (\<beta>\<^sup>P) \<^bold>= \<tau> in v]"
          apply -
          apply (rule cqt_5_mod[where \<psi>="\<lambda> \<tau> . \<lparr>A!,\<tau>\<rparr>", axiom_instance, deduction])
           subgoal unfolding identity_defs by (rule SimpleExOrEnc.intros)
          by PLM_solver
      }
      ultimately show "[\<^bold>\<exists> \<beta> . (\<beta>\<^sup>P) \<^bold>= \<tau> in v]" unfolding identity\<^sub>\<kappa>_def
        using intro_elim_4_b reductio_aa_1 by blast
    qed

  lemma t_id_t_proper_2[PLM]: "[\<tau> \<^bold>= \<tau>' \<^bold>\<rightarrow> (\<^bold>\<exists> \<beta> . (\<beta>\<^sup>P) \<^bold>= \<tau>') in v]"
  proof (rule CP)
    assume "[\<tau> \<^bold>= \<tau>' in v]"
    moreover {
      assume "[\<tau> \<^bold>=\<^sub>E \<tau>' in v]"
      hence "[\<^bold>\<exists> \<beta> . (\<beta>\<^sup>P) \<^bold>= \<tau>' in v]"
        apply -
        apply (rule cqt_5_mod[where \<psi>="\<lambda> \<tau>' . \<tau> \<^bold>=\<^sub>E \<tau>'", axiom_instance, deduction])
         subgoal unfolding identity_defs by (rule SimpleExOrEnc.intros)
        by simp
    }
    moreover {
      assume "[\<lparr>A!,\<tau>\<rparr> \<^bold>& \<lparr>A!,\<tau>'\<rparr> \<^bold>& \<^bold>\<box>(\<^bold>\<forall>F. \<lbrace>\<tau>,F\<rbrace> \<^bold>\<equiv> \<lbrace>\<tau>',F\<rbrace>) in v]"
      hence "[\<^bold>\<exists> \<beta> . (\<beta>\<^sup>P) \<^bold>= \<tau>' in v]"
        apply -
        apply (rule cqt_5_mod[where \<psi>="\<lambda> \<tau> . \<lparr>A!,\<tau>\<rparr>", axiom_instance, deduction])
         subgoal unfolding identity_defs by (rule SimpleExOrEnc.intros)
        by PLM_solver
    }
    ultimately show "[\<^bold>\<exists> \<beta> . (\<beta>\<^sup>P) \<^bold>= \<tau>' in v]" unfolding identity\<^sub>\<kappa>_def
      using intro_elim_4_b reductio_aa_1 by blast
  qed

  lemma id_nec[PLM]: "[((\<alpha>::'a::id_eq) \<^bold>= (\<beta>)) \<^bold>\<equiv> \<^bold>\<box>((\<alpha>) \<^bold>= (\<beta>)) in v]"
    apply (rule "\<^bold>\<equiv>I")
     using l_identity[where \<phi> = "(\<lambda> \<beta> .  \<^bold>\<box>((\<alpha>) \<^bold>= (\<beta>)))", axiom_instance]
           id_eq_1 RN ded_thm_cor_4 unfolding identity_\<nu>_def
     apply blast
    using qml_2[axiom_instance] by blast

  lemma id_nec_desc[PLM]:
    "[((\<^bold>\<iota>x. \<phi> x) \<^bold>= (\<^bold>\<iota>x. \<psi> x)) \<^bold>\<equiv> \<^bold>\<box>((\<^bold>\<iota>x. \<phi> x) \<^bold>= (\<^bold>\<iota>x. \<psi> x)) in v]"
    proof (cases "[(\<^bold>\<exists> \<alpha>. (\<alpha>\<^sup>P) \<^bold>= (\<^bold>\<iota>x . \<phi> x)) in v] \<and> [(\<^bold>\<exists> \<beta>. (\<beta>\<^sup>P) \<^bold>= (\<^bold>\<iota>x . \<psi> x)) in v]")
      assume "[(\<^bold>\<exists> \<alpha>. (\<alpha>\<^sup>P) \<^bold>= (\<^bold>\<iota>x . \<phi> x)) in v] \<and> [(\<^bold>\<exists> \<beta>. (\<beta>\<^sup>P) \<^bold>= (\<^bold>\<iota>x . \<psi> x)) in v]"
      then obtain \<alpha> and \<beta> where
        "[(\<alpha>\<^sup>P) \<^bold>= (\<^bold>\<iota>x . \<phi> x) in v] \<and> [(\<beta>\<^sup>P) \<^bold>= (\<^bold>\<iota>x . \<psi> x) in v]"
        apply - unfolding conn_defs by PLM_solver
      moreover {
        moreover have "[(\<alpha>) \<^bold>= (\<beta>) \<^bold>\<equiv> \<^bold>\<box>((\<alpha>) \<^bold>= (\<beta>)) in v]" by PLM_solver
        ultimately have "[((\<^bold>\<iota>x. \<phi> x) \<^bold>= (\<beta>\<^sup>P) \<^bold>\<equiv> \<^bold>\<box>((\<^bold>\<iota>x. \<phi> x) \<^bold>= (\<beta>\<^sup>P))) in v]"
          using l_identity[where \<phi>="\<lambda> \<alpha> . (\<alpha>) \<^bold>= (\<beta>\<^sup>P) \<^bold>\<equiv> \<^bold>\<box>((\<alpha>) \<^bold>= (\<beta>\<^sup>P))", axiom_instance]
          modus_ponens unfolding identity_\<nu>_def by metis
      }
      ultimately show ?thesis
        using l_identity[where \<phi>="\<lambda> \<alpha> . (\<^bold>\<iota>x . \<phi> x) \<^bold>= (\<alpha>)
                                   \<^bold>\<equiv> \<^bold>\<box>((\<^bold>\<iota>x . \<phi> x) \<^bold>= (\<alpha>))", axiom_instance]
        modus_ponens by metis
    next
      assume "\<not>([(\<^bold>\<exists> \<alpha>. (\<alpha>\<^sup>P) \<^bold>= (\<^bold>\<iota>x . \<phi> x)) in v] \<and> [(\<^bold>\<exists> \<beta>. (\<beta>\<^sup>P) \<^bold>= (\<^bold>\<iota>x . \<psi> x)) in v])"
      hence "\<not>[\<lparr>A!,(\<^bold>\<iota>x . \<phi> x)\<rparr> in v] \<and> \<not>[(\<^bold>\<iota>x . \<phi> x) \<^bold>=\<^sub>E (\<^bold>\<iota>x . \<psi> x) in v]
           \<or> \<not>[\<lparr>A!,(\<^bold>\<iota>x . \<psi> x)\<rparr> in v] \<and> \<not>[(\<^bold>\<iota>x . \<phi> x) \<^bold>=\<^sub>E (\<^bold>\<iota>x . \<psi> x) in v]"
      unfolding identity\<^sub>E_infix_def
      using cqt_5[axiom_instance] PLM.contraposition_1 SimpleExOrEnc.intros
            vdash_properties_10 by meson
      hence "\<not>[(\<^bold>\<iota>x . \<phi> x) \<^bold>= (\<^bold>\<iota>x . \<psi> x) in v]"
        apply - unfolding identity_defs by PLM_solver
      thus ?thesis apply - apply PLM_solver
        using qml_2[axiom_instance, deduction] by auto
    qed


  lemma rule_ui[PLM,PLM_elim,PLM_dest]:
    "[\<^bold>\<forall>\<alpha> . \<phi> \<alpha> in v] \<Longrightarrow> [\<phi> \<beta> in v]"
    by (meson cqt_1[axiom_instance, deduction])
  lemmas "\<^bold>\<forall>E" = rule_ui

  lemma rule_ui_2[PLM,PLM_elim,PLM_dest]:
    "\<lbrakk>[\<^bold>\<forall>\<alpha> . \<phi> (\<alpha>\<^sup>P) in v]; [\<^bold>\<exists> \<alpha> . (\<alpha>)\<^sup>P \<^bold>= \<beta> in v]\<rbrakk> \<Longrightarrow> [\<phi> \<beta> in v]"
    using cqt_1_\<kappa>[axiom_instance, deduction, deduction] by blast

  lemma cqt_orig_1[PLM]:
    "[(\<^bold>\<forall>\<alpha>. \<phi> \<alpha>) \<^bold>\<rightarrow> \<phi> \<beta> in v]"
    by PLM_solver
  lemma cqt_orig_2[PLM]:
    "[(\<^bold>\<forall>\<alpha>. \<phi> \<^bold>\<rightarrow> \<psi> \<alpha>) \<^bold>\<rightarrow> (\<phi> \<^bold>\<rightarrow> (\<^bold>\<forall>\<alpha>. \<psi> \<alpha>)) in v]"
    by PLM_solver

  lemma universal[PLM]:
    "(\<And>\<alpha> . [\<phi> \<alpha> in v]) \<Longrightarrow> [\<^bold>\<forall> \<alpha> . \<phi> \<alpha> in v]"
    using rule_gen .
  lemmas "\<^bold>\<forall>I" = universal

  lemma cqt_basic_1[PLM]:
    "[(\<^bold>\<forall>\<alpha>. (\<^bold>\<forall>\<beta> . \<phi> \<alpha> \<beta>)) \<^bold>\<equiv> (\<^bold>\<forall>\<beta>. (\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<beta>)) in v]"
    by PLM_solver
  lemma cqt_basic_2[PLM]:
    "[(\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>\<equiv> \<psi> \<alpha>) \<^bold>\<equiv> ((\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>\<rightarrow> \<psi> \<alpha>) \<^bold>& (\<^bold>\<forall>\<alpha>. \<psi> \<alpha> \<^bold>\<rightarrow> \<phi> \<alpha>)) in v]"
    by PLM_solver
  lemma cqt_basic_3[PLM]:
    "[(\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>\<equiv> \<psi> \<alpha>) \<^bold>\<rightarrow> ((\<^bold>\<forall>\<alpha>. \<phi> \<alpha>) \<^bold>\<equiv> (\<^bold>\<forall>\<alpha>. \<psi> \<alpha>)) in v]"
    by PLM_solver
  lemma cqt_basic_4[PLM]:
    "[(\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>& \<psi> \<alpha>) \<^bold>\<equiv> ((\<^bold>\<forall>\<alpha>. \<phi> \<alpha>) \<^bold>& (\<^bold>\<forall>\<alpha>. \<psi> \<alpha>)) in v]"
    by PLM_solver
  lemma cqt_basic_6[PLM]:
    "[(\<^bold>\<forall>\<alpha>. (\<^bold>\<forall>\<alpha>. \<phi> \<alpha>)) \<^bold>\<equiv> (\<^bold>\<forall>\<alpha>. \<phi> \<alpha>) in v]"
    by PLM_solver
  lemma cqt_basic_7[PLM]:
    "[(\<phi> \<^bold>\<rightarrow> (\<^bold>\<forall>\<alpha> . \<psi> \<alpha>)) \<^bold>\<equiv> (\<^bold>\<forall>\<alpha>.(\<phi> \<^bold>\<rightarrow> \<psi> \<alpha>)) in v]"
    by PLM_solver
  lemma cqt_basic_8[PLM]:
    "[((\<^bold>\<forall>\<alpha>. \<phi> \<alpha>) \<^bold>\<or> (\<^bold>\<forall>\<alpha>. \<psi> \<alpha>)) \<^bold>\<rightarrow> (\<^bold>\<forall>\<alpha>. (\<phi> \<alpha> \<^bold>\<or> \<psi> \<alpha>)) in v]"
    by PLM_solver
  lemma cqt_basic_9[PLM]:
    "[((\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>\<rightarrow> \<psi> \<alpha>) \<^bold>& (\<^bold>\<forall>\<alpha>. \<psi> \<alpha> \<^bold>\<rightarrow> \<chi> \<alpha>)) \<^bold>\<rightarrow> (\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>\<rightarrow> \<chi> \<alpha>) in v]"
    by PLM_solver
  lemma cqt_basic_10[PLM]:
    "[((\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>\<equiv> \<psi> \<alpha>) \<^bold>& (\<^bold>\<forall>\<alpha>. \<psi> \<alpha> \<^bold>\<equiv> \<chi> \<alpha>)) \<^bold>\<rightarrow> (\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>\<equiv> \<chi> \<alpha>) in v]"
    by PLM_solver
  lemma cqt_basic_11[PLM]:
    "[(\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>\<equiv> \<psi> \<alpha>) \<^bold>\<equiv> (\<^bold>\<forall>\<alpha>. \<psi> \<alpha> \<^bold>\<equiv> \<phi> \<alpha>) in v]"
    by PLM_solver
  lemma cqt_basic_12[PLM]:
    "[(\<^bold>\<forall>\<alpha>. \<phi> \<alpha>) \<^bold>\<equiv> (\<^bold>\<forall>\<beta>. \<phi> \<beta>) in v]"
    by PLM_solver

  lemma existential[PLM,PLM_intro]:
    "[\<phi> \<alpha> in v] \<Longrightarrow> [\<^bold>\<exists> \<alpha>. \<phi> \<alpha> in v]"
    unfolding exists_def by PLM_solver
  lemmas "\<^bold>\<exists>I" = existential
  lemma instantiation_[PLM,PLM_elim,PLM_dest]:
    "\<lbrakk>[\<^bold>\<exists>\<alpha> . \<phi> \<alpha> in v]; (\<And>\<alpha>.[\<phi> \<alpha> in v] \<Longrightarrow> [\<psi> in v])\<rbrakk> \<Longrightarrow> [\<psi> in v]"
    unfolding exists_def by PLM_solver

  lemma Instantiate:
    assumes "[\<^bold>\<exists> x . \<phi> x  in v]"
    obtains x where "[\<phi> x in v]"
    apply (insert assms) unfolding exists_def by PLM_solver
  lemmas "\<^bold>\<exists>E" = Instantiate

  lemma cqt_further_1[PLM]:
    "[(\<^bold>\<forall>\<alpha>. \<phi> \<alpha>) \<^bold>\<rightarrow> (\<^bold>\<exists>\<alpha>. \<phi> \<alpha>) in v]"
    by PLM_solver
  lemma cqt_further_2[PLM]:
    "[(\<^bold>\<not>(\<^bold>\<forall>\<alpha>. \<phi> \<alpha>)) \<^bold>\<equiv> (\<^bold>\<exists>\<alpha>. \<^bold>\<not>\<phi> \<alpha>) in v]"
    unfolding exists_def by PLM_solver
  lemma cqt_further_3[PLM]:
    "[(\<^bold>\<forall>\<alpha>. \<phi> \<alpha>) \<^bold>\<equiv> \<^bold>\<not>(\<^bold>\<exists>\<alpha>. \<^bold>\<not>\<phi> \<alpha>) in v]"
    unfolding exists_def by PLM_solver
  lemma cqt_further_4[PLM]:
    "[(\<^bold>\<not>(\<^bold>\<exists>\<alpha>. \<phi> \<alpha>)) \<^bold>\<equiv> (\<^bold>\<forall>\<alpha>. \<^bold>\<not>\<phi> \<alpha>) in v]"
    unfolding exists_def by PLM_solver
  lemma cqt_further_5[PLM]:
    "[(\<^bold>\<exists>\<alpha>. \<phi> \<alpha> \<^bold>& \<psi> \<alpha>) \<^bold>\<rightarrow> ((\<^bold>\<exists>\<alpha>. \<phi> \<alpha>) \<^bold>& (\<^bold>\<exists>\<alpha>. \<psi> \<alpha>)) in v]"
      unfolding exists_def by PLM_solver
  lemma cqt_further_6[PLM]:
    "[(\<^bold>\<exists>\<alpha>. \<phi> \<alpha> \<^bold>\<or> \<psi> \<alpha>) \<^bold>\<equiv> ((\<^bold>\<exists>\<alpha>. \<phi> \<alpha>) \<^bold>\<or> (\<^bold>\<exists>\<alpha>. \<psi> \<alpha>)) in v]"
    unfolding exists_def by PLM_solver
  lemma cqt_further_10[PLM]:
    "[(\<phi> (\<alpha>::'a::id_eq) \<^bold>& (\<^bold>\<forall> \<beta> . \<phi> \<beta> \<^bold>\<rightarrow> \<beta> \<^bold>= \<alpha>)) \<^bold>\<equiv> (\<^bold>\<forall> \<beta> . \<phi> \<beta> \<^bold>\<equiv> \<beta> \<^bold>= \<alpha>) in v]"
    apply PLM_solver
     using l_identity[axiom_instance, deduction, deduction] id_eq_2[deduction]
     apply blast
    using id_eq_1 by auto
  lemma cqt_further_11[PLM]:
    "[((\<^bold>\<forall>\<alpha>. \<phi> \<alpha>) \<^bold>& (\<^bold>\<forall>\<alpha>. \<psi> \<alpha>)) \<^bold>\<rightarrow> (\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>\<equiv> \<psi> \<alpha>) in v]"
    by PLM_solver
  lemma cqt_further_12[PLM]:
    "[((\<^bold>\<not>(\<^bold>\<exists>\<alpha>. \<phi> \<alpha>)) \<^bold>& (\<^bold>\<not>(\<^bold>\<exists>\<alpha>. \<psi> \<alpha>))) \<^bold>\<rightarrow> (\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>\<equiv> \<psi> \<alpha>) in v]"
    unfolding exists_def by PLM_solver
  lemma cqt_further_13[PLM]:
    "[((\<^bold>\<exists>\<alpha>. \<phi> \<alpha>) \<^bold>& (\<^bold>\<not>(\<^bold>\<exists>\<alpha>. \<psi> \<alpha>))) \<^bold>\<rightarrow> (\<^bold>\<not>(\<^bold>\<forall>\<alpha>. \<phi> \<alpha> \<^bold>\<equiv> \<psi> \<alpha>)) in v]"
    unfolding exists_def by PLM_solver
  lemma cqt_further_14[PLM]:
    "[(\<^bold>\<exists>\<alpha>. \<^bold>\<exists>\<beta>. \<phi> \<alpha> \<beta>) \<^bold>\<equiv> (\<^bold>\<exists>\<beta>. \<^bold>\<exists>\<alpha>. \<phi> \<alpha> \<beta>) in v]"
    unfolding exists_def by PLM_solver

  lemma nec_exist_unique[PLM]:
    "[(\<^bold>\<forall> x. \<phi> x \<^bold>\<rightarrow> \<^bold>\<box>(\<phi> x)) \<^bold>\<rightarrow> ((\<^bold>\<exists>!x. \<phi> x) \<^bold>\<rightarrow> (\<^bold>\<exists>!x. \<^bold>\<box>(\<phi> x))) in v]"
    proof (rule CP)
      assume a: "[\<^bold>\<forall>x. \<phi> x \<^bold>\<rightarrow> \<^bold>\<box>\<phi> x in v]"
      show "[(\<^bold>\<exists>!x. \<phi> x) \<^bold>\<rightarrow> (\<^bold>\<exists>!x. \<^bold>\<box>\<phi> x) in v]"
      proof (rule CP)
        assume "[(\<^bold>\<exists>!x. \<phi> x) in v]"
        hence "[\<^bold>\<exists>\<alpha>. \<phi> \<alpha> \<^bold>& (\<^bold>\<forall>\<beta>. \<phi> \<beta> \<^bold>\<rightarrow> \<beta> \<^bold>= \<alpha>) in v]"
          by (simp only: exists_unique_def)
        then obtain \<alpha> where 1:
          "[\<phi> \<alpha> \<^bold>& (\<^bold>\<forall>\<beta>. \<phi> \<beta> \<^bold>\<rightarrow> \<beta> \<^bold>= \<alpha>) in v]"
          by (rule "\<^bold>\<exists>E")
        {
          fix \<beta>
          have "[\<^bold>\<box>\<phi> \<beta> \<^bold>\<rightarrow> \<beta> \<^bold>= \<alpha> in v]"
            using 1 "\<^bold>&E"(2) qml_2[axiom_instance]
              ded_thm_cor_3 "\<^bold>\<forall>E" by fastforce
        }
        hence "[\<^bold>\<forall>\<beta>. \<^bold>\<box>\<phi> \<beta> \<^bold>\<rightarrow> \<beta> \<^bold>= \<alpha> in v]" by (rule "\<^bold>\<forall>I")
        moreover have "[\<^bold>\<box>(\<phi> \<alpha>) in v]"
          using 1 "\<^bold>&E"(1) a vdash_properties_10 cqt_orig_1[deduction]
          by fast
        ultimately have "[\<^bold>\<exists>\<alpha>. \<^bold>\<box>(\<phi> \<alpha>) \<^bold>& (\<^bold>\<forall>\<beta>. \<^bold>\<box>\<phi> \<beta> \<^bold>\<rightarrow> \<beta> \<^bold>= \<alpha>) in v]"
          using "\<^bold>&I" "\<^bold>\<exists>I" by fast
        thus "[(\<^bold>\<exists>!x. \<^bold>\<box>\<phi> x) in v]"
          unfolding exists_unique_def by assumption
      qed
    qed



  lemma nec_imp_act[PLM]: "[\<^bold>\<box>\<phi> \<^bold>\<rightarrow> \<^bold>\<A>\<phi> in v]"
    apply (rule CP)
    using qml_act_2[axiom_instance, equiv_lr]
          qml_2[axiom_actualization, axiom_instance]
          logic_actual_nec_2[axiom_instance, equiv_lr, deduction]
    by blast
  lemma act_conj_act_1[PLM]:
    "[\<^bold>\<A>(\<^bold>\<A>\<phi> \<^bold>\<rightarrow> \<phi>) in v]"
    using equiv_def logic_actual_nec_2[axiom_instance]
          logic_actual_nec_4[axiom_instance] "\<^bold>&E"(2) "\<^bold>\<equiv>E"(2)
    by metis
  lemma act_conj_act_2[PLM]:
    "[\<^bold>\<A>(\<phi> \<^bold>\<rightarrow> \<^bold>\<A>\<phi>) in v]"
    using logic_actual_nec_2[axiom_instance] qml_act_1[axiom_instance]
          ded_thm_cor_3 "\<^bold>\<equiv>E"(2) nec_imp_act
    by blast
  lemma act_conj_act_3[PLM]:
    "[(\<^bold>\<A>\<phi> \<^bold>& \<^bold>\<A>\<psi>) \<^bold>\<rightarrow> \<^bold>\<A>(\<phi> \<^bold>& \<psi>) in v]"
    unfolding conn_defs
    by (metis logic_actual_nec_2[axiom_instance]
              logic_actual_nec_1[axiom_instance]
              "\<^bold>\<equiv>E"(2) CP "\<^bold>\<equiv>E"(4) reductio_aa_2
              vdash_properties_10)
  lemma act_conj_act_4[PLM]:
    "[\<^bold>\<A>(\<^bold>\<A>\<phi> \<^bold>\<equiv> \<phi>) in v]"
    unfolding equiv_def
    by (PLM_solver PLM_intro: act_conj_act_3[where \<phi>="\<^bold>\<A>\<phi> \<^bold>\<rightarrow> \<phi>"
                                and \<psi>="\<phi> \<^bold>\<rightarrow> \<^bold>\<A>\<phi>", deduction])
  lemma closure_act_1a[PLM]:
    "[\<^bold>\<A>\<^bold>\<A>(\<^bold>\<A>\<phi> \<^bold>\<equiv> \<phi>) in v]"
    using logic_actual_nec_4[axiom_instance]
          act_conj_act_4 "\<^bold>\<equiv>E"(1)
    by blast
  lemma closure_act_1b[PLM]:
    "[\<^bold>\<A>\<^bold>\<A>\<^bold>\<A>(\<^bold>\<A>\<phi> \<^bold>\<equiv> \<phi>) in v]"
    using logic_actual_nec_4[axiom_instance]
          act_conj_act_4 "\<^bold>\<equiv>E"(1)
    by blast
  lemma closure_act_1c[PLM]:
    "[\<^bold>\<A>\<^bold>\<A>\<^bold>\<A>\<^bold>\<A>(\<^bold>\<A>\<phi> \<^bold>\<equiv> \<phi>) in v]"
    using logic_actual_nec_4[axiom_instance]
          act_conj_act_4 "\<^bold>\<equiv>E"(1)
    by blast
  lemma closure_act_2[PLM]:
    "[\<^bold>\<forall>\<alpha>. \<^bold>\<A>(\<^bold>\<A>(\<phi> \<alpha>) \<^bold>\<equiv> \<phi> \<alpha>) in v]"
    by PLM_solver

  lemma closure_act_3[PLM]:
    "[\<^bold>\<A>(\<^bold>\<forall>\<alpha>. \<^bold>\<A>(\<phi> \<alpha>) \<^bold>\<equiv> \<phi> \<alpha>) in v]"
    by (PLM_solver PLM_intro: logic_actual_nec_3[axiom_instance, equiv_rl])
  lemma closure_act_4[PLM]:
    "[\<^bold>\<A>(\<^bold>\<forall>\<alpha>\<^sub>1 \<alpha>\<^sub>2. \<^bold>\<A>(\<phi> \<alpha>\<^sub>1 \<alpha>\<^sub>2) \<^bold>\<equiv> \<phi> \<alpha>\<^sub>1 \<alpha>\<^sub>2) in v]"
    by (PLM_solver PLM_intro: logic_actual_nec_3[axiom_instance, equiv_rl])
  lemma closure_act_4_b[PLM]:
    "[\<^bold>\<A>(\<^bold>\<forall>\<alpha>\<^sub>1 \<alpha>\<^sub>2 \<alpha>\<^sub>3. \<^bold>\<A>(\<phi> \<alpha>\<^sub>1 \<alpha>\<^sub>2 \<alpha>\<^sub>3) \<^bold>\<equiv> \<phi> \<alpha>\<^sub>1 \<alpha>\<^sub>2 \<alpha>\<^sub>3) in v]"
    by (PLM_solver PLM_intro: logic_actual_nec_3[axiom_instance, equiv_rl])
  lemma closure_act_4_c[PLM]:
    "[\<^bold>\<A>(\<^bold>\<forall>\<alpha>\<^sub>1 \<alpha>\<^sub>2 \<alpha>\<^sub>3 \<alpha>\<^sub>4. \<^bold>\<A>(\<phi> \<alpha>\<^sub>1 \<alpha>\<^sub>2 \<alpha>\<^sub>3 \<alpha>\<^sub>4) \<^bold>\<equiv> \<phi> \<alpha>\<^sub>1 \<alpha>\<^sub>2 \<alpha>\<^sub>3 \<alpha>\<^sub>4) in v]"
    by (PLM_solver PLM_intro: logic_actual_nec_3[axiom_instance, equiv_rl])

  lemma RA[PLM,PLM_intro]:
    "([\<phi> in dw]) \<Longrightarrow> [\<^bold>\<A>\<phi> in dw]"
    using logic_actual[necessitation_averse_axiom_instance, equiv_rl] .

  lemma RA_2[PLM,PLM_intro]:
    "([\<psi> in dw] \<Longrightarrow> [\<phi> in dw]) \<Longrightarrow> ([\<^bold>\<A>\<psi> in dw] \<Longrightarrow> [\<^bold>\<A>\<phi> in dw])"
    using RA logic_actual[necessitation_averse_axiom_instance] intro_elim_6_a by blast

  context
  begin
    private lemma ActualE[PLM,PLM_elim,PLM_dest]:
      "[\<^bold>\<A>\<phi> in dw] \<Longrightarrow> [\<phi> in dw]"
      using logic_actual[necessitation_averse_axiom_instance, equiv_lr] .
    
    private lemma NotActualD[PLM_dest]:
      "\<not>[\<^bold>\<A>\<phi> in dw] \<Longrightarrow> \<not>[\<phi> in dw]"
      using RA by metis
    
    private lemma ActualImplI[PLM_intro]:
      "[\<^bold>\<A>\<phi> \<^bold>\<rightarrow> \<^bold>\<A>\<psi> in v] \<Longrightarrow> [\<^bold>\<A>(\<phi> \<^bold>\<rightarrow> \<psi>) in v]"
      using logic_actual_nec_2[axiom_instance, equiv_rl] .
    private lemma ActualImplE[PLM_dest, PLM_elim]:
      "[\<^bold>\<A>(\<phi> \<^bold>\<rightarrow> \<psi>) in v] \<Longrightarrow> [\<^bold>\<A>\<phi> \<^bold>\<rightarrow> \<^bold>\<A>\<psi> in v]"
      using logic_actual_nec_2[axiom_instance, equiv_lr] .
    private lemma NotActualImplD[PLM_dest]:
      "\<not>[\<^bold>\<A>(\<phi> \<^bold>\<rightarrow> \<psi>) in v] \<Longrightarrow> \<not>[\<^bold>\<A>\<phi> \<^bold>\<rightarrow> \<^bold>\<A>\<psi> in v]"
      using ActualImplI by blast
    
    private lemma ActualNotI[PLM_intro]:
      "[\<^bold>\<not>\<^bold>\<A>\<phi> in v] \<Longrightarrow> [\<^bold>\<A>\<^bold>\<not>\<phi> in v]"
      using logic_actual_nec_1[axiom_instance, equiv_rl] .
    lemma ActualNotE[PLM_elim,PLM_dest]:
      "[\<^bold>\<A>\<^bold>\<not>\<phi> in v] \<Longrightarrow> [\<^bold>\<not>\<^bold>\<A>\<phi> in v]"
      using logic_actual_nec_1[axiom_instance, equiv_lr] .
    lemma NotActualNotD[PLM_dest]:
      "\<not>[\<^bold>\<A>\<^bold>\<not>\<phi> in v] \<Longrightarrow> \<not>[\<^bold>\<not>\<^bold>\<A>\<phi> in v]"
      using ActualNotI by blast
    
    private  lemma ActualConjI[PLM_intro]:
      "[\<^bold>\<A>\<phi> \<^bold>& \<^bold>\<A>\<psi> in v] \<Longrightarrow> [\<^bold>\<A>(\<phi> \<^bold>& \<psi>) in v]"
      unfolding equiv_def
      by (PLM_solver PLM_intro: act_conj_act_3[deduction])
    private lemma ActualConjE[PLM_elim,PLM_dest]:
      "[\<^bold>\<A>(\<phi> \<^bold>& \<psi>) in v] \<Longrightarrow> [\<^bold>\<A>\<phi> \<^bold>& \<^bold>\<A>\<psi> in v]"
      unfolding conj_def by PLM_solver
    
    private lemma ActualEquivI[PLM_intro]:
      "[\<^bold>\<A>\<phi> \<^bold>\<equiv> \<^bold>\<A>\<psi> in v] \<Longrightarrow> [\<^bold>\<A>(\<phi> \<^bold>\<equiv> \<psi>) in v]"
      unfolding equiv_def
      by (PLM_solver PLM_intro: act_conj_act_3[deduction])
    private lemma ActualEquivE[PLM_elim, PLM_dest]:
      "[\<^bold>\<A>(\<phi> \<^bold>\<equiv> \<psi>) in v] \<Longrightarrow> [\<^bold>\<A>\<phi> \<^bold>\<equiv> \<^bold>\<A>\<psi> in v]"
      unfolding equiv_def by PLM_solver

    private lemma ActualBoxI[PLM_intro]:
      "[\<^bold>\<box>\<phi> in v] \<Longrightarrow> [\<^bold>\<A>(\<^bold>\<box>\<phi>) in v]"
      using qml_act_2[axiom_instance, equiv_lr] .
    private lemma ActualBoxE[PLM_elim, PLM_dest]:
      "[\<^bold>\<A>(\<^bold>\<box>\<phi>) in v] \<Longrightarrow> [\<^bold>\<box>\<phi> in v]"
      using qml_act_2[axiom_instance, equiv_rl] .
    private lemma NotActualBoxD[PLM_dest]:
      "\<not>[\<^bold>\<A>(\<^bold>\<box>\<phi>) in v] \<Longrightarrow> \<not>[\<^bold>\<box>\<phi> in v]"
      using ActualBoxI by blast

    private lemma ActualDisjI[PLM_intro]:
      "[\<^bold>\<A>\<phi> \<^bold>\<or> \<^bold>\<A>\<psi> in v] \<Longrightarrow> [\<^bold>\<A>(\<phi> \<^bold>\<or> \<psi>) in v]"
      unfolding disj_def by PLM_solver
    private lemma ActualDisjE[PLM_elim,PLM_dest]:
      "[\<^bold>\<A>(\<phi> \<^bold>\<or> \<psi>) in v] \<Longrightarrow> [\<^bold>\<A>\<phi> \<^bold>\<or> \<^bold>\<A>\<psi> in v]"
      unfolding disj_def by PLM_solver
    private lemma NotActualDisjD[PLM_dest]:
      "\<not>[\<^bold>\<A>(\<phi> \<^bold>\<or> \<psi>) in v] \<Longrightarrow> \<not>[\<^bold>\<A>\<phi> \<^bold>\<or> \<^bold>\<A>\<psi> in v]"
      using ActualDisjI by blast

    private lemma ActualForallI[PLM_intro]:
      "[\<^bold>\<forall> x . \<^bold>\<A>(\<phi> x) in v] \<Longrightarrow> [\<^bold>\<A>(\<^bold>\<forall> x . \<phi> x) in v]"
      using logic_actual_nec_3[axiom_instance, equiv_rl] .
    lemma ActualForallE[PLM_elim,PLM_dest]:
      "[\<^bold>\<A>(\<^bold>\<forall> x . \<phi> x) in v] \<Longrightarrow> [\<^bold>\<forall> x . \<^bold>\<A>(\<phi> x) in v]"
      using logic_actual_nec_3[axiom_instance, equiv_lr] .
    lemma NotActualForallD[PLM_dest]:
      "\<not>[\<^bold>\<A>(\<^bold>\<forall> x . \<phi> x) in v] \<Longrightarrow> \<not>[\<^bold>\<forall> x . \<^bold>\<A>(\<phi> x) in v]"
      using ActualForallI by blast

    lemma ActualActualI[PLM_intro]:
      "[\<^bold>\<A>\<phi> in v] \<Longrightarrow> [\<^bold>\<A>\<^bold>\<A>\<phi> in v]"
      using logic_actual_nec_4[axiom_instance, equiv_lr] .
    lemma ActualActualE[PLM_elim,PLM_dest]:
      "[\<^bold>\<A>\<^bold>\<A>\<phi> in v] \<Longrightarrow> [\<^bold>\<A>\<phi> in v]"
      using logic_actual_nec_4[axiom_instance, equiv_rl] .
    lemma NotActualActualD[PLM_dest]:
      "\<not>[\<^bold>\<A>\<^bold>\<A>\<phi> in v] \<Longrightarrow> \<not>[\<^bold>\<A>\<phi> in v]"
      using ActualActualI by blast
  end

  lemma ANeg_1[PLM]:
    "[\<^bold>\<not>\<^bold>\<A>\<phi> \<^bold>\<equiv> \<^bold>\<not>\<phi> in dw]"
    by PLM_solver
  lemma ANeg_2[PLM]:
    "[\<^bold>\<not>\<^bold>\<A>\<^bold>\<not>\<phi> \<^bold>\<equiv> \<phi> in dw]"
    by PLM_solver
  lemma Act_Basic_1[PLM]:
    "[\<^bold>\<A>\<phi> \<^bold>\<or> \<^bold>\<A>\<^bold>\<not>\<phi> in v]"
    by PLM_solver
  lemma Act_Basic_2[PLM]:
    "[\<^bold>\<A>(\<phi> \<^bold>& \<psi>) \<^bold>\<equiv> (\<^bold>\<A>\<phi> \<^bold>& \<^bold>\<A>\<psi>) in v]"
    by PLM_solver
  lemma Act_Basic_3[PLM]:
    "[\<^bold>\<A>(\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<equiv> ((\<^bold>\<A>(\<phi> \<^bold>\<rightarrow> \<psi>)) \<^bold>& (\<^bold>\<A>(\<psi> \<^bold>\<rightarrow> \<phi>))) in v]"
    by PLM_solver
  lemma Act_Basic_4[PLM]:
    "[(\<^bold>\<A>(\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>& \<^bold>\<A>(\<psi> \<^bold>\<rightarrow> \<phi>)) \<^bold>\<equiv> (\<^bold>\<A>\<phi> \<^bold>\<equiv> \<^bold>\<A>\<psi>) in v]"
    by PLM_solver
  lemma Act_Basic_5[PLM]:
    "[\<^bold>\<A>(\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<equiv> (\<^bold>\<A>\<phi> \<^bold>\<equiv> \<^bold>\<A>\<psi>) in v]"
    by PLM_solver
  lemma Act_Basic_6[PLM]:
    "[\<^bold>\<diamond>\<phi> \<^bold>\<equiv> \<^bold>\<A>(\<^bold>\<diamond>\<phi>) in v]"
    unfolding diamond_def by PLM_solver
  lemma Act_Basic_7[PLM]:
    "[\<^bold>\<A>\<phi> \<^bold>\<equiv> \<^bold>\<box>\<^bold>\<A>\<phi> in v]"
    by (simp add: qml_2[axiom_instance] qml_act_1[axiom_instance] "\<^bold>\<equiv>I")
  lemma Act_Basic_8[PLM]:
    "[\<^bold>\<A>(\<^bold>\<box>\<phi>) \<^bold>\<rightarrow> \<^bold>\<box>\<^bold>\<A>\<phi> in v]"
    by (metis qml_act_2[axiom_instance] CP Act_Basic_7 "\<^bold>\<equiv>E"(1)
              "\<^bold>\<equiv>E"(2) nec_imp_act vdash_properties_10)
  lemma Act_Basic_9[PLM]:
    "[\<^bold>\<box>\<phi> \<^bold>\<rightarrow> \<^bold>\<box>\<^bold>\<A>\<phi> in v]"
    using qml_act_1[axiom_instance] ded_thm_cor_3 nec_imp_act by blast
  lemma Act_Basic_10[PLM]:
    "[\<^bold>\<A>(\<phi> \<^bold>\<or> \<psi>) \<^bold>\<equiv> \<^bold>\<A>\<phi> \<^bold>\<or> \<^bold>\<A>\<psi> in v]"
    by PLM_solver

  lemma Act_Basic_11[PLM]:
    "[\<^bold>\<A>(\<^bold>\<exists>\<alpha>. \<phi> \<alpha>) \<^bold>\<equiv> (\<^bold>\<exists>\<alpha>.\<^bold>\<A>(\<phi> \<alpha>)) in v]"
    proof -
      have "[\<^bold>\<A>(\<^bold>\<forall> \<alpha> . \<^bold>\<not>\<phi> \<alpha>) \<^bold>\<equiv> (\<^bold>\<forall> \<alpha> . \<^bold>\<A>\<^bold>\<not>\<phi> \<alpha>) in v]"
        using logic_actual_nec_3[axiom_instance] by blast
      hence "[\<^bold>\<not>\<^bold>\<A>(\<^bold>\<forall> \<alpha> . \<^bold>\<not>\<phi> \<alpha>) \<^bold>\<equiv> \<^bold>\<not>(\<^bold>\<forall> \<alpha> . \<^bold>\<A>\<^bold>\<not>\<phi> \<alpha>) in v]"
        using oth_class_taut_5_d[equiv_lr] by blast
      moreover have "[\<^bold>\<A>\<^bold>\<not>(\<^bold>\<forall> \<alpha> . \<^bold>\<not>\<phi> \<alpha>) \<^bold>\<equiv> \<^bold>\<not>\<^bold>\<A>(\<^bold>\<forall> \<alpha> . \<^bold>\<not>\<phi> \<alpha>) in v]"
        using logic_actual_nec_1[axiom_instance] by blast
      ultimately have "[\<^bold>\<A>\<^bold>\<not>(\<^bold>\<forall> \<alpha> . \<^bold>\<not>\<phi> \<alpha>) \<^bold>\<equiv> \<^bold>\<not>(\<^bold>\<forall> \<alpha> . \<^bold>\<A>\<^bold>\<not>\<phi> \<alpha>) in v]"
        using "\<^bold>\<equiv>E"(5) by auto
      moreover {
        have "[\<^bold>\<forall> \<alpha> . \<^bold>\<A>\<^bold>\<not>\<phi> \<alpha> \<^bold>\<equiv> \<^bold>\<not>\<^bold>\<A>\<phi> \<alpha> in v]"
          using logic_actual_nec_1[axiom_universal, axiom_instance] by blast 
        hence "[(\<^bold>\<forall> \<alpha> . \<^bold>\<A>\<^bold>\<not>\<phi> \<alpha>) \<^bold>\<equiv> (\<^bold>\<forall> \<alpha> . \<^bold>\<not>\<^bold>\<A>\<phi> \<alpha>) in v]"
          using cqt_basic_3[deduction] by fast
        hence "[(\<^bold>\<not>(\<^bold>\<forall> \<alpha> . \<^bold>\<A>\<^bold>\<not>\<phi> \<alpha>)) \<^bold>\<equiv> \<^bold>\<not>(\<^bold>\<forall> \<alpha> . \<^bold>\<not>\<^bold>\<A>\<phi> \<alpha>) in v]"
          using oth_class_taut_5_d[equiv_lr] by blast
      }
      ultimately show ?thesis unfolding exists_def using "\<^bold>\<equiv>E"(5) by auto
    qed

  lemma act_quant_uniq[PLM]:
    "[(\<^bold>\<forall> z . \<^bold>\<A>\<phi> z \<^bold>\<equiv> z \<^bold>= x) \<^bold>\<equiv> (\<^bold>\<forall> z . \<phi> z \<^bold>\<equiv> z \<^bold>= x) in dw]"
    by PLM_solver

  lemma fund_cont_desc[PLM]:
    "[(x\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x)) \<^bold>\<equiv> (\<^bold>\<forall> z . \<phi> z \<^bold>\<equiv> (z \<^bold>= x)) in dw]"
    using descriptions[axiom_instance] act_quant_uniq "\<^bold>\<equiv>E"(5) by fast

  lemma hintikka[PLM]:
    "[(x\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x)) \<^bold>\<equiv> (\<phi> x \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= x)) in dw]"
    proof -
      have "[(\<^bold>\<forall> z . \<phi> z \<^bold>\<equiv> z \<^bold>= x) \<^bold>\<equiv> (\<phi> x \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= x)) in dw]"
        unfolding identity_\<nu>_def apply PLM_solver using id_eq_obj_1 apply simp
        using l_identity[where \<phi>="\<lambda> x . \<phi> x", axiom_instance,
                          deduction, deduction]
        using id_eq_obj_2[deduction] unfolding identity_\<nu>_def by fastforce
      thus ?thesis using "\<^bold>\<equiv>E"(5) fund_cont_desc by blast
    qed

  lemma russell_axiom_a[PLM]:
    "[(\<lparr>F, \<^bold>\<iota>x. \<phi> x\<rparr>) \<^bold>\<equiv> (\<^bold>\<exists> x . \<phi> x \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= x) \<^bold>& \<lparr>F, x\<^sup>P\<rparr>) in dw]"
    (is "[?lhs \<^bold>\<equiv> ?rhs in dw]")
    proof -
      {
        assume 1: "[?lhs in dw]"
        hence "[\<^bold>\<exists>\<alpha>. \<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in dw]"
        using cqt_5[axiom_instance, deduction]
              SimpleExOrEnc.intros
        by blast
        then obtain \<alpha> where 2:
          "[\<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in dw]"
          using "\<^bold>\<exists>E" by auto          
        hence 3: "[\<phi> \<alpha> \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= \<alpha>) in dw]"
          using hintikka[equiv_lr] by simp
        from 2 have "[(\<^bold>\<iota>x. \<phi> x) \<^bold>= (\<alpha>\<^sup>P)  in dw]"
          using l_identity[where \<alpha>="\<alpha>\<^sup>P" and \<beta>="\<^bold>\<iota>x. \<phi> x" and \<phi>="\<lambda> x . x \<^bold>= \<alpha>\<^sup>P",
                axiom_instance, deduction, deduction]
                id_eq_obj_1[where x=\<alpha>] by auto
        hence "[\<lparr>F, \<alpha>\<^sup>P\<rparr> in dw]"
        using 1 l_identity[where \<beta>="\<alpha>\<^sup>P" and \<alpha>="\<^bold>\<iota>x. \<phi> x" and \<phi>="\<lambda> x . \<lparr>F,x\<rparr>",
                           axiom_instance, deduction, deduction] by auto
        with 3 have "[\<phi> \<alpha> \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= \<alpha>) \<^bold>& \<lparr>F, \<alpha>\<^sup>P\<rparr> in dw]" by (rule "\<^bold>&I")
        hence "[?rhs in dw]" using "\<^bold>\<exists>I"[where \<alpha>=\<alpha>] by simp
      }
      moreover {
        assume "[?rhs in dw]"
        then obtain \<alpha> where 4:
          "[\<phi> \<alpha> \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= \<alpha>) \<^bold>& \<lparr>F, \<alpha>\<^sup>P\<rparr> in dw]"
          using "\<^bold>\<exists>E" by auto
        hence "[\<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<phi> x) in dw] \<and> [\<lparr>F, \<alpha>\<^sup>P\<rparr> in dw]"
          using hintikka[equiv_rl] "\<^bold>&E" by blast
        hence "[?lhs in dw]"
          using l_identity[axiom_instance, deduction, deduction]
          by blast
      }
      ultimately show ?thesis by PLM_solver
    qed

  lemma russell_axiom_g[PLM]:
    "[\<lbrace>\<^bold>\<iota>x. \<phi> x,F\<rbrace> \<^bold>\<equiv> (\<^bold>\<exists> x . \<phi> x \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= x) \<^bold>& \<lbrace>x\<^sup>P, F\<rbrace>) in dw]"
    (is "[?lhs \<^bold>\<equiv> ?rhs in dw]")
    proof -
      {
        assume 1: "[?lhs in dw]"
        hence "[\<^bold>\<exists>\<alpha>. \<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in dw]"
        using cqt_5[axiom_instance, deduction] SimpleExOrEnc.intros by blast
        then obtain \<alpha> where 2: "[\<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in dw]" by (rule "\<^bold>\<exists>E")
        hence 3: "[(\<phi> \<alpha> \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= \<alpha>)) in dw]"
          using hintikka[equiv_lr] by simp
        from 2 have "[(\<^bold>\<iota>x. \<phi> x) \<^bold>= \<alpha>\<^sup>P  in dw]"
          using l_identity[where \<alpha>="\<alpha>\<^sup>P" and \<beta>="\<^bold>\<iota>x. \<phi> x" and \<phi>="\<lambda> x . x \<^bold>= \<alpha>\<^sup>P",
                axiom_instance, deduction, deduction]
                id_eq_obj_1[where x=\<alpha>] by auto
        hence "[\<lbrace>\<alpha>\<^sup>P, F\<rbrace> in dw]"
        using 1 l_identity[where \<beta>="\<alpha>\<^sup>P" and \<alpha>="\<^bold>\<iota>x. \<phi> x" and \<phi>="\<lambda> x . \<lbrace>x,F\<rbrace>",
                           axiom_instance, deduction, deduction] by auto
        with 3 have "[(\<phi> \<alpha> \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= \<alpha>)) \<^bold>& \<lbrace>\<alpha>\<^sup>P, F\<rbrace> in dw]"
          using "\<^bold>&I" by auto
        hence "[?rhs in dw]" using "\<^bold>\<exists>I"[where \<alpha>=\<alpha>] by (simp add: identity_defs)
      }
      moreover {
        assume "[?rhs in dw]"
        then obtain \<alpha> where 4:
          "[\<phi> \<alpha> \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= \<alpha>) \<^bold>& \<lbrace>\<alpha>\<^sup>P, F\<rbrace> in dw]"
          using "\<^bold>\<exists>E" by auto
        hence "[\<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<phi> x) in dw] \<and> [\<lbrace>\<alpha>\<^sup>P, F\<rbrace> in dw]"
          using hintikka[equiv_rl] "\<^bold>&E" by blast
        hence "[?lhs in dw]"
          using l_identity[axiom_instance, deduction, deduction]
          by fast
      }
      ultimately show ?thesis by PLM_solver
    qed

  lemma russell_axiom[PLM]:
    assumes "SimpleExOrEnc \<psi>"
    shows "[\<psi> (\<^bold>\<iota>x. \<phi> x) \<^bold>\<equiv> (\<^bold>\<exists> x . \<phi> x \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= x) \<^bold>& \<psi> (x\<^sup>P)) in dw]"
    (is "[?lhs \<^bold>\<equiv> ?rhs in dw]")
    proof -
      {
        assume 1: "[?lhs in dw]"
        hence "[\<^bold>\<exists>\<alpha>. \<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in dw]"
        using cqt_5[axiom_instance, deduction] assms by blast
        then obtain \<alpha> where 2: "[\<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in dw]" by (rule "\<^bold>\<exists>E")
        hence 3: "[(\<phi> \<alpha> \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= \<alpha>)) in dw]"
          using hintikka[equiv_lr] by simp
        from 2 have "[(\<^bold>\<iota>x. \<phi> x) \<^bold>= (\<alpha>\<^sup>P)  in dw]"
          using l_identity[where \<alpha>="\<alpha>\<^sup>P" and \<beta>="\<^bold>\<iota>x. \<phi> x" and \<phi>="\<lambda> x . x \<^bold>= \<alpha>\<^sup>P",
                axiom_instance, deduction, deduction]
                id_eq_obj_1[where x=\<alpha>] by auto
        hence "[\<psi> (\<alpha>\<^sup>P) in dw]"
          using 1 l_identity[where \<beta>="\<alpha>\<^sup>P" and \<alpha>="\<^bold>\<iota>x. \<phi> x" and \<phi>="\<lambda> x . \<psi> x",
                             axiom_instance, deduction, deduction] by auto
        with 3 have "[\<phi> \<alpha> \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= \<alpha>) \<^bold>& \<psi> (\<alpha>\<^sup>P) in dw]"
          using "\<^bold>&I" by auto
        hence "[?rhs in dw]" using "\<^bold>\<exists>I"[where \<alpha>=\<alpha>] by (simp add: identity_defs)
      }
      moreover {
        assume "[?rhs in dw]"
        then obtain \<alpha> where 4:
          "[\<phi> \<alpha> \<^bold>& (\<^bold>\<forall> z . \<phi> z \<^bold>\<rightarrow> z \<^bold>= \<alpha>) \<^bold>& \<psi> (\<alpha>\<^sup>P) in dw]"
          using "\<^bold>\<exists>E" by auto
        hence "[\<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<phi> x) in dw] \<and> [\<psi> (\<alpha>\<^sup>P) in dw]"
          using hintikka[equiv_rl] "\<^bold>&E" by blast
        hence "[?lhs in dw]"
          using l_identity[axiom_instance, deduction, deduction]
          by fast
      }
      ultimately show ?thesis by PLM_solver
    qed

  lemma unique_exists[PLM]:
    "[(\<^bold>\<exists> y . y\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x)) \<^bold>\<equiv> (\<^bold>\<exists>!x . \<phi> x) in dw]"     
    proof((rule "\<^bold>\<equiv>I", rule CP, rule_tac[2] CP))
      assume "[\<^bold>\<exists>y. y\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in dw]"
      then obtain \<alpha> where
        "[\<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in dw]"
        by (rule "\<^bold>\<exists>E")
      hence "[\<phi> \<alpha> \<^bold>& (\<^bold>\<forall>\<beta>. \<phi> \<beta> \<^bold>\<rightarrow> \<beta> \<^bold>= \<alpha>) in dw]"
        using hintikka[equiv_lr] by auto
      thus "[\<^bold>\<exists>!x . \<phi> x in dw]"
        unfolding exists_unique_def using "\<^bold>\<exists>I" by fast
    next
      assume "[\<^bold>\<exists>!x . \<phi> x in dw]"
      then obtain \<alpha> where
        "[\<phi> \<alpha> \<^bold>& (\<^bold>\<forall>\<beta>. \<phi> \<beta> \<^bold>\<rightarrow> \<beta> \<^bold>= \<alpha>) in dw]"
        unfolding exists_unique_def by (rule "\<^bold>\<exists>E")
      hence "[\<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in dw]"
        using hintikka[equiv_rl] by auto
      thus "[\<^bold>\<exists>y. y\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in dw]"
        using "\<^bold>\<exists>I" by fast
    qed

  lemma y_in_1[PLM]:
    "[x\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<phi>) \<^bold>\<rightarrow> \<phi> in dw]"
    using hintikka[equiv_lr, conj1] by (rule CP)

  lemma y_in_2[PLM]:
    "[z\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<phi> x) \<^bold>\<rightarrow> \<phi> z in dw]"
    using hintikka[equiv_lr, conj1] by (rule CP)

  lemma y_in_3[PLM]:
    "[(\<^bold>\<exists> y . y\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<phi> (x\<^sup>P))) \<^bold>\<rightarrow> \<phi> (\<^bold>\<iota>x . \<phi> (x\<^sup>P)) in dw]"
    proof (rule CP)
      assume "[(\<^bold>\<exists> y . y\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<phi> (x\<^sup>P))) in dw]"
      then obtain y where 1:
        "[y\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> (x\<^sup>P)) in dw]"
        by (rule "\<^bold>\<exists>E")
      hence "[\<phi> (y\<^sup>P) in dw]"
        using y_in_2[deduction] unfolding identity_\<nu>_def by blast
      thus "[\<phi> (\<^bold>\<iota>x. \<phi> (x\<^sup>P)) in dw]"
        using l_identity[axiom_instance, deduction,
                         deduction] 1 by fast
    qed

  lemma act_quant_nec[PLM]:
    "[(\<^bold>\<forall>z . (\<^bold>\<A>\<phi> z \<^bold>\<equiv> z \<^bold>= x)) \<^bold>\<equiv> (\<^bold>\<forall>z. \<^bold>\<A>\<^bold>\<A>\<phi> z \<^bold>\<equiv> z \<^bold>= x) in v]"
    by PLM_solver

  lemma equi_desc_descA_1[PLM]:
    "[(x\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<phi> x)) \<^bold>\<equiv> (x\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<^bold>\<A>\<phi> x)) in v]"
    using descriptions[axiom_instance] apply (rule "\<^bold>\<equiv>E"(5))
    using act_quant_nec apply (rule "\<^bold>\<equiv>E"(5))
    using descriptions[axiom_instance]
    by (meson "\<^bold>\<equiv>E"(6) oth_class_taut_4_a)

  lemma equi_desc_descA_2[PLM]:
    "[(\<^bold>\<exists> y . y\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x)) \<^bold>\<rightarrow> ((\<^bold>\<iota>x . \<phi> x) \<^bold>= (\<^bold>\<iota>x . \<^bold>\<A>\<phi> x)) in v]"
    proof (rule CP)
      assume "[\<^bold>\<exists>y. y\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in v]"
      then obtain y where
        "[y\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in v]"
        by (rule "\<^bold>\<exists>E")
      moreover hence "[y\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<^bold>\<A>\<phi> x) in v]"
        using equi_desc_descA_1[equiv_lr] by auto
      ultimately show "[(\<^bold>\<iota>x. \<phi> x) \<^bold>= (\<^bold>\<iota>x. \<^bold>\<A>\<phi> x) in v]"
        using l_identity[axiom_instance, deduction, deduction]
        by fast
    qed

  lemma equi_desc_descA_3[PLM]:
    assumes "SimpleExOrEnc \<psi>"
    shows "[\<psi> (\<^bold>\<iota>x. \<phi> x) \<^bold>\<rightarrow> (\<^bold>\<exists> y . y\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<^bold>\<A>\<phi> x)) in v]"
    proof (rule CP)
      assume "[\<psi> (\<^bold>\<iota>x. \<phi> x) in v]"
      hence "[\<^bold>\<exists>\<alpha>. \<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in v]"
        using cqt_5[OF assms, axiom_instance, deduction] by auto
      then obtain \<alpha> where "[\<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in v]" by (rule "\<^bold>\<exists>E")
      hence "[\<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<^bold>\<A>\<phi> x) in v]"
        using equi_desc_descA_1[equiv_lr] by auto
      thus "[\<^bold>\<exists>y. y\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<^bold>\<A>\<phi> x) in v]"
        using "\<^bold>\<exists>I" by fast
    qed

  lemma equi_desc_descA_4[PLM]:
    assumes "SimpleExOrEnc \<psi>"
    shows "[\<psi> (\<^bold>\<iota>x. \<phi> x) \<^bold>\<rightarrow> ((\<^bold>\<iota>x. \<phi> x) \<^bold>= (\<^bold>\<iota>x. \<^bold>\<A>\<phi> x)) in v]"
    proof (rule CP)
      assume "[\<psi> (\<^bold>\<iota>x. \<phi> x) in v]"
      hence "[\<^bold>\<exists>\<alpha>. \<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in v]"
        using cqt_5[OF assms, axiom_instance, deduction] by auto
      then obtain \<alpha> where "[\<alpha>\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in v]" by (rule "\<^bold>\<exists>E")
      moreover hence "[\<alpha>\<^sup>P  \<^bold>= (\<^bold>\<iota>x . \<^bold>\<A>\<phi> x) in v]"
        using equi_desc_descA_1[equiv_lr] by auto
      ultimately show "[(\<^bold>\<iota>x. \<phi> x)  \<^bold>= (\<^bold>\<iota>x . \<^bold>\<A>\<phi> x) in v]"
        using l_identity[axiom_instance, deduction, deduction] by fast
    qed

  lemma nec_hintikka_scheme[PLM]:
    "[(x\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x)) \<^bold>\<equiv> (\<^bold>\<A>\<phi> x \<^bold>& (\<^bold>\<forall> z . \<^bold>\<A>\<phi> z \<^bold>\<rightarrow> z \<^bold>= x)) in v]"
    using descriptions[axiom_instance]
    apply (rule "\<^bold>\<equiv>E"(5))
    apply PLM_solver
     using id_eq_obj_1 apply simp
     using id_eq_obj_2[deduction]
           l_identity[where \<alpha>="x", axiom_instance, deduction, deduction]
     unfolding identity_\<nu>_def
     apply blast
    using l_identity[where \<alpha>="x", axiom_instance, deduction, deduction]
    id_eq_2[where 'a=\<nu>, deduction] unfolding identity_\<nu>_def by meson

  lemma equiv_desc_eq[PLM]:
    assumes "\<And>x.[\<^bold>\<A>(\<phi> x \<^bold>\<equiv> \<psi> x) in v]"
    shows "[(\<^bold>\<forall> x . ((x\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<phi> x)) \<^bold>\<equiv> (x\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<psi> x)))) in v]"
    proof(rule "\<^bold>\<forall>I")
      fix x
      {
        assume "[x\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<phi> x) in v]"
        hence 1: "[\<^bold>\<A>\<phi> x \<^bold>& (\<^bold>\<forall>z. \<^bold>\<A>\<phi> z \<^bold>\<rightarrow> z \<^bold>= x) in v]"
          using nec_hintikka_scheme[equiv_lr] by auto
        hence 2: "[\<^bold>\<A>\<phi> x in v] \<and> [(\<^bold>\<forall>z. \<^bold>\<A>\<phi> z \<^bold>\<rightarrow> z \<^bold>= x) in v]"
          using "\<^bold>&E" by blast
        {
           fix z
           {
             assume "[\<^bold>\<A>\<psi> z in v]"
             hence "[\<^bold>\<A>\<phi> z in v]"
              using assms[where x=z] apply - by PLM_solver
             moreover have "[\<^bold>\<A>\<phi> z \<^bold>\<rightarrow> z \<^bold>= x in v]"
               using 2 cqt_1[axiom_instance,deduction] by auto
             ultimately have "[z \<^bold>= x in v]"
              using vdash_properties_10 by auto
           }
           hence "[\<^bold>\<A>\<psi> z \<^bold>\<rightarrow> z \<^bold>= x in v]" by (rule CP)
        }
        hence "[(\<^bold>\<forall> z . \<^bold>\<A>\<psi> z \<^bold>\<rightarrow> z \<^bold>= x) in v]" by (rule "\<^bold>\<forall>I")
        moreover have "[\<^bold>\<A>\<psi> x in v]"
          using 1[conj1] assms[where x=x]
          apply - by PLM_solver
        ultimately have "[\<^bold>\<A>\<psi> x \<^bold>& (\<^bold>\<forall>z. \<^bold>\<A>\<psi> z \<^bold>\<rightarrow> z \<^bold>= x) in v]"
          by PLM_solver
        hence "[x\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<psi> x) in v]"
         using nec_hintikka_scheme[where \<phi>="\<psi>", equiv_rl] by auto
      }
      moreover {
        assume "[x\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<psi> x) in v]"
        hence 1: "[\<^bold>\<A>\<psi> x \<^bold>& (\<^bold>\<forall>z. \<^bold>\<A>\<psi> z \<^bold>\<rightarrow> z \<^bold>= x) in v]"
          using nec_hintikka_scheme[equiv_lr] by auto
        hence 2: "[\<^bold>\<A>\<psi> x in v] \<and> [(\<^bold>\<forall>z. \<^bold>\<A>\<psi> z \<^bold>\<rightarrow> z \<^bold>= x) in v]"
          using "\<^bold>&E" by blast
        {
          fix z
          {
            assume "[\<^bold>\<A>\<phi> z in v]"
            hence "[\<^bold>\<A>\<psi> z in v]"
              using assms[where x=z]
              apply - by PLM_solver
            moreover have "[\<^bold>\<A>\<psi> z \<^bold>\<rightarrow> z \<^bold>= x in v]"
              using 2 cqt_1[axiom_instance,deduction] by auto
            ultimately have "[z \<^bold>= x in v]"
              using vdash_properties_10 by auto
          }
          hence "[\<^bold>\<A>\<phi> z \<^bold>\<rightarrow> z \<^bold>= x in v]" by (rule CP)
        }
        hence "[(\<^bold>\<forall>z. \<^bold>\<A>\<phi> z \<^bold>\<rightarrow> z \<^bold>= x) in v]" by (rule "\<^bold>\<forall>I")
        moreover have "[\<^bold>\<A>\<phi> x in v]"
          using 1[conj1] assms[where x=x]
          apply - by PLM_solver
        ultimately have "[\<^bold>\<A>\<phi> x \<^bold>& (\<^bold>\<forall>z. \<^bold>\<A>\<phi> z \<^bold>\<rightarrow> z \<^bold>= x) in v]"
          by PLM_solver
        hence "[x\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) in v]"
          using nec_hintikka_scheme[where \<phi>="\<phi>",equiv_rl]
          by auto
      }
      ultimately show "[x\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> x) \<^bold>\<equiv> (x\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<psi> x) in v]"
        using "\<^bold>\<equiv>I" CP by auto
    qed

  lemma UniqueAux:
    assumes "[(\<^bold>\<A>\<phi> (\<alpha>::\<nu>) \<^bold>& (\<^bold>\<forall> z . \<^bold>\<A>(\<phi> z) \<^bold>\<rightarrow> z \<^bold>= \<alpha>)) in v]"
    shows "[(\<^bold>\<forall> z . (\<^bold>\<A>(\<phi> z) \<^bold>\<equiv> (z \<^bold>= \<alpha>))) in v]"
    proof -
      {
        fix z
        {
          assume "[\<^bold>\<A>(\<phi> z) in v]"
          hence "[z \<^bold>= \<alpha> in v]"
            using assms[conj2, THEN cqt_1[where \<alpha>=z,
                          axiom_instance, deduction],
                        deduction] by auto
        }
        moreover {
          assume "[z \<^bold>= \<alpha> in v]"
          hence "[\<alpha> \<^bold>= z in v]"
            unfolding identity_\<nu>_def
            using id_eq_obj_2[deduction] by fast
          hence "[\<^bold>\<A>(\<phi> z) in v]" using assms[conj1]
            using l_identity[axiom_instance, deduction,
                             deduction] by fast
        }
        ultimately have "[(\<^bold>\<A>(\<phi> z) \<^bold>\<equiv> (z \<^bold>= \<alpha>)) in v]"
          using "\<^bold>\<equiv>I" CP by auto
      }
      thus "[(\<^bold>\<forall> z . (\<^bold>\<A>(\<phi> z) \<^bold>\<equiv> (z \<^bold>= \<alpha>))) in v]"
      by (rule "\<^bold>\<forall>I")
    qed

  lemma nec_russell_axiom[PLM]:
    assumes "SimpleExOrEnc \<psi>"
    shows "[(\<psi> (\<^bold>\<iota>x. \<phi> x)) \<^bold>\<equiv> (\<^bold>\<exists> x . (\<^bold>\<A>\<phi> x \<^bold>& (\<^bold>\<forall> z . \<^bold>\<A>(\<phi> z) \<^bold>\<rightarrow> z \<^bold>= x))
                              \<^bold>& \<psi> (x\<^sup>P)) in v]"
    (is "[?lhs \<^bold>\<equiv> ?rhs in v]")
    proof -
      {
        assume 1: "[?lhs in v]"
        hence "[\<^bold>\<exists>\<alpha>. (\<alpha>\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi> x) in v]"
          using cqt_5[axiom_instance, deduction] assms by blast
        then obtain \<alpha> where 2: "[(\<alpha>\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi> x) in v]" by (rule "\<^bold>\<exists>E")
        hence "[(\<^bold>\<forall> z . (\<^bold>\<A>(\<phi> z) \<^bold>\<equiv> (z \<^bold>= \<alpha>))) in v]"
          using descriptions[axiom_instance, equiv_lr] by auto
        hence 3: "[(\<^bold>\<A>\<phi> \<alpha>) \<^bold>& (\<^bold>\<forall> z . (\<^bold>\<A>(\<phi> z) \<^bold>\<rightarrow> (z \<^bold>= \<alpha>))) in v]"
          using cqt_1[where \<alpha>=\<alpha> and \<phi>="\<lambda> z . (\<^bold>\<A>(\<phi> z) \<^bold>\<equiv> (z \<^bold>= \<alpha>))",
                      axiom_instance, deduction, equiv_rl]
          using id_eq_obj_1[where x=\<alpha>] unfolding identity_\<nu>_def
          using hintikka[equiv_lr] cqt_basic_2[equiv_lr,conj1]
          "\<^bold>&I" by fast
        from 2 have "[(\<^bold>\<iota>x. \<phi> x) \<^bold>= (\<alpha>\<^sup>P)  in v]"
          using l_identity[where \<beta>="(\<^bold>\<iota>x. \<phi> x)" and \<phi>="\<lambda> x . x \<^bold>= (\<alpha>\<^sup>P)",
                axiom_instance, deduction, deduction]
                id_eq_obj_1[where x=\<alpha>] by auto
        hence "[\<psi> (\<alpha>\<^sup>P) in v]"
          using 1 l_identity[where \<alpha>="(\<^bold>\<iota>x. \<phi> x)" and \<phi>="\<lambda> x . \<psi> x",
                             axiom_instance, deduction,
                             deduction] by auto
        with 3 have "[(\<^bold>\<A>\<phi> \<alpha> \<^bold>& (\<^bold>\<forall> z . \<^bold>\<A>(\<phi> z) \<^bold>\<rightarrow> (z \<^bold>= \<alpha>))) \<^bold>& \<psi> (\<alpha>\<^sup>P) in v]"
          using "\<^bold>&I" by simp
        hence "[?rhs in v]"
          using "\<^bold>\<exists>I"[where \<alpha>=\<alpha>]
          by (simp add: identity_defs)
      }
      moreover {
        assume "[?rhs in v]"
        then obtain \<alpha> where 4:
          "[(\<^bold>\<A>\<phi> \<alpha> \<^bold>& (\<^bold>\<forall> z . \<^bold>\<A>(\<phi> z) \<^bold>\<rightarrow> z \<^bold>= \<alpha>)) \<^bold>& \<psi> (\<alpha>\<^sup>P) in v]"
          using "\<^bold>\<exists>E" by auto
        hence "[(\<^bold>\<forall> z . (\<^bold>\<A>(\<phi> z) \<^bold>\<equiv> (z \<^bold>= \<alpha>))) in v]"
          using UniqueAux "\<^bold>&E"(1) by auto
        hence "[(\<alpha>\<^sup>P) \<^bold>= (\<^bold>\<iota>x . \<phi> x) in v] \<and> [\<psi> (\<alpha>\<^sup>P) in v]"
          using descriptions[axiom_instance, equiv_rl]
                4[conj2] by blast
        hence "[?lhs in v]"
          using l_identity[axiom_instance, deduction,
                           deduction]
          by fast
      }
      ultimately show ?thesis by PLM_solver
    qed

  lemma actual_desc_1[PLM]:
    "[(\<^bold>\<exists> y . (y\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi> x)) \<^bold>\<equiv> (\<^bold>\<exists>! x . \<^bold>\<A>(\<phi> x)) in v]" (is "[?lhs \<^bold>\<equiv> ?rhs in v]")
    proof -
      {
        assume "[?lhs in v]"
        then obtain \<alpha> where
          "[((\<alpha>\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi> x)) in v]"
          by (rule "\<^bold>\<exists>E")
        hence "[\<lparr>A!,(\<^bold>\<iota>x. \<phi> x)\<rparr> in v] \<or> [(\<alpha>\<^sup>P) \<^bold>=\<^sub>E (\<^bold>\<iota>x. \<phi> x) in v]"
          apply - unfolding identity_defs by PLM_solver
        then obtain x where
          "[((\<^bold>\<A>\<phi> x \<^bold>& (\<^bold>\<forall> z . \<^bold>\<A>(\<phi> z) \<^bold>\<rightarrow> z \<^bold>= x))) in v]"
          using nec_russell_axiom[where \<psi>="\<lambda>x . \<lparr>A!,x\<rparr>", equiv_lr, THEN "\<^bold>\<exists>E"]
          using nec_russell_axiom[where \<psi>="\<lambda>x . (\<alpha>\<^sup>P) \<^bold>=\<^sub>E x", equiv_lr, THEN "\<^bold>\<exists>E"]
          using SimpleExOrEnc.intros unfolding identity\<^sub>E_infix_def
          by (meson "\<^bold>&E")
        hence "[?rhs in v]" unfolding exists_unique_def by (rule "\<^bold>\<exists>I")
      }
      moreover {
        assume "[?rhs in v]"
        then obtain x where
          "[((\<^bold>\<A>\<phi> x \<^bold>& (\<^bold>\<forall> z . \<^bold>\<A>(\<phi> z) \<^bold>\<rightarrow> z \<^bold>= x))) in v]"
          unfolding exists_unique_def by (rule "\<^bold>\<exists>E")
        hence "[\<^bold>\<forall>z. \<^bold>\<A>\<phi> z \<^bold>\<equiv> z \<^bold>= x in v]"
          using UniqueAux by auto
        hence "[(x\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi> x) in v]"
          using descriptions[axiom_instance, equiv_rl] by auto
        hence "[?lhs in v]" by (rule "\<^bold>\<exists>I")
      }
      ultimately show ?thesis
        using "\<^bold>\<equiv>I" CP by auto
    qed

  lemma actual_desc_2[PLM]:
    "[(x\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi>) \<^bold>\<rightarrow> \<^bold>\<A>\<phi> in v]"
    using nec_hintikka_scheme[equiv_lr, conj1]
    by (rule CP)

  lemma actual_desc_3[PLM]:
    "[(z\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi> x) \<^bold>\<rightarrow> \<^bold>\<A>(\<phi> z) in v]"
    using nec_hintikka_scheme[equiv_lr, conj1]
    by (rule CP)

  lemma actual_desc_4[PLM]:
    "[(\<^bold>\<exists> y . ((y\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi> (x\<^sup>P)))) \<^bold>\<rightarrow> \<^bold>\<A>(\<phi> (\<^bold>\<iota>x. \<phi> (x\<^sup>P))) in v]"
    proof (rule CP)
      assume "[(\<^bold>\<exists> y . (y\<^sup>P) \<^bold>= (\<^bold>\<iota>x . \<phi> (x\<^sup>P))) in v]"
      then obtain y where 1:
        "[y\<^sup>P \<^bold>= (\<^bold>\<iota>x. \<phi> (x\<^sup>P)) in v]"
        by (rule "\<^bold>\<exists>E")
      hence "[\<^bold>\<A>(\<phi> (y\<^sup>P)) in v]" using actual_desc_3[deduction] by fast
      thus "[\<^bold>\<A>(\<phi> (\<^bold>\<iota>x. \<phi> (x\<^sup>P))) in v]"
        using l_identity[axiom_instance, deduction,
                         deduction] 1 by fast
    qed

  lemma unique_box_desc_1[PLM]:
    "[(\<^bold>\<exists>!x . \<^bold>\<box>(\<phi> x)) \<^bold>\<rightarrow> (\<^bold>\<forall> y . (y\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi> x) \<^bold>\<rightarrow> \<phi> y) in v]"
    proof (rule CP)
      assume "[(\<^bold>\<exists>!x . \<^bold>\<box>(\<phi> x)) in v]"
      then obtain \<alpha> where 1:
        "[\<^bold>\<box>\<phi> \<alpha> \<^bold>& (\<^bold>\<forall>\<beta>. \<^bold>\<box>(\<phi> \<beta>) \<^bold>\<rightarrow> \<beta> \<^bold>= \<alpha>) in v]"
        unfolding exists_unique_def by (rule "\<^bold>\<exists>E")
      {
        fix y
        {
          assume "[(y\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi> x) in v]"
          hence "[\<^bold>\<A>\<phi> \<alpha> \<^bold>\<rightarrow> \<alpha> \<^bold>= y in v]"
            using nec_hintikka_scheme[where x="y" and \<phi>="\<phi>", equiv_lr, conj2,
                          THEN cqt_1[where \<alpha>=\<alpha>,axiom_instance, deduction]] by simp
          hence "[\<alpha> \<^bold>= y in v]"
            using 1[conj1] nec_imp_act vdash_properties_10 by blast
          hence "[\<phi> y in v]"
            using 1[conj1] qml_2[axiom_instance, deduction]
                  l_identity[axiom_instance, deduction, deduction]
            by fast
        }
        hence "[(y\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi> x) \<^bold>\<rightarrow> \<phi> y in v]"
          by (rule CP)
      }
      thus "[\<^bold>\<forall> y . (y\<^sup>P) \<^bold>= (\<^bold>\<iota>x. \<phi> x) \<^bold>\<rightarrow> \<phi> y in v]"
        by (rule "\<^bold>\<forall>I")
    qed

  lemma unique_box_desc[PLM]:
    "[(\<^bold>\<forall> x . (\<phi> x \<^bold>\<rightarrow> \<^bold>\<box>(\<phi> x))) \<^bold>\<rightarrow> ((\<^bold>\<exists>!x . \<phi> x)
      \<^bold>\<rightarrow> (\<^bold>\<forall> y . (y\<^sup>P \<^bold>= (\<^bold>\<iota>x . \<phi> x)) \<^bold>\<rightarrow> \<phi> y)) in v]"
    apply (rule CP, rule CP)
    using nec_exist_unique[deduction, deduction]
          unique_box_desc_1[deduction] by blast


  lemma RM_1[PLM]:
    "(\<And>v.[\<phi> \<^bold>\<rightarrow> \<psi> in v]) \<Longrightarrow> [\<^bold>\<box>\<phi> \<^bold>\<rightarrow> \<^bold>\<box>\<psi> in v]"
    using RN qml_1[axiom_instance] vdash_properties_10 by blast

  lemma RM_1_b[PLM]:
    "(\<And>v.[\<chi> in v] \<Longrightarrow> [\<phi> \<^bold>\<rightarrow> \<psi> in v]) \<Longrightarrow> ([\<^bold>\<box>\<chi> in v] \<Longrightarrow> [\<^bold>\<box>\<phi> \<^bold>\<rightarrow> \<^bold>\<box>\<psi> in v])"
    using RN_2 qml_1[axiom_instance] vdash_properties_10 by blast

  lemma RM_2[PLM]:
    "(\<And>v.[\<phi> \<^bold>\<rightarrow> \<psi> in v]) \<Longrightarrow> [\<^bold>\<diamond>\<phi> \<^bold>\<rightarrow> \<^bold>\<diamond>\<psi> in v]"
    unfolding diamond_def
    using RM_1 contraposition_1 by auto

  lemma RM_2_b[PLM]:
    "(\<And>v.[\<chi> in v] \<Longrightarrow> [\<phi> \<^bold>\<rightarrow> \<psi> in v]) \<Longrightarrow> ([\<^bold>\<box>\<chi> in v] \<Longrightarrow> [\<^bold>\<diamond>\<phi> \<^bold>\<rightarrow> \<^bold>\<diamond>\<psi> in v])"
    unfolding diamond_def
    using RM_1_b contraposition_1 by blast

  lemma KBasic_1[PLM]:
    "[\<^bold>\<box>\<phi> \<^bold>\<rightarrow> \<^bold>\<box>(\<psi> \<^bold>\<rightarrow> \<phi>) in v]"
    by (simp only: pl_1[axiom_instance] RM_1)
  lemma KBasic_2[PLM]:
    "[\<^bold>\<box>(\<^bold>\<not>\<phi>) \<^bold>\<rightarrow> \<^bold>\<box>(\<phi> \<^bold>\<rightarrow> \<psi>) in v]"
    by (simp only: RM_1 useful_tautologies_3)
  lemma KBasic_3[PLM]:
    "[\<^bold>\<box>(\<phi> \<^bold>& \<psi>) \<^bold>\<equiv> \<^bold>\<box>\<phi> \<^bold>& \<^bold>\<box>\<psi> in v]"
    apply (rule "\<^bold>\<equiv>I")
     apply (rule CP)
     apply (rule "\<^bold>&I")
      using RM_1 oth_class_taut_9_a vdash_properties_6 apply blast
     using RM_1 oth_class_taut_9_b vdash_properties_6 apply blast
    using qml_1[axiom_instance] RM_1 ded_thm_cor_3 oth_class_taut_10_a
          oth_class_taut_8_b vdash_properties_10
    by blast
  lemma KBasic_4[PLM]:
    "[\<^bold>\<box>(\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<equiv> (\<^bold>\<box>(\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>& \<^bold>\<box>(\<psi> \<^bold>\<rightarrow> \<phi>)) in v]"
    apply (rule "\<^bold>\<equiv>I")
     unfolding equiv_def using KBasic_3 PLM.CP "\<^bold>\<equiv>E"(1)
     apply blast
    using KBasic_3 PLM.CP "\<^bold>\<equiv>E"(2)
    by blast
  lemma KBasic_5[PLM]:
    "[(\<^bold>\<box>(\<phi> \<^bold>\<rightarrow> \<psi>) \<^bold>& \<^bold>\<box>(\<psi> \<^bold>\<rightarrow> \<phi>)) \<^bold>\<rightarrow> (\<^bold>\<box>\<phi> \<^bold>\<equiv> \<^bold>\<box>\<psi>) in v]"
    by (metis qml_1[axiom_instance] CP "\<^bold>&E" "\<^bold>\<equiv>I" vdash_properties_10)
  lemma KBasic_6[PLM]:
    "[\<^bold>\<box>(\<phi> \<^bold>\<equiv> \<psi>) \<^bold>\<rightarrow> (\<^bold>\<box>\<phi> \<^bold>\<equiv> \<^bold>\<box>\<psi>) in v]"
    using KBasic_4 KBasic_5 by (metis equiv_def ded_thm_cor_3 "\<^bold>&E"(1))
  lemma "[(\<^bold>\<box>\<phi> \<^bold>\<equiv> \<^bold>\<box>\<psi>) \<^bold>\<rightarrow> \<^bold>\<box>(\<phi> \<^bold>\<equiv> \<psi>) in v]"
    nitpick[expect=genuine, user_axioms, card = 1, card i = 2]
  lemma KBasic_7[PLM]:
    "[(\<^bold>\<box>\<phi> \<^bold>& \<^bold>\<box>\<psi>) \<^bold>\<rightarrow> \<^bold>\<box>(\<phi> \<^bold>\<equiv> \<psi>) in v]"
    proof (rule CP)
      assume "[\<^bold>\<box>\<phi> \<^bold>& \<^bold>\<box>\<psi> in v]"
      hence "[\<^bold>\<box>(\<psi> \<^bold>\<rightarrow> \<phi>) in v] \<and> [\<^bold>\<box>(\<phi> \<^bold>\<rightarrow> \<psi>) in v]"
        using "\<^bold>&E" KBasic_1 vdash_properties_10 by blast
      thus "[\<^bold>\<box>(\<phi> \<^bold>\<equiv> \<psi>) in v]"
        using KBasic_4 "\<^bold>\<equiv>E"(2) intro_elim_1 by blast
    qed

  lemma KBasic_8[PLM]:
    "[\<^bold>\<box>(\<phi> \<^bold>& \<psi>) \<^bold>\<rightarrow> \<^bold>\<box>(\<phi> \<^bold>\<equiv> \<psi>) in v]"
    using KBasic_7 KBasic_3
    by (metis equiv_def PLM.ded_thm_cor_3 "\<^bold>&E"(1))
  lemma KBasic_9[PLM]:
    "[\<^bold>\<box>((\<^bold>\<not>\<phi>) \<^bold>& (\<^bold>\<not>\<psi>)) \<^bold>\<rightarrow> \<^bold>\<box>(\<phi> \<^bold>\<equiv> \<psi>) in v]"
    proof (rule CP)
      assume "[\<^bold>\<box>((\<^bold>\<not>\<phi>) \<^bold>& (\<^bold>\<not>\<psi>)) in v]"
      hence "[\<^bold>\<box>((\<^bold>\<not>\<phi>) \<^bold>\<equiv> (\<^bold>\<not>\<psi>)) in v]"
        using KBasic_8 vdash_properties_10 by blast
      moreover have "\<And>v.[((\<^bold>\<not>\<phi>) \<^bold>\<equiv> (\<^bold>\<not>\<psi>)) \<^bold>\<rightarrow> (\<phi> \<^bold>\<equiv> \<psi>) in v]"
        using CP "\<^bold>\<equiv>E"(2) oth_class_taut_5_d by blast
      ultimately show "[\<^bold>\<box>(\<phi> \<^bold>\<equiv> \<psi>) in v]"
        using RM_1 PLM.vdash_properties_10 by blast
    qed

  lemma rule_sub_lem_1_a[PLM]:
    "[\<^bold>\<box>(\<psi> \<^bold>\<equiv> \<chi>) in v] \<Longrightarrow> [(\<^bold>\<not>\<psi>) \<^bold>\<equiv> (\<^bold>\<not>\<chi>) in v]"
    using qml_2[axiom_instance] "\<^bold>\<equiv>E"(1) oth_class_taut_5_d
          vdash_properties_10
    by blast
  lemma rule_sub_lem_1_b[PLM]:
    "[\<^bold>\<box>(\<psi> \<^bold>\<equiv> \<chi>) in v] \<Longrightarrow> [(\<psi> \<^bold>\<rightarrow> \<Theta>) \<^bold>\<equiv> (\<chi> \<^bold>\<rightarrow> \<Theta>) in v]"
    by (metis equiv_def contraposition_1 CP "\<^bold>&E"(2) "\<^bold>\<equiv>I"
              "\<^bold>\<equiv>E"(1) rule_sub_lem_1_a)
  lemma rule_sub_lem_1_c[PLM]:
    "[\<^bold>\<box>(\<psi> \<^bold>\<equiv> \<chi>) in v] \<Longrightarrow> [(\<Theta> \<^bold>\<rightarrow> \<psi>) \<^bold>\<equiv> (\<Theta> \<^bold>\<rightarrow> \<chi>) in v]"
    by (metis CP "\<^bold>\<equiv>I" "\<^bold>\<equiv>E"(3) "\<^bold>\<equiv>E"(4) "\<^bold>\<not>\<^bold>\<not>I"
              "\<^bold>\<not>\<^bold>\<not>E" rule_sub_lem_1_a)
  lemma rule_sub_lem_1_d[PLM]:
    "(\<And>x.[\<^bold>\<box>(\<psi> x \<^bold>\<equiv> \<chi> x) in v]) \<Longrightarrow> [(\<^bold>\<forall>\<alpha>. \<psi> \<alpha>) \<^bold>\<equiv> (\<^bold>\<forall>\<alpha>. \<chi> \<alpha>) in v]" 
    by (metis equiv_def "\<^bold>\<forall>I" CP "\<^bold>&E" "\<^bold>\<equiv>I" raa_cor_1
              vdash_properties_10 rule_sub_lem_1_a "\<^bold>\<forall>E")
  lemma rule_sub_lem_1_e[PLM]:
    "[\<^bold>\<box>(\<psi> \<^bold>\<equiv> \<chi>) in v] \<Longrightarrow> [\<^bold>\<A>\<psi> \<^bold>\<equiv> \<^bold>\<A>\<chi> in v]"
    using Act_Basic_5 "\<^bold>\<equiv>E"(1) nec_imp_act
          vdash_properties_10
    by blast
  lemma rule_sub_lem_1_f[PLM]:
    "[\<^bold>\<box>(\<psi> \<^bold>\<equiv> \<chi>) in v] \<Longrightarrow> [\<^bold>\<box>\<psi> \<^bold>\<equiv> \<^bold>\<box>\<chi> in v]" 
    using KBasic_6 "\<^bold>\<equiv>I" "\<^bold>\<equiv>E"(1) vdash_properties_9
    by blast


  named_theorems Substable_intros
  
  definition Substable :: "('a\<Rightarrow>'a\<Rightarrow>bool)\<Rightarrow>('a\<Rightarrow>\<o>) \<Rightarrow> bool"
    where "Substable \<equiv> (\<lambda> cond \<phi> . \<forall> \<psi> \<chi> v . (cond \<psi> \<chi>) \<longrightarrow> [\<phi> \<psi> \<^bold>\<equiv> \<phi> \<chi> in v])"
  
  lemma Substable_intro_const[Substable_intros]:
    "Substable cond (\<lambda> \<phi> . \<Theta>)"
    unfolding Substable_def using oth_class_taut_4_a by blast

  lemma Substable_intro_not[Substable_intros]:
    assumes "Substable cond \<psi>"
    shows "Substable cond (\<lambda> \<phi> . \<^bold>\<not>(\<psi> \<phi>))"
    using assms unfolding Substable_def
    using rule_sub_lem_1_a RN_2 "\<^bold>\<equiv>E" oth_class_taut_5_d by metis
  lemma Substable_intro_impl[Substable_intros]:
    assumes "Substable cond \<psi>"
        and "Substable cond \<chi>"
    shows "Substable cond (\<lambda> \<phi> . \<psi> \<phi> \<^bold>\<rightarrow> \<chi> \<phi>)"
    using assms unfolding Substable_def
    by (metis "\<^bold>\<equiv>I" CP intro_elim_6_a intro_elim_6_b)
  lemma Substable_intro_box[Substable_intros]:
    assumes "Substable cond \<psi>"
    shows "Substable cond (\<lambda> \<phi> . \<^bold>\<box>(\<psi> \<phi>))"
    using assms unfolding Substable_def
    using rule_sub_lem_1_f RN by meson
  lemma Substable_intro_actual[Substable_intros]:
    assumes "Substable cond \<psi>"
    shows "Substable cond (\<lambda> \<phi> . \<^bold>\<A>(\<psi> \<phi>))"
    using assms unfolding Substable_def
    using rule_sub_lem_1_e RN by meson
  lemma Substable_intro_all[Substable_intros]:
    assumes "\<forall> x . Substable cond (\<psi> x)"
    shows "Substable cond (\<lambda> \<phi> . \<^bold>\<forall> x . \<psi> x \<phi>)"
    using assms unfolding Substable_def
    by (simp add: RN rule_sub_lem_1_d)

  named_theorems Substable_Cond_defs
end

class Substable =
  fixes Substable_Cond :: "'a\<Rightarrow>'a\<Rightarrow>bool"
  assumes rule_sub_nec:
    "\<And> \<phi> \<psi> \<chi> \<Theta> v . \<lbrakk>PLM.Substable Substable_Cond \<phi>; Substable_Cond \<psi> \<chi>\<rbrakk>
      \<Longrightarrow> \<Theta> [\<phi> \<psi> in v] \<Longrightarrow> \<Theta> [\<phi> \<chi> in v]"

instantiation \<o> :: Substable
begin
  definition Substable_Cond_\<o> where [PLM.Substable_Cond_defs]:
    "Substable_Cond_\<o> \<equiv> \<lambda> \<phi> \<psi> . \<forall> v . [\<phi> \<^bold>\<equiv> \<psi> in v]"
  instance proof
    interpret PLM .
    fix \<phi> :: "\<o> \<Rightarrow> \<o>" and  \<psi> \<chi> :: \<o> and \<Theta> :: "bool \<Rightarrow> bool" and v::i
    assume "Substable Substable_Cond \<phi>"
    moreover assume "Substable_Cond \<psi> \<chi>"
    ultimately have "[\<phi> \<psi> \<^bold>\<equiv> \<phi> \<chi> in v]"
    unfolding Substable_def by blast
    hence "[\<phi> \<psi> in v] = [\<phi> \<chi> in v]" using "\<^bold>\<equiv>E" by blast
    moreover assume "\<Theta> [\<phi> \<psi> in v]"
    ultimately show "\<Theta> [\<phi> \<chi> in v]" by simp
  qed
end

instantiation "fun" :: (type, Substable) Substable
begin
  definition Substable_Cond_fun where [PLM.Substable_Cond_defs]:
    "Substable_Cond_fun \<equiv> \<lambda> \<phi> \<psi> . \<forall> x . Substable_Cond (\<phi> x) (\<psi> x)"
  instance proof
    interpret PLM .
    fix \<phi>:: "('a \<Rightarrow> 'b) \<Rightarrow> \<o>" and  \<psi> \<chi> :: "'a \<Rightarrow> 'b" and \<Theta> v
    assume "Substable Substable_Cond \<phi>"
    moreover assume "Substable_Cond \<psi> \<chi>"
    ultimately have "[\<phi> \<psi> \<^bold>\<equiv> \<phi> \<chi> in v]"
      unfolding Substable_def by blast
    hence "[\<phi> \<psi> in v] = [\<phi> \<chi> in v]" using "\<^bold>\<equiv>E" by blast
    moreover assume "\<Theta> [\<phi> \<psi> in v]"
    ultimately show "\<Theta> [\<phi> \<chi> in v]" by simp
  qed
end

context PLM
begin

  lemma Substable_intro_equiv[Substable_intros]:
    assumes "Substable cond \<psi>"
        and "Substable cond \<chi>"
    shows "Substable cond (\<lambda> \<phi> . \<psi> \<phi> \<^bold>\<equiv> \<chi> \<phi>)"
    unfolding conn_defs by (simp add: assms Substable_intros)
  lemma Substable_intro_conj[Substable_intros]:
    assumes "Substable cond \<psi>"
        and "Substable cond \<chi>"
    shows "Substable cond (\<lambda> \<phi> . \<psi> \<phi> \<^bold>& \<chi> \<phi>)"
    unfolding conn_defs by (simp add: assms Substable_intros)
  lemma Substable_intro_disj[Substable_intros]:
    assumes "Substable cond \<psi>"
        and "Substable cond \<chi>"
    shows "Substable cond (\<lambda> \<phi> . \<psi> \<phi> \<^bold>\<or> \<chi> \<phi>)"
    unfolding conn_defs by (simp add: assms Substable_intros)
  lemma Substable_intro_diamond[Substable_intros]:
    assumes "Substable cond \<psi>"
    shows "Substable cond (\<lambda> \<phi> . \<^bold>\<diamond>(\<psi> \<phi>))"
    unfolding conn_defs by (simp add: assms Substable_intros)
  lemma Substable_intro_exist[Substable_intros]:
    assumes "\<forall> x . Substable cond (\<psi> x)"
    shows "Substable cond (\<lambda> \<phi> . \<^bold>\<exists> x . \<psi> x \<phi>)"
    unfolding conn_defs by (simp add: assms Substable_intros)

  lemma Substable_intro_id_\<o>[Substable_intros]:
    "Substable Substable_Cond (\<lambda> \<phi> . \<phi>)"
    unfolding Substable_def Substable_Cond_\<o>_def by blast
  lemma Substable_intro_id_fun[Substable_intros]:
    assumes "Substable Substable_Cond \<psi>"
    shows "Substable Substable_Cond (\<lambda> \<phi> . \<psi> (\<phi> x))"
    using assms unfolding Substable_def Substable_Cond_fun_def
    by blast

  method PLM_subst_method for \<psi>::"'a::Substable" and \<chi>::"'a::Substable" =
    (match conclusion in "\<Theta> [\<phi> \<chi> in v]" for \<Theta> and \<phi> and v \<Rightarrow>

  method PLM_autosubst =
    (match premises in "\<And>v . [\<psi> \<^bold>\<equiv> \<chi> in v]" for \<psi> and \<chi> \<Rightarrow>
