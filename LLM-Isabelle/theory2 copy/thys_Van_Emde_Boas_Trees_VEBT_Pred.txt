theory VEBT_Pred imports VEBT_MinMax VEBT_Insert
begin


definition is_pred_in_set :: "nat set \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> bool" where
  "is_pred_in_set xs x y =  (y \<in> xs \<and> y < x \<and> (\<forall> z \<in> xs. (z < x \<longrightarrow> z \<le> y)))"

context VEBT_internal begin  
  

corollary pred_member: "is_pred_in_set (set_vebt' t) x y = (vebt_member t y \<and> y < x \<and> (\<forall> z. vebt_member t z \<and> z < x \<longrightarrow> z \<le> y))" 
  using is_pred_in_set_def set_vebt'_def by auto

lemma "finite (A:: nat set) \<Longrightarrow> A \<noteq> {}\<Longrightarrow> Max A \<in> A"
proof(induction A rule: finite.induct)
  case emptyI
  then show ?case by blast
next
  case (insertI A a)
  then show ?case 
    by (meson Max_in finite_insert)
qed

lemma obtain_set_pred: assumes "(x::nat) > z " and "min_in_set A z" and "finite A"  shows "\<exists> y. is_pred_in_set A x y"
proof-
  have "{y \<in> A. y < x} \<noteq> {}"
    using assms(1) assms(2) min_in_set_def by auto
  hence "Max {y \<in> A. y < x} \<in> {y \<in> A. y < x}" 
    by (metis (full_types) Max_eq_iff finite_M_bounded_by_nat)
  moreover have "i \<in> A\<Longrightarrow> i < x \<Longrightarrow> i \<le> Max {y \<in> A. y < x} " for i by simp
  ultimately have "is_pred_in_set A x (Max {y \<in> A. y < x})" 
    using is_pred_in_set_def by auto
  then show?thesis by auto
qed

lemma pred_none_empty: assumes "(\<nexists> x. is_pred_in_set (xs) a x)"  and "finite xs"shows "\<not> (\<exists> x \<in> xs. ord_class.less x a)"
proof-
  have "\<exists> x \<in> xs. ord_class.less x a \<Longrightarrow> False"
  proof-
    assume "\<exists> x \<in> xs. ord_class.less x a"
    hence "{x \<in> xs. ord_class.less x  a} \<noteq> {}" by auto
    hence "Max {y \<in> xs. y < a} \<in> {y \<in> xs. y < a}"
      by (metis (full_types) Max_eq_iff finite_M_bounded_by_nat)
    moreover hence "i \<in> xs \<Longrightarrow>  ord_class.less i  a\<Longrightarrow> 
             ord_class.less_eq i (Max {y \<in> xs. ord_class.less y  a}) " for i 
      by (simp add: assms(2))
    ultimately have "is_pred_in_set xs a (Max {y \<in> xs. y < a})"
      using is_pred_in_set_def by auto
    then show False 
      using assms(1) by blast
  qed
  then show ?thesis by blast
qed

end


context begin
  interpretation VEBT_internal .

fun vebt_pred :: "VEBT \<Rightarrow> nat \<Rightarrow> nat option" where
  "vebt_pred (Leaf _ _) 0 = None"|
  "vebt_pred (Leaf a _) (Suc 0) = (if a then Some 0 else None)"|
  "vebt_pred (Leaf a b) _ = (if b then Some 1 else if a then Some 0 else None)"|
  "vebt_pred (Node None _ _ _) _ = None"|
  "vebt_pred (Node _ 0 _ _) _ = None"|
  "vebt_pred (Node _ (Suc 0) _ _) _ = None"|
  "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = (
         if x > ma then Some ma 
         else (let l = low x (deg div 2); h = high x (deg div 2) in 
               if h < length treeList then  
                  let minlow = vebt_mint (treeList ! h) in (
                      if minlow \<noteq> None \<and> (Some l >\<^sub>o  minlow) then 
                         Some (2^(deg div 2)) *\<^sub>o Some h +\<^sub>o vebt_pred (treeList ! h) l
                      else let pr = vebt_pred summary h in
                               if pr = None then (
                                  if x > mi then Some mi 
                                  else None)
                               else Some (2^(deg div 2)) *\<^sub>o pr +\<^sub>o vebt_maxt (treeList ! the pr) )
               else None))"

end               
               
context VEBT_internal begin

lemma pred_max: 
  assumes "deg \<ge> 2" and "(x::nat) > ma" 
  shows "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = Some ma"
  by (metis VEBT_Pred.vebt_pred.simps(7) add_2_eq_Suc assms(1) assms(2) le_add_diff_inverse)

lemma pred_lesseq_max: 
  assumes "deg \<ge> 2" and "(x::nat) \<le> ma" 
  shows "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x =  (let l = low x (deg div 2); h = high x (deg div 2) in 
                       if h < length treeList then  
  
                            let minlow = vebt_mint (treeList ! h) in 
                            (if minlow \<noteq> None \<and> (Some l >\<^sub>o  minlow) then 
                                                    Some (2^(deg div 2)) *\<^sub>o Some h +\<^sub>o vebt_pred (treeList ! h) l
                             else let pr = vebt_pred summary h in
                             if pr = None then (if x > mi then Some mi else None)
                             else Some (2^(deg div 2)) *\<^sub>o pr +\<^sub>o vebt_maxt (treeList ! the pr) )

                     else None)"
  by (smt VEBT_Pred.vebt_pred.simps(7) add_numeral_left assms(1) assms(2) leD le_add_diff_inverse numerals(1) plus_1_eq_Suc semiring_norm(2))

lemma pred_list_to_short: 
  assumes "deg \<ge> 2" and "ord_class.less_eq x ma" and " high x (deg div 2) \<ge> length treeList" 
  shows "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = None" 
  by (simp add: assms(1) assms(2) assms(3) leD pred_lesseq_max)


lemma pred_less_length_list: 
  assumes "deg \<ge> 2" and "ord_class.less_eq x  ma" and " high x (deg div 2) < length treeList" 
  shows
  "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = (let l = low x (deg div 2); h = high x (deg div 2); minlow = vebt_mint (treeList ! h) in 
                            (if minlow \<noteq> None \<and> (Some l >\<^sub>o  minlow) then 
                                                    Some (2^(deg div 2)) *\<^sub>o Some h +\<^sub>o vebt_pred (treeList ! h) l
                             else let pr = vebt_pred summary h in
                             if pr = None then (if x > mi then Some mi else None)
                             else Some (2^(deg div 2)) *\<^sub>o pr +\<^sub>o vebt_maxt (treeList ! the pr) ))"
  by (simp add: assms(1) assms(2) assms(3) pred_lesseq_max)


theorem pred_corr: "invar_vebt t n \<Longrightarrow> vebt_pred t x = Some px == is_pred_in_set (set_vebt' t) x px"
proof(induction t n arbitrary: x px rule: invar_vebt.induct)
  case (1 a b)
  then show ?case 
  proof(cases x)
    case 0
    then show ?thesis
      by (simp add: is_pred_in_set_def)
  next
    case (Suc sucX)
    hence "x \<ge> 0 \<and> x = Suc sucX" by auto
    then show ?thesis
    proof(cases sucX)
      case 0
      then show ?thesis
        by (simp add: Suc pred_member)
    next
      case (Suc nat)
      hence "x\<ge> 2" 
      then show ?thesis
      proof(cases b)
        case True
        hence "vebt_pred (Leaf a b) x = Some 1"
        moreover have "is_pred_in_set (set_vebt' (Leaf a b)) x 1" 
        ultimately show ?thesis
          using pred_member by auto
      next
        case False
        hence "b = False" by simp
        then show ?thesis
        proof(cases a)
          case True
          hence "vebt_pred (Leaf a b) x = Some 0" 
          moreover have "is_pred_in_set (set_vebt' (Leaf a b)) x 0"
          ultimately show ?thesis 
            by (metis False VEBT_Member.vebt_member.simps(1) option.sel pred_member)
        next
          case False
          then show ?thesis
        qed
      qed
    qed
  qed
next
  case (2 treeList n summary m deg)
  then show ?case
    by (simp add: pred_member)
next
  case (3 treeList n summary m deg)
  then show ?case
    by (simp add: pred_member)
next
  case (4 treeList n summary m deg mi ma)
  hence "n = m" and "n \<ge> 1" and "deg \<ge> 2" and "deg = n + m"
       apply blast+ 
    using "4.hyps"(2) "4.hyps"(5) Suc_le_eq deg_not_0 apply auto[1]
    using "4.hyps"(2) "4.hyps"(5) "4.hyps"(6) deg_not_0 apply fastforce
    by (simp add: "4.hyps"(6))
  moreover hence thisvalid:"invar_vebt (Node (Some (mi, ma)) deg treeList summary) deg" 
    using 4 invar_vebt.intros(4)[of treeList n summary m]  by blast
  ultimately have "deg div 2 =n" and "length treeList = 2^n" 
    using add_self_div_2 apply blast by (simp add: "4.hyps"(4) "4.hyps"(5))
  then show ?case
  proof(cases "x > ma")
    case True
    hence 0: "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = Some ma" 
    have 1:"ma = the (vebt_maxt (Node (Some (mi, ma)) deg treeList summary))" by simp
    hence "ma \<in> set_vebt' (Node (Some (mi, ma)) deg treeList summary)"
    hence 2:"y \<in> set_vebt' (Node (Some (mi, ma)) deg treeList summary) \<Longrightarrow> y \<le> x" for y
      using "4.hyps"(9) True member_inv set_vebt'_def by fastforce
    hence 3: "y \<in> set_vebt' (Node (Some (mi, ma)) deg treeList summary) \<Longrightarrow> (y < ma \<Longrightarrow> y \<le> x)" for y by blast
    hence 4: "\<forall> y \<in> set_vebt' (Node (Some (mi, ma)) deg treeList summary). y < ma \<longrightarrow> y \<le> x" by blast
    hence "is_pred_in_set (set_vebt' (Node (Some (mi, ma)) deg treeList summary)) x ma" 
    then show ?thesis 
      by (metis "0" option.sel leD le_less_Suc_eq not_less_eq pred_member)
  next
    case False
    hence "x \<le> ma"by simp  
    then show ?thesis 
    proof(cases "high x (deg div 2)< length treeList ")
      case True
      hence "high x n < 2^n \<and> low x n < 2^n"
      let ?l = "low x (deg div 2)" 
      let ?h = "high x (deg div 2)"
      let ?minlow = "vebt_mint (treeList ! ?h)"
      let ?pr = "vebt_pred summary ?h"
      have 1:"vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = 
                           (if ?minlow \<noteq> None \<and> (Some ?l >\<^sub>o  ?minlow) then 
                                                    Some (2^(deg div 2)) *\<^sub>o Some ?h +\<^sub>o vebt_pred (treeList ! ?h) ?l
                             else let pr = vebt_pred summary ?h in
                             if pr = None then (if x > mi then Some mi else None)
                             else Some (2^(deg div 2)) *\<^sub>o pr +\<^sub>o vebt_maxt (treeList ! the pr) )"
      then show ?thesis 
      proof(cases "?minlow \<noteq> None \<and> (Some ?l >\<^sub>o  ?minlow)")
        case True
        then obtain minl where 00:"(Some minl = ?minlow) \<and> ?l > minl" by auto
        have 01:"invar_vebt ((treeList ! ?h)) n \<and> (treeList ! ?h) \<in> set treeList "
        have  02:"vebt_member ((treeList ! ?h)) minl" 
          using "00" "01" mint_member by auto
        hence 03: "\<exists> y. y < ?l \<and> vebt_member ((treeList ! ?h)) y"
          using "00" by blast 
        hence afinite: "finite (set_vebt' (treeList ! ?h)) " 
          using "01" set_vebt_finite by blast
        then obtain predy where 04:"is_pred_in_set (set_vebt' (treeList ! ?h)) ?l predy"
          using "00" "01" mint_corr obtain_set_pred by fastforce
        hence 05:"Some predy =  vebt_pred (treeList ! ?h) ?l"  using 4(1) 01 by force
        hence "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x  =  Some (2^(deg div 2)*  ?h + predy) "
          using  "1" True add_def mul_def option_shift.simps(3) by metis
        hence 06: "predy \<in> set_vebt' (treeList ! ?h)" 
          using "04" is_pred_in_set_def by blast
        hence 07: "predy < 2^(deg div 2) \<and> ?h < 2^(deg div 2) \<and> deg div 2 + deg div 2 = deg" 
        let ?y = "2^(deg div 2)*  ?h + predy"
        have 08: "vebt_member (treeList ! ?h) predy"
          using "06" set_vebt'_def by auto
        hence 09: "both_member_options (treeList ! ?h) predy"
          using "01" both_member_options_equiv_member by blast
        have 10: "high ?y (deg div 2) = ?h \<and> low ?y (deg div 2) = predy"
          by (simp add: "07" high_inv low_inv mult.commute)
        hence 14:"both_member_options (Node (Some (mi, ma)) deg treeList summary) ?y" 
        have 15: "vebt_member (Node (Some (mi, ma)) deg treeList summary) ?y" 
          using "14" thisvalid valid_member_both_member_options by blast
        have 16: "Some ?y = vebt_pred (Node (Some (mi, ma)) deg treeList summary) x" 
        have 17: "x = ?h * 2^(deg div 2) + ?l"
          using bit_concat_def bit_split_inv by auto 
        have 18: "x - ?y =   ?h * 2^(deg div 2) + ?l -?h * 2^(deg div 2) - predy " 
          by (metis "17" diff_diff_add mult.commute)
        hence 19: "?y < x" 
          using "04" "17" mult.commute nat_add_left_cancel_less pred_member by fastforce
        have 20: "z < x \<Longrightarrow> vebt_member (Node (Some (mi, ma)) deg treeList summary) z \<Longrightarrow> z\<le> ?y " for z 
        proof-
          assume "z < x" and "vebt_member (Node (Some (mi, ma)) deg treeList summary) z"
          hence "high z (deg div 2) \<le> high x (deg div 2)" 
            by (simp add: div_le_mono high_def)
          then show ?thesis 
          proof(cases "high z (deg div 2) = high x (deg div 2)")
            case True
            hence 0000: "high z (deg div 2) = high x (deg div 2)" by simp
            then show ?thesis
            proof(cases "z = mi")
              case True
              then show ?thesis
                using "15" vebt_mint.simps(3) mint_corr_help thisvalid by blast
            next
              case False    
              hence ad:"vebt_member (treeList ! ?h) (low z (deg div 2))" 
                using vebt_member.simps(5)[of mi ma "deg-2" treeList summary z]
              have "is_pred_in_set (set_vebt' (treeList ! ?h)) ?l predy" 
                using "04" by blast
              have "low z (deg div 2) < ?l" 
              hence "predy \<ge> low z (deg div 2)" using 04 ad unfolding is_pred_in_set_def
                by (simp add: set_vebt'_def)
              hence "?y \<ge> z" 
                by (smt True bit_concat_def bit_split_inv diff_add_inverse diff_diff_add diff_is_0_eq mult.commute)
              then show ?thesis by blast
            qed
          next
            case False
            hence "high z (deg div 2) < high ?y (deg div 2)"
            then show ?thesis 
              by (metis div_le_mono high_def nat_le_linear not_le)
          qed
        qed
        hence "is_pred_in_set (set_vebt' (Node (Some (mi, ma)) deg treeList summary)) x ?y" 
          by (simp add: "15" "19" pred_member)
        then show ?thesis using 16
          by (metis eq_iff option.inject pred_member)
      next
        case False
        hence i1:"?minlow =  None \<or> \<not> (Some ?l >\<^sub>o  ?minlow)" by simp
        hence 2: "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x =  (
                            if ?pr = None then (if x > mi 
                                                then Some mi 
                                                else None)
                             else Some (2^(deg div 2)) *\<^sub>o ?pr +\<^sub>o vebt_maxt (treeList ! the ?pr))" 
          using "1" by auto
        have " invar_vebt (treeList ! ?h) n"
          by (metis "4"(1) True inthall member_def)
        hence 33:"\<nexists> u. vebt_member (treeList ! ?h) u \<and> u < ?l"
        proof(cases "?minlow = None")
          case True
          then show ?thesis using mint_corr_help_empty[of "treeList ! ?h" n] 
        next
          case False
          obtain minilow where "?minlow =Some minilow" 
            using False by blast
          hence "minilow \<ge> ?l" 
            using "i1" by auto
          then show ?thesis
        qed
        then show ?thesis 
        proof(cases "?pr= None")
          case True
          hence "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x =  (if x > mi then Some mi else  None)" 
            by (simp add: "2")
          hence "\<nexists> i. is_pred_in_set (set_vebt' summary) ?h i"
            using "4.hyps"(3) True by force
          hence "\<nexists> i. i < ?h \<and> vebt_member summary i " using pred_none_empty[of "set_vebt' summary" ?h] 
          proof -
            { fix nn :: nat
              have "\<forall>n. ((is_pred_in_set (Collect (vebt_member summary)) (high x (deg div 2)) esk1_0 \<or> infinite (Collect (vebt_member summary))) \<or> n \<notin> Collect (vebt_member summary)) \<or> \<not> n < high x (deg div 2)"
              then have "\<not> nn < high x (deg div 2) \<or> \<not> vebt_member summary nn"
            then show ?thesis
              by blast
          qed
          then show ?thesis 
          proof(cases "x > mi")
            case True
            hence "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = Some mi" 
            have "(vebt_member (Node (Some (mi, ma)) deg treeList summary) z  \<and> z < x \<and> z > mi) \<Longrightarrow> False" for z
            proof-
              assume "vebt_member (Node (Some (mi, ma)) deg treeList summary) z  \<and> z < x \<and> z > mi"
              hence "vebt_member ( treeList ! (high z (deg div 2))) (low z (deg div 2))"
              moreover hence "high z (deg div 2) < 2^m" 
              moreover hence "invar_vebt (treeList ! (high z (deg div 2))) n" using 4(1)
                by (simp add: "4.hyps"(4))
              ultimately have "vebt_member summary (high z (deg div 2))" using 4(7) 
                using "4.hyps"(2) both_member_options_equiv_member by blast
              have "(high z (deg div 2)) \<le> ?h" 
              then show False 
            qed
            hence "is_pred_in_set (set_vebt' ((Node (Some (mi, ma)) deg treeList summary))) x mi" 
            then show ?thesis 
          next
            case False
            hence "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = None"
              by (simp add: "2" True)
            then show ?thesis 
              by (metis (full_types) False less_trans member_inv option.distinct(1) pred_max pred_member)
          qed
        next
          case False
          hence fst:"vebt_pred (Node (Some (mi, ma)) deg treeList summary) x =
                    Some (2^(deg div 2)) *\<^sub>o ?pr +\<^sub>o vebt_maxt (treeList ! the ?pr)"
            using "2" by presburger 
          obtain pr where "?pr = Some pr" 
            using False by blast
          hence "is_pred_in_set (set_vebt' summary) ?h pr"
            using "4.hyps"(3) by blast
          hence "vebt_member summary pr"
            using pred_member by blast
          hence "both_member_options summary pr" 
            using "4.hyps"(2) both_member_options_equiv_member by auto
          hence "pr < 2^m" 
          hence "\<exists> maxy. both_member_options (treeList ! pr) maxy" 
          hence fgh:"set_vebt' (treeList ! pr) \<noteq> {}"
          hence "invar_vebt (treeList ! the ?pr) n"
          then obtain maxy where "Some maxy = vebt_maxt (treeList ! pr)" 
          hence "Some maxy = vebt_maxt (treeList ! the ?pr)" 
          hence "max_in_set (set_vebt' (treeList ! the ?pr)) maxy" 
          hence scmem:"vebt_member (treeList ! the ?pr) maxy"
          let ?res =  "Some (2^(deg div 2)) *\<^sub>o ?pr +\<^sub>o vebt_maxt (treeList ! the ?pr)"
          obtain res where snd: "res = the ?res" by blast
          hence "res = 2^(deg div 2) * pr + maxy" 
          have "high res (deg div 2) = pr" 
          hence "res < x" 
          have "both_member_options (treeList ! (high res (deg div 2))) (low res (deg div 2))"
          have "both_member_options (Node (Some (mi, ma)) deg treeList summary) res" 
          hence "vebt_member (Node (Some (mi, ma)) deg treeList summary) res" 
            using thisvalid valid_member_both_member_options by auto
          hence "res > mi"
          hence "res < ma"
          have "(vebt_member (Node (Some (mi, ma)) deg treeList summary) z \<and> z < x) \<Longrightarrow> z \<le> res" for z
          proof-
            fix z
            assume "vebt_member (Node (Some (mi, ma)) deg treeList summary) z \<and> z < x"
            hence 20: "z = mi \<or> z = ma \<or> (high z (deg div 2) < length treeList 
                                    \<and> vebt_member ( treeList ! (high z (deg div 2))) (low z (deg div 2)))" using
              vebt_member.simps(5)[of mi ma "deg-2" treeList summary z] 
              using member_inv by blast
            have "z \<noteq> ma" 
            hence "mi \<noteq> ma" 
            hence "z < 2^deg" 
            hence abc:"invar_vebt (treeList ! (high z (deg div 2))) n" 
            then show "z \<le> res"
            proof(cases "z = mi")
              case True
              then show ?thesis
            next
              case False
              hence abe:"vebt_member( treeList ! (high z (deg div 2))) (low z (deg div 2))" 
              hence abh:"vebt_member summary (high z (deg div 2))"
              have aaa:"(high z (deg div 2)) = (high x (deg div 2)) \<Longrightarrow> vebt_member (treeList ! ?h) (low z (deg div 2))"
                using abe by auto
              have "high z(deg div 2) > pr \<Longrightarrow> False" 
              proof-
                assume "high z(deg div 2) > pr"
                hence "vebt_member summary (high z(deg div 2))" 
                  using abh by blast
                have aaaa:"?h \<le> high z(deg div 2)"
                have bbbb:"?h \<ge> high z(deg div 2)" 
                hence "?h = high z (deg div 2)" 
                  using aaaa eq_iff by blast
                hence "vebt_member (treeList ! ?h) (low z (deg div 2))" 
                  using aaa by linarith
                hence "(low z (deg div 2)) < ?l" 
                then show False 
              qed
              hence "high z(deg div 2) \<le> pr" 
                using not_less by blast
              then show " z \<le> res"
              proof(cases "high z(deg div 2) = pr")
                case True
                hence "vebt_member (treeList ! (high z(deg div 2))) (low z (deg div 2))" 
                  using abe by blast
                have "low z (deg div 2) \<le> maxy"
                hence "z \<le> res"
                then show ?thesis by simp
              next
                case False
                hence "high z(deg div 2) < pr" 
                then show ?thesis
              qed
            qed
          qed
          hence "is_pred_in_set (set_vebt' (Node (Some (mi, ma)) deg treeList summary)) x res"
          then show ?thesis using fst snd
        qed
      qed
    next
      case False
      then show ?thesis 
    qed
  qed
next
  case (5 treeList n summary m deg mi ma)
  hence "Suc n = m"  and "deg = n + m" and "length treeList = 2^m \<and> invar_vebt summary m"
    by blast + 
  hence "n \<ge> 1" 
    using "5.hyps"(1) set_n_deg_not_0 by blast 
  hence "deg \<ge> 2" 
    by (simp add: "5.hyps"(5) "5.hyps"(6))    
  hence "deg div 2 =n" 
    by (simp add: "5.hyps"(5) "5.hyps"(6))
  moreover hence thisvalid:"invar_vebt (Node (Some (mi, ma)) deg treeList summary) deg" 
    using 5 invar_vebt.intros(5)[of treeList n summary m]  by blast
  ultimately have "deg div 2 =n" by simp
  then show ?case
  proof(cases "x > ma")
    case True
    hence 0: "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = Some ma" 
    have 1:"ma = the (vebt_maxt (Node (Some (mi, ma)) deg treeList summary))" by simp
    hence "ma \<in> set_vebt' (Node (Some (mi, ma)) deg treeList summary)"
    hence 2:"y \<in> set_vebt' (Node (Some (mi, ma)) deg treeList summary) \<Longrightarrow> y \<le> x" for y
      using "5.hyps"(9) True member_inv set_vebt'_def by fastforce
    hence 3: "y \<in> set_vebt' (Node (Some (mi, ma)) deg treeList summary) \<Longrightarrow> (y < ma \<Longrightarrow> y \<le> x)" for y by blast
    hence 4: "\<forall> y \<in> set_vebt' (Node (Some (mi, ma)) deg treeList summary). y < ma \<longrightarrow> y \<le> x" by blast
    hence "is_pred_in_set (set_vebt' (Node (Some (mi, ma)) deg treeList summary)) x ma" 
    then show ?thesis 
      by (metis "0" option.sel leD le_less_Suc_eq not_less_eq pred_member)
  next
    case False
    hence "x \<le> ma"by simp  
    then show ?thesis 
    proof(cases "high x (deg div 2)< length treeList ")
      case True
      hence "high x n < 2^m \<and> low x n < 2^n"
      let ?l = "low x (deg div 2)" 
      let ?h = "high x (deg div 2)"
      let ?minlow = "vebt_mint (treeList ! ?h)"
      let ?pr = "vebt_pred summary ?h"
      have 1:"vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = 
                           (if ?minlow \<noteq> None \<and> (Some ?l >\<^sub>o  ?minlow) then 
                                                    Some (2^(deg div 2)) *\<^sub>o Some ?h +\<^sub>o vebt_pred (treeList ! ?h) ?l
                             else let pr = vebt_pred summary ?h in
                             if pr = None then (if x > mi then Some mi else None)
                             else Some (2^(deg div 2)) *\<^sub>o pr +\<^sub>o vebt_maxt (treeList ! the pr) )"
      then show ?thesis 
      proof(cases "?minlow \<noteq> None \<and> (Some ?l >\<^sub>o  ?minlow)")
        case True
        then obtain minl where 00:"(Some minl = ?minlow) \<and> ?l > minl" by auto
        have 01:"invar_vebt ((treeList ! ?h)) n \<and> (treeList ! ?h) \<in> set treeList "
        have  02:"vebt_member ((treeList ! ?h)) minl" 
          using "00" "01" mint_member by auto
        hence 03: "\<exists> y. y < ?l \<and> vebt_member ((treeList ! ?h)) y"
          using "00" by blast 
        hence afinite: "finite (set_vebt' (treeList ! ?h)) " 
          using "01" set_vebt_finite by blast
        then obtain predy where 04:"is_pred_in_set (set_vebt' (treeList ! ?h)) ?l predy"
          using "00" "01" mint_corr obtain_set_pred by fastforce
        hence 05:"Some predy =  vebt_pred (treeList ! ?h) ?l"  using 5(1) 01 by force
        hence "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x  =  Some (2^(deg div 2)*  ?h + predy) "
          by (metis "1" True add_def mul_def option_shift.simps(3))
        hence 06: "predy \<in> set_vebt' (treeList ! ?h)" 
          using "04" is_pred_in_set_def by blast
        hence 07: "predy < 2^(deg div 2) \<and> ?h < 2^(deg div 2 +1) \<and> deg div 2 + deg div 2 +1 = deg"
        let ?y = "2^(deg div 2)*  ?h + predy"
        have 08: "vebt_member (treeList ! ?h) predy"
          using "06" set_vebt'_def by auto
        hence 09: "both_member_options (treeList ! ?h) predy"
          using "01" both_member_options_equiv_member by blast
        have 10: "high ?y (deg div 2) = ?h \<and> low ?y (deg div 2) = predy"
          by (simp add: "07" high_inv low_inv mult.commute)
        hence 14:"both_member_options (Node (Some (mi, ma)) deg treeList summary) ?y"
        have 15: "vebt_member (Node (Some (mi, ma)) deg treeList summary) ?y"
          using "14" thisvalid valid_member_both_member_options by blast
        have 16: "Some ?y = vebt_pred (Node (Some (mi, ma)) deg treeList summary) x" 
        have 17: "x = ?h * 2^(deg div 2) + ?l"
          using bit_concat_def bit_split_inv by auto 
        have 18: "x - ?y =   ?h * 2^(deg div 2) + ?l -?h * 2^(deg div 2) - predy " 
          by (metis "17" diff_diff_add mult.commute)
        hence 19: "?y < x" 
          using "04" "17" mult.commute nat_add_left_cancel_less pred_member by fastforce
        have 20: "z < x \<Longrightarrow> vebt_member (Node (Some (mi, ma)) deg treeList summary) z \<Longrightarrow> z\<le> ?y " for z 
        proof-
          assume "z < x" and "vebt_member (Node (Some (mi, ma)) deg treeList summary) z"
          hence "high z (deg div 2) \<le> high x (deg div 2)" 
            by (simp add: div_le_mono high_def)
          then show ?thesis 
          proof(cases "high z (deg div 2) = high x (deg div 2)")
            case True
            hence 0000: "high z (deg div 2) = high x (deg div 2)" by simp
            then show ?thesis
            proof(cases "z = mi")
              case True
              then show ?thesis 
                by (metis "15" "5.hyps"(9) add.left_neutral le_add2 less_imp_le_nat member_inv)
            next
              case False    
              hence ad:"vebt_member (treeList ! ?h) (low z (deg div 2))" 
                using vebt_member.simps(5)[of mi ma "deg-2" treeList summary z]
              have "is_pred_in_set (set_vebt' (treeList ! ?h)) ?l predy" 
                using "04" by blast
              have "low z (deg div 2) < ?l" 
              hence "predy \<ge> low z (deg div 2)" using 04 ad unfolding is_pred_in_set_def
                by (simp add: set_vebt'_def)
              hence "?y \<ge> z" 
                by (smt True bit_concat_def bit_split_inv diff_add_inverse diff_diff_add diff_is_0_eq mult.commute)
              then show ?thesis by blast
            qed
          next
            case False
            hence "high z (deg div 2) < high ?y (deg div 2)"
            then show ?thesis 
              by (metis div_le_mono high_def nat_le_linear not_le)
          qed
        qed
        hence "is_pred_in_set (set_vebt'(Node (Some (mi, ma)) deg treeList summary)) x ?y" 
          by (simp add: "15" "19" pred_member)
        then show ?thesis using 16
          by (metis eq_iff option.inject pred_member)
      next
        case False
        hence i1:"?minlow =  None \<or> \<not> (Some ?l >\<^sub>o  ?minlow)" by simp
        hence 2: "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x =  (
                            if ?pr = None then (if x > mi 
                                                then Some mi 
                                                else None)
                             else Some (2^(deg div 2)) *\<^sub>o ?pr +\<^sub>o vebt_maxt (treeList ! the ?pr))" 
          using "1" by auto
        have " invar_vebt (treeList ! ?h) n"
          by (metis "5"(1) True inthall member_def)
        hence 33:"\<nexists> u. vebt_member (treeList ! ?h) u \<and> u < ?l"
        proof(cases "?minlow = None")
          case True
          then show ?thesis using mint_corr_help_empty[of "treeList ! ?h" n] 
        next
          case False
          obtain minilow where "?minlow =Some minilow" 
            using False by blast
          hence "minilow \<ge> ?l" 
            using "i1" by auto
          then show ?thesis
        qed
        then show ?thesis 
        proof(cases "?pr= None")
          case True
          hence "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x =  (if x > mi then Some mi else  None)" 
            by (simp add: "2")
          hence "\<nexists> i. is_pred_in_set (set_vebt' summary) ?h i"
            using "5.hyps"(3) True by force
          hence "\<nexists> i. i < ?h \<and> vebt_member summary i " using pred_none_empty[of "set_vebt' summary" ?h] 
          proof -
            { fix nn :: nat
              have "\<forall>n. ((is_pred_in_set (Collect (vebt_member summary)) (high x (deg div 2)) esk1_0 \<or> infinite (Collect (vebt_member summary))) \<or> n \<notin> Collect (vebt_member summary)) \<or> \<not> n < high x (deg div 2)"
              then have "\<not> nn < high x (deg div 2) \<or> \<not> vebt_member summary nn"
            then show ?thesis
              by blast
          qed
          then show ?thesis 
          proof(cases "x > mi")
            case True
            hence "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = Some mi" 
            have "(vebt_member (Node (Some (mi, ma)) deg treeList summary) z  \<and> z < x \<and> z > mi) \<Longrightarrow> False" for z
            proof-
              assume "vebt_member (Node (Some (mi, ma)) deg treeList summary) z  \<and> z < x \<and> z > mi"
              hence "vebt_member ( treeList ! (high z (deg div 2))) (low z (deg div 2))"
              moreover hence "high z (deg div 2) < 2^m" 
              moreover hence "invar_vebt (treeList ! (high z (deg div 2))) n" using 5(1)
                by (simp add: "5.hyps"(4))
              ultimately have "vebt_member summary (high z (deg div 2))" using 5(7) 
                using "5.hyps"(2) both_member_options_equiv_member by blast
              have "(high z (deg div 2)) \<le> ?h" 
              then show False 
            qed
            hence "is_pred_in_set (set_vebt' ((Node (Some (mi, ma)) deg treeList summary))) x mi" 
            then show ?thesis 
          next
            case False
            hence "vebt_pred (Node (Some (mi, ma)) deg treeList summary) x = None"
              by (simp add: "2" True)
            then show ?thesis 
              by (metis (full_types) False less_trans member_inv option.distinct(1) pred_max pred_member)
          qed
        next
          case False
          hence fst:"vebt_pred (Node (Some (mi, ma)) deg treeList summary) x =
                    Some (2^(deg div 2)) *\<^sub>o ?pr +\<^sub>o vebt_maxt (treeList ! the ?pr)"
            using "2" by presburger 
          obtain pr where "?pr = Some pr" 
            using False by blast
          hence "is_pred_in_set (set_vebt' summary) ?h pr"
            using "5.hyps"(3) by blast
          hence "vebt_member summary pr"
            using pred_member by blast
          hence "both_member_options summary pr" 
            using "5.hyps"(2) both_member_options_equiv_member by auto
          hence "pr < 2^m" 
          hence "\<exists> maxy. both_member_options (treeList ! pr) maxy" 
          hence fgh:"set_vebt' (treeList ! pr) \<noteq> {}"
          hence "invar_vebt (treeList ! the ?pr) n"
          then obtain maxy where "Some maxy = vebt_maxt (treeList ! pr)" 
          hence "Some maxy = vebt_maxt (treeList ! the ?pr)" 
          hence "max_in_set (set_vebt' (treeList ! the ?pr)) maxy" 
          hence scmem:"vebt_member (treeList ! the ?pr) maxy"
          let ?res =  "Some (2^(deg div 2)) *\<^sub>o ?pr +\<^sub>o vebt_maxt (treeList ! the ?pr)"
          obtain res where snd: "res = the ?res" by blast
          hence "res = 2^(deg div 2) * pr + maxy" 
          have "high res (deg div 2) = pr" 
          hence "res < x" 
          have "both_member_options (treeList ! (high res (deg div 2))) (low res (deg div 2))"
          have "both_member_options (Node (Some (mi, ma)) deg treeList summary) res" 
          hence "vebt_member (Node (Some (mi, ma)) deg treeList summary) res" 
            using thisvalid valid_member_both_member_options by auto
          hence "res > mi"
          hence "res < ma"
          have "(vebt_member (Node (Some (mi, ma)) deg treeList summary) z \<and> z < x) \<Longrightarrow> z \<le> res" for z
          proof-
            fix z
            assume "vebt_member (Node (Some (mi, ma)) deg treeList summary) z \<and> z < x"
            hence 20: "z = mi \<or> z = ma \<or> (high z (deg div 2) < length treeList 
                                    \<and> vebt_member ( treeList ! (high z (deg div 2))) (low z (deg div 2)))" using
              vebt_member.simps(5)[of mi ma "deg-2" treeList summary z] 
              using member_inv by blast
            have "z \<noteq> ma" 
            hence "mi \<noteq> ma" 
            hence "z < 2^deg" 
            hence "(high z (deg div 2)) <2^m" 
            hence abc:"invar_vebt (treeList ! (high z (deg div 2))) n" 
              by (simp add: "5.hyps"(1) "5.hyps"(4))
            then show "z \<le> res"
            proof(cases "z = mi")
              case True
              then show ?thesis
            next
              case False
              hence abe:"vebt_member( treeList ! (high z (deg div 2))) (low z (deg div 2))" 
              hence abh:"vebt_member summary (high z (deg div 2))"
              have aaa:"(high z (deg div 2)) = (high x (deg div 2)) \<Longrightarrow> vebt_member (treeList ! ?h) (low z (deg div 2))"
                using abe by auto
              have "high z(deg div 2) > pr \<Longrightarrow> False" 
              proof-
                assume "high z(deg div 2) > pr"
                hence "vebt_member summary (high z(deg div 2))" 
                  using abh by blast
                have aaaa:"?h \<le> high z(deg div 2)"
                have bbbb:"?h \<ge> high z(deg div 2)" 
                hence "?h = high z (deg div 2)" 
                  using aaaa eq_iff by blast
                hence "vebt_member (treeList ! ?h) (low z (deg div 2))" 
                  using aaa by linarith
                hence "(low z (deg div 2)) < ?l" 
                then show False 
              qed
              hence "high z(deg div 2) \<le> pr" 
                using not_less by blast
              then show " z \<le> res"
              proof(cases "high z(deg div 2) = pr")
                case True
                hence "vebt_member (treeList ! (high z(deg div 2))) (low z (deg div 2))" 
                  using abe by blast
                have "low z (deg div 2) \<le> maxy"
                hence "z \<le> res"
                then show ?thesis by simp
              next
                case False
                hence "high z(deg div 2) < pr" 
                then show ?thesis
              qed
            qed
          qed
          hence "is_pred_in_set (set_vebt' (Node (Some (mi, ma)) deg treeList summary)) x res"
          then show ?thesis using fst snd
        qed
      qed
    next
      case False
      then show ?thesis
    qed
  qed
qed

corollary pred_empty: assumes "invar_vebt t n " 
  shows " (vebt_pred t x = None) = ({y. vebt_member t y \<and> y < x} = {})" 
proof
  show " vebt_pred t x = None \<Longrightarrow> {y. vebt_member t y \<and> x > y} = {}"
  proof
    show "vebt_pred t x = None \<Longrightarrow> {y. vebt_member t y \<and> x > y} \<subseteq> {}"
    proof-
      assume "vebt_pred t x = None"
      hence "\<nexists> y. is_pred_in_set (set_vebt' t) x y" 
        using assms pred_corr by force
      moreover hence "is_pred_in_set (set_vebt' t) x y \<Longrightarrow> vebt_member t y \<and> x < y " for y by auto
      ultimately show "{y. vebt_member t y \<and> x > y} \<subseteq> {}"
        using assms pred_none_empty set_vebt'_def set_vebt_finite by auto
    qed
    show " vebt_pred t x = None \<Longrightarrow> {} \<subseteq> {y. vebt_member t y \<and> x > y}" by simp
  qed
  show " {y. vebt_member t y \<and> x > y} = {} \<Longrightarrow> vebt_pred t x = None"
  proof-
    assume "{y. vebt_member t y \<and> x > y} = {} "
    hence "is_pred_in_set (set_vebt' t) x y \<Longrightarrow> False" for y 
      using pred_member by auto
    thus "vebt_pred t x  = None"
      by (meson assms option_shift.elims pred_corr)
  qed
qed

theorem pred_correct: "invar_vebt t n \<Longrightarrow> vebt_pred t x = Some sx \<longleftrightarrow>is_pred_in_set (set_vebt t) x sx" 
  by (simp add: pred_corr set_vebt_set_vebt'_valid)

lemma helpypredd:"invar_vebt t n \<Longrightarrow> vebt_pred t x = Some y \<Longrightarrow> y < 2^n" 
  using member_bound pred_corr pred_member by blast

lemma "invar_vebt t n \<Longrightarrow> vebt_pred t x = Some y \<Longrightarrow> y < x"
  by (simp add: pred_corr pred_member)

end
end

