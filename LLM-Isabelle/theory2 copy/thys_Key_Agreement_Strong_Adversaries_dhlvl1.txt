theory dhlvl1
imports Runs Secrecy AuthenticationI Payloads
begin

declare option.split_asm [split]


consts
  Nend :: "nat"

abbreviation nx :: nat where "nx \<equiv> 2"
abbreviation ny :: nat where "ny \<equiv> 3"

abbreviation
  "xEnd \<equiv> Var 0"

abbreviation
  "xnx \<equiv> Var 2"

abbreviation
  "xny \<equiv> Var 3"

abbreviation
  "xsk \<equiv> Var 4"

abbreviation
  "xgnx \<equiv> Var 5"

abbreviation
  "xgny \<equiv> Var 6"



abbreviation 
  "End \<equiv> Number Nend"



fun domain :: "role_t \<Rightarrow> var set" where
  "domain Init = {xnx, xgnx, xgny, xsk, xEnd}"
| "domain Resp = {xny, xgnx, xgny, xsk, xEnd}"


consts
  test :: rid_t
  
consts
  guessed_runs :: "rid_t \<Rightarrow> run_t"
  guessed_frame :: "rid_t \<Rightarrow> frame"

specification (guessed_frame) 
  guessed_frame_dom_spec [simp]:
    "dom (guessed_frame R) = domain (role (guessed_runs R))"
  guessed_frame_payload_spec [simp, elim]:
    "guessed_frame R x = Some y \<Longrightarrow> y \<in> payload"
  guessed_frame_Init_xnx [simp]: 
    "role (guessed_runs R) = Init \<Longrightarrow> guessed_frame R xnx = Some (NonceF (R$nx))"
  guessed_frame_Init_xgnx [simp]: 
    "role (guessed_runs R) = Init \<Longrightarrow> guessed_frame R xgnx = Some (Exp Gen (NonceF (R$nx)))"
  guessed_frame_Resp_xny [simp]: 
    "role (guessed_runs R) = Resp \<Longrightarrow> guessed_frame R xny = Some (NonceF (R$ny))"
  guessed_frame_Resp_xgny [simp]: 
    "role (guessed_runs R) = Resp \<Longrightarrow> guessed_frame R xgny = Some (Exp Gen (NonceF (R$ny)))"
  guessed_frame_xEnd [simp]:
    "guessed_frame R xEnd = Some End"
apply (rule exI [of _ 
    "\<lambda>R.
      if role (guessed_runs R) = Init then
        [xnx \<mapsto> NonceF (R$nx), xgnx \<mapsto> Exp Gen (NonceF (R$nx)), xgny \<mapsto> End, 
         xsk \<mapsto> End, xEnd \<mapsto> End]
      else
        [xny \<mapsto> NonceF (R$ny), xgnx \<mapsto> End, xgny \<mapsto> Exp Gen (NonceF (R$ny)), 
         xsk \<mapsto> End, xEnd \<mapsto> End]"],
  auto simp add: domIff intro: role_t.exhaust) 
done

abbreviation
  "test_owner \<equiv> owner (guessed_runs test)"

abbreviation
  "test_partner \<equiv> partner (guessed_runs test)"



record l1_state = 
  s0_state +
  progress :: progress_t
  signalsInit :: "signal \<Rightarrow> nat"
  signalsResp :: "signal \<Rightarrow> nat"


type_synonym l1_obs = "l1_state"


abbreviation
  run_ended :: "var set option \<Rightarrow> bool"
where
  "run_ended r \<equiv> in_progress r xEnd"

lemma run_ended_not_None [elim]:
  "run_ended R \<Longrightarrow> R = None \<Longrightarrow> False"
by (fast dest: in_progress_Some)


abbreviation
  test_ended :: "'a l1_state_scheme \<Rightarrow> bool"
where
  "test_ended s \<equiv> run_ended (progress s test)"


definition
  can_signal :: "'a l1_state_scheme \<Rightarrow> agent \<Rightarrow> agent \<Rightarrow> bool"
where
  "can_signal s A B \<equiv>
  ((A = test_owner \<and> B = test_partner) \<or> (B = test_owner \<and> A = test_partner)) \<and>
  \<not> test_ended s"



definition
  l1_learn :: "msg \<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set"
where
  "l1_learn m \<equiv> {(s,s').
    synth (analz (insert m (ik s))) \<inter> (secret s) = {}  \<and>
    s' = s \<lparr>ik := ik s \<union> {m}\<rparr>
  }"




definition
  l1_step1 :: "rid_t \<Rightarrow> agent \<Rightarrow> agent \<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set"
where
  "l1_step1 Ra A B \<equiv> {(s, s').
    Ra \<notin> dom (progress s) \<and>
    guessed_runs Ra = \<lparr>role=Init, owner=A, partner=B\<rparr> \<and>
    s' = s\<lparr>
      progress := (progress s)(Ra \<mapsto> {xnx, xgnx})
      \<rparr>
  }"


definition
  l1_step2 :: "rid_t \<Rightarrow> agent \<Rightarrow> agent \<Rightarrow> msg \<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set"
where
  "l1_step2 Rb A B gnx \<equiv> {(s, s').
    guessed_runs Rb = \<lparr>role=Resp, owner=B, partner=A\<rparr> \<and>
    Rb \<notin> dom (progress s) \<and>
    guessed_frame Rb xgnx = Some gnx \<and>
    guessed_frame Rb xsk = Some (Exp gnx (NonceF (Rb$ny))) \<and>
    s' = s\<lparr> progress := (progress s)(Rb \<mapsto> {xny, xgny, xgnx, xsk}),
            signalsInit := if can_signal s A B then
                          addSignal (signalsInit s) (Running A B (Exp gnx (NonceF (Rb$ny))))
                       else
                          signalsInit s
          \<rparr>
  }"

definition
  l1_step3 :: "rid_t \<Rightarrow> agent \<Rightarrow> agent \<Rightarrow> msg \<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set"
where
  "l1_step3 Ra A B gny \<equiv> {(s, s').
    guessed_runs Ra = \<lparr>role=Init, owner=A, partner=B\<rparr> \<and>
    progress s Ra = Some {xnx, xgnx} \<and>
    guessed_frame Ra xgny = Some gny \<and>
    guessed_frame Ra xsk = Some (Exp gny (NonceF (Ra$nx))) \<and>
      (\<exists> Rb. guessed_runs Rb = \<lparr>role=Resp, owner=B, partner=A\<rparr> \<and>
             in_progressS (progress s Rb) {xny, xgnx, xgny, xsk} \<and>
             guessed_frame Rb xgny = Some gny \<and>
             guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra$nx))))) \<and>
    (Ra = test \<longrightarrow> Exp gny (NonceF (Ra$nx)) \<notin> synth (analz (ik s))) \<and>

    s' = s\<lparr> progress := (progress s)(Ra \<mapsto> {xnx, xgnx, xgny, xsk, xEnd}),
            secret := {x. x = Exp gny (NonceF (Ra$nx)) \<and> Ra = test} \<union> secret s,
            signalsInit := if can_signal s A B then
                         addSignal (signalsInit s) (Commit A B (Exp gny (NonceF (Ra$nx))))
                       else
                         signalsInit s,
            signalsResp := if can_signal s A B then
                         addSignal (signalsResp s) (Running A B (Exp gny (NonceF (Ra$nx))))
                       else
                         signalsResp s

          \<rparr>
  }"


definition
  l1_step4 :: "rid_t \<Rightarrow> agent \<Rightarrow> agent \<Rightarrow> msg \<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set"
where
  "l1_step4 Rb A B gnx \<equiv> {(s, s').
    guessed_runs Rb = \<lparr>role=Resp, owner=B, partner=A\<rparr> \<and>
    progress s Rb = Some {xny, xgnx, xgny, xsk} \<and>
    guessed_frame Rb xgnx = Some gnx \<and>
      (\<exists> Ra. guessed_runs Ra = \<lparr>role=Init, owner=A, partner=B\<rparr> \<and>
             in_progressS (progress s Ra) {xnx, xgnx, xgny, xsk, xEnd} \<and>
             guessed_frame Ra xgnx = Some gnx \<and>
             guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb$ny))))) \<and>
    (Rb = test \<longrightarrow> Exp gnx (NonceF (Rb$ny)) \<notin> synth (analz (ik s))) \<and>

    s' = s\<lparr> progress := (progress s)(Rb \<mapsto> {xny, xgnx, xgny, xsk, xEnd}),
            secret := {x. x = Exp gnx (NonceF (Rb$ny)) \<and> Rb = test} \<union> secret s,
            signalsResp := if can_signal s A B then
                             addSignal (signalsResp s) (Commit A B (Exp gnx (NonceF (Rb$ny))))
                           else
                             signalsResp s
          \<rparr>
  }"



definition 
  l1_init :: "l1_state set"
where
  "l1_init \<equiv> { \<lparr>
    ik = {},
    secret = {},
    progress = Map.empty,
    signalsInit = \<lambda>x. 0,
    signalsResp = \<lambda>x. 0
    \<rparr> }"

definition 
  l1_trans :: "('a l1_state_scheme * 'a l1_state_scheme) set" where
  "l1_trans \<equiv> (\<Union>m Ra Rb A B x.
     l1_step1 Ra A B \<union>
     l1_step2 Rb A B x \<union>
     l1_step3 Ra A B x \<union>
     l1_step4 Rb A B x \<union>
     l1_learn m \<union>
     Id
  )"

definition 
  l1 :: "(l1_state, l1_obs) spec" where
  "l1 \<equiv> \<lparr>
    init = l1_init,
    trans = l1_trans,
    obs = id
  \<rparr>"

lemmas l1_defs = 
  l1_def l1_init_def l1_trans_def
  l1_learn_def
  l1_step1_def l1_step2_def l1_step3_def l1_step4_def

lemmas l1_nostep_defs =
  l1_def l1_init_def l1_trans_def

lemma l1_obs_id [simp]: "obs l1 = id"
by (simp add: l1_def)


lemma run_ended_trans:
  "run_ended (progress s R) \<Longrightarrow>
   (s, s') \<in> trans l1 \<Longrightarrow>
   run_ended (progress s' R)"
apply (auto simp add: l1_nostep_defs)
apply (auto simp add: l1_defs ik_dy_def)
done

lemma can_signal_trans:
  "can_signal s' A B \<Longrightarrow>
  (s, s') \<in> trans l1 \<Longrightarrow>
  can_signal s A B"
by (auto simp add: can_signal_def run_ended_trans)



definition 
  med01s :: "l1_obs \<Rightarrow> s0_obs"
where
  "med01s t \<equiv> \<lparr> ik = ik t, secret = secret t \<rparr>"


definition
  R01s :: "(s0_state * l1_state) set"
where
  "R01s \<equiv> {(s,s').
    s = \<lparr>ik = ik s', secret = secret s'\<rparr>
    }"



lemma l1_learn_refines_learn:
  "{R01s} s0_learn m, l1_learn m {>R01s}"
apply (simp add: PO_rhoare_defs R01s_def)
apply auto
apply (simp add: l1_defs s0_defs s0_secrecy_def)
done



lemma l1_step1_refines_skip:
  "{R01s} Id, l1_step1 Ra A B {>R01s}"
by (auto simp add: PO_rhoare_defs R01s_def l1_step1_def)

lemma l1_step2_refines_skip:
  "{R01s} Id, l1_step2 Rb A B gnx {>R01s}"
apply (auto simp add: PO_rhoare_defs R01s_def)
apply (auto simp add: l1_step2_def)
done

lemma l1_step3_refines_add_secret_skip:
  "{R01s} s0_add_secret (Exp gny (NonceF (Ra$nx))) \<union> Id, l1_step3 Ra A B gny {>R01s}"
apply (auto simp add: PO_rhoare_defs R01s_def s0_add_secret_def)
apply (auto simp add: l1_step3_def)
done

lemma l1_step4_refines_add_secret_skip:
  "{R01s} s0_add_secret (Exp gnx (NonceF (Rb$ny))) \<union> Id, l1_step4 Rb A B gnx {>R01s}"
apply (auto simp add: PO_rhoare_defs R01s_def s0_add_secret_def)
apply (auto simp add: l1_step4_def)
done


lemmas l1_trans_refines_s0_trans = 
  l1_learn_refines_learn
  l1_step1_refines_skip l1_step2_refines_skip 
  l1_step3_refines_add_secret_skip l1_step4_refines_add_secret_skip

lemma l1_refines_init_s0 [iff]:
  "init l1 \<subseteq> R01s `` (init s0)"
by (auto simp add: R01s_def s0_defs l1_defs s0_secrecy_def)


lemma l1_refines_trans_s0 [iff]:
  "{R01s} trans s0, trans l1 {> R01s}"
by (auto simp add: s0_def l1_def s0_trans_def l1_trans_def 
         intro: l1_trans_refines_s0_trans)


lemma obs_consistent_med01x [iff]: 
  "obs_consistent R01s med01s s0 l1"
by (auto simp add: obs_consistent_def R01s_def med01s_def)



lemma l1s_refines_s0 [iff]: 
  "refines 
     R01s
     med01s s0 l1"
by (auto simp add:refines_def PO_refines_def)

lemma  l1_implements_s0 [iff]: "implements med01s s0 l1"
by (rule refinement_soundness) (fast)



abbreviation "l1_secrecy \<equiv> s0_secrecy"


lemma l1_obs_secrecy [iff]: "oreach l1 \<subseteq> l1_secrecy"
apply (rule external_invariant_translation 
         [OF s0_obs_secrecy _ l1_implements_s0])
apply (auto simp add: med01s_def s0_secrecy_def)
done

lemma l1_secrecy [iff]: "reach l1 \<subseteq> l1_secrecy"
by (rule external_to_internal_invariant [OF l1_obs_secrecy], auto)



