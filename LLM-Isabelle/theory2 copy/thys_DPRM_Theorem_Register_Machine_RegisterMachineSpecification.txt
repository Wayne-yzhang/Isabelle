theory RegisterMachineSpecification
  imports Main
begin



type_synonym register = nat
type_synonym tape = "register list"

type_synonym state = nat
datatype instruction =
  isadd: Add (modifies : register) (goes_to : state) |
  issub: Sub (modifies : register) (goes_to : state) (goes_to_alt : state) |
  ishalt: Halt
where
  "modifies Halt = 0" |
  "goes_to_alt (Add _ next) = next"

type_synonym program = "instruction list"

type_synonym configuration = "(state * tape)"



definition read :: "tape \<Rightarrow> program \<Rightarrow> state \<Rightarrow> nat"
  where "read t p s = t ! (modifies (p!s))"

definition fetch :: "state \<Rightarrow> program \<Rightarrow> nat \<Rightarrow> state" where
  "fetch s p v = (if issub (p!s) \<and> v = 0 then goes_to_alt (p!s)
                       else if ishalt (p!s) then s
                       else goes_to (p!s))"

definition update :: "tape \<Rightarrow> instruction \<Rightarrow> tape" where
  "update t i = (if ishalt i then t
                    else if isadd i then list_update t (modifies i) (t!(modifies i) + 1)
                    else list_update t (modifies i) (if t!(modifies i) = 0 then 0 else (t!(modifies i)) - 1) )"

definition step :: "configuration \<Rightarrow> program \<Rightarrow> configuration"
  where
    "(step ic p) = (let nexts = fetch (fst ic) p (read (snd ic) p (fst ic));
                        nextt = update (snd ic) (p!(fst ic))
                        in (nexts, nextt))"

fun steps :: "configuration \<Rightarrow> program \<Rightarrow> nat \<Rightarrow> configuration"
  where
    steps_zero: "(steps c p 0) = c"
  | steps_suc:  "(steps c p (Suc n)) = (step (steps c p n) p)"



fun instruction_state_check :: "nat \<Rightarrow> instruction \<Rightarrow> bool"
  where isc_halt: "instruction_state_check _ Halt = True"
  |     isc_add: "instruction_state_check m (Add _ ns) = (ns < m)"
  |     isc_sub: "instruction_state_check m (Sub _ ns1 ns2) = ((ns1 < m) & (ns2 < m))"

fun instruction_register_check :: "nat \<Rightarrow> instruction \<Rightarrow> bool"
  where "instruction_register_check _ Halt = True"
  |     "instruction_register_check n (Add reg _) = (reg < n)"
  |     "instruction_register_check n (Sub reg _ _) = (reg < n)"

fun program_state_check :: "program \<Rightarrow> bool"
  where "program_state_check p = list_all (instruction_state_check (length p)) p"

fun program_register_check :: "program \<Rightarrow> nat \<Rightarrow> bool"
  where "program_register_check p n = list_all (instruction_register_check n) p"

fun tape_check_initial :: "tape \<Rightarrow> nat \<Rightarrow> bool"
  where "tape_check_initial t a = (t \<noteq> [] \<and> t!0 = a \<and> (\<forall>l>0. t ! l = 0))"

fun program_includes_halt :: "program \<Rightarrow> bool"
  where "program_includes_halt p = (length p > 1 \<and> ishalt (p ! (length p -1)) \<and> (\<forall>k<length p-1. \<not> ishalt (p!k)))"


definition is_valid
  where "is_valid c p = (program_includes_halt p \<and> program_state_check p
                            \<and> (program_register_check p (length (snd c))))"

definition is_valid_initial
  where "is_valid_initial c p a = ((is_valid c p)
                                \<and> (tape_check_initial (snd c) a)
                                \<and> (fst c = 0))"

definition correct_halt
                            \<and> (\<forall>l<(length (snd c)). snd (steps c p q) ! l = 0))"

definition terminates :: "configuration \<Rightarrow> program \<Rightarrow> nat \<Rightarrow> bool"
  where "terminates c p q = ((q>0)
                          \<and> (correct_halt c p q)
                          \<and> (\<forall>x<q. \<not> ishalt (p ! (fst (steps c p x)))))"

definition initial_config :: "nat \<Rightarrow> nat \<Rightarrow> configuration" where
  "initial_config n a = (0, (a # replicate n 0))"

end
