theory Store
imports Aexp Bexp
begin







type_synonym 'a store = "'a \<Rightarrow> nat"





definition symvar :: 
  "'a \<Rightarrow> 'a store \<Rightarrow> 'a symvar"
where
  "symvar v s \<equiv> (v,s v)"




lemma 
  "inj (\<lambda> v. symvar v s)"
by (auto simp add : inj_on_def symvar_def)




definition symvars :: 
  "'a store \<Rightarrow> 'a symvar set" 
where
 "symvars s = (\<lambda> v. symvar v s) ` (UNIV::'a set)"





definition fresh_symvar :: 
  "'v symvar \<Rightarrow> 'v store \<Rightarrow> bool" 
where
 "fresh_symvar sv s = (sv \<notin> symvars s)"





definition consistent ::
  "('v,'d) state \<Rightarrow> ('v symvar, 'd) state \<Rightarrow> 'v store \<Rightarrow> bool"
where
  "consistent \<sigma> \<sigma>\<^sub>s\<^sub>y\<^sub>m s \<equiv> (\<forall> v. \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar v s) = \<sigma> v)"




lemma
  "\<exists> \<sigma> \<sigma>\<^sub>s\<^sub>y\<^sub>m. consistent \<sigma> \<sigma>\<^sub>s\<^sub>y\<^sub>m s"
by (auto simp add : consistent_def)




lemma consistent_eq1 :
  "consistent \<sigma> \<sigma>\<^sub>s\<^sub>y\<^sub>m s = (\<forall> sv \<in> symvars s. \<sigma>\<^sub>s\<^sub>y\<^sub>m sv = \<sigma> (fst sv))"
by (auto simp add : consistent_def symvars_def symvar_def)


lemma consistent_eq2 :
  "consistent \<sigma> \<sigma>\<^sub>s\<^sub>y\<^sub>m store = (\<sigma> = (\<lambda> v. \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar v store)))"
by (auto simp add : consistent_def)


lemma consistentI1 : 
  "consistent \<sigma> (\<lambda> sv. \<sigma> (fst sv)) store" 
using consistent_eq1 by fast


lemma consistentI2 :
  "consistent (\<lambda> v. \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar v store)) \<sigma>\<^sub>s\<^sub>y\<^sub>m store"
using consistent_eq2 by fast






definition adapt_aexp :: 
  "('v,'d) aexp \<Rightarrow> 'v store \<Rightarrow> ('v symvar,'d) aexp" 
where
  "adapt_aexp e s = (\<lambda> \<sigma>\<^sub>s\<^sub>y\<^sub>m. e (\<lambda> v. \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar v s)))"




lemma adapt_aexp_is_subst :
  assumes "consistent \<sigma> \<sigma>\<^sub>s\<^sub>y\<^sub>m s" 
  shows   "(adapt_aexp e s) \<sigma>\<^sub>s\<^sub>y\<^sub>m = e \<sigma>"
using assms by (simp add : consistent_eq2 adapt_aexp_def)






lemma var_imp_symvar_var :
  assumes "v \<in> Aexp.vars e"
  shows   "symvar v s \<in> Aexp.vars (adapt_aexp e s)" (is "?sv \<in> Aexp.vars ?e'")
proof -
  obtain \<sigma> val where "e (\<sigma> (v := val)) \<noteq> e \<sigma>" 
  using assms unfolding Aexp.vars_def by blast  
  
  moreover
  have "(\<lambda>va. ((\<lambda>sv. \<sigma> (fst sv))(?sv := val)) (symvar va s)) = (\<sigma>(v := val))"
  by (auto simp add : symvar_def)  

  ultimately
  show ?thesis
  unfolding Aexp.vars_def mem_Collect_eq
  using consistentI1[of \<sigma> s] 
        consistentI2[of "(\<lambda>sv. \<sigma> (fst sv))(?sv:= val)" s]
  by (rule_tac ?x="\<lambda>sv. \<sigma> (fst sv)" in exI, rule_tac ?x="val" in exI) 
     (simp add : adapt_aexp_is_subst)
qed




lemma symvars_of_adapt_aexp :
  "Aexp.vars (adapt_aexp e s) \<subseteq> symvars s" (is "Aexp.vars ?e' \<subseteq> symvars s")
unfolding subset_iff
proof (intro allI impI)
  fix sv

  assume "sv \<in> Aexp.vars ?e'"

  then obtain \<sigma>\<^sub>s\<^sub>y\<^sub>m val 
  where "?e' (\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) \<noteq> ?e' \<sigma>\<^sub>s\<^sub>y\<^sub>m" 
  by (simp add : Aexp.vars_def, blast)

  hence "(\<lambda> x. (\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) (symvar x s)) \<noteq> (\<lambda> x. \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar x s))"
  proof (intro notI)
    assume "(\<lambda>x. (\<sigma>\<^sub>s\<^sub>y\<^sub>m(sv := val)) (symvar x s)) = (\<lambda>x. \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar x s))"
    
    hence "?e' (\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) = ?e' \<sigma>\<^sub>s\<^sub>y\<^sub>m" 
    by (simp add : adapt_aexp_def)
    
    thus False 
    by (elim notE)
  qed

  then obtain v 
  where "(\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) (symvar v s) \<noteq> \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar v s)" 
  by blast

  hence "sv = symvar v s" by (case_tac "sv = symvar v s", simp_all)

  thus "sv \<in> symvars s" by (simp add : symvars_def)
qed


lemma symvar_var_imp_var :
  assumes "sv \<in> Aexp.vars (adapt_aexp e s)" (is "sv \<in> Aexp.vars ?e'")
  shows   "fst sv \<in> Aexp.vars e"
proof -
  obtain v where "sv = (v, s v)" 
  using assms(1) symvars_of_adapt_aexp 
  unfolding symvars_def symvar_def 
  by blast
  
  obtain \<sigma>\<^sub>s\<^sub>y\<^sub>m val where "?e' (\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) \<noteq> ?e' \<sigma>\<^sub>s\<^sub>y\<^sub>m"
  using assms unfolding Aexp.vars_def by blast

  moreover
  have "(\<lambda> v. (\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) (symvar v s)) = (\<lambda> v. \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar v s)) (v := val)"
  
  ultimately
  show ?thesis
        consistentI2[of \<sigma>\<^sub>s\<^sub>y\<^sub>m s] 
        consistentI2[of "\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)" s]
  unfolding Aexp.vars_def 
  by (simp add : adapt_aexp_is_subst) blast
qed





lemma adapt_aexp_vars :
  "Aexp.vars (adapt_aexp e s) = (\<lambda> v. symvar v s) ` Aexp.vars e"
unfolding set_eq_iff image_def mem_Collect_eq Bex_def
proof (intro allI iffI, goal_cases)
  case (1 sv)

  moreover
  have "sv = symvar (fst sv) s" 
  using 1 symvars_of_adapt_aexp 
  by (force simp add:  symvar_def symvars_def)

  ultimately
  show ?case using symvar_var_imp_var by blast
next
  case (2 sv) thus ?case using var_imp_symvar_var by fast
qed 




lemma finite_vars_imp_finite_adapt_a :
  assumes "finite (Aexp.vars e)"
  shows   "finite (Aexp.vars (adapt_aexp e s))"
unfolding adapt_aexp_vars using assms by auto




definition adapt_bexp :: 
  "('v,'d) bexp \<Rightarrow> 'v store \<Rightarrow> ('v symvar,'d) bexp" 
where
  "adapt_bexp e s = (\<lambda> \<sigma>. e (\<lambda> x. \<sigma> (symvar x s)))"


lemma adapt_bexp_is_subst :
  assumes "consistent \<sigma> \<sigma>\<^sub>s\<^sub>y\<^sub>m s" 
  shows   "(adapt_bexp e s) \<sigma>\<^sub>s\<^sub>y\<^sub>m = e \<sigma>"
using assms by (simp add : consistent_eq2 adapt_bexp_def)


lemma var_imp_symvar_var2 :
  assumes "v \<in> Bexp.vars e"
  shows   "symvar v s \<in> Bexp.vars (adapt_bexp e s)" (is "?sv \<in> Bexp.vars ?e'")
proof -
  obtain \<sigma> val where A : "e (\<sigma> (v := val)) \<noteq> e \<sigma>" 
  using assms unfolding Bexp.vars_def by blast  
  
  moreover
  have "(\<lambda>va. ((\<lambda>sv. \<sigma> (fst sv))(?sv := val)) (symvar va s)) = (\<sigma>(v := val))"
  by (auto simp add : symvar_def)  

  ultimately
  show ?thesis
  unfolding Bexp.vars_def mem_Collect_eq
  using consistentI1[of \<sigma> s] 
        consistentI2[of "(\<lambda>sv. \<sigma> (fst sv))(?sv:= val)" s]
  by (rule_tac ?x="\<lambda>sv. \<sigma> (fst sv)" in exI, rule_tac ?x="val" in exI) 
     (simp add : adapt_bexp_is_subst)
qed


lemma symvars_of_adapt_bexp :
  "Bexp.vars (adapt_bexp e s) \<subseteq> symvars s" (is "Bexp.vars ?e' \<subseteq> ?SV")
proof
  fix sv
  assume "sv \<in> Bexp.vars ?e'"

  then obtain \<sigma>\<^sub>s\<^sub>y\<^sub>m val 
  where "?e' (\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) \<noteq> ?e' \<sigma>\<^sub>s\<^sub>y\<^sub>m"
  by (simp add : Bexp.vars_def, blast)

  hence "(\<lambda> x. (\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) (symvar x s)) \<noteq> (\<lambda> x. \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar x s))"
  by (auto simp add : adapt_bexp_def)

  hence "\<exists> v. (\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) (symvar v s) \<noteq> \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar v s)" by force

  then obtain v 
  where "(\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) (symvar v s) \<noteq> \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar v s)" 
  by blast

  hence "sv = symvar v s" by (case_tac "sv = symvar v s", simp_all)

  thus "sv \<in> symvars s" by (simp add : symvars_def)
qed


lemma symvar_var_imp_var2 :
  assumes "sv \<in> Bexp.vars (adapt_bexp e s)" (is "sv \<in> Bexp.vars ?e'")
  shows   "fst sv \<in> Bexp.vars e"
proof -
  obtain v where "sv = (v, s v)" 
  using assms symvars_of_adapt_bexp 
  unfolding symvars_def symvar_def 
  by blast
  
  obtain \<sigma>\<^sub>s\<^sub>y\<^sub>m val where "?e' (\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) \<noteq> ?e' \<sigma>\<^sub>s\<^sub>y\<^sub>m"
  using assms unfolding vars_def by blast

  moreover
  have "(\<lambda> v. (\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)) (symvar v s)) = (\<lambda> v. \<sigma>\<^sub>s\<^sub>y\<^sub>m (symvar v s)) (v := val)"
  
  ultimately
  show ?thesis
        consistentI2[of \<sigma>\<^sub>s\<^sub>y\<^sub>m s] 
        consistentI2[of "\<sigma>\<^sub>s\<^sub>y\<^sub>m (sv := val)" s]
  unfolding vars_def by (simp add : adapt_bexp_is_subst) blast
qed


lemma adapt_bexp_vars :
  "Bexp.vars (adapt_bexp e s) = (\<lambda> v. symvar v s) ` Bexp.vars e"
  (is "Bexp.vars ?e' = ?R")
unfolding set_eq_iff image_def mem_Collect_eq Bex_def
proof (intro allI iffI, goal_cases)
  case (1 sv)

  hence "fst sv \<in> vars e" by (rule symvar_var_imp_var2)

  moreover
  have "sv = symvar (fst sv) s" 
  using 1 symvars_of_adapt_bexp 
  by (force simp add:  symvar_def symvars_def)

  ultimately
  show ?case by blast
next
  case (2 sv)

  then obtain v where "v \<in> vars e" "sv = symvar v s" by blast

  thus ?case using var_imp_symvar_var2 by simp
qed 


lemma finite_vars_imp_finite_adapt_b :
  assumes "finite (Bexp.vars e)"
  shows   "finite (Bexp.vars (adapt_bexp e s))"
unfolding adapt_bexp_vars using assms by auto

end
