theory EdmondsKarp_Algo
imports EdmondsKarp_Termination_Abstract FordFulkerson_Algo
begin


context Network 
begin

definition "find_shortest_augmenting_spec f \<equiv> assert (NFlow c s t f) \<then> 
  (select p. Graph.isShortestPath (residualGraph c f) s p t)"

thm SELECT_refine  
lemma find_shortest_augmenting_refine[refine]: 
  "(f',f)\<in>Id \<Longrightarrow> find_shortest_augmenting_spec f' \<le> \<Down>(\<langle>Id\<rangle>option_rel) (find_augmenting_spec f)"  
  unfolding find_shortest_augmenting_spec_def find_augmenting_spec_def
  apply (refine_vcg)
  apply (auto 
    simp: NFlow.shortest_is_augmenting RELATESI
    dest: NFlow.augmenting_path_imp_shortest)
  done

definition "edka_partial \<equiv> do {
  let f = (\<lambda>_. 0);

  (f,_) \<leftarrow> while\<^bsup>fofu_invar\<^esup>
    (\<lambda>(f,brk). \<not>brk) 
    (\<lambda>(f,_). do {
      p \<leftarrow> find_shortest_augmenting_spec f;
      case p of 
        None \<Rightarrow> return (f,True)
      | Some p \<Rightarrow> do {
          assert (p\<noteq>[]);
          assert (NPreflow.isAugmentingPath c s t f p);
          assert (Graph.isShortestPath (residualGraph c f) s p t);
          let f = NFlow.augment_with_path c f p;
          assert (NFlow c s t f);
          return (f, False)
        }  
    })
    (f,False);
  assert (NFlow c s t f);
  return f 
}"

lemma edka_partial_refine[refine]: "edka_partial \<le> \<Down>Id fofu"
  unfolding edka_partial_def fofu_def
  apply (refine_rcg bind_refine')
  apply (refine_dref_type)
  apply (vc_solve simp: find_shortest_augmenting_spec_def)
  done



context Network begin
definition "edka \<equiv> do {
  let f = (\<lambda>_. 0);

  (f,_) \<leftarrow> while\<^sub>T\<^bsup>fofu_invar\<^esup>
    (\<lambda>(f,brk). \<not>brk) 
    (\<lambda>(f,_). do {
      p \<leftarrow> find_shortest_augmenting_spec f;
      case p of 
        None \<Rightarrow> return (f,True)
      | Some p \<Rightarrow> do {
          assert (p\<noteq>[]);
          assert (NPreflow.isAugmentingPath c s t f p);
          assert (Graph.isShortestPath (residualGraph c f) s p t);
          let f = NFlow.augment_with_path c f p;
          assert (NFlow c s t f);
          return (f, False)
        }  
    })
    (f,False);
  assert (NFlow c s t f);
  return f 
}"

definition "edka_wf_rel \<equiv> inv_image 
  (less_than_bool <*lex*> measure (\<lambda>cf. ek_analysis_defs.ekMeasure cf s t))
  (\<lambda>(f,brk). (\<not>brk,residualGraph c f))"

lemma edka_wf_rel_wf[simp, intro!]: "wf edka_wf_rel"
  unfolding edka_wf_rel_def by auto

theorem edka_refine[refine]: "edka \<le> \<Down>Id edka_partial"
  unfolding edka_def edka_partial_def
  apply (refine_rcg bind_refine' 
    WHILEIT_refine_WHILEI[where V=edka_wf_rel])
  apply (refine_dref_type)
  apply (simp; fail)
  subgoal
    apply (simp)
    apply (erule bind_sim_select_rule)
    apply (auto split: option.split 
      simp: NFlow.augment_with_path_def
      simp: assert_bind_spec_conv Let_def
      simp: find_shortest_augmenting_spec_def
      simp: edka_wf_rel_def NFlow.shortest_path_decr_ek_measure
    ; fail) []
  done

  apply (vc_solve)
  done


lemma ekMeasure_upper_bound: 
  "ek_analysis_defs.ekMeasure (residualGraph c (\<lambda>_. 0)) s t 
   < 2 * card V * card E + card V"
proof -  
  interpret NFlow c s t "(\<lambda>_. 0)"
    by unfold_locales (auto simp: s_node t_node cap_non_negative)

  interpret ek: ek_analysis cf  
    by unfold_locales auto

  have cardV_positive: "card V > 0" and cardE_positive: "card E > 0"
    using card_0_eq[OF finite_V] V_not_empty apply blast
    using card_0_eq[OF finite_E] E_not_empty apply blast
    done

  show ?thesis proof (cases "cf.connected s t")  
    case False hence "ek.ekMeasure = 0" by (auto simp: ek.ekMeasure_def)
    with cardV_positive cardE_positive show ?thesis
      by auto
  next
    case True 

    have "cf.min_dist s t > 0"
      apply (rule ccontr)
      apply (auto simp: Graph.min_dist_z_iff True s_not_t[symmetric])
      done

    have "cf = c"  
      unfolding residualGraph_def E_def
      by auto
    hence "ek.uE = E\<union>E\<inverse>" unfolding ek.uE_def by simp

    from True have "ek.ekMeasure 
      = (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + (card (ek.spEdges))"
      unfolding ek.ekMeasure_def by simp
    also from 
      mlex_bound[of "card cf.V - cf.min_dist s t" "card V", 
                 OF _ ek.card_spEdges_less]
    have "\<dots> < card V * (card ek.uE+1)" 
      by (auto simp: resV_netV)
      apply (rule order_trans)
      apply (rule card_Un_le)
      by auto
    finally show ?thesis by (auto simp: algebra_simps)
  qed  
qed  


definition "edkac_rel \<equiv> {((f,brk,itc), (f,brk)) | f brk itc.
    itc + ek_analysis_defs.ekMeasure (residualGraph c f) s t 
  < 2 * card V * card E + card V
}"

definition "edka_complexity \<equiv> do {
  let f = (\<lambda>_. 0);

  (f,_,itc) \<leftarrow> while\<^sub>T 
    (\<lambda>(f,brk,_). \<not>brk) 
    (\<lambda>(f,_,itc). do {
      p \<leftarrow> find_shortest_augmenting_spec f;
      case p of 
        None \<Rightarrow> return (f,True,itc)
      | Some p \<Rightarrow> do {
          let f = NFlow.augment_with_path c f p;
          return (f, False,itc + 1)
        }  
    })
    (f,False,0);
  assert (itc < 2 * card V * card E + card V);
  return f 
}"
  
lemma edka_complexity_refine: "edka_complexity \<le> \<Down>Id edka"
proof -
  have [refine_dref_RELATES]: 
    "RELATES edkac_rel"
    by (auto simp: RELATES_def)

  show ?thesis  
    unfolding edka_complexity_def edka_def
    apply (refine_rcg)
    apply (refine_dref_type)
    apply (vc_solve simp: edkac_rel_def "NFlow.augment_with_path_def")
    subgoal using ekMeasure_upper_bound by auto []
    subgoal by (drule (1) NFlow.shortest_path_decr_ek_measure; auto)
    done
qed    

theorem "edka_complexity \<le> (spec f. isMaxFlow f)"
proof -  
  note edka_complexity_refine
  also note edka_refine
  also note edka_partial_refine
  also note fofu_partial_correct
  finally show ?thesis .
qed  


