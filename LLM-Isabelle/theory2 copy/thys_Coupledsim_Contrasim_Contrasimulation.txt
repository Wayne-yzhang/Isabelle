theory Contrasimulation
imports
  Weak_Relations
begin

context lts_tau
begin


definition contrasimulation ::
where

lemma contrasim_simpler_def:
proof -
  then show ?thesis
    unfolding contrasimulation_def
    using word_steps_ignore_tau_addition word_steps_ignore_tau_removal
    by metis
qed


lemma contrasim_preorder_is_contrasim:
  unfolding contrasimulation_def
  by metis

lemma contrasim_preorder_is_greatest:
  using assms by auto

lemma contrasim_tau_step:
  unfolding contrasimulation_def
  using steps.simps tau_tau tau_word_concat
  by metis

lemma contrasim_trans_constructive:
  fixes R1 R2
  defines
  assumes
  shows
  using assms(2,3,4,5) unfolding R_def contrasimulation_def by metis+

lemma contrasim_trans:
  assumes
  shows
  using assms contrasim_trans_constructive by blast

lemma contrasim_refl:
  shows
  using contrasim_tau_step steps.refl by blast

lemma contrasimilarity_equiv:
proof -
    using contrasim_refl unfolding contrasimilarity_def reflp_def by blast
    unfolding contrasimilarity_def symp_def by blast
    using contrasim_trans unfolding contrasimilarity_def transp_def by meson
  ultimately show ?thesis using equivpI by blast
qed

lemma contrasim_implies_trace_incl:
by (metis assms contrasim_simpler_def trace_inclusion_def) 

lemma contrasim_coupled:
  assumes
  shows
  using assms steps.refl[of p tau] weak_step_seq.simps(1)
  unfolding contrasim_simpler_def by blast

lemma contrasim_taufree_symm:
  assumes
  shows
  using contrasim_coupled assms stable_tauclosure_only_loop by blast

lemma symm_contrasim_is_weak_bisim:
  assumes
  shows
  using assms unfolding contrasim_simpler_def weak_sim_word weak_bisim_weak_sim by blast

lemma contrasim_weakest_bisim:
  assumes
  shows
  using assms contrasim_taufree_symm symm_contrasim_is_weak_bisim weak_bisim_taufree_strong
  by blast

lemma symm_weak_sim_is_contrasim:
  assumes
  shows
  using assms unfolding contrasim_simpler_def weak_sim_word by blast


definition mimicking :: "('s \<Rightarrow> 's set \<Rightarrow> bool) \<Rightarrow> 's \<Rightarrow> 's set \<Rightarrow> bool" where 

definition set_lifted :: "('s \<Rightarrow> 's \<Rightarrow> bool) \<Rightarrow> 's \<Rightarrow> 's set \<Rightarrow> bool" where 

lemma R_is_in_mimicking_of_R : 
  using assms steps.refl lts_tau.weak_step_seq.simps(1)
  unfolding mimicking_def by fastforce

lemma mimicking_of_C_guarantees_tau_succ:
  assumes
proof -
  obtain p0 Q0 A q0
      using mimicking_def assms set_lifted_def by metis
    by (simp add: word_reachable_implies_in_dsuccs) 
qed

lemma mimicking_of_C_guarantees_action_succ:
 assumes 
proof -
  obtain p0 Q0 A q0
    using mimicking_def assms set_lifted_def by metis
    using assms set_lifted_def by (metis singleton_inject) 
    by (meson steps.step steps_concat)
    by fastforce
    using word_reachable_implies_in_dsuccs by blast
  thus ?thesis
qed


definition contrasim_step ::
where

lemma contrasim_step_weaker_than_seq:
  assumes
  shows
  unfolding contrasim_step_def
proof ((rule allI impI)+)
  fix p q p' a
  assume
  hence
    using assms `R p q` unfolding contrasim_simpler_def by blast
qed

lemma contrasim_step_seq_coincide_for_sims:
  assumes
  shows
  unfolding contrasimulation_def
proof (clarify)
  fix p q p' A
  assume
  proof (induct A arbitrary: p p' q)
    case Nil
    then show ?case using assms(1) unfolding contrasim_step_def
      using tau_tau weak_step_seq.simps(1) by blast
  next
    case (Cons a A)
      using assms(2) `R p q` unfolding weak_sim_weak_premise by blast
    then show ?case using q1_def(1) by auto
  qed
qed

end
end
