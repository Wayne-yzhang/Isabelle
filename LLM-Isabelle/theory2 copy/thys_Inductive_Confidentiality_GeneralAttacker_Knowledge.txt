theory Knowledge
imports NS_Public_Bad_GA
begin


theorem knowledge_equiv:
 "\<lbrakk> X \<in> knows A evs; Notes A X \<notin> set evs;
   X \<notin> {Key (priEK A), Key (priSK A), Key (shrK A)} \<rbrakk>
 \<Longrightarrow> X \<in> knows B evs"
apply (erule rev_mp, erule rev_mp, erule rev_mp)
apply (induct_tac "A", induct_tac "B", induct_tac "evs")
apply (induct_tac [2] "a") apply auto
done

lemma knowledge_equiv_bis:
 "\<lbrakk> X \<in> knows A evs; Notes A X \<notin> set evs \<rbrakk>
 \<Longrightarrow> X \<in> {Key (priEK A), Key (priSK A), Key (shrK A)} \<union> knows B evs"
apply (blast dest: knowledge_equiv)
done

lemma knowledge_equiv_ter:
 "\<lbrakk> X \<in> knows A evs; X \<notin> {Key (priEK A), Key (priSK A), Key (shrK A)} \<rbrakk>
\<Longrightarrow> X \<in> knows B evs \<or> Notes A X \<in> set evs"
apply (blast dest: knowledge_equiv)
done

lemma knowledge_equiv_quater:
 " X \<in> knows A evs
\<Longrightarrow> X \<in> knows B evs \<or> Notes A X \<in> set evs \<or> 
   X \<in> {Key (priEK A), Key (priSK A), Key (shrK A)}"
apply (blast dest: knowledge_equiv)
done

lemma setdiff_diff_insert: "A-B-C=D-E-F \<Longrightarrow> insert m (A-B-C) = insert m (D-E-F)"
by simp
lemma "A-B-C=D-E-F \<Longrightarrow> insert m A-B-C = insert m D-E-F"
oops

lemma knowledge_equiv_eq_setdiff:
 "knows A evs  -
   {Key (priEK A), Key (priSK A), Key (shrK A)} -
     {X. Notes A X \<in> set evs}
  =
  knows B evs -
   {Key (priEK B), Key (priSK B), Key (shrK B)} -
     {X. Notes B X \<in> set evs}"
apply (induct_tac "evs", induct_tac "A", induct_tac "B")
apply force
apply (induct_tac "a")

apply simp_all




lemma knowledge_equiv_eq_old:
 "knows A evs  \<union>  
   {Key (priEK B), Key (priSK B), Key (shrK B)} \<union> 
     {X. Notes B X \<in> set evs} 
  = 
  knows B evs \<union> 
   {Key (priEK A), Key (priSK A), Key (shrK A)} \<union> 
     {X. Notes A X \<in> set evs}"
apply (induct_tac "evs", induct_tac "A", induct_tac "B")
apply force
apply (induct_tac "a")
apply simp_all
done


theorem knowledge_eval: "knows A evs = 
       {Key (priEK A), Key (priSK A), Key (shrK A)} \<union> 
       (Key ` range pubEK) \<union> (Key ` range pubSK) \<union>
       {X. \<exists> S R. Says S R X \<in> set evs} \<union>
       {X. Notes A X \<in> set evs}"
apply (induct_tac "A", induct_tac "evs")
apply (induct_tac [2] "a")
apply auto
done

lemma knowledge_eval_setdiff:
 "knows A evs  - 
   {Key (priEK A), Key (priSK A), Key (shrK A)} -
     {X. Notes A X \<in> set evs}
  = 
       (Key ` range pubEK) \<union> (Key ` range pubSK) \<union>
       {X. \<exists> S R. Says S R X \<in> set evs}"
apply (simp only: knowledge_eval) apply auto

theorem knowledge_equiv_eq: "knows A evs  \<union>  
   {Key (priEK B), Key (priSK B), Key (shrK B)} \<union> 
     {X. Notes B X \<in> set evs} 
  = 
  knows B evs \<union> 
   {Key (priEK A), Key (priSK A), Key (shrK A)} \<union> 
     {X. Notes A X \<in> set evs}"
apply (force simp only: knowledge_eval)
done

lemma "knows A evs  \<union>  
   {Key (priEK B), Key (priSK B), Key (shrK B)} \<union> 
     {X. Notes B X \<in> set evs} -
(  {Key (priEK B), Key (priSK B), Key (shrK B)} \<union> 
     {X. Notes B X \<in> set evs} ) = knows A evs"
apply auto
oops

theorem parts_knowledge_equiv_eq: "
parts(knows A evs)  \<union>  
   {Key (priEK B), Key (priSK B), Key (shrK B)} \<union> 
     parts({X. Notes B X \<in> set evs}) 
  = 
parts(knows B evs) \<union> 
   {Key (priEK A), Key (priSK A), Key (shrK A)} \<union> 
     parts({X. Notes A X \<in> set evs})"
apply (simp only: knowledge_eval parts_Un) apply force
done

lemmas parts_knowledge_equiv = parts_knowledge_equiv_eq [THEN equalityD1, THEN subsetD]
thm parts_knowledge_equiv
theorem noprishr_parts_knowledge_equiv: "
\<lbrakk> X \<notin> {Key (priEK A), Key (priSK A), Key (shrK A)};
  X \<in> parts(knows A evs) \<rbrakk>
\<Longrightarrow>  X \<in> parts(knows B evs) \<union> 
      parts({X. Notes A X \<in> set evs})"
apply (force dest: UnI1 [THEN UnI1, THEN parts_knowledge_equiv])
done





lemma knowledge_equiv_eq_NS: " 
  evs \<in> ns_public \<Longrightarrow>
  knows A evs  \<union> {Key (priEK B), Key (priSK B), Key (shrK B)}  = 
  knows B evs \<union> {Key (priEK A), Key (priSK A), Key (shrK A)}"
apply (force simp only: knowledge_eval NS_no_Notes)
done

lemma parts_knowledge_equiv_eq_NS: " 
  evs \<in> ns_public \<Longrightarrow>
  parts(knows A evs) \<union> {Key (priEK B), Key (priSK B), Key (shrK B)}  = 
  parts(knows B evs) \<union> {Key (priEK A), Key (priSK A), Key (shrK A)}"
apply (simp only: knowledge_eval NS_no_Notes parts_Un) apply force
done

theorem noprishr_parts_knowledge_equiv_NS: " 
\<lbrakk> X \<notin> {Key (priEK A), Key (priSK A), Key (shrK A)};
  X \<in> parts(knows A evs); evs \<in> ns_public \<rbrakk>
\<Longrightarrow>  X \<in> parts(knows B evs)"
apply (drule noprishr_parts_knowledge_equiv, simp)
apply (simp add: NS_no_Notes)
done

theorem Agent_not_analz_N:
"\<lbrakk> Nonce N \<notin> parts(knows A evs); evs \<in> ns_public \<rbrakk>
 \<Longrightarrow> Nonce N \<notin> analz(knows B evs)"
apply (force intro: noprishr_parts_knowledge_equiv_NS analz_into_parts)
done

end
