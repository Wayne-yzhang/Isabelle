theory IMP2_from_IMP
imports "../IMP2"
begin


  
  definition "exp_count_up1 \<equiv> 
    ''a'' ::= N 1;;
    ''c'' ::= N 0;;
    WHILE Cmpop (<) (V ''c'') (V ''n'') DO (
      ''c'' ::= Binop (+) (V ''c'') (N 1))"

      
  lemma "exp_count_up1 = exp_count_up2"
    unfolding exp_count_up1_def exp_count_up2_def ..
  
  


  value "bval (Cmpop (\<le>) (Binop (+) (Unop uminus (V ''x'')) (N 42)) (N 50)) <''x'':=(\<lambda>_. -5)> "
    
  thm aval.simps bval.simps


  
  
  
    
  

  thm big_step.AssignIdx big_step.ArrayCpy big_step.ArrayClear
  
  
  thm big_step.Scope
  
  context fixes f :: com begin
  end
  
  
  thm big_step.PCall
  
  thm big_step.PScope
  
  
  lemmas nat_distribs = nat_add_distrib nat_diff_distrib Suc_diff_le nat_mult_distrib nat_div_distrib
  
  lemma "s\<^sub>0 ''n'' 0 \<ge> 0 \<Longrightarrow> wlp \<pi> exp_count_up1 (\<lambda>s. s ''a'' 0 = 2^nat (s\<^sub>0 ''n'' 0)) s\<^sub>0"
    unfolding exp_count_up1_def
    apply (subst annotate_whileI[where 
          I="\<lambda>s. s ''n'' 0 = s\<^sub>0 ''n'' 0 \<and>  s ''a'' 0 = 2 ^ nat (s ''c'' 0) \<and> 0 \<le> s ''c'' 0 \<and> s ''c'' 0 \<le> s\<^sub>0 ''n'' 0" 
        ])
    apply (i_vcg_preprocess; i_vcg_gen; clarsimp)
    apply i_vcg_postprocess
    by (auto simp: algebra_simps nat_distribs)
        
  lemma "s\<^sub>0 ''n'' 0 \<ge> 0 \<Longrightarrow> wlp \<pi> exp_count_up1 (\<lambda>s. s ''a'' 0 = 2^nat (s\<^sub>0 ''n'' 0)) s\<^sub>0"
    unfolding exp_count_up1_def
    apply (subst annotate_whileI[where 
          I="\<lambda>s. s ''n'' 0 = s\<^sub>0 ''n'' 0 \<and>  s ''a'' 0 = 2 ^ nat (s ''c'' 0) \<and> 0 \<le> s ''c'' 0 \<and> s ''c'' 0 \<le> s\<^sub>0 ''n'' 0" 
        ])
    apply vcg
    oops
    
    
  

  lemma "let n = s\<^sub>0 ''n'' 0 in n \<ge> 0 
    \<Longrightarrow> wlp \<pi> exp_count_up1 (\<lambda>s. let a = s ''a'' 0; n\<^sub>0 = s\<^sub>0 ''n'' 0 in a = 2^nat (n\<^sub>0)) s\<^sub>0"
    unfolding exp_count_up1_def
    apply (subst annotate_whileI[where 
          I="\<lambda>s. s ''n'' 0 = s\<^sub>0 ''n'' 0 \<and>  s ''a'' 0 = 2 ^ nat (s ''c'' 0) \<and> 0 \<le> s ''c'' 0 \<and> s ''c'' 0 \<le> s\<^sub>0 ''n'' 0" 
        ])
    apply vcg
    apply (auto simp: algebra_simps nat_distribs)
    done
  
  lemma "VAR (s x) P = (let v=s x in P v)" unfolding VAR_def by simp 

  program_spec (partial) exp_count_up
