theory Attributes
imports "../Isabelle/Subtype"
begin


datatype AttId = CounterImpl'value | UndoCounter'save
  | Dummy'dummy | Counter'dummy



definition dtype:: "AttId \<Rightarrow> Javatype" where
"dtype f = (case f of 
              CounterImpl'value \<Rightarrow> CClassT CounterImpl
            | UndoCounter'save \<Rightarrow> CClassT UndoCounter
            | Dummy'dummy \<Rightarrow> AClassT Dummy
            | Counter'dummy \<Rightarrow> InterfaceT Counter)"

lemma dtype_simps [simp]:
"dtype CounterImpl'value = CClassT CounterImpl" 
"dtype UndoCounter'save = CClassT UndoCounter"
"dtype Dummy'dummy = AClassT Dummy"
"dtype Counter'dummy = InterfaceT Counter"
  by (simp_all add: dtype_def dtype_def dtype_def)

  
definition cDTypeId :: "AttId \<Rightarrow> CTypeId" where
"cDTypeId f = (case f of 
              CounterImpl'value \<Rightarrow> CounterImpl
            | UndoCounter'save \<Rightarrow> UndoCounter
            | Dummy'dummy \<Rightarrow> undefined
            | Counter'dummy \<Rightarrow> undefined )"

definition aDTypeId:: "AttId \<Rightarrow> ATypeId" where
"aDTypeId f = (case f of 
              CounterImpl'value \<Rightarrow> undefined
            | UndoCounter'save \<Rightarrow> undefined
            | Dummy'dummy \<Rightarrow> Dummy
            | Counter'dummy \<Rightarrow> undefined )"

definition iDTypeId:: "AttId \<Rightarrow> ITypeId" where
"iDTypeId f = (case f of 
              CounterImpl'value \<Rightarrow> undefined
            | UndoCounter'save \<Rightarrow> undefined
            | Dummy'dummy \<Rightarrow> undefined
            | Counter'dummy \<Rightarrow> Counter )"

lemma DTypeId_simps [simp]:
"cDTypeId CounterImpl'value = CounterImpl" 
"cDTypeId UndoCounter'save = UndoCounter"
"aDTypeId Dummy'dummy = Dummy"
"iDTypeId Counter'dummy = Counter"
  by (simp_all add: cDTypeId_def aDTypeId_def iDTypeId_def)


definition rtype:: "AttId \<Rightarrow> Javatype" where
"rtype f = (case f of 
              CounterImpl'value \<Rightarrow> IntgT
            | UndoCounter'save \<Rightarrow> IntgT
            | Dummy'dummy \<Rightarrow> NullT
            | Counter'dummy \<Rightarrow> NullT)"

lemma rtype_simps [simp]:
"rtype CounterImpl'value  = IntgT"
"rtype UndoCounter'save  = IntgT"
"rtype Dummy'dummy = NullT"
"rtype Counter'dummy = NullT"
  by (simp_all add: rtype_def rtype_def rtype_def)

in memory for
instance fields. We rule out the impossible combinations of class names and
field. A store model which provides locations for all possible combinations
of the Cartesian product of class name and field name works out fine as 
well, because we cannot express modification of such ``wrong'' 
locations in a Java program. So we can only prove useful properties about 
reasonable combinations.
The only drawback in such a model is that we cannot prove a property like 
If the store provides locations for
every combination of class name and field name, we cannot rule out 
reachability of certain pointer chains that go through ``wrong'' locations. 

are declared in which classes and interfaces,
fields at run-time. Thus,

There is only one such datatype because only objects of concrete classes can be 
created at run-time,
thus only instance fields of concrete classes can occupy memory.\<close>
text \<open>Function \<open>catt\<close> builds a \<open>CAttId\<close> from a class name
\<open>undefined\<close>. We can also filter out static fields in 
\<open>catt\<close>.\<close>
text \<open>Selection of the class name of the type of the object in which the field lives.
  The field can only be located in a concrete class.\<close>
text \<open>Selection of the field name.\<close>
