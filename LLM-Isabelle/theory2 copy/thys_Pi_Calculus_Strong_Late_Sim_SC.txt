theory Strong_Late_Sim_SC
  imports Strong_Late_Sim
begin


lemma nilSim[dest]:
  fixes a :: name
  and   b :: name
  and   x :: name
  and   P :: pi
  and   Q :: pi

  shows "\<zero> \<leadsto>[Rel] \<tau>.(P) \<Longrightarrow> False"
  and   "\<zero> \<leadsto>[Rel] a<x>.P \<Longrightarrow> False"
  and   "\<zero> \<leadsto>[Rel] a{b}.P \<Longrightarrow> False"
by(fastforce simp add: simulation_def intro: Tau Input Output)+

lemma nilSimRight:
  fixes P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  shows "P \<leadsto>[Rel] \<zero>"
by(auto simp add: simulation_def)


lemma matchIdLeft:
  fixes a   :: name
  and   P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes "Id \<subseteq> Rel"

  shows "[a\<frown>a]P \<leadsto>[Rel] P"
using assms
by(force simp add: simulation_def dest: Match derivativeReflexive)

lemma matchIdRight:
  fixes P   :: pi
  and   a   :: name
  and   Rel :: "(pi \<times> pi) set"

  assumes IdRel: "Id \<subseteq> Rel"

  shows "P \<leadsto>[Rel] [a\<frown>a]P"
using assms
by(fastforce simp add: simulation_def elim: matchCases intro: derivativeReflexive)

lemma matchNilLeft:
  fixes a :: name
  and   b :: name
  and   P :: pi

  assumes "a \<noteq> b"
  
  shows "\<zero> \<leadsto>[Rel] [a\<frown>b]P"
using assms
by(auto simp add: simulation_def)


lemma mismatchIdLeft:
  fixes a   :: name
  and   b   :: name
  and   P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes "Id \<subseteq> Rel"
  and     "a \<noteq> b"

  shows "[a\<noteq>b]P \<leadsto>[Rel] P"
using assms
by(fastforce simp add: simulation_def intro: Mismatch dest: derivativeReflexive)

lemma mismatchIdRight:
  fixes P   :: pi
  and   a   :: name
  and   b   :: name
  and   Rel :: "(pi \<times> pi) set"

  assumes IdRel: "Id \<subseteq> Rel"
  and     aineqb: "a \<noteq> b"

  shows "P \<leadsto>[Rel] [a\<noteq>b]P"
using assms
by(fastforce simp add: simulation_def elim: mismatchCases intro: derivativeReflexive)

lemma mismatchNilLeft:
  fixes a :: name
  and   P :: pi
  
  shows "\<zero> \<leadsto>[Rel] [a\<noteq>a]P"
by(auto simp add: simulation_def)


lemma sumSym:
  fixes P   :: pi
  and   Q   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes Id: "Id \<subseteq> Rel"
  
  shows "P \<oplus> Q \<leadsto>[Rel] Q \<oplus> P"
using assms
by(fastforce simp add: simulation_def elim: sumCases intro: Sum1 Sum2 derivativeReflexive)

lemma sumIdempLeft:
  fixes P :: pi
  and Rel :: "(pi \<times> pi) set"

  assumes "Id \<subseteq> Rel"

  shows "P \<leadsto>[Rel] P \<oplus> P"
using assms
by(fastforce simp add: simulation_def elim: sumCases intro: derivativeReflexive)

lemma sumIdempRight:
  fixes P :: pi
  and Rel :: "(pi \<times> pi) set"

  assumes I: "Id \<subseteq> Rel"

  shows "P \<oplus> P \<leadsto>[Rel] P"
using assms
by(fastforce simp add: simulation_def intro: Sum1 derivativeReflexive)

lemma sumAssocLeft:
  fixes P   :: pi
  and   Q   :: pi
  and   R   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes Id: "Id \<subseteq> Rel"

  shows "(P \<oplus> Q) \<oplus> R \<leadsto>[Rel] P \<oplus> (Q \<oplus> R)"
using assms
by(fastforce simp add: simulation_def elim: sumCases intro: Sum1 Sum2 derivativeReflexive)

lemma sumAssocRight:
  fixes P   :: pi
  and   Q   :: pi
  and   R   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes Id: "Id \<subseteq> Rel"

  shows "P \<oplus> (Q \<oplus> R) \<leadsto>[Rel] (P \<oplus> Q) \<oplus> R"
using assms
by(fastforce simp add: simulation_def elim: sumCases intro: Sum1 Sum2 derivativeReflexive)

lemma sumZeroLeft:
  fixes P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes Id: "Id \<subseteq> Rel"

  shows "P \<oplus> \<zero> \<leadsto>[Rel] P"
using assms
by(fastforce simp add: simulation_def intro: Sum1 derivativeReflexive)

lemma sumZeroRight:
  fixes P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes Id: "Id \<subseteq> Rel"

  shows "P \<leadsto>[Rel] P \<oplus> \<zero>"
using assms
by(fastforce simp add: simulation_def elim: sumCases intro: derivativeReflexive)

lemma sumResLeft:
  fixes x   :: name
  and   P   :: pi
  and   Q   :: pi

  assumes Id: "Id \<subseteq> Rel"
  and     Eqvt: "eqvt Rel"

  shows "(<\<nu>x>P) \<oplus> (<\<nu>x>Q) \<leadsto>[Rel] <\<nu>x>(P \<oplus> Q)"
using Eqvt
proof(induct rule: simCasesCont[where C="(x, P, Q)"])
  case(Bound a y PQ)
  hence "y \<sharp> P \<oplus> Q" by simp
  proof(induct rule: resCasesB)
    case(cOpen a PQ)
    proof(induct rule: sumCases)
      case cSum1
      hence "(<\<nu>x>P) \<oplus> (<\<nu>x>Q) \<longmapsto>a<\<nu>x> \<prec> PQ" by(rule Sum1)
        by(simp add: alphaBoundResidual)
      moreover from Id have "derivative ([(y, x)] \<bullet> PQ) ([(y, x)] \<bullet> PQ) (BoundOutputS a) y Rel"
        by(force simp add: derivative_def)
      ultimately show ?case by blast
    next
      case cSum2
      hence "(<\<nu>x>P) \<oplus> (<\<nu>x>Q) \<longmapsto>a<\<nu>x> \<prec> PQ" by(rule Sum2)
        by(simp add: alphaBoundResidual)
      moreover from Id have "derivative ([(y, x)] \<bullet> PQ) ([(y, x)] \<bullet> PQ) (BoundOutputS a) y Rel"
        by(force simp add: derivative_def)
      ultimately show ?case by blast
    qed
  next
    case(cRes PQ)
    proof(induct rule: sumCases)
      case cSum1
      hence "(<\<nu>x>P) \<oplus> (<\<nu>x>Q) \<longmapsto>a\<guillemotleft>y\<guillemotright> \<prec> <\<nu>x>PQ" by(rule Sum1)
      moreover from Id have "derivative (<\<nu>x>PQ) (<\<nu>x>PQ) a y Rel"
        by(cases a) (auto simp add: derivative_def)
      ultimately show ?case by blast
    next
      case cSum2
      hence "(<\<nu>x>P) \<oplus> (<\<nu>x>Q) \<longmapsto>a\<guillemotleft>y\<guillemotright> \<prec> <\<nu>x>PQ" by(rule Sum2)
      moreover from Id have "derivative (<\<nu>x>PQ) (<\<nu>x>PQ) a y Rel"
        by(cases a) (auto simp add: derivative_def)
      ultimately show ?case by blast
    qed
  qed
next
  case(Free \<alpha> PQ)
  proof(induct rule: resCasesF)
    case(cRes PQ)
    proof(induct rule: sumCases)
      case cSum1 
      hence "(<\<nu>x>P) \<oplus> (<\<nu>x>Q) \<longmapsto>\<alpha> \<prec> <\<nu>x>PQ" by(rule Sum1)
      with Id show ?case by blast
    next
      case cSum2
      hence "(<\<nu>x>P) \<oplus> (<\<nu>x>Q) \<longmapsto>\<alpha> \<prec> <\<nu>x>PQ" by(rule Sum2)
      with Id show ?case by blast
    qed
  qed
qed

lemma sumResRight:
  fixes x   :: name
  and   P   :: pi
  and   Q   :: pi

  assumes Id: "Id \<subseteq> Rel"
  and     Eqvt: "eqvt Rel"

  shows "<\<nu>x>(P \<oplus> Q) \<leadsto>[Rel] (<\<nu>x>P) \<oplus> (<\<nu>x>Q)"
proof(induct rule: simCasesCont[where C="(x, P, Q)"])
  case(Bound a y PQ)
  proof(induct rule: sumCases)
    case cSum1
    proof(induct rule: resCasesB)
      case(cOpen a P')
      
      moreover from Id have "derivative ([(y, x)] \<bullet> P') ([(y, x)] \<bullet> P') (BoundOutputS a) y Rel"
        by(force simp add: derivative_def)
      ultimately show ?case by blast
    next
      case(cRes P')
      moreover from Id have "derivative (<\<nu>x>P') (<\<nu>x>P') a y Rel"
        by(cases a) (auto simp add: derivative_def)
      ultimately show ?case by blast
    qed
  next
    case cSum2
    proof(induct rule: resCasesB)
      case(cOpen a Q')
      
      moreover from Id have "derivative ([(y, x)] \<bullet> Q') ([(y, x)] \<bullet> Q') (BoundOutputS a) y Rel"
        by(force simp add: derivative_def)
      ultimately show ?case by blast
    next
      case(cRes Q')
      moreover from Id have "derivative (<\<nu>x>Q') (<\<nu>x>Q') a y Rel"
        by(cases a) (auto simp add: derivative_def)
      ultimately show ?case by blast
    qed
  qed
next
  case(Free \<alpha> PQ)
  proof(induct rule: sumCases)
    case cSum1
    proof(induct rule: resCasesF)
      case(cRes P')
      with Id show ?case by blast
    qed
  next
    case cSum2
    proof(induct rule: resCasesF)
      case(cRes Q')
      with Id show ?case by blast
    qed
  qed
qed


lemma parZeroLeft:
  fixes P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes ParZero: "\<And>Q. (Q \<parallel> \<zero>, Q) \<in> Rel"

  shows "P \<parallel> \<zero> \<leadsto>[Rel] P"
proof -
  {
    fix P Q a x
    from ParZero have "derivative (P \<parallel> \<zero>) P a x Rel"
      by(case_tac a) (auto simp add: derivative_def)
  }
  thus ?thesis using assms
    by(fastforce simp add: simulation_def intro: Par1B Par1F)
qed

lemma parZeroRight:
  fixes P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes ParZero: "\<And>Q. (Q, Q \<parallel> \<zero>) \<in> Rel"

  shows "P \<leadsto>[Rel] P \<parallel> \<zero>"
proof -
  {
    fix P Q a x
    from ParZero have "derivative P (P \<parallel> \<zero>) a x Rel"
      by(case_tac a) (auto simp add: derivative_def)
  }
  thus ?thesis using assms
    by(fastforce simp add: simulation_def elim: parCasesF parCasesB)+
qed
  
lemma parSym:
  fixes P    :: pi
  and   Q    :: pi
  and   Rel  :: "(pi \<times> pi) set"
  
  assumes Sym: "\<And>R S. (R \<parallel> S, S \<parallel> R) \<in> Rel"
  and     Res: "\<And>R S x. (R, S) \<in> Rel \<Longrightarrow> (<\<nu>x>R, <\<nu>x>S) \<in> Rel"
  
  shows "P \<parallel> Q \<leadsto>[Rel] Q \<parallel> P"
proof(induct rule: simCases)
  case(Bound a x QP)
  proof(induct rule: parCasesB)
    case(cPar1 Q')
    moreover have "derivative (P \<parallel> Q')  (Q' \<parallel> P) a x Rel"
      by(cases a, auto simp add: derivative_def intro: Sym)
    ultimately show ?case by blast
  next
    case(cPar2 P')
    moreover have "derivative (P' \<parallel> Q)  (Q \<parallel> P') a x Rel"
      by(cases a, auto simp add: derivative_def intro: Sym)
    ultimately show ?case by blast
  qed
next
  case(Free \<alpha> QP)
  proof(induct rule: parCasesF[where C="()"])
    case(cPar1 Q')
    moreover have "(P \<parallel> Q', Q' \<parallel> P) \<in> Rel" by(rule Sym)
    ultimately show ?case by blast
  next
    case(cPar2 P')
    moreover have "(P' \<parallel> Q, Q \<parallel> P') \<in> Rel" by(rule Sym)
    ultimately show ?case by blast
  next
    case(cComm1 Q' P' a b x)
    have "P \<parallel> Q \<longmapsto> \<tau> \<prec> P' \<parallel> (Q'[x::=b])" by(rule Comm2)
    moreover have "(P' \<parallel> Q'[x::=b], Q'[x::=b] \<parallel> P') \<in> Rel" by(rule Sym)
    ultimately show ?case by blast
  next
    case(cComm2 Q' P' a b x)
    have "P \<parallel> Q \<longmapsto> \<tau> \<prec> (P'[x::=b]) \<parallel> Q'" by(rule Comm1)
    moreover have "(P'[x::=b] \<parallel> Q', Q' \<parallel> P'[x::=b]) \<in> Rel" by(rule Sym)
    ultimately show ?case by blast
  next
    case(cClose1 Q' P' a x y)
    have "P \<parallel> Q \<longmapsto> \<tau> \<prec> <\<nu>y>(P' \<parallel> (Q'[x::=y]))" by(rule Close2)
    moreover have "(<\<nu>y>(P' \<parallel> Q'[x::=y]), <\<nu>y>(Q'[x::=y] \<parallel> P')) \<in> Rel" by(metis Res Sym)
    ultimately show ?case by blast
  next
    case(cClose2 Q' P' a x y)
    have "P \<parallel> Q \<longmapsto> \<tau> \<prec> <\<nu>y>((P'[x::=y]) \<parallel> Q')" by(rule Close1)
    moreover have "(<\<nu>y>(P'[x::=y] \<parallel> Q'), <\<nu>y>(Q' \<parallel> P'[x::=y])) \<in> Rel" by(metis Res Sym)
    ultimately show ?case by blast
  qed
qed

lemma parAssocLeft:
  fixes P    :: pi
  and   Q    :: pi
  and   R    :: pi
  and   Rel  :: "(pi \<times> pi) set"

  assumes Ass:       "\<And>S T U. ((S \<parallel> T) \<parallel> U, S \<parallel> (T \<parallel> U)) \<in> Rel"
  and     Res:       "\<And>S T x. (S, T) \<in> Rel \<Longrightarrow> (<\<nu>x>S, <\<nu>x>T) \<in> Rel"
  and     FreshExt:  "\<And>S T U x. x \<sharp> S \<Longrightarrow> (<\<nu>x>((S \<parallel> T) \<parallel> U), S \<parallel> <\<nu>x>(T \<parallel> U)) \<in> Rel"
  and     FreshExt': "\<And>S T U x. x \<sharp> U \<Longrightarrow> ((<\<nu>x>(S \<parallel> T)) \<parallel> U, <\<nu>x>(S \<parallel> (T \<parallel> U))) \<in> Rel"

  shows "(P \<parallel> Q) \<parallel> R \<leadsto>[Rel] P \<parallel> (Q \<parallel> R)"
proof(induct rule: simCases)
  case(Bound a x PQR)
  hence "x \<sharp> (Q \<parallel> R)" by simp
  proof(induct rule: parCasesB)
    case(cPar1 P')
    moreover have "derivative ((P' \<parallel> Q) \<parallel> R) (P' \<parallel> (Q \<parallel> R)) a x Rel"
      by(cases a, auto intro: Ass simp add: derivative_def)
    ultimately show ?case by blast
  next
    case(cPar2 QR)
    proof(induct rule: parCasesB)
      case(cPar1 Q')
      moreover have "derivative ((P \<parallel> Q') \<parallel> R) (P \<parallel> (Q' \<parallel> R)) a x Rel"
        by(cases a, auto intro: Ass simp add: derivative_def)
      ultimately show ?case by blast
    next
      case(cPar2 R')
        by(rule_tac Par2B) auto
      moreover have "derivative ((P \<parallel> Q) \<parallel> R') (P \<parallel> (Q \<parallel> R')) a x Rel"
        by(cases a, auto intro: Ass simp add: derivative_def)
      ultimately show ?case by blast
    qed
  qed
next
  case(Free \<alpha> PQR)
  proof(induct rule: parCasesF[where C="Q"])
    case(cPar1 P')
    hence "(P \<parallel> Q) \<parallel> R \<longmapsto> \<alpha> \<prec> (P' \<parallel> Q) \<parallel> R" by(rule Par1F)
    moreover from Ass have "((P' \<parallel> Q) \<parallel> R, P' \<parallel> (Q \<parallel> R)) \<in> Rel" by blast
    ultimately show ?case by blast
  next
    case(cPar2 QR)
    proof(induct rule: parCasesF[where C="P"])
      case(cPar1 Q')
      hence "(P \<parallel> Q) \<parallel> R \<longmapsto> \<alpha> \<prec> (P \<parallel> Q') \<parallel> R" by(rule Par1F)
      moreover from Ass have "((P \<parallel> Q') \<parallel> R, P \<parallel> (Q' \<parallel> R)) \<in> Rel" by blast
      ultimately show ?case by blast
    next
      case(cPar2 R')
      moreover from Ass have "((P \<parallel> Q) \<parallel> R', P \<parallel> (Q \<parallel> R')) \<in> Rel" by blast
      ultimately show ?case by blast
    next
      case(cComm1 Q' R' a b x)
      moreover from Ass have "((P \<parallel> (Q'[x::=b])) \<parallel> R', P \<parallel> (Q'[x::=b] \<parallel> R')) \<in> Rel" by blast
      ultimately show ?case by blast
    next
      case(cComm2 Q' R' a b x)
        by(force intro: Comm2)
      moreover from Ass have "((P \<parallel> Q') \<parallel> R'[x::=b], P \<parallel> (Q' \<parallel> R'[x::=b])) \<in> Rel" by blast
      ultimately show ?case by blast
    next
      case(cClose1 Q' R' a x y)
        by(rule_tac Close1) auto
        by(rule FreshExt)
      ultimately show ?case by blast
    next
      case(cClose2 Q' R' a x y)
        by(rule FreshExt)
      ultimately show ?case by blast
    qed
  next
    case(cComm1 P' QR a b x)
    proof(induct rule: parCasesF[where C="()"])
      case(cPar1 Q')
      hence "(P \<parallel> Q) \<parallel> R \<longmapsto> \<tau> \<prec> (P'[x::=b] \<parallel> Q') \<parallel> R" by(rule Par1F)
      moreover from Ass have "((P'[x::=b] \<parallel> Q') \<parallel> R, P'[x::=b] \<parallel> (Q' \<parallel> R)) \<in> Rel" by blast
      ultimately show ?case by blast
    next
      case(cPar2 R')
      moreover from Ass have "((P'[x::=b] \<parallel> Q) \<parallel> R', P'[x::=b] \<parallel> (Q \<parallel> R')) \<in> Rel" by blast
      ultimately show ?case by blast
    next
      case(cComm1 Q' R')
    next
      case(cComm2 Q' R')
    next
      case(cClose1 Q' R')
    next
      case(cClose2 Q' R')
    qed
  next
    case(cComm2 P' QR a b x)
    proof(induct rule: parCasesB)
      case(cPar1 Q')
      hence "(P \<parallel> Q) \<parallel> R \<longmapsto> \<tau> \<prec> (P' \<parallel> Q'[x::=b]) \<parallel> R" by(rule Par1F)
      moreover from Ass have "((P' \<parallel> Q'[x::=b]) \<parallel> R, P' \<parallel> Q'[x::=b] \<parallel> R) \<in> Rel" by blast
      ultimately show ?case by blast
    next
      case(cPar2 R')
      moreover from Ass have "((P' \<parallel> Q) \<parallel> R'[x::=b], P' \<parallel> Q \<parallel> (R'[x::=b])) \<in> Rel" by blast
      ultimately show ?case by blast
    qed
  next
    case(cClose1 P' QR a x y)
    proof(induct rule: parCasesB)
      case(cPar1 Q')
      hence "(P \<parallel> Q) \<parallel> R \<longmapsto> \<tau> \<prec> (<\<nu>y>(P'[x::=y] \<parallel> Q')) \<parallel> R" by(rule Par1F)
        by(rule FreshExt')
      ultimately show ?case by blast
    next
      case(cPar2 R')
        by(rule_tac Close1) auto
      moreover have "(<\<nu>y>((P'[x::=y] \<parallel> Q) \<parallel> R'), <\<nu>y>(P'[x::=y] \<parallel> (Q \<parallel> R'))) \<in> Rel" by(metis Ass Res)
      ultimately show ?case by blast
    qed
  next
    case(cClose2 P' QR a x y)
    proof(induct rule: parCasesB)
      case(cPar1 Q')
        by(rule Close2)
      hence "(P \<parallel> Q) \<parallel> R \<longmapsto> \<tau> \<prec> (<\<nu>y>(P' \<parallel> Q'[x::=y])) \<parallel> R" by(rule Par1F)
        by(rule FreshExt')
        by(simp add: forget)
      ultimately show ?case by blast
    next
      case(cPar2 R')
      moreover have "((P' \<parallel> Q) \<parallel> R'[x::=y], P' \<parallel> (Q \<parallel> R'[x::=y])) \<in> Rel" by(rule Ass)
      hence "(<\<nu>y>((P' \<parallel> Q) \<parallel> R'[x::=y]), <\<nu>y>(P' \<parallel> (Q \<parallel> R'[x::=y]))) \<in> Rel" by(rule Res) 
        by(simp add: forget)
      ultimately show ?case by blast
    qed
  qed
qed

lemma substRes3:
  fixes a :: name
  and   P :: pi
  and   x :: name

  shows "(<\<nu>a>P)[x::=a] = <\<nu>x>([(x, a)] \<bullet> P)"
proof -
  have "a \<sharp> <\<nu>a>P" by(simp add: name_fresh_abs)
  hence "(<\<nu>a>P)[x::=a] = [(x, a)] \<bullet> <\<nu>a>P" by(rule injPermSubst[THEN sym])
  thus "(<\<nu>a>P)[x::=a] = <\<nu>x>([(x, a)] \<bullet> P)" by(simp add: name_calc)
qed

lemma scopeExtParLeft:
  fixes P   :: pi
  and   Q   :: pi
  and   a   :: name
  and   lst :: "name list"
  and   Rel :: "(pi \<times> pi) set"

  assumes "x \<sharp> P"
  and     Id:         "Id \<subseteq> Rel"
  and     EqvtRel:    "eqvt Rel"
  and     Res:        "\<And>R S y. y \<sharp> R \<Longrightarrow> (<\<nu>y>(R \<parallel> S), R \<parallel> <\<nu>y>S) \<in> Rel"
  and     ScopeExt:   "\<And>R S y z. y \<sharp> R \<Longrightarrow> (<\<nu>y><\<nu>z>(R \<parallel> S), <\<nu>z>(R \<parallel> <\<nu>y>S)) \<in> Rel"

  shows "<\<nu>x>(P \<parallel> Q) \<leadsto>[Rel] P \<parallel> <\<nu>x>Q"
proof(induct rule: simCasesCont[where C="(x, P, Q)"])
  case(Bound a y PxQ)
  hence "y \<sharp> P" and "y \<sharp> <\<nu>x>Q" by(simp add: abs_fresh)+
  proof(induct rule: parCasesB)
    case(cPar1 P')
      by(force intro: freshBoundDerivative)+

    moreover have "derivative (<\<nu>x>(P' \<parallel> Q)) (P' \<parallel> <\<nu>x>Q) a y Rel"
    proof(cases a, auto simp add: derivative_def)
      fix u

      show "((<\<nu>x>(P' \<parallel> Q))[y::=u],  P'[y::=u] \<parallel>  ((<\<nu>x>Q)[y::=u])) \<in> Rel"
      proof(cases "x=u")
        case True
        have "(<\<nu>x>(P' \<parallel> Q))[y::=x] = <\<nu>y>(([(y, x)] \<bullet> P') \<parallel> ([(y, x)] \<bullet> Q))"
          by(simp add: substRes3)
        moreover have "(<\<nu>x>Q)[y::=x] = <\<nu>y>([(y, x)] \<bullet> Q)" by(rule substRes3)
      next
        case False
          by(simp add: fresh_prod name_fresh)
          by(simp add: fresh_prod name_fresh)
        ultimately show ?thesis by(force intro: Res)
      qed
    next
    qed
    
    ultimately show ?case by blast
  next
    case(cPar2 xQ)
    proof(induct rule: resCasesB)
      case(cOpen a Q')

        by(subst alphaBoundResidual[where x'=x]) (auto simp add: fresh_left calc_atm)
        by(simp add: name_fresh_fresh)

      moreover have "derivative (P \<parallel> ([(x, y)] \<bullet> Q')) (P \<parallel> ([(y, x)] \<bullet> Q')) (BoundOutputS a) y Rel" using Id
        by(auto simp add: derivative_def name_swap)
         
      ultimately show ?case by blast
    next
      case(cRes Q')

        by(rule_tac ResB) auto
      moreover have "derivative (<\<nu>x>(P \<parallel> Q')) (P \<parallel> <\<nu>x>Q') a y Rel"
      proof(cases a, auto simp add: derivative_def)
        fix u
        show "((<\<nu>x>(P \<parallel> Q'))[y::=u],  P[y::=u] \<parallel>  (<\<nu>x>Q')[y::=u]) \<in> Rel"
        proof(cases "x=u")
          case True
            by(simp add: substRes3 perm_fresh_fresh)
          moreover have "(<\<nu>x>Q')[y::=x] = <\<nu>y>([(y, x)] \<bullet> Q')" by(rule substRes3)
        next
          case False
            by(simp add: fresh_prod name_fresh)
            by(simp add: fresh_prod name_fresh)
          ultimately show ?thesis by(force intro: Res)
        qed
      next
      qed
      ultimately show ?case by blast
    qed
  qed
next
  case(Free \<alpha> PxQ)
  proof(induct rule: parCasesF[where C="x"])
    case(cPar1 P')
    ultimately show ?case by blast
  next
    case(cPar2 Q')
    proof(induct rule: resCasesF)
      case(cRes Q')
      ultimately show ?case by blast
    qed
  next
    case(cComm1 P' xQ a b y)
    proof(induct rule: resCasesF)
      case(cRes Q')
      hence "<\<nu>x>(P \<parallel> Q) \<longmapsto> \<tau> \<prec> <\<nu>x>(P'[y::=b] \<parallel> Q')" by(rule_tac ResF) auto
      hence "(<\<nu>x>(P'[y::=b] \<parallel> Q'), P'[y::=b] \<parallel> <\<nu>x>Q') \<in> Rel" by(rule Res)
      ultimately show ?case by blast
    qed
  next
    case(cComm2 P' xQ a b y)
    proof(induct rule: resCasesB)
      case(cOpen b Q')
      thus ?case by simp
    next
      case(cRes Q')
      hence "<\<nu>x>(P \<parallel> Q) \<longmapsto> \<tau> \<prec> <\<nu>x>(P' \<parallel> Q'[y::=b])" by(rule_tac ResF) auto
      ultimately show ?case by blast
    qed
  next
    case(cClose1 P' Q' a y z)
    proof(induct rule: resCasesB)
      case(cOpen b Q')
        by(rule_tac transitions.eqvt) simp
        by(simp add: name_calc eqvts)
        by(rule Comm1)
      hence "<\<nu>z>(P \<parallel> ([(x, z)] \<bullet> Q)) \<longmapsto> \<tau> \<prec> <\<nu>z>(P'[y::=z] \<parallel> ([(z, x)] \<bullet> Q'))"
        by(rule_tac ResF) auto
        by(subst alphaRes[where c=z]) auto
      with Id show ?case by force
    next
      case(cRes Q')
        by(rule Close1)
      hence "<\<nu>x>(P \<parallel> Q) \<longmapsto> \<tau> \<prec> <\<nu>x><\<nu>z>(P'[y::=z] \<parallel> Q')" by(rule_tac ResF) auto
        by(force dest: freshBoundDerivative)
      hence "(<\<nu>x><\<nu>z>(P'[y::=z] \<parallel> Q'), <\<nu>z>(P'[y::=z] \<parallel> <\<nu>x>Q')) \<in> Rel"
        by(rule ScopeExt)
      ultimately show ?case by blast
    qed
  next
    case(cClose2 P' xQ a y z)
    proof(induct rule: resCasesB)
      case(cOpen b Q')
      thus ?case by simp
    next
      case(cRes Q')
        by(rule Close2)
      hence "<\<nu>x>(P \<parallel> Q) \<longmapsto> \<tau> \<prec> <\<nu>x><\<nu>z>(P' \<parallel> (Q'[y::=z]))"
        by(rule_tac ResF) auto
      hence "(<\<nu>x><\<nu>z>(P' \<parallel> (Q'[y::=z])), <\<nu>z>(P' \<parallel> (<\<nu>x>(Q'[y::=z])))) \<in> Rel"
        by(rule ScopeExt)
        by simp
      ultimately show ?case by blast
    qed
  qed
qed

lemma scopeExtParRight:
  fixes P   :: pi
  and   Q   :: pi
  and   a   :: name
  and   Rel :: "(pi \<times> pi) set"

  assumes "x \<sharp> P"
  and     Id:         "Id \<subseteq> Rel"
  and     "eqvt Rel"
  and     Res:        "\<And>R S y. y \<sharp> R \<Longrightarrow> (R \<parallel> <\<nu>y>S, <\<nu>y>(R \<parallel> S)) \<in> Rel"
  and     ScopeExt:   "\<And>R S y z. y \<sharp> R \<Longrightarrow> (<\<nu>z>(R \<parallel> <\<nu>y>S), <\<nu>y><\<nu>z>(R \<parallel> S)) \<in> Rel"

  shows "P \<parallel> <\<nu>x>Q \<leadsto>[Rel] <\<nu>x>(P \<parallel> Q)"
proof(induct rule: simCasesCont[where C="(x, P, Q)"])
  case(Bound a y xPQ)
  hence "y \<noteq> x" and "y \<sharp> P \<parallel> Q" by(auto simp add: abs_fresh)
  proof(induct rule: resCasesB)
    case(cOpen a PQ)
    proof(induct rule: parCasesF[where C="()"])
      case(cPar1 P')
      thus ?case by simp
    next
      case(cPar2 Q')
        by(subst alphaBoundResidual[where x'=x]) (auto simp add: fresh_left calc_atm)
      moreover with Id have "derivative ([(y, x)] \<bullet> (P \<parallel>  Q'))
                                        ([(y, x)] \<bullet> (P \<parallel> Q')) (BoundOutputS a) y Rel"
        by(auto simp add: derivative_def)
      ultimately show ?case by blast
    next
      case(cComm1 P' Q' b c y)
    next
      case(cComm2 P' Q' b c y)
    next
      case(cClose1 P' Q' b y z)
    next
      case(cClose2 P' Q' b y z)
    qed
  next
    case(cRes PQ)
    show ?case
    proof(induct rule: parCasesB)
      case(cPar1 P')
      
        by(rule_tac Par1B) (auto simp add: abs_fresh)
      moreover have "derivative (P' \<parallel> <\<nu>x>Q) (<\<nu>x>(P' \<parallel> Q)) a y Rel"
      proof(cases a, auto simp add: derivative_def)
        fix u::name
        obtain z::name where "z \<sharp> Q" and "y \<noteq> z" and "z \<noteq> u" and "z \<sharp> P" and "z \<sharp> P'"
          by(generate_fresh "name") auto
          by(subst alphaRes[where c=z and a=x], auto)
            (subst alphaRes[where c=z and a=x], auto intro: Res simp add: fresh_fact1)
      next
          by(rule Res)
      qed

      ultimately show ?case by blast
    next
      case(cPar2 Q')
        by(rule_tac ResB) auto
      
      moreover have "derivative (P \<parallel> <\<nu>x>Q') (<\<nu>x>(P \<parallel> Q')) a y Rel"
      proof(cases a, auto simp add: derivative_def)
        fix u::name
        obtain z::name where "z \<sharp> Q" and "z \<noteq> y" and "z \<noteq> u" and "z \<sharp> P" and "z \<sharp> Q'"
          by(generate_fresh "name") auto
        
          by(subst alphaRes[where a=x and c=z], auto)
            (subst alphaRes[where a=x and c=z], auto intro: Res simp add: fresh_fact1)
      next
          by(rule Res)
      qed
      
      ultimately show ?case by blast
    qed
  qed
next
  case(Free \<alpha> xPQ)
  proof(induct rule: resCasesF)
    case(cRes PQ)
    proof(induct rule: parCasesF[where C="x"])
      case(cPar1 P')
      hence "(P' \<parallel> <\<nu>x>Q, <\<nu>x>(P' \<parallel> Q)) \<in> Rel" by(rule Res)
      ultimately show ?case by blast
    next
      case(cPar2 Q')
      hence "P \<parallel> <\<nu>x>Q \<longmapsto>\<alpha> \<prec> P \<parallel> <\<nu>x>Q'" by(rule Par2F)
      ultimately show ?case by blast
    next
      case(cComm1 P' Q' a b y)
      show ?case
      proof(cases "b=x")
        case True
        moreover from Id have "(<\<nu>x>(P'[y::=b] \<parallel> Q'), <\<nu>x>(P'[y::=b] \<parallel> Q')) \<in> Rel" by blast
      next
        case False
          by(force intro: Res simp add: fresh_fact1)
        ultimately show ?thesis by blast
      qed
    next
      case(cComm2 P' Q' a b y)
    next
      case(cClose1 P' Q' a y z)
        by(rule_tac ScopeExt) (auto simp add: fresh_fact1)
      ultimately show ?case by blast
    next
      case(cClose2 P' Q' a y z)
        by(rule_tac Close2) (auto simp add: abs_fresh)
    qed
  qed
qed

lemma resNilRight:
  fixes x   :: name
  and   Rel :: "(pi \<times> pi) set"

  shows "\<zero> \<leadsto>[Rel] <\<nu>x>\<zero>"
by(fastforce simp add: simulation_def pi.inject alpha' elim: resCasesB' resCasesF)

lemma resComm:
  fixes a   :: name
  and   b   :: name
  and   P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes ResComm: "\<And>c d Q. (<\<nu>c><\<nu>d>Q, <\<nu>d><\<nu>c>Q) \<in> Rel"
  and     Id:      "Id \<subseteq> Rel"
  and     EqvtRel: "eqvt Rel"

  shows "<\<nu>a><\<nu>b>P \<leadsto>[Rel] <\<nu>b><\<nu>a>P"
proof(cases "a=b")
  assume "a=b"
  with Id show ?thesis by(force intro: Strong_Late_Sim.reflexive)
next
  assume aineqb: "a \<noteq> b"
  from EqvtRel show ?thesis
  proof(induct rule: simCasesCont[where C="(a, b, P)"])
    case(Bound c x baP)
    proof(induct rule: resCasesB)
      case(cOpen c aP)
      show ?case
      proof(induct rule: resCasesF)
        case(cRes P')
          by(rule_tac ResB) auto
        moreover from Id have "derivative (<\<nu>a>([(x, b)] \<bullet> P')) (<\<nu>a>([(x, b)] \<bullet> P')) (BoundOutputS c) x Rel"
          by(force simp add: derivative_def)
      qed
    next
      case(cRes aP)
      proof(induct rule: resCasesB)
        case(cOpen c P')
          apply(subst alphaBoundResidual[where x'=a]) by(auto simp add: abs_fresh fresh_left calc_atm)
        moreover have "derivative (<\<nu>b>([(x, a)] \<bullet> P')) (<\<nu>b>([(x, a)] \<bullet> P')) (BoundOutputS c) x Rel" using Id
          by(force simp add: derivative_def)
        ultimately show ?case by blast
      next
        case(cRes P')
        moreover have "derivative (<\<nu>a><\<nu>b>P') (<\<nu>b><\<nu>a>P') c x Rel"
        proof(cases c, auto simp add: derivative_def)
          fix u::name
          show  "((<\<nu>a><\<nu>b>P')[x::=u],  (<\<nu>b><\<nu>a>P')[x::=u]) \<in> Rel"
          proof(cases "u=a")
            case True
              by(subst injPermSubst[symmetric], auto simp add: abs_fresh)
                (subst injPermSubst[symmetric], auto simp add: abs_fresh calc_atm intro: ResComm)
          next
            case False
            show ?thesis
            proof(cases "u=b")
              case True
              by(subst injPermSubst[symmetric], auto simp add: abs_fresh)
                (subst injPermSubst[symmetric], auto simp add: abs_fresh calc_atm intro: ResComm)
            next
              case False
            qed
          qed
        next
          show "(<\<nu>a><\<nu>b>P', <\<nu>b><\<nu>a>P') \<in> Rel" by(rule ResComm)
        qed
        ultimately show ?case by blast
      qed
    qed
  next
    case(Free \<alpha> baP)
    proof(induct rule: resCasesF)
      case(cRes aP)
      proof(induct rule: resCasesF)
        case(cRes P')
        moreover have "(<\<nu>a><\<nu>b>P', <\<nu>b><\<nu>a>P') \<in> Rel" by(rule ResComm)
        ultimately show ?case by blast
      qed
    qed
  qed
qed


lemma bangLeftSC:
  fixes P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes "Id \<subseteq> Rel"

  shows "!P \<leadsto>[Rel] P \<parallel> !P"
using assms
by(force simp add: simulation_def dest: Bang derivativeReflexive)

lemma bangRightSC:
  fixes P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes IdRel: "Id \<subseteq> Rel"

  shows "P \<parallel> !P \<leadsto>[Rel] !P"
using assms
by(fastforce simp add: pi.inject simulation_def intro: derivativeReflexive elim: bangCases)

lemma resNilLeft:
  fixes x   :: name
  and   y   :: name
  and   P   :: pi
  and   Rel :: "(pi \<times> pi) set"
  and   b   :: name

  shows "\<zero> \<leadsto>[Rel] <\<nu>x>(x<y>.P)"
  and   "\<zero> \<leadsto>[Rel] <\<nu>x>(x{b}.P)"
by(auto simp add: simulation_def)

lemma resInputLeft:
  fixes x :: name
  and   a :: name
  and   y :: name
  and   P :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes xineqa: "x \<noteq> a"
  and     xineqy: "x \<noteq> y"
  and     Eqvt: "eqvt Rel"
  and     Id: "Id \<subseteq> Rel"

  shows "<\<nu>x>a<y>.P \<leadsto>[Rel] a<y>.(<\<nu>x>P)"
using Eqvt
proof(induct rule: simCasesCont[where C="(x, y, a, P)"])
  case(Bound b z P')
  proof(induct rule: inputCases)
    case cInput
    have "a<y>.P \<longmapsto>a<y> \<prec> P" by(rule Input)
      by(subst alphaBoundResidual[where x'=y]) (auto simp add: abs_fresh fresh_left calc_atm)
    moreover from Id have "derivative ([(y, z)] \<bullet> <\<nu>x>P) ([(y, z)] \<bullet> <\<nu>x>P) (InputS a) z Rel" 
      by(rule derivativeReflexive)
    ultimately show ?case by blast
  qed
next
  case(Free \<alpha> P')
  thus ?case by simp
qed

lemma resInputRight:
  fixes a :: name
  and   y :: name
  and   x :: name
  and   P :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes xineqa: "x \<noteq> a"
  and     xineqy: "x \<noteq> y"
  and     Eqvt: "eqvt Rel"
  and     Id: "Id \<subseteq> Rel"

  shows "a<y>.(<\<nu>x>P) \<leadsto>[Rel] <\<nu>x>a<y>.P"
  using Eqvt
proof(induct rule: simCasesCont[where C="(x, y, a, P)"])
  case(Bound b z xP)
  proof(induct rule: resCasesB)
    case(cOpen b P')
    thus ?case by simp
  next
    case(cRes P')
    proof(induct rule: inputCases)
      case cInput
      have "a<y>.(<\<nu>x>P) \<longmapsto>a<y> \<prec> (<\<nu>x>P)" by(rule Input)
        by(subst alphaBoundResidual[where x'=y]) (auto simp add: abs_fresh calc_atm fresh_left)
      moreover from Id have "derivative (<\<nu>x>([(y, z)] \<bullet> P)) (<\<nu>x>([(y, z)] \<bullet> P)) (InputS a) z Rel"
        by(rule derivativeReflexive)
      ultimately show ?case by blast
    qed
  qed
next
  case(Free \<alpha> P')
  thus ?case by simp
qed

lemma resOutputLeft:
  fixes x   :: name
  and   a   :: name
  and   b   :: name
  and   P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes xineqa: "x \<noteq> a"
  and     xineqb: "x \<noteq> b"
  and     Id: "Id \<subseteq> Rel"

  shows "<\<nu>x>a{b}.P \<leadsto>[Rel] a{b}.(<\<nu>x>P)"
using assms
by(fastforce simp add: simulation_def elim: outputCases intro: Output ResF)

lemma resOutputRight:
  fixes x   :: name
  and   a   :: name
  and   b   :: name
  and   P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes xineqa: "x \<noteq> a"
  and     xineqb: "x \<noteq> b"
  and     Id: "Id \<subseteq> Rel"
  and     Eqvt: "eqvt Rel"

  shows "a{b}.(<\<nu>x>P) \<leadsto>[Rel] <\<nu>x>a{b}.P"
using assms
by(erule_tac simCasesCont[where C=x])
  (force simp add: abs_fresh elim: resCasesB resCasesF outputCases intro: ResF Output)+

lemma resTauLeft:
  fixes x   :: name
  and   P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes Id: "Id \<subseteq> Rel"

  shows "<\<nu>x>(\<tau>.(P)) \<leadsto>[Rel] \<tau>.(<\<nu>x>P)"
using assms
by(force simp add: simulation_def elim: tauCases resCasesF intro: Tau ResF)

lemma resTauRight: 
  fixes x   :: name
  and   P   :: pi
  and   Rel :: "(pi \<times> pi) set"

  assumes Id:   "Id \<subseteq> Rel"

  shows "\<tau>.(<\<nu>x>P) \<leadsto>[Rel] <\<nu>x>(\<tau>.(P))"
using assms
by(force simp add: simulation_def elim: tauCases resCasesF intro: Tau ResF)

end
