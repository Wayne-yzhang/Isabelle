theory Refine_Imp_Hol
  imports "Hoare_Triple"
            "HOL-Eisbach.Eisbach"
begin

    
  definition [code del]: "assert' P \<equiv> if P then ureturn () else raise ''assert''"

  lemma execute_assert'[execute_simps]: "execute (assert' P) h = (if P then Some ((),h,0) else None)"
    by (auto simp: assert'_def execute_simps)

  
  lemma assert'_rule: "\<lbrakk>\<And>h. h\<Turnstile>P \<Longrightarrow> \<phi>\<rbrakk> \<Longrightarrow> <P> assert' \<phi> <\<lambda>_. P>"  
    apply rule
    apply (auto simp: execute_simps in_range.simps relH_refl)
    done
    
  lemma assert'_bind_rule: 
    assumes "\<And>h. h\<Turnstile>P \<Longrightarrow> \<phi>"
    assumes "\<phi> \<Longrightarrow> <P> c <Q>"
    shows "<P> do {assert' \<phi>; c} <Q>"  
    apply rule
    using assms
    apply (auto simp: execute_simps in_range.simps relH_refl elim!: hoare_tripleE)
    done    
    
    correctness proof (proving the assertions) to the refinement proof (assuming the assertions).
  \<close>
  subsubsection \<open>Admissibility\<close>
  subsection \<open>Syntactic rules for \<^const>\<open>refines\<close>\<close>  
subsection \<open>Automation\<close>    
  method refines_step= determ\<open>rule refines_rule refl refines_refl refines_let_right refines_case_prod_right 
                               | assumption | simp only:\<close>
