theory Implicational_Logic_Appendix imports Main begin

datatype form =




  by (induct p rule: Ax.induct) simp_all

  using MP 01 01 .

  using MP 04 04 .

  using MP 04 01 .

  using MP 05 06 .

  using MP 01 03 .

  using MP 09 06 .

  using MP MP 10 02 02 .

  using MP 09 11 .

  using MP 07 12 .

  using MP 01 13 .

  using MP 14 02 .

  using MP 09 02 .

  using MP 09 15 .

  using MP MP 05 17 03 .

  using MP 01 18 .

  using MP 19 15 .

  using MP 05 20 .

  using MP 21 01 .

  using MP 01 21 .

  using MP MP 23 15 03 .

  using MP 21 06 .

  using MP 25 24 .

  using MP 01 26 .

  using MP 28 26 .

  using MP 07 29 .

  using MP 21 31 .

  using MP 32 18 .

  using MP 21 33 .

  using MP 34 22 .

  using MP 21 03 .

lemmas
  Tran = 01 and
  Clavius = 02 and
  Expl = 03 and
  Frege' = 05 and
  Clavius' = 15 and
  Id = 16 and
  Simp = 18 and
  Swap = 21 and
  Tran' = 22 and
  Peirce = 24 and
  Frege = 35 and
  Expl' = 36

  using MP Clavius' Expl' Frege' Swap by meson

  using MP Tran MP Swap Expl .

  using MP Peirce Tran Tran' by meson

  using MP Tran MP Tran Simp .

  using MP Swap Tran by meson


primrec pros where

  by (induct p) simp_all


  by (induct ps) simp_all


proof -
  then show ?thesis
    by simp
qed

  by (induct ps) (use MP Frege Simp imply.simps in metis)+

  by (induct ps) (use imply_Cons imply_head in auto)

proof (induct ps)
  case (Cons r ps)
    using MP Frege Simp by meson
  then show ?case
    by simp
qed (auto intro: Id)

  using MP imply_MP by metis

  by (induct qs arbitrary: ps) (simp, metis MP' imply_append imply_Cons imply_head imply.simps(2))

  using imply_append imply_swap_append imply.simps by metis

proof -
  note MP
    using imply_head by simp
  ultimately show ?thesis .
qed

  by (induct ps arbitrary: p) (simp, metis MP' imply_deduct imply_mem insert_subset list.set(2))



  using imply_weaken by (metis (no_types, lifting) image_mono set_map)

proof (induct p)
  case (Neg q)
    by blast
  then show ?case
  proof cases
    case 1
      using Neg by simp
      using MP' Neg1 add_imply by blast
    with 1 show ?thesis
      by simp
  next
    case 2
      using Neg by simp
      using MP' Neg2 add_imply by blast
    with 2 show ?thesis
      by simp
  qed
next
  case (Imp q r)
    by blast
  then show ?case
  proof cases
    case 1
      using Imp1 MP' add_imply by blast
    with 1 show ?thesis
      by simp
  next
    case 2
      using Imp2 MP' add_imply by blast
    with 2 show ?thesis
      by simp
  next
    case 3
      using Imp3 MP' add_imply by blast
    with 3 show ?thesis
      by simp
  qed
qed (auto intro: Id)

proof -
    using lifts_pros_lift[of I p p] by simp
  then show ?thesis
    using Id MP' add_imply by blast
qed

proof -
    by (induct l) blast+
  proof -
    proof
      fix I
        by blast+
        by simp
        by (simp_all cong: map_cong)
        using MP' imply_deduct by blast
        by blast
        by simp
    qed
  qed
    using lifts_pros distinct_pros by blast
  then show ?thesis
    by simp
qed

  using soundness completeness by blast



end
