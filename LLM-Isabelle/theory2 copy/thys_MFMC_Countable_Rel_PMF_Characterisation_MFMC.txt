theory Rel_PMF_Characterisation_MFMC
imports 
  MFMC_Bounded 
  MFMC_Unbounded
  "HOL-Library.Simps_Case_Conv"
begin


context begin

private datatype ('a, 'b) vertex = Source | Sink | Left 'a | Right 'b

private lemma inj_Left [simp]: "inj_on Left X"
by(simp add: inj_on_def)

private lemma inj_Right [simp]: "inj_on Right X"
by(simp add: inj_on_def)

context fixes p :: "'a pmf" and q :: "'b pmf" and R :: "'a \<Rightarrow> 'b \<Rightarrow> bool" begin

private inductive edge' :: "('a, 'b) vertex \<Rightarrow> ('a, 'b) vertex \<Rightarrow> bool" where
  "edge' Source (Left x)" if "x \<in> set_pmf p"
| "edge' (Left x) (Right y)" if "R x y" "x \<in> set_pmf p" "y \<in> set_pmf q"
| "edge' (Right y) Sink" if "y \<in> set_pmf q"

private inductive_simps edge'_simps [simp]:
  "edge' xv (Left x)"
  "edge' (Left x) (Right y)"
  "edge' (Right y) yv"
  "edge' Source (Right y)"
  "edge' Source Sink"
  "edge' xv Source"
  "edge' Sink yv"
  "edge' (Left x) Sink"

private inductive_cases edge'_SourceE [elim!]: "edge' Source yv"
private inductive_cases edge'_LeftE [elim!]: "edge' (Left x) yv"
private inductive_cases edge'_RightE [elim!]: "edge' xv (Right y)"
private inductive_cases edge'_SinkE [elim!]: "edge' xv Sink"

private function cap :: "('a, 'b) vertex flow" where
  "cap (xv, Left x) = (if xv = Source then ennreal (pmf p x) else 0)"
| "cap (Left x, Right y) = 
  (if R x y \<and> x \<in> set_pmf p \<and> y \<in> set_pmf q 
                    i.e., the network satisfies @{locale bounded_countable_network}.\<close>
proposition rel_pmf_measureI_unbounded: \<comment> \<open>Proof uses the unbounded max-flow min-cut theorem\<close>
proposition rel_pmf_measureI_bounded: \<comment> \<open>Proof uses the bounded max-flow min-cut theorem\<close>
\<comment> \<open>This fact has already been proven for the registration of @{typ "'a pmf"} as a BNF,
  comparison of formalisations.\<close>
