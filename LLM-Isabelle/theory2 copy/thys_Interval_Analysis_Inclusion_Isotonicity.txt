theory
  Inclusion_Isotonicity
imports
  "Interval_Utilities"
  "Affine_Functions"
  Interval_Division_Non_Zero
begin


                               (infix "(is'_interval'_extension'_of)" 50)
where 


lemma interval_extension_comp: 
  using assms unfolding is_interval_extension_of_def
  by simp 

  unfolding is_interval_extension_of_def  
  by (simp add: interval_eq_iff) 

  unfolding is_interval_extension_of_def  
  by (simp add: interval_eq_iff) 

definition 
where 

  unfolding is_interval_extension_of_def extend_natural_def
  by(auto simp add: mk_interval' interval_of_def)

  unfolding is_natural_interval_extension_of_def extend_natural_def
  by(auto simp add: mk_interval' interval_of_def)

lemma natural_interval_extension_implies_interval_extension:
  using assms unfolding is_natural_interval_extension_of_def is_interval_extension_of_def
  mk_interval_def interval_of_def
  by(auto split:if_splits)

lemma const_add_is_natural_interval_extensions: 
  unfolding is_natural_interval_extension_of_def mk_interval_def 
  by (simp add: add_mono_thms_linordered_semiring(1) antisym interval_eq_iff add_mono
           split:if_splits) 

lemma const_times_is_natural_interval_extensions:
  unfolding is_natural_interval_extension_of_def mk_interval_def 
  unfolding times_interval_def Let_def 
  by(simp add: interval_eq_iff Interval_inverse interval_of.rep_eq add_mono 
          split:if_splits)
 
  unfolding is_natural_interval_extension_of_def
  apply(auto simp add:mk_interval' interval_of_def split:if_splits)[1]
  by (metis bounds_of_interval_eq_lower_upper bounds_of_interval_inverse lower_le_upper) 

  unfolding is_natural_interval_extension_of_def
  apply(auto simp add:mk_interval' interval_of_def split:if_splits)[1]
  by (metis bounds_of_interval_eq_lower_upper bounds_of_interval_inverse lower_le_upper) 

lemma extend_natural_is_interval_extension: 
  unfolding extend_natural_def is_natural_interval_extension_of_def mk_interval'_def
  by (smt (z3) case_prod_conv mk_interval_def lower_bounds nle_le upper_bounds) 

lemma is_natural_interval_extension_implies_bounds: 
  shows
  by (smt (verit) assms interval_eqI is_natural_interval_extension_of_def less_eq_interval_def 
          lower_le_upper mk_interval_lower mk_interval_upper)

lemma interval_extension_lower:
  unfolding is_interval_extension_of_def by simp

lemma interval_extension_upper:
  unfolding is_interval_extension_of_def by simp

lemma is_interval_extension_eq_upper_and_lower:
  unfolding is_interval_extension_of_def
  by (simp add: interval_eq_iff) 

lemma interval_extension_lower_simp[simp]: 
  by (metis assms interval_extension_lower interval_of.abs_eq) 

lemma interval_extension_upper_simp[simp]: 
  by (metis assms interval_extension_upper interval_of.abs_eq) 


definition
  where

lemma real_affine_fun_is_inclusion_isotonicM: 
  using assms  
  unfolding inclusion_isotonic_def extend_natural_def Interval.less_eq_interval_def affine_fun_real_linfun
  by(auto, (metis lower_le_upper mult_le_cancel_left nle_le)+)

definition
  where

  unfolding inclusion_isotonic_on_def inclusion_isotonic_def
  by simp

  where

  where

  unfolding inclusion_isotonic_binary_on_def inclusion_isotonic_binary_def
  by simp




  unfolding inclusion_isotonicM_n_on_def inclusion_isotonicM_n_def
  by simp


locale inclusion_isotonicM =
  fixes  n :: nat 
  assumes inclusion_isotonicM :
begin 
end

locale inclusion_isotonicM_on =
     and n :: nat 
  assumes inclusion_isotonicM :
begin 
end

  unfolding inclusion_isotonicM_on_def inclusion_isotonicM_def
  by simp  

lemma inclusion_isotonic_conv:
  unfolding inclusion_isotonic_def inclusion_isotonicM_def
  by(auto simp add: le_interval_single split:list.split)

lemma inclusion_isotonicM_n_conv1:
  unfolding  inclusion_isotonicM_n_def inclusion_isotonicM_def le_interval_list_def 
  by(auto)

lemma inclusion_isotonicM_conv2:
  using assms unfolding inclusion_isotonicM_def 
  apply(simp split:if_splits, safe)
  apply(subst le_interval_single[symmetric])
  apply(subst le_interval_list_all)
  subgoal by blast 
  subgoal by blast 
  subgoal by(rule TrueI)
done 

lemma inclusion_isotonicM_n_on_conv1:
  unfolding  inclusion_isotonicM_n_on_def inclusion_isotonicM_on_def le_interval_list_def 
  by(auto)

lemma inclusion_isotonicM_on_conv2:
  using assms unfolding inclusion_isotonicM_on_def 
  apply(simp split:if_splits, safe)
  apply(subst le_interval_single[symmetric])
  apply(subst le_interval_list_all)
  subgoal by blast 
  subgoal by blast 
  subgoal by(rule TrueI)
done 

lemma inclusion_isotonic_binary_conv1: 
  unfolding inclusion_isotonic_binary_def inclusion_isotonicM_n_def le_interval_list_def
  by(auto simp add: le_interval_list_def split:list.split)

lemma inclusion_isotonic_binary_conv2: 
  apply(simp add: inclusion_isotonic_binary_conv1)
  apply(simp add: inclusion_isotonicM_n_conv1)
  unfolding inclusion_isotonicM_def 
  by(auto split:list.split)

lemma inclusion_isotonic_binary_on_conv1: 
  unfolding inclusion_isotonic_binary_on_def inclusion_isotonicM_n_on_def le_interval_list_def
  by(auto simp add: le_interval_list_def split:list.split)

lemma inclusion_isotonic_binary_on_conv2: 
  apply(simp add: inclusion_isotonic_binary_on_conv1)
  apply(simp add: inclusion_isotonicM_n_on_conv1)
  unfolding inclusion_isotonicM_on_def 
  by(auto split:list.split)



lemma inclusion_isotonicM_comp: 
  using assms unfolding inclusion_isotonicM_def 
  by(simp)

lemma inclusion_isotonicM_on_comp: 
  using assms  unfolding inclusion_isotonicM_on_def  o_def
  by(auto)

lemma inclusion_isotonic_comp: 
  using assms unfolding inclusion_isotonic_def 
  by(simp)

lemma inclusion_isotonic_on_comp: 
  using assms unfolding inclusion_isotonic_on_def 
  by(simp)



  by (simp add: inclusion_isotonic_def less_eq_interval_def)


  by (simp add: inclusion_isotonic_binary_def less_eq_interval_def add_mono) 


  by (simp add: inclusion_isotonic_binary_def less_eq_interval_def diff_mono) 


lemma inclusion_isotonicM_times[simp]: 
  unfolding inclusion_isotonic_binary_def using set_of_mul_inc interval_set_leq_eq 
  by metis 



unfolding inclusion_isotonicM_def by(simp)

  unfolding inclusion_isotonic_def le_interval_list_def 
  by(simp)

  unfolding inclusion_isotonicM_def le_interval_list_def 
  by(simp)

lemma inclusion_isotonicM_hd[simp]: 
unfolding inclusion_isotonicM_n_def le_interval_list_def 
proof(insert assms, induction n rule:nat_induct_non_zero)
  case 1
  then show ?case 
    by (auto, metis (no_types, lifting) Nil_eq_zip_iff case_prodD foldl_conj_set_True hd_zip insert_iff 
       length_0_conv list.map_disc_iff list.map_sel(1) list.set(2) list.set_sel(1) nat.distinct(1))
next
  case (Suc n)
  then show ?case
    by (auto, metis (no_types, lifting) Nil_eq_zip_iff Zero_not_Suc case_prodD foldl_conj_set_True hd_zip 
              insert_iff length_0_conv list.map_disc_iff list.map_sel(1) list.set(2) list.set_sel(1))
qed

lemma inclusion_isotonic_add_const1[simp]:
  unfolding inclusion_isotonic_def
  by (simp add: add_mono_thms_linordered_semiring(3) less_eq_interval_def) 
  
lemma inclusion_isotonicM_1_add_const2[simp]: 
  unfolding inclusion_isotonic_def
  by (simp add: add_mono_thms_linordered_semiring(2) less_eq_interval_def) 
 
lemma inclusion_isotonic_times_right[simp]: 
  unfolding inclusion_isotonic_def
  using times_interval_right by auto 

lemma inclusion_isotonic_times_left[simp]:
  unfolding inclusion_isotonic_def
  using times_interval_left by auto 

lemma map_inclusion_isotonicM:
  using assms map_set map_pair_set_left map_pair_set_right map_pair_set
  unfolding inclusion_isotonicM_def le_interval_list_def inclusion_isotonic_def 
  by(simp add: foldl_conj_set_True map_pair_f_all, blast)

lemma inclusion_isotonicM_fun_plus:
  using assms unfolding inclusion_isotonic_def
  by (simp add: add_mono_thms_linordered_semiring(1) less_eq_interval_def) 

lemma inclusion_isotonic_plus_const:
  using assms unfolding inclusion_isotonic_def
  by (simp add: add_mono_thms_linordered_semiring(1) less_eq_interval_def) 

lemma inclusion_isotonic_times_const_real:
  using inclusion_isotonic_comp  assms 
  unfolding inclusion_isotonic_def
  by (simp add: times_interval_right)  

lemma intervall_le_foldr: 
proof (induction rule:list_induct2)
  case Nil
  then show ?case 
    by (simp add: less_eq_interval_def)     
next
  case (Cons x xs y ys)
  then show ?case 
    unfolding le_interval_list_def
    by (simp, metis (no_types, lifting) assms foldl_conj_True inclusion_isotonic_binary_def 
        list_all_simps(1))
qed

lemma intervall_le_foldr_map: 
proof (induction rule:list_induct2)
  case Nil
  then show ?case 
    by (simp add: less_eq_interval_def)
next
  case (Cons x xs y ys)
  then show ?case 
    using assms unfolding inclusion_isotonicM_n_def le_interval_list_def
    by(simp add: foldl_conj_True inclusion_isotonic_def inclusion_isotonic_binary_def) 
qed

lemma intervall_le_foldr_e: 
proof (induction xs)
  case Nil
  then show ?case using assms by(simp)     
next
  case (Cons x)
  then show ?case
    using assms unfolding le_interval_list_def inclusion_isotonic_binary_def
    by (simp add: less_eq_interval_def) 
 qed

lemma foldr_inclusion_isotonicM_e:
  using assms 
  unfolding inclusion_isotonic_def
  by(simp add: intervall_le_foldr_e)

lemma foldr_inclusion_isotonicM:
  using assms 
  unfolding inclusion_isotonicM_n_def using  intervall_le_foldr
  by auto 

lemma foldr_inclusion_isotonicM_g:
  using assms(2)
  unfolding inclusion_isotonicM_n_def inclusion_isotonicM_def  
  by (metis assms(1) intervall_le_foldr le_interval_list_imp_length)

lemma foldr_map_inclusion_isotonicM_g:
  using intervall_le_foldr_map assms(3)
  unfolding inclusion_isotonicM_n_def  inclusion_isotonicM_def
  by (metis (no_types, lifting) assms(1) assms(2) intervall_le_foldr_map le_interval_list_imp_length) 

lemma foldl_inclusion_isotonicM:
  unfolding inclusion_isotonicM_n_def
  apply(subst foldl_conv_foldr)
  apply(subst foldl_conv_foldr)
  using assms foldr_inclusion_isotonicM[simplified inclusion_isotonicM_def]
        le_interval_list_rev length_rev
  unfolding inclusion_isotonicM_n_def inclusion_isotonic_binary_def
  by (metis)

lemma fold_inclusion_isotonicM:
  unfolding inclusion_isotonicM_n_def
  apply(subst foldl_conv_fold[symmetric])
  apply(subst foldl_conv_fold[symmetric])
  using assms foldl_inclusion_isotonicM[simplified inclusion_isotonicM_def]
  unfolding inclusion_isotonic_binary_def inclusion_isotonicM_n_def
  by (metis) 


  unfolding inclusion_isotonicM_def inclusion_isotonic_binary_def
  apply(safe,subst le_interval_list_all2, simp_all)
  using le_interval_list_imp le_interval_list_all 
  by (metis assms dual_order.refl inclusion_isotonic_binary_def less_eq_interval_def)

  unfolding inclusion_isotonicM_def inclusion_isotonic_binary_def
  apply(safe,subst le_interval_list_all2, simp_all)
  using le_interval_list_imp le_interval_list_all 
  by (metis assms dual_order.refl inclusion_isotonic_binary_def less_eq_interval_def)
                           

lemma map2_inclusion_isotonicM_right_g: 
  using assms unfolding inclusion_isotonic_binary_def
  apply(subst le_interval_list_all2, simp_all)
  using assms unfolding inclusion_isotonic_binary_def  
  by (metis dual_order.refl inclusion_isotonicM_def
            le_interval_list_imp less_eq_interval_def) 

lemma inclusion_isotonicM_map: 
  using assms by(subst le_interval_list_all2, simp_all)


lemma interval_extension_inclusion:
  using assms
  unfolding is_interval_extension_of_def 
  by (simp add: in_interval_to_interval interval_of_in_eq)

lemma interval_extension_subset_const:
  using assms
  unfolding is_interval_extension_of_def set_of_def by auto

lemma fundamental_theorem_of_interval_analysis:
proof
  fix X
  proof
    fix y
  qed
qed 

lemma interval_extension_bounds:
  assumes "inclusion_isotonic F"
  and "F is_interval_extension_of f"
  shows "(\<forall> x \<in> set_of X. lower (F X) \<le>  f x) \<or> (\<forall>x \<in> set_of X. f x \<le> lower (F X))"
  using assms 
  by (metis (no_types, lifting) in_bounds inclusion_isotonic_def interval_of_in_eq 
                                is_interval_extension_of_def) 

lemma inclusion_isotonic_extension_subset:
  assumes  "inclusion_isotonic F"  
  and "F is_interval_extension_of f"
  using assms interval_of_in_eq   
  unfolding inclusion_isotonic_def set_of_eq is_interval_extension_of_def 
  by (metis (mono_tags, lifting) image_subsetI) 

lemma inclusion_isotonic_extension_includes:
  assumes  "inclusion_isotonic F"  
  and "F is_interval_extension_of f"
  using assms inclusion_isotonic_extension_subset
  by blast  

lemma inclusion_isotonic_extension_lower_bound:
  assumes  "inclusion_isotonic F"  
  and "F is_interval_extension_of f"
  using assms inclusion_isotonic_extension_includes
  using in_bounds by blast 

lemma inclusion_isotonic_extension_upper_bound:
  assumes  "inclusion_isotonic F"  
  and "F is_interval_extension_of f"
  using assms inclusion_isotonic_extension_includes
  using in_bounds by blast 


lemma inclusion_isotonic_inf:
  assumes  "inclusion_isotonic F"  
  and "F is_interval_extension_of f"
  using inclusion_isotonic_extension_subset[of F f X, simplified assms]
  cInf_superset_mono[of "f ` set_of X"  "set_of (F X)"]
  by (simp add: bdd_below_set_of  inf_set_of)

lemma inclusion_isotonic_sup:
  assumes  "inclusion_isotonic F"  
  and "F is_interval_extension_of f"
  using inclusion_isotonic_extension_subset[of F f X, simplified assms]  
        cSup_subset_mono[of "f ` set_of X" "set_of (F X)"]
  by (simp add: bdd_above_set_of sup_set_of)

lemma lower_inf:
  assumes  "inclusion_isotonic F"  
  and "F is_interval_extension_of f"
  shows "Inf (f ` set_of X) \<le> f (lower X)"
  using cInf_superset_mono[of "{f (lower X)}" "f ` set_of X"]
  by (metis assms(1) assms(2) bdd_below_mono bdd_below_set_of bot.extremum 
                     cInf_singleton imageI insert_not_empty insert_subsetI 
                     fundamental_theorem_of_interval_analysis lower_in_interval) 
lemma upper_sup:
  assumes  "inclusion_isotonic F"  
  and "F is_interval_extension_of f"
  shows "f (upper X) \<le> Sup (f ` set_of X)"
  using cSup_subset_mono[of "{f (upper X)}" "f ` set_of X"]
  by (meson assms(1) assms(2) bdd_above_mono bdd_above_set_of cSup_upper 
            imageI fundamental_theorem_of_interval_analysis upper_in_interval) 
  
lemma lower_F_f:
  assumes  "inclusion_isotonic F"  
  and "F is_interval_extension_of f"
  shows "lower (F X) \<le> f (lower X)"
  by (simp add: assms(1) assms(2) inclusion_isotonic_extension_lower_bound) 
  
lemma upper_F_f:
  assumes  "inclusion_isotonic F"  
  and "F is_interval_extension_of f"
  shows "f (upper X) \<le> upper (F X)"
  by (simp add: assms(1) assms(2) inclusion_isotonic_extension_upper_bound)

lemma inclusion_isotonic_interval_extension_le:
  using inclusion_isotonic_extension_lower_bound[of F f, simplified assms, simplified]  
        inclusion_isotonic_extension_upper_bound[of F f, simplified assms, simplified]
        le_left_mono lower_in_interval upper_in_interval
  by(metis adjacent)



context interval_division_inverse
begin 
lemma inclusion_isotonic_on_inverse[simp]:
  using inverse_non_zero_def
  unfolding inclusion_isotonic_on_def less_eq_interval_def
  by (smt (z3) dual_order.trans in_bounds in_intervalI lower_le_upper mk_interval_lower 
      mk_interval_upper upper_leq_lower_div)

lemma inclusion_isotonic_on_division[simp]:
  using inclusion_isotonicM_times  divide_non_zero_def inclusion_isotonic_on_inverse
  unfolding  o_def inclusion_isotonic_binary_on_def
            inclusion_isotonic_on_def inclusion_isotonic_binary_def
  by metis 

end 

end 
