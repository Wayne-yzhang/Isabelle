theory Simplex
  imports
    Linear_Poly_Maps
    QDelta
    Rel_Chain
    Simplex_Algebra
    "HOL-Library.Multiset"
    "HOL-Library.RBT_Mapping"
    "HOL-Library.Code_Target_Numeral"
begin

demands that these constraints are satisfied.\<close>
text \<open>Indexed constraints are just pairs of indices and constraints. Indices will be used
  to identify constraints, e.g., to easily specify an unsatisfiable core by a list of indices.\<close>
text \<open>The operation @{const restrict_to} is used to select constraints for a given index set.\<close>
text \<open>The operation @{const flat} is used to drop indices from a set of indexed constraints.\<close>
text \<open>For the unsat-core predicate we only demand minimality in case that the indices are distinct.
  Otherwise, minimality does in general not hold. For instance, consider the input
  constraints $c_1: x < 0$, $c_2: x > 2$ and $c_2: x < 1$ where the index $c_2$ occurs twice.
  If the simplex-method first encounters constraint $c_1$, then it will detect that there is a conflict
  between $c_1$ and the first $c_2$-constraint. Consequently, the index-set $\{c_1,c_2\}$ will be returned,
  but this set is not minimal since $\{c_2\}$ is already unsatisfiable.\<close>
subsection \<open>Procedure Specification\<close>
text\<open>The specification for the satisfiability check procedure is given by:\<close>
  \<comment> \<open>Decide if the given list of constraints is satisfiable. Return either
     an unsat core, or a satisfying valuation.\<close>
    \<comment> \<open>If the status @{const Sat} is returned, then returned valuation
      satisfies all constraints.\<close>
    \<comment> \<open>If the status @{const Unsat} is returned, then constraints are
     unsatisfiable, i.e., an unsatisfiable core is returned.\<close>
text\<open>Note that the above specification requires returning a
valuation (defined as a HOL function), which is not efficiently
executable. In order to enable more efficient data structures for
representing valuations, a refinement of this specification is needed
for representing mappings can be easily plugged-in during code
given by: @{thm map2fun_def'[no_vars]}.\<close>
subsection \<open>Handling Strict Inequalities\<close>
text\<open>The first step of the procedure is removing all equalities and
strict inequalities. Equalities can be easily rewritten to non-strict
inequalities. Removing strict inequalities can be done by replacing
the list of constraints by a new one, formulated over an extension
\<in> {\<le>, \<ge>}\<close>. The non-strict constraints are represented by the type
\<open>'a ns_constraint\<close>, and their semantics is denoted by \<open>\<Turnstile>\<^sub>n\<^sub>s\<close> and \<open>\<Turnstile>\<^sub>n\<^sub>s\<^sub>s\<close>. The indexed variant is \<open>\<Turnstile>\<^sub>i\<^sub>n\<^sub>s\<^sub>s\<close>.\<close>
text\<open>Specification of reduction of constraints to non-strict form is given by:\<close>
  \<comment> \<open>Convert a constraint to an equisatisfiable non-strict constraint list.
      The conversion must work for arbitrary subsets of constraints -- selected by some index set I --
      in order to carry over unsat-cores and in order to support incremental simplex solving.\<close>
    \<comment> \<open>Convert the valuation that satisfies all non-strict constraints to the valuation that
   satisfies all initial constraints.\<close>
text\<open>After the transformation, the procedure is reduced to solving
function can be easily defined and it can be easily shown that this
\<close>
subsection \<open>Preprocessing\<close>
text\<open>The next step in the procedure rewrites a list of non-strict
constraints into an equisatisfiable form consisting of a list of
linear equations (called the \emph{tableau}) and of a list of
transformation is straightforward and introduces auxiliary variables
for linear polynomials occurring in the initial formula. For example,
b\<^sub>2, x\<^sub>2 \<ge> b\<^sub>3]\<close>.\<close>
text \<open>The condition that the rhss are non-zero is required to obtain minimal unsatisfiable cores.
To observe the problem with 0 as rhs, consider the tableau $x = 0$ in combination
with atom $(A: x \leq 0)$ where then $(B: x \geq 1)$ is asserted.
In this case, the unsat core would be computed as $\{A,B\}$, although already $\{B\}$ is unsatisfiable.\<close>
text\<open>Equations are of the form \<open>x = p\<close>, where \<open>x\<close> is
a variable and \<open>p\<close> is a polynomial, and are represented by the
type \<open>eq = var \<times> linear_poly\<close>. Semantics of equations is given
of equations, by the type \<open>tableau = eq list\<close>. Semantics for a
\<open>lvars\<close> and \<open>rvars\<close> return sets of variables appearing on
called \emph{non-basic} variables. A tableau \<open>t\<close> is
s\<close> will denote that all variables of \<open>\<T> s\<close> are explicitly
valuated in \<open>\<V> s\<close>.\<close>
text\<open>Assuming that the \<open>\<U>\<close> flag and the current valuation
\<open>\<V>\<close> in the final state determine the solution of a problem, the
\<open>assert_all\<close> function can be reduced to the \<open>assert_all_state\<close>
cheap to detect. Next, \<open>check\<close> performs the full simplex
algorithm. The \<open>assert\<close> function can be implemented as \<open>assert a s = check (assert_bound a s)\<close>. Note that it is also
\medskip Asserting an atom \<open>x \<bowtie> b\<close> begins with the function
\<open>assert_bound\<close>.  If the atom is subsumed by the current bounds,
then no changes are performed. Otherwise, bounds for \<open>x\<close> are
previous bounds for \<open>x\<close>, the @{term \<U>} flag is raised. If
\<open>x\<close> is not a lhs variable in the current tableau and if the
value for \<open>x\<close> in the current valuation violates the new bound
\<open>b\<close>, the value for \<open>x\<close> can be updated and set to
\<open>b\<close>, meanwhile updating the values for lhs variables of
