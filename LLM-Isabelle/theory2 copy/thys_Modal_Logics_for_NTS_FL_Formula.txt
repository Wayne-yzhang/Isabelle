theory FL_Formula
imports
  Nominal_Bounded_Set
  Nominal_Wellfounded
  Residual
  FL_Transition_System
begin




predicate or an action formula. So to simplify the representation of formula trees with effects, the
effect operator is merged into the predicate or action it precedes.\<close>
    tConj "('idx,'pred,'act,'eff) Tree set['idx]"  \<comment> \<open>potentially infinite sets of trees\<close>
text \<open>The (automatically generated) induction principle for trees allows us to prove that the
following relation over trees is well-founded. This will be useful for termination proofs when we
define functions by recursion over trees.\<close>
text \<open>We define a permutation operation on the type of trees.\<close>
    "p \<bullet> (tConj tset) = tConj (map_bset (permute p) tset)"  \<comment> \<open>neat trick to get around the fact that~@{term tset} is not of permutation type yet\<close>
text \<open>Now that the type of trees---and hence the type of (bounded) sets of trees---is a permutation
type, we can massage the definition of~@{term "p \<bullet> tConj tset"} into its more usual form.\<close>
text \<open>The relation~@{const Tree_wf} is equivariant.\<close>
text \<open>The definition of~@{const permute} for trees gives rise to the usual notion of support. The
following lemmas, one for each constructor, describe the support of trees.\<close>
subsection \<open>Trees modulo \texorpdfstring{$\alpha$}{alpha}-equivalence\<close>
text \<open>We generalize the notion of support, which considers whether a permuted element is
\emph{equal} to itself, to arbitrary endorelations. This is available as @{const supp_rel} in
Nominal Isabelle.\<close>
text \<open>Usually, the definition of $\alpha$-equivalence presupposes a notion of free variables.
However, the variables that are ``free'' in an infinitary conjunction are not necessarily those
that are free in one of the conjuncts. For instance, consider a conjunction over \emph{all} names.
Applying any permutation will yield the same conjunction, i.e., this conjunction has \emph{no} free
variables.

To obtain the correct notion of free variables for infinitary conjunctions, we initially defined
$\alpha$-equivalence and free variables via mutual recursion. In particular, we defined the free
variables of a conjunction as term @{term "fv_Tree (tConj tset) = supp_rel alpha_Tree (tConj tset)"}.

We then realized that it is not necessary to define the concept of ``free variables'' at all, but
the definition of $\alpha$-equivalence becomes much simpler (in particular, it is no longer mutually
recursive) if we directly use the support modulo $\alpha$-equivalence.\<close>
text \<open>The following lemmas and constructions are used to prove termination of our definition.\<close>
text \<open>Here it comes \ldots\<close>
\<comment> \<open>@{const alpha_Tree}\<close>
\<comment> \<open>the action may have binding names\<close>
\<comment> \<open>254 subgoals (!)\<close>
text \<open>We provide more descriptive case names for the automatically generated induction principle,
and specialize it to an induction rule for $\alpha$-equivalence.\<close>
text \<open>$\alpha$-equivalence is equivariant.\<close>
text \<open>@{const alpha_Tree} is an equivalence relation.\<close>
text \<open>$\alpha$-equivalent trees have the same support modulo $\alpha$-equivalence.\<close>
text \<open>@{const tAct} preserves $\alpha$-equivalence.\<close>
text \<open>The following lemmas describe the support modulo $\alpha$-equivalence.\<close>
text \<open>The support modulo $\alpha$-equivalence of~@{term "tAct \<alpha> t"} is not easily described:
when~@{term t} has infinite support (modulo $\alpha$-equivalence), the support (modulo
$\alpha$-equivalence) of~@{term "tAct \<alpha> t"} may still contain names in~@{term "bn \<alpha>"}. This
incongruity is avoided when~@{term t} has finite support modulo $\alpha$-equivalence.\<close>
text \<open>We define the type of (infinitely branching) trees quotiented by $\alpha$-equivalence.\<close>
text \<open>The permutation operation is lifted from trees.\<close>
text \<open>The abstraction function from trees to trees modulo $\alpha$-equivalence is equivariant. The
representation function is equivariant modulo $\alpha$-equivalence.\<close>
subsection \<open>Constructors for trees modulo \texorpdfstring{$\alpha$}{alpha}-equivalence\<close>
text \<open>The constructors are lifted from trees.\<close>
text \<open>The lifted constructors are equivariant.\<close>
text \<open>The lifted constructors are injective (except for~@{const Act\<^sub>\<alpha>}).\<close>
text \<open>The lifted constructors are free (except for~@{const Act\<^sub>\<alpha>}).\<close>
text \<open>The following lemmas describe the support of constructed trees modulo $\alpha$-equivalence.\<close>
subsection \<open>Induction over trees modulo \texorpdfstring{$\alpha$}{alpha}-equivalence\<close>
text \<open>There is no (obvious) strong induction principle for trees modulo $\alpha$-equivalence: since
their support may be infinite, we may not be able to rename bound variables without also renaming
free variables.\<close>
subsection \<open>Hereditarily finitely supported trees\<close>
text \<open>We cannot obtain the type of infinitary formulas simply as the sub-type of all trees (modulo
$\alpha$-equivalence) that are finitely supported: since an infinite set of trees may be finitely
supported even though its members are not (and thus, would not be formulas), the sub-type of
\emph{all} finitely supported trees does not validate the induction principle that we desire for
formulas.

Instead, we define \emph{hereditarily} finitely supported trees. We require that environments and
state predicates are finitely supported.\<close>
text \<open>@{const hereditarily_fs} is equivariant.\<close>
text \<open>@{const hereditarily_fs} is preserved under $\alpha$-renaming.\<close>
text \<open>Hereditarily finitely supported trees have finite support.\<close>
subsection \<open>Infinitary formulas\<close>
text \<open>Now, infinitary formulas are simply the sub-type of hereditarily finitely supported trees.\<close>
text \<open>We set up Isabelle's lifting infrastructure so that we can lift definitions from the type of
trees modulo $\alpha$-equivalence to the sub-type of formulas.\<close>
text \<open>Now we lift the permutation operation.\<close>
text \<open>The abstraction and representation functions for formulas are equivariant, and they preserve
support.\<close>
text \<open>Formulas are in fact finitely supported.\<close>
subsection \<open>Constructors for infinitary formulas\<close>
text \<open>We lift the constructors for trees (modulo $\alpha$-equivalence) to infinitary formulas.
Since~@{const Conj\<^sub>\<alpha>} does not necessarily yield a (hereditarily) finitely supported tree when
applied to a (potentially infinite) set of (hereditarily) finitely supported trees, we cannot use
Isabelle's {\bf lift\_definition} to define~@{term Conj}. Instead, theorems about terms of the
form~@{term "Conj xset"} will usually carry an assumption that~@{term xset} is finitely supported.\<close>
text \<open>The lifted constructors are equivariant (in the case of~@{const Conj}, on finitely supported
arguments).\<close>
text \<open>The following lemmas describe the support of constructed formulas.\<close>
text \<open>The lifted constructors are injective (partially for @{const Act}).\<close>
text \<open>Helpful lemmas for dealing with equalities involving~@{const Act}.\<close>
  moreover from \<open>?l\<close> obtain p where p: "supp x1 - bn \<alpha>1 = supp x2 - bn \<alpha>2 \<and> (supp x1 - bn \<alpha>1) \<sharp>* p \<and> p \<bullet> x1 = x2 \<and> supp \<alpha>1 - bn \<alpha>1 = supp \<alpha>2 - bn \<alpha>2 \<and> (supp \<alpha>1 - bn \<alpha>1) \<sharp>* p \<and> p \<bullet> \<alpha>1 = \<alpha>2"
text \<open>The lifted constructors are free (except for @{const Act}).\<close>
subsection \<open>\texorpdfstring{$F/L$}{F/L}-formulas\<close>
text \<open>The predicate~@{term is_FL_formula} will characterise exactly those formulas in a particular
set~$A^{F/L}$.\<close>
subsection \<open>Induction over infinitary formulas\<close>
subsection \<open>Strong induction over infinitary formulas\<close>
