theory
  Convergence
imports
  Util
begin
  
     causal dependencies between operations. It can be defined in terms of sending and receiving
     messages on a network.
     However, for now, we keep it abstract, our only restriction on the happens-before relation is
     that it must be a \emph{strict partial order},
     that is, it must be irreflexive and transitive, which implies that it is also antisymmetric.
     We describe the state of a node using an abstract type variable.
     To model state changes, we assume the existence of an \emph{interpretation} function \isa{interp}
     which lifts an operation into a \emph{state transformer}---a function that either maps
     an old state to a new state, or fails.\<close>
subsection\<open>Concurrent operations\<close>
text\<open>We say that two operations $x$ and $y$ are \emph{concurrent}, written
    $\isa{x} \mathbin{\isasymparallel} \isa{y}$, whenever one does not happen before the other:
    $\neg (\isa{x} \prec \isa{y})$ and $\neg (\isa{y} \prec \isa{x})$.\<close>
subsection\<open>Happens-before consistency\<close>
text\<open>The purpose of the happens-before relation is to require that some operations must be applied
     in a particular order, while allowing concurrent operations to be reordered with respect to each other.
     We assume that each node applies operations in some sequential order (a standard assumption
     for distributed algorithms), and so we can model the execution history of a node as a list of operations.\<close>
text\<open>As a result, whenever two operations $\isa{x}$ and $\isa{y}$ appear in a hb-consistent list,
     and $\isa{x}\prec\isa{y}$, then $\isa{x}$ must appear before $\isa{y}$ in the list.
     However, if $\isa{x}\mathbin{\isasymparallel}\isa{y}$, the operations can appear in the list
     in either order.\<close>
subsection\<open>Apply operations\<close>
text\<open>We can now define a function \isa{apply-operations} that composes an arbitrary list of operations
     into a state transformer. We first map \isa{interp} across the list to obtain a state transformer
     for each operation, and then collectively compose them using the Kleisli arrow composition combinator.\<close>
subsection\<open>Concurrent operations commute\<close>
text\<open>We say that two operations $\isa{x}$ and $\isa{y}$ \emph{commute} whenever
     $\langle\isa{x}\rangle \mathbin{\isasymrhd} \langle\isa{y}\rangle = \langle\isa{y}\rangle \mathbin{\isasymrhd} \langle\isa{x}\rangle$,
     i.e. when we can swap the order of the composition of their interpretations without changing
     the resulting state transformer. For our purposes, requiring that this property holds for
     \emph{all} pairs of operations is too strong. Rather, the commutation property is only required
     to hold for operations that are concurrent.\<close>
subsection\<open>Abstract convergence theorem\<close>
text\<open>We can now state and prove our main theorem, $\isa{convergence}$.
     This theorem states that two hb-consistent lists of distinct operations, which are permutations
     of each other and in which concurrent operations commute, have the same interpretation.\<close>
subsection\<open>Convergence and progress\<close>
text\<open>Besides convergence, another required property of SEC is \emph{progress}: if a valid operation
     was issued on one node, then applying that operation on other nodes must also succeed---that is,
     the execution must not become stuck in an error state.
     Although the type signature of the interpretation function allows operations to fail, we need to
     prove that in all $\isa{hb-consistent}$ network behaviours such failure never actually occurs.
     We capture the combined requirements in the $\isa{strong-eventual-consistency}$ locale,
     which extends $\isa{happens-before}$.\<close>
