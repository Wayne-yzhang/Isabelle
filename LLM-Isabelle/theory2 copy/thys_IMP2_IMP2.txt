theory IMP2
imports "automation/IMP2_VCG" "automation/IMP2_Specification"
begin


lemmas [deriv_unfolds] = Params_def Inline_def AssignIdx_retv_def ArrayCpy_retv_def


  
experiment begin

lemma upd_idxSame[named_ss vcg_bb]: "f(i:=a,i:=b) = f (i:=b)" by auto

lemmas [named_ss vcg_bb] = triv_forall_equality

declare [[eta_contract = false ]]  
program_spec (partial) p2
  assumes "n>0"  
  ensures "n=0"
    n=n-1; 
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    G1=n; G2=n; G3=n; n=G1; n=G2; n=G3;
    skip
  } }\<close>
  defines \<open>while (n>0) @variant \<open>n\<close> @invariant \<open>n\<ge>0\<close> { n=n-1 }\<close>
  defines \<open>while (n>0) @relation \<open>measure nat\<close> @variant \<open>n\<close> @invariant \<open>n\<ge>0\<close> { n=n-1 }\<close>
  defines \<open>
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope n = 0;
    scope {n = 0}; N=42
  \<close>
subsection \<open>More Regression Tests\<close>
  defines \<open>
    a = 1;
    c = 0;
    while (c<n) 
    {
      a=2*a;
      
      
      c=c+1
    }
  \<close>
  defines \<open>
    a = 1;
    c = 0;
    while (c<n) 
    {
      a=2*a; a=2*a; a=2*a; a=2*a;
      a=a / 2; a=a / 2; a=a / 2; a=a / 2; 
      
      a=2*a;
      c=c+1
    }
  \<close>
  defines \<open>
    a = 1;
    c = 0;
    while (c<n) 
    {
      a=2*a;
      
      {
      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;

      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;

      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;

      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;

      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;

      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;

      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;

      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;

      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;   a=2*a;    a=2*a;    a=2*a;   a=2*a;    a=2*a;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;
      a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;  a=a / 2; a=a / 2;  a=a / 2;
      skip
      };
      
      c=c+1
    }
  \<close>
      apply (all \<open>simp?\<close>)
  defines \<open>
    a = 1;
    c = 0;
    while (c<n) 
    {
      a=2*a;
      
      a=a+a; a=a+a; a=a+a; a = a/8;
      a=a+a; a=a+a; a=a+a; a = a/8;
      a=a+a; a=a+a; a=a+a; a = a/8;
      a=a+a; a = a/2;
      
      skip
      };
      
      c=c+1
    }
  \<close>
      apply (all \<open>simp?\<close>)
  defines \<open>
      a = 1;
      c = 0;
      while (c<n) 
      {
        a=2*a;
        c=c+1
      }
  \<close>
  ensures \<open>n = 2^(2^nat n\<^sub>0)\<close>
  defines \<open>
    n = exp_count_up(n);
    n = exp_count_up(n)
  \<close>
  defines \<open>
    r = a+b+c
  \<close>
  defines \<open>
    r1 = add3(a, b, b);
    r2 = add3(a, b, b);
    r = r1+r2
  \<close>
  defines \<open>
    c = a / b;
    d = a mod b
  \<close>
  defines \<open>
    (d,m) = divmod (a,b);
    r = d*b + m
  \<close>
  defines \<open>
      a = 1;
      c = 0;
      while (c<n) 
      {
        a=2*a;
        c=c+1
      }
      
  \<close>
  ensures \<open>n = 2^(2^nat n\<^sub>0)\<close>
  defines \<open>
    n = exp_count_up(n);
    n = exp_count_up(n)
  \<close>
text \<open>Deriving big-step semantics\<close>
  defines \<open>
    r = a+b+c
  \<close>
  defines \<open>
    r1 = add3(a, b, b);
    r2 = add3(a, b, b);
    r = r1+r2
  \<close>
  defines \<open>r = 42\<close>
  assumes \<open>a\<ge>0\<close>
  defines \<open>
    r1 = no_param();
    add3(a, a, r1);
    r2 = add3(a, r1, r1);
    r = r2
  \<close>
  procedure_spec add (a,b) returns r assumes True ensures "r=a\<^sub>0+b\<^sub>0" defines \<open>r = a + b\<close> by vcg_cs
  procedure_spec test (a) returns r assumes True ensures "r = a\<^sub>0" defines \<open>
    x1 = add(a,a);
    x2 = add(a,a);
    x3 = add (x1-x2, a);
    
    x1 = add(a,a);
    x2 = add(a,a);
    x3 = add (x1-x2, a);
  
    x1 = add(a,a);
    x2 = add(a,a);
    x3 = add (x1-x2, a);
  
    x1 = add(a,a);
    x2 = add(a,a);
    x3 = add (x1-x2, a);
  
    x1 = add(a,a);
    x2 = add(a,a);
    x3 = add (x1-x2, a);
  
    x1 = add(a,a);
    x2 = add(a,a);
    x3 = add (x1-x2, a);
  
    r = x3
  \<close>
  relation \<open>measure nat\<close>
    defines \<open>
      if (a==0) b=1
      else {
        b = rec foo (a-1);
        b = 2 * b
      }
    \<close>
    defines \<open>
      if (a==0) b=0
      else {
        b = rec even (a-1)
      }
    \<close>
    assumes \<open>a\<ge>0\<close>
    defines \<open>
      if (a==0) b=1
      else {
        b = rec odd (a-1)
      }
    \<close>
