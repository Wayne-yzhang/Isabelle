theory SeCaV imports Main begin






primrec semantics_term and semantics_list where

primrec semantics where


  by simp

  by simp


primrec new_term and new_list where

primrec new where

primrec news where

primrec inc_term and inc_list where

primrec sub_term and sub_list where

primrec sub where

primrec member where

primrec ext where


  by (induct z) simp_all

  by (induct z) simp_all




  using sequent_calculus.intros(1,3,13) ext.simps member.simps(2) by metis


lemmas Basic = sequent_calculus.intros(1)

lemmas AlphaDis = sequent_calculus.intros(2)
lemmas AlphaImp = sequent_calculus.intros(3)
lemmas AlphaCon = sequent_calculus.intros(4)

lemmas BetaCon = sequent_calculus.intros(5)
lemmas BetaImp = sequent_calculus.intros(6)
lemmas BetaDis = sequent_calculus.intros(7)

lemmas GammaExi = sequent_calculus.intros(8)
lemmas GammaUni = sequent_calculus.intros(9)

lemmas DeltaUni = sequent_calculus.intros(10)
lemmas DeltaExi = sequent_calculus.intros(11)

lemmas Neg = sequent_calculus.intros(12)

lemmas Ext = sequent_calculus.intros(13)


proof -
    using that by simp
    using that by simp
  with Basic show ?thesis
    by simp
qed






  by (induct ts) simp_all


  by (induct t) simp_all




  by (induct p) simp_all


  by (induct t) simp_all


  by (induct p) simp_all


lemma upd_lemma' [simp]:
  by (induct t and ts rule: paramst.induct paramsts.induct) auto

  by (induct p arbitrary: e) simp_all




  unfolding shift_def by simp

  unfolding shift_def by simp

  unfolding shift_def by simp

  unfolding shift_def by force

lemma subst_lemma' [simp]:
  by (induct t and ts rule: substt.induct substts.induct) simp_all

lemma lift_lemma [simp]:
  by (induct t and ts rule: liftt.induct liftts.induct) simp_all

lemma subst_lemma [iff]:
  by (induct a arbitrary: e i t) simp_all


  by (induct t and l rule: new_term.induct new_list.induct) simp_all

  by (induct p) simp_all

  by (induct z) simp_all

  by (induct t and l rule: inc_term.induct inc_list.induct) simp_all

  by (induct t and l rule: inc_term.induct inc_list.induct) simp_all

  by (induct p arbitrary: v s) simp_all


proof (induct arbitrary: f rule: sequent_calculus.induct)
  case (10 i p z)
  then show ?case
    case False
      using 10 by simp
    ultimately show ?thesis
      using 10 Ball_set insert_iff list.set(2) upd_lemma by metis
  qed simp
next
  case (11 i p z)
  then show ?case
    case False
      using 11 by simp
    ultimately show ?thesis
      using 11 Ball_set insert_iff list.set(2) upd_lemma by metis
  qed simp
qed force+

  using sound by force

  using sound by force

  using sound by force



end
