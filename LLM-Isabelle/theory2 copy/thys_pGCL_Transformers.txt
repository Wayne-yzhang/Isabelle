theory Transformers imports Expectations begin


type_synonym 's trans = "'s expect \<Rightarrow> 's expect"






definition
  le_trans :: "'s trans \<Rightarrow> 's trans \<Rightarrow> bool"
where
  "le_trans t u \<equiv> \<forall>P. sound P \<longrightarrow> t P \<le> u P"


definition
  le_utrans :: "'s trans \<Rightarrow> 's trans \<Rightarrow> bool"
where
  "le_utrans t u \<longleftrightarrow> (\<forall>P. unitary P \<longrightarrow> t P \<le> u P)"

lemma le_transI[intro]:
  "\<lbrakk> \<And>P. sound P \<Longrightarrow> t P \<le> u P \<rbrakk> \<Longrightarrow> le_trans t u"
  by(simp add:le_trans_def)

lemma le_utransI[intro]:
  "\<lbrakk> \<And>P. unitary P \<Longrightarrow> t P \<le> u P \<rbrakk> \<Longrightarrow> le_utrans t u"
  by(simp add:le_utrans_def)

lemma  le_transD[dest]:
  "\<lbrakk> le_trans t u; sound P \<rbrakk> \<Longrightarrow> t P \<le> u P"
  by(simp add:le_trans_def)
  
lemma le_utransD[dest]:
  "\<lbrakk> le_utrans t u; unitary P \<rbrakk> \<Longrightarrow> t P \<le> u P"
  by(simp add:le_utrans_def)

lemma le_trans_trans[trans]:
  "\<lbrakk> le_trans x y; le_trans y z \<rbrakk> \<Longrightarrow> le_trans x z"
  unfolding le_trans_def by(blast dest:order_trans)
  
lemma le_utrans_trans[trans]:
  "\<lbrakk> le_utrans x y; le_utrans y z \<rbrakk> \<Longrightarrow> le_utrans x z"
  unfolding le_utrans_def by(blast dest:order_trans)

lemma le_trans_refl[iff]:
  "le_trans x x"
  by(simp add:le_trans_def)
  
lemma le_utrans_refl[iff]:
  "le_utrans x x"
  by(simp add:le_utrans_def)
  
lemma le_trans_le_utrans[dest]:
  "le_trans t u \<Longrightarrow> le_utrans t u"
  unfolding le_trans_def le_utrans_def by(auto)

definition
  l_trans :: "'s trans \<Rightarrow> 's trans \<Rightarrow> bool"
where
  "l_trans t u \<longleftrightarrow> le_trans t u \<and> \<not> le_trans u t"


definition
  equiv_trans :: "'s trans \<Rightarrow> 's trans \<Rightarrow> bool"
where
  "equiv_trans t u \<longleftrightarrow> le_trans t u \<and> le_trans u t"

definition
  equiv_utrans :: "'s trans \<Rightarrow> 's trans \<Rightarrow> bool"
where
  "equiv_utrans t u \<longleftrightarrow> le_utrans t u \<and> le_utrans u t"

lemma equiv_transI[intro]:
  "\<lbrakk> \<And>P. sound P \<Longrightarrow> t P = u P \<rbrakk> \<Longrightarrow> equiv_trans t u"
  unfolding equiv_trans_def by(force)

lemma equiv_utransI[intro]:
  "\<lbrakk> \<And>P. sound P \<Longrightarrow> t P = u P \<rbrakk> \<Longrightarrow> equiv_utrans t u"
  unfolding equiv_utrans_def by(force)

lemma equiv_transD[dest]:
  "\<lbrakk> equiv_trans t u; sound P \<rbrakk> \<Longrightarrow> t P = u P"
  unfolding equiv_trans_def by(blast intro:antisym)

lemma equiv_utransD[dest]:
  "\<lbrakk> equiv_utrans t u; unitary P \<rbrakk> \<Longrightarrow> t P = u P"
  unfolding equiv_utrans_def by(blast intro:antisym)

lemma equiv_trans_refl[iff]:
  "equiv_trans t t"
  by(blast)

lemma equiv_utrans_refl[iff]:
  "equiv_utrans t t"
  by(blast)

lemma le_trans_antisym:
  "\<lbrakk> le_trans x y; le_trans y x \<rbrakk> \<Longrightarrow> equiv_trans x y"
  unfolding equiv_trans_def by(simp)

lemma le_utrans_antisym:
  "\<lbrakk> le_utrans x y; le_utrans y x \<rbrakk> \<Longrightarrow> equiv_utrans x y"
  unfolding equiv_utrans_def by(simp)

lemma equiv_trans_comm[ac_simps]:
  "equiv_trans t u \<longleftrightarrow> equiv_trans u t"
  unfolding equiv_trans_def by(blast)

lemma equiv_utrans_comm[ac_simps]:
  "equiv_utrans t u \<longleftrightarrow> equiv_utrans u t"
  unfolding equiv_utrans_def by(blast)

lemma equiv_imp_le[intro]:
  "equiv_trans t u \<Longrightarrow> le_trans t u"
  unfolding equiv_trans_def by(clarify)

lemma equivu_imp_le[intro]:
  "equiv_utrans t u \<Longrightarrow> le_utrans t u"
  unfolding equiv_utrans_def by(clarify)

lemma equiv_imp_le_alt:
  "equiv_trans t u \<Longrightarrow> le_trans u t"
  by(force simp:ac_simps)

lemma equiv_uimp_le_alt:
  "equiv_utrans t u \<Longrightarrow> le_utrans u t"
  by(force simp:ac_simps)

lemma le_trans_equiv_rsp[simp]:
  "equiv_trans t u \<Longrightarrow> le_trans t v \<longleftrightarrow> le_trans u v"
  unfolding equiv_trans_def by(blast intro:le_trans_trans)

lemma le_utrans_equiv_rsp[simp]:
  "equiv_utrans t u \<Longrightarrow> le_utrans t v \<longleftrightarrow> le_utrans u v"
  unfolding equiv_utrans_def by(blast intro:le_utrans_trans)

lemma equiv_trans_le_trans[trans]:
  "\<lbrakk> equiv_trans t u; le_trans u v \<rbrakk> \<Longrightarrow> le_trans t v"
  by(simp)

lemma equiv_utrans_le_utrans[trans]:
  "\<lbrakk> equiv_utrans t u; le_utrans u v \<rbrakk> \<Longrightarrow> le_utrans t v"
  by(simp)

lemma le_trans_equiv_rsp_right[simp]:
  "equiv_trans t u \<Longrightarrow> le_trans v t \<longleftrightarrow> le_trans v u"
  unfolding equiv_trans_def by(blast intro:le_trans_trans)

lemma le_utrans_equiv_rsp_right[simp]:
  "equiv_utrans t u \<Longrightarrow> le_utrans v t \<longleftrightarrow> le_utrans v u"
  unfolding equiv_utrans_def by(blast intro:le_utrans_trans)

lemma le_trans_equiv_trans[trans]:
  "\<lbrakk> le_trans t u; equiv_trans u v \<rbrakk> \<Longrightarrow> le_trans t v"
  by(simp)

lemma le_utrans_equiv_utrans[trans]:
  "\<lbrakk> le_utrans t u; equiv_utrans u v \<rbrakk> \<Longrightarrow> le_utrans t v"
  by(simp)

lemma equiv_trans_trans[trans]:
  assumes xy: "equiv_trans x y"
      and yz: "equiv_trans y z"
  shows "equiv_trans x z"
proof(rule le_trans_antisym)
  from xy have "le_trans x y" by(blast)
  also from yz have "le_trans y z" by(blast)
  finally show "le_trans x z" .
  from yz have "le_trans z y" by(force simp:ac_simps)
  also from xy have "le_trans y x" by(force simp:ac_simps)
  finally show "le_trans z x" .
qed

lemma equiv_utrans_trans[trans]:
  assumes xy: "equiv_utrans x y"
      and yz: "equiv_utrans y z"
  shows "equiv_utrans x z"
proof(rule le_utrans_antisym)
  from xy have "le_utrans x y" by(blast)
  also from yz have "le_utrans y z" by(blast)
  finally show "le_utrans x z" .
  from yz have "le_utrans z y" by(force simp:ac_simps)
  also from xy have "le_utrans y x" by(force simp:ac_simps)
  finally show "le_utrans z x" .
qed

lemma equiv_trans_equiv_utrans[dest]:
  "equiv_trans t u \<Longrightarrow> equiv_utrans t u"
  by(auto)



definition feasible :: "(('a \<Rightarrow> real) \<Rightarrow> ('a \<Rightarrow> real)) \<Rightarrow> bool"
where     "feasible t \<longleftrightarrow> (\<forall>P b. bounded_by b P \<and> nneg P \<longrightarrow>
                               bounded_by b (t P) \<and> nneg (t P))"


lemma feasibleI[intro]:
  "\<lbrakk> \<And>b P. \<lbrakk> bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> bounded_by b (t P);
     \<And>b P. \<lbrakk> bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> nneg (t P) \<rbrakk> \<Longrightarrow> feasible t"
  by(force simp:feasible_def)

lemma feasible_boundedD[dest]:
  "\<lbrakk> feasible t; bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> bounded_by b (t P)"
  by(simp add:feasible_def)

lemma feasible_nnegD[dest]:
  "\<lbrakk> feasible t; bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> nneg (t P)"
  by(simp add:feasible_def)

lemma feasible_sound[dest]:
  "\<lbrakk> feasible t; sound P \<rbrakk> \<Longrightarrow> sound (t P)"
  by(rule soundI, unfold sound_def, (blast)+)

lemma feasible_pr_0[simp]:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes ft: "feasible t"
  shows "t (\<lambda>x. 0) = (\<lambda>x. 0)"
proof(rule ext, rule antisym)
  fix s

  have "bounded_by 0 (\<lambda>_::'s. 0::real)" by(blast)
  with ft have "bounded_by 0 (t (\<lambda>_. 0))" by(blast)
  thus "t (\<lambda>_. 0) s \<le> 0" by(blast)

  have "nneg (\<lambda>_::'s. 0::real)" by(blast)
  with ft have "nneg (t (\<lambda>_. 0))" by(blast)
  thus "0 \<le> t (\<lambda>_. 0) s" by(blast)
qed

lemma feasible_id:
  "feasible (\<lambda>x. x)"
  unfolding feasible_def by(blast)

lemma feasible_bounded_by[dest]:
  "\<lbrakk> feasible t; sound P; bounded_by b P \<rbrakk> \<Longrightarrow> bounded_by b (t P)"
  by(auto)

lemma feasible_fixes_top:
  "feasible t \<Longrightarrow> t (\<lambda>s. 1) \<le> (\<lambda>s. (1::real))"
  by(drule bounded_byD2[OF feasible_bounded_by], auto)

lemma feasible_fixes_bot:
  assumes ft: "feasible t"
  shows "t (\<lambda>s. 0) = (\<lambda>s. 0)"
proof(rule antisym)
  have sb: "sound (\<lambda>s. 0)" by(auto)
  with ft show "(\<lambda>s. 0) \<le> t (\<lambda>s. 0)" by(auto)
  thm bound_of_const
  from sb have "bounded_by (bound_of (\<lambda>s. 0::real)) (\<lambda>s. 0)" by(auto)
  hence "bounded_by 0 (\<lambda>s. 0::real)" by(simp add:bound_of_const)
  with ft have "bounded_by 0 (t (\<lambda>s. 0))" by(auto)
  thus "t (\<lambda>s. 0) \<le> (\<lambda>s. 0)" by(auto)
qed

lemma feasible_unitaryD[dest]:
  assumes ft: "feasible t" and uP: "unitary P"
  shows "unitary (t P)"
proof(rule unitaryI)
  from uP have "sound P" by(auto)
  with ft show "sound (t P)" by(auto)
  from assms show "bounded_by 1 (t P)" by(auto)
qed


definition
  mono_trans :: "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "mono_trans t \<equiv> \<forall>P Q. (sound P \<and> sound Q \<and> P \<le> Q) \<longrightarrow> t P \<le> t Q"


lemma mono_transI[intro]:
  "\<lbrakk> \<And>P Q. \<lbrakk> sound P; sound Q; P \<le> Q \<rbrakk> \<Longrightarrow>  t P \<le> t Q \<rbrakk> \<Longrightarrow> mono_trans t"
  by(simp add:mono_trans_def)

lemma mono_transD[dest]:
  "\<lbrakk> mono_trans t; sound P; sound Q; P \<le> Q \<rbrakk> \<Longrightarrow> t P \<le> t Q"
  by(simp add:mono_trans_def)



definition
  scaling :: "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "scaling t \<equiv> \<forall>P c x. sound P \<and> 0 \<le> c \<longrightarrow> c * t P x = t (\<lambda>x. c * P x) x"


lemma scalingI[intro]:
  "\<lbrakk> \<And>P c x. \<lbrakk> sound P; 0 \<le> c \<rbrakk> \<Longrightarrow> c * t P x = t (\<lambda>x. c * P x) x \<rbrakk> \<Longrightarrow> scaling t"
  by(simp add:scaling_def)

lemma scalingD[dest]:
  "\<lbrakk> scaling t; sound P; 0 \<le> c \<rbrakk>  \<Longrightarrow> c * t P x = t (\<lambda>x. c * P x) x"
  by(simp add:scaling_def)

lemma right_scalingD:
  assumes st: "scaling t"
      and sP: "sound P"
      and nnc: "0 \<le> c"
  shows "t P s * c = t (\<lambda>s. P s * c) s"
proof -
  have "t P s * c = c * t P s" by(simp add:algebra_simps)
  also from assms have "... = t (\<lambda>s. c * P s) s" by(rule scalingD)
  also have "... = t (\<lambda>s. P s * c) s" by(simp add:algebra_simps)
  finally show ?thesis .
qed



definition
  healthy :: "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "healthy t \<longleftrightarrow> feasible t \<and> mono_trans t \<and> scaling t"

lemma healthyI[intro]:
  "\<lbrakk> feasible t; mono_trans t; scaling t \<rbrakk> \<Longrightarrow> healthy t"
  by(simp add:healthy_def)

lemmas healthy_parts = healthyI[OF feasibleI mono_transI scalingI]

lemma healthy_monoD[dest]:
  "healthy t \<Longrightarrow> mono_trans t"
  by(simp add:healthy_def)

lemmas healthy_monoD2 = mono_transD[OF healthy_monoD]

lemma healthy_feasibleD[dest]:
  "healthy t \<Longrightarrow> feasible t"
  by(simp add:healthy_def)

lemma healthy_scalingD[dest]:
  "healthy t \<Longrightarrow> scaling t"
  by(simp add:healthy_def)

lemma healthy_bounded_byD[intro]:
  "\<lbrakk> healthy t; bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> bounded_by b (t P)"
   by(blast)

lemma healthy_bounded_byD2:
  "\<lbrakk> healthy t; bounded_by b P; sound P \<rbrakk> \<Longrightarrow> bounded_by b (t P)"
  by(blast)

lemma healthy_boundedD[dest,simp]:
  "\<lbrakk> healthy t; sound P \<rbrakk> \<Longrightarrow> bounded (t P)"
  by(blast)

lemma healthy_nnegD[dest,simp]:
  "\<lbrakk> healthy t; sound P \<rbrakk> \<Longrightarrow> nneg (t P)"
  by(blast intro!:feasible_nnegD)

lemma healthy_nnegD2[dest,simp]:
  "\<lbrakk> healthy t; bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> nneg (t P)"
  by(blast)

lemma healthy_sound[intro]:
  "\<lbrakk> healthy t; sound P \<rbrakk> \<Longrightarrow> sound (t P)"
  by(rule soundI, blast, blast intro:feasible_nnegD)

lemma healthy_unitary[intro]:
  "\<lbrakk> healthy t; unitary P \<rbrakk> \<Longrightarrow> unitary (t P)"
  by(blast intro!:unitaryI dest:unitary_bound healthy_bounded_byD)

lemma healthy_id[simp,intro!]:
  "healthy id"
  by(simp add:healthyI feasibleI mono_transI scalingI)

lemmas healthy_fixes_bot = feasible_fixes_bot[OF healthy_feasibleD]


lemma le_trans_bot[intro,simp]:
  "healthy t \<Longrightarrow> le_trans (\<lambda>P s. 0) t"
  by(blast intro:le_funI)

lemma le_trans_top[intro,simp]:
  "healthy t \<Longrightarrow> le_trans t (\<lambda>P s. bound_of P)"
  by(blast intro!:le_transI[OF le_funI])

lemma healthy_pr_bot[simp]:
  "healthy t \<Longrightarrow> t (\<lambda>s. 0) = (\<lambda>s. 0)"
  by(blast intro:feasible_pr_0)


lemma healthy_equivI:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real" and u
  assumes equiv:   "equiv_trans t u"
      and healthy: "healthy t"
  shows "healthy u"
proof
  have le_t_u: "le_trans t u" by(blast intro:equiv)
  have le_u_t: "le_trans u t" by(simp add:equiv_imp_le ac_simps equiv)
  from equiv have eq_u_t: "equiv_trans u t" by(simp add:ac_simps)

  show "feasible u"
  proof
    fix b and P::"'s \<Rightarrow> real"
    assume bP: "bounded_by b P" and nP: "nneg P"
    hence sP: "sound P" by(blast)
    with healthy have "\<And>s. 0 \<le> t P s" by(blast)
    also from sP and le_t_u have "\<And>s. ... s \<le> u P s" by(blast)
    finally show "nneg (u P)" by(blast)

    from sP and le_u_t have "\<And>s. u P s \<le> t P s" by(blast)
    also from healthy and sP and bP have "\<And>s. t P s \<le> b" by(blast)
    finally show "bounded_by b (u P)" by(blast)
  qed

  show "mono_trans u"
  proof
    fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real"
    assume sP: "sound P" and sQ: "sound Q"
       and le: "P \<tturnstile> Q"
    from sP and le_u_t have "u P \<tturnstile> t P" by(blast)
    also from sP and sQ and le and healthy have "t P \<tturnstile> t Q" by(blast)
    also from sQ and le_t_u have "t Q \<tturnstile> u Q" by(blast)
    finally show "u P \<tturnstile> u Q" .
  qed

  show "scaling u"
  proof
    fix P::"'s \<Rightarrow> real" and c::real and x::'s
    assume sound: "sound P"
       and pos:   "0 \<le> c"

    hence "bounded_by (c * bound_of P) (\<lambda>x. c * P x)"
      by(blast intro!:mult_left_mono dest!:less_imp_le)
    hence sc_bounded: "bounded (\<lambda>x. c * P x)"
      by(blast)
    moreover from sound and pos have sc_nneg: "nneg (\<lambda>x. c * P x)"
      by(blast intro:mult_nonneg_nonneg less_imp_le)
    ultimately have sc_sound: "sound (\<lambda>x. c * P x)" by(blast)
        
    show "c * u P x = u (\<lambda>x. c * P x) x"
    proof -
      from sound have "c * u P x = c * t P x"
        by(simp add:equiv_transD[OF eq_u_t])

      also have "... = t (\<lambda>x. c * P x) x"
        using healthy and sound and pos
        by(blast intro: scalingD)

      also from sc_sound and equiv have "... = u (\<lambda>x. c * P x) x"
        by(blast intro:fun_cong)

      finally show ?thesis .
    qed
  qed
qed

lemma healthy_equiv:
  "equiv_trans t u \<Longrightarrow> healthy t \<longleftrightarrow> healthy u"
  by(rule iffI, rule healthy_equivI, assumption+,
     simp add:healthy_equivI ac_simps)

lemma healthy_scale:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes ht: "healthy t" and nc: "0 \<le> c" and bc: "c \<le> 1"
  shows "healthy (\<lambda>P s. c * t P s)"
proof
  show "feasible (\<lambda>P s. c * t P s)"
  proof
    fix b and P::"'s \<Rightarrow> real"
    assume nnP: "nneg P" and bP: "bounded_by b P"

    from ht nnP bP have "\<And>s. t P s \<le> b" by(blast)
    with nc have "\<And>s. c * t P s \<le> c * b" by(blast intro:mult_left_mono)
    also {
      from nnP and bP have "0 \<le> b" by(auto)
      with bc have "c * b \<le> 1 * b" by(blast intro:mult_right_mono)
      hence "c * b \<le> b" by(simp)
    }
    finally show "bounded_by b (\<lambda>s. c * t P s)" by(blast)

    from ht nnP bP have "\<And>s. 0 \<le> t P s" by(blast)
    with nc have "\<And>s. 0 \<le> c * t P s" by(rule mult_nonneg_nonneg)
    thus "nneg (\<lambda>s. c * t P s)" by(blast)
  qed
  show "mono_trans (\<lambda>P s. c * t P s)"
  proof
    fix P::"'s \<Rightarrow> real" and Q
    assume sP: "sound P" and sQ: "sound Q" and le: "P \<tturnstile> Q"
    with ht have "\<And>s. t P s \<le> t Q s" by(auto intro:le_funD)
    with nc have "\<And>s. c * t P s \<le> c * t Q s"
      by(blast intro:mult_left_mono)
    thus "\<lambda>s. c * t P s \<tturnstile> \<lambda>s. c * t Q s" by(blast)
  qed
  from ht show "scaling (\<lambda>P s. c * t P s)"
    by(auto simp:scalingD healthy_scalingD ht)
qed

lemma healthy_top[iff]:
  "healthy (\<lambda>P s. bound_of P)"
  by(auto intro!:healthy_parts)

lemma healthy_bot[iff]:
  "healthy (\<lambda>P s. 0)"
  by(auto intro!:healthy_parts)


definition
  nearly_healthy :: "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "nearly_healthy t \<longleftrightarrow> (\<forall>P. unitary P \<longrightarrow> unitary (t P)) \<and>
                        (\<forall>P Q. unitary P \<longrightarrow> unitary Q \<longrightarrow> P \<tturnstile> Q \<longrightarrow> t P \<tturnstile> t Q)"

lemma nearly_healthyI[intro]:
  "\<lbrakk> \<And>P. unitary P \<Longrightarrow> unitary (t P);
     \<And>P Q. \<lbrakk> unitary P; unitary Q; P \<tturnstile> Q \<rbrakk> \<Longrightarrow> t P \<tturnstile> t Q \<rbrakk> \<Longrightarrow> nearly_healthy t"
  by(simp add:nearly_healthy_def)

lemma nearly_healthy_monoD[dest]:
  "\<lbrakk> nearly_healthy t; P \<tturnstile> Q; unitary P; unitary Q \<rbrakk> \<Longrightarrow> t P \<tturnstile> t Q"
  by(simp add:nearly_healthy_def)

lemma nearly_healthy_unitaryD[dest]:
  "\<lbrakk> nearly_healthy t; unitary P \<rbrakk> \<Longrightarrow> unitary (t P)"
  by(simp add:nearly_healthy_def)

lemma healthy_nearly_healthy[dest]:
  assumes ht: "healthy t"
  shows "nearly_healthy t"
  by(intro nearly_healthyI, auto intro:mono_transD[OF healthy_monoD, OF ht] ht)

lemmas nearly_healthy_id[iff] =
  healthy_nearly_healthy[OF healthy_id, unfolded id_def]



definition sublinear ::
  "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "sublinear t \<longleftrightarrow> (\<forall>a b c P Q s. (sound P \<and> sound Q \<and> 0 \<le> a \<and> 0 \<le> b \<and> 0 \<le> c) \<longrightarrow>
                  a * t P s + b * t Q s \<ominus> c
                  \<le> t (\<lambda>s'. a * P s' + b * Q s' \<ominus> c) s)"

lemma sublinearI[intro]:
  "\<lbrakk> \<And>a b c P Q s. \<lbrakk> sound P; sound Q; 0 \<le> a; 0 \<le> b; 0 \<le> c \<rbrakk> \<Longrightarrow>
     a * t P s + b * t Q s \<ominus> c \<le>
     t (\<lambda>s'. a * P s' + b * Q s' \<ominus> c) s \<rbrakk> \<Longrightarrow> sublinear t"
  by(simp add:sublinear_def)

lemma sublinearD[dest]:
  "\<lbrakk> sublinear t; sound P; sound Q; 0 \<le> a; 0 \<le> b; 0 \<le> c \<rbrakk> \<Longrightarrow>
   a * t P s + b * t Q s \<ominus> c \<le>
   t (\<lambda>s'. a * P s' + b * Q s' \<ominus> c) s"
  by(simp add:sublinear_def)



definition sub_add ::
  "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "sub_add t \<longleftrightarrow> (\<forall>P Q s. (sound P \<and> sound Q) \<longrightarrow>
                t P s + t Q s \<le> t (\<lambda>s'. P s' + Q s') s)"



lemma sub_addI[intro]:
  "\<lbrakk> \<And>P Q s. \<lbrakk> sound P; sound Q \<rbrakk> \<Longrightarrow>
             t P s + t Q s \<le> t (\<lambda>s'. P s' + Q s') s \<rbrakk> \<Longrightarrow> sub_add t"
  by(simp add:sub_add_def)

lemma sub_addI2:
  "\<lbrakk>\<And>P Q. \<lbrakk> sound P; sound Q \<rbrakk> \<Longrightarrow>
          \<lambda>s. t P s + t Q s \<tturnstile> t (\<lambda>s. P s + Q s)\<rbrakk> \<Longrightarrow>
   sub_add t"
  by(auto)

lemma sub_addD[dest]:
  "\<lbrakk> sub_add t; sound P; sound Q \<rbrakk> \<Longrightarrow> t P s + t Q s \<le> t (\<lambda>s'. P s' + Q s') s"
  by(simp add:sub_add_def)

lemma equiv_sub_add:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes eq: "equiv_trans t u"
      and sa: "sub_add t"
  shows "sub_add u"
proof
  fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::"'s"
  assume sP: "sound P" and sQ: "sound Q"

  with eq have "u P s + u Q s = t P s + t Q s"
    by(simp add:equiv_transD)
  also from sP sQ sa have "t P s + t Q s \<le> t (\<lambda>s. P s + Q s) s"
    by(auto)
  also {
    from sP sQ have "sound (\<lambda>s. P s + Q s)" by(auto)
    with eq have "t (\<lambda>s. P s + Q s) s = u (\<lambda>s. P s + Q s) s"
      by(simp add:equiv_transD)
  }
  finally show "u P s + u Q s \<le> u (\<lambda>s. P s + Q s) s" .
qed

lemma sublinear_subadd:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes slt: "sublinear t"
      and ft:  "feasible t"
  shows "sub_add t"
proof
  fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s
  assume sP: "sound P" and sQ: "sound Q"

  with ft have "sound (t P)" "sound (t Q)" by(auto)
  hence "0 \<le> t P s" and "0 \<le> t Q s" by(auto)
  hence "0 \<le> t P s + t Q s" by(auto)
  hence "... = ...\<ominus> 0" by(simp)

  also from sP sQ
  have "... \<le> t (\<lambda>s. P s + Q s \<ominus> 0) s"
    by(rule sublinearD[OF slt, where a=1 and b=1 and c=0, simplified])

  also {
    from sP sQ have "\<And>s. 0 \<le> P s" and "\<And>s. 0 \<le> Q s" by(auto)
    hence "\<And>s. 0 \<le> P s + Q s" by(auto)
    hence "t (\<lambda>s. P s + Q s \<ominus> 0) s = t (\<lambda>s. P s + Q s) s"
      by(simp)
  }

  finally show "t P s + t Q s \<le> t (\<lambda>s. P s + Q s) s" .
qed

lemma standard_negate:
  assumes ht: "healthy t"
      and sat: "sub_add t"
  shows "t \<guillemotleft>P\<guillemotright> s + t \<guillemotleft>\<N> P\<guillemotright> s \<le> 1"
proof -
  from sat have "t \<guillemotleft>P\<guillemotright> s + t \<guillemotleft>\<N> P\<guillemotright> s \<le> t (\<lambda>s. \<guillemotleft>P\<guillemotright> s + \<guillemotleft>\<N> P\<guillemotright> s) s" by(auto)
  also have "... = t (\<lambda>s. 1) s" by(simp add:negate_embed)
  also {
    from ht have "bounded_by 1 (t (\<lambda>s. 1))" by(auto)
    hence "t (\<lambda>s. 1) s \<le> 1" by(auto)
  }
  finally show ?thesis .
qed

lemma sub_add_sum:
  fixes t::"'s trans" and S::"'a set"
  assumes sat: "sub_add t"
      and ht: "healthy t"
      and sP: "\<And>x. sound (P x)"
  shows "(\<lambda>x. \<Sum>y\<in>S. t (P y) x) \<le> t (\<lambda>x. \<Sum>y\<in>S. P y x)"
proof(cases "infinite S", simp_all add:ht)
  assume fS: "finite S"
  show ?thesis
  proof(rule finite_induct[OF fS le_funI le_funI], simp_all)
    fix s::'s
    from ht have "sound (t (\<lambda>s. 0))" by(auto)
    thus "0 \<le> t (\<lambda>s. 0) s" by(auto)

    fix F::"'a set" and x::'a
    assume IH: "\<lambda>a. \<Sum>y\<in>F. t (P y) a \<tturnstile> t (\<lambda>x. \<Sum>y\<in>F. P y x)"
    hence "t (P x) s + (\<Sum>y\<in>F. t (P y) s) \<le>
           t (P x) s + t (\<lambda>x. \<Sum>y\<in>F. P y x) s"
      by(auto intro:add_left_mono)
    also from sat sP
    have "... \<le> t (\<lambda>xa. P x xa + (\<Sum>y\<in>F. P y xa)) s"
      by(auto intro!:sub_addD[OF sat] sum_sound)
    finally
    show "t (P x) s + (\<Sum>y\<in>F. t (P y) s) \<le>
          t (\<lambda>xa. P x xa + (\<Sum>y\<in>F. P y xa)) s" .
  qed
qed

lemma sub_add_guard_split:
  fixes t::"'s::finite trans" and P::"'s expect" and s::'s
  assumes sat: "sub_add t"
      and ht: "healthy t"
      and sP: "sound P"
  shows "(\<Sum>y\<in>{s. G s}.  P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) +
         (\<Sum>y\<in>{s. \<not>G s}. P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) \<le> t P s"
proof -
  have "{s. G s} \<inter> {s. \<not>G s} = {}" by(blast)
  hence "(\<Sum>y\<in>{s. G s}.  P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) +
         (\<Sum>y\<in>{s. \<not>G s}. P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) =
         (\<Sum>y\<in>({s. G s} \<union> {s. \<not>G s}). P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s)"
    by(auto intro: sum.union_disjoint[symmetric])
  also {
    have "{s. G s} \<union> {s. \<not>G s} = UNIV" by (blast)
    hence "(\<Sum>y\<in>({s. G s} \<union> {s. \<not>G s}). P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) =
           (\<lambda>x. \<Sum>y\<in>UNIV. P y * t (\<lambda>x. \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) s"
      by(simp)
  }
  also {
    from sP have "\<And>y. 0 \<le> P y" by(auto)
    with healthy_scalingD[OF ht]
    have "(\<lambda>x. \<Sum>y\<in>UNIV. P y * t (\<lambda>x. \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) s =
          (\<lambda>x. \<Sum>y\<in>UNIV. t (\<lambda>x. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) s"
      by(simp add:scalingD)
  }
  also {
    from sat ht sP
    have "(\<lambda>x. \<Sum>y\<in>UNIV. t (\<lambda>x. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) \<le>
          t (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"
      by(intro sub_add_sum sound_intros, auto)
    hence "(\<lambda>x. \<Sum>y\<in>UNIV. t (\<lambda>x. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) s \<le>
          t (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) s" by(auto)
  }
  also {
    have rw1: "(\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) =
               (\<lambda>x. \<Sum>y\<in>UNIV. if y = x then P y else 0)"
      by (rule ext [OF sum.cong]) auto
    also from sP have "... \<tturnstile> P"
      by(cases "finite (UNIV::'s set)", auto simp:sum.delta)
    finally have leP: "\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft> \<lambda>z. z = y \<guillemotright> x \<tturnstile> P" .
    moreover have "sound (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"
    proof(intro soundI2 bounded_byI nnegI sum_nonneg ballI)
      fix x
      from leP have "(\<Sum>y\<in>UNIV. P y * \<guillemotleft> \<lambda>z. z = y \<guillemotright> x) \<le> P x" by(auto)
      also from sP have "... \<le> bound_of P" by(auto)
      finally show "(\<Sum>y\<in>UNIV. P y * \<guillemotleft> \<lambda>z. z = y \<guillemotright> x) \<le> bound_of P" .
      fix y
      from sP show "0 \<le> P y * \<guillemotleft> \<lambda>z. z = y \<guillemotright> x"
        by(auto intro:mult_nonneg_nonneg)
    qed
    ultimately have "t (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) s \<le> t P s"
      using sP by(auto intro:le_funD[OF mono_transD, OF healthy_monoD, OF ht])
  }
  finally show ?thesis .
qed


definition sub_distrib ::
  "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "sub_distrib t \<longleftrightarrow> (\<forall>P s. sound P \<longrightarrow> t P s \<ominus> 1 \<le> t (\<lambda>s'. P s' \<ominus> 1) s)"

lemma sub_distribI[intro]:
  "\<lbrakk> \<And>P s. sound P \<Longrightarrow> t P s \<ominus> 1 \<le> t (\<lambda>s'. P s' \<ominus> 1) s \<rbrakk> \<Longrightarrow> sub_distrib t"
  by(simp add:sub_distrib_def)
  
lemma sub_distribI2:
  "\<lbrakk> \<And>P. sound P \<Longrightarrow> \<lambda>s. t P s \<ominus> 1 \<tturnstile> t (\<lambda>s. P s \<ominus> 1) \<rbrakk> \<Longrightarrow> sub_distrib t"
  by(auto)

lemma sub_distribD[dest]:
  "\<lbrakk> sub_distrib t; sound P \<rbrakk> \<Longrightarrow> t P s \<ominus> 1 \<le> t (\<lambda>s'. P s' \<ominus> 1) s"
  by(simp add:sub_distrib_def)

lemma equiv_sub_distrib:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes eq: "equiv_trans t u"
      and sd: "sub_distrib t"
  shows "sub_distrib u"
proof
  fix P::"'s \<Rightarrow> real" and s::"'s"
  assume sP: "sound P"

  with eq have "u P s \<ominus> 1 = t P s \<ominus> 1" by(simp add:equiv_transD)
  also from sP sd have "... \<le> t (\<lambda>s. P s \<ominus> 1) s" by(auto)
  also from sP eq have "... = u (\<lambda>s. P s \<ominus> 1) s"
    by(simp add:equiv_transD tminus_sound)
  finally show "u P s \<ominus> 1 \<le> u (\<lambda>s. P s \<ominus> 1) s" .
qed

lemma sublinear_sub_distrib:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes slt: "sublinear t"
  shows "sub_distrib t"
proof
  fix P::"'s \<Rightarrow> real" and s::'s
  assume sP: "sound P"
  moreover have "sound (\<lambda>_. 0)" by(auto)
  ultimately show "t P s \<ominus> 1 \<le> t (\<lambda>s. P s \<ominus> 1) s"
    by(rule sublinearD[OF slt, where a=1 and b=0 and c=1, simplified])
qed

lemma sd_sa_sublinear:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes sdt: "sub_distrib t" and sat: "sub_add t" and ht: "healthy t"
  shows "sublinear t"
proof
  fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s
  and a::real and b::real and c::real
  assume sP: "sound P" and sQ: "sound Q"
     and nna: "0 \<le> a" and nnb: "0 \<le> b" and nnc: "0 \<le> c"

  from ht sP sQ nna nnb
  have saP: "sound (\<lambda>s. a * P s)" and staP: "sound (\<lambda>s. a * t P s)"
   and sbQ: "sound (\<lambda>s. b * Q s)" and stbQ: "sound (\<lambda>s. b * t Q s)"
    by(auto intro:sc_sound)
  hence sabPQ:  "sound (\<lambda>s. a * P s + b * Q s)"
    and stabPQ: "sound (\<lambda>s. a * t P s + b * t Q s)"
    by(auto intro:sound_sum)

  from ht sP sQ nna nnb
  have "a * t P s + b * t Q s = t (\<lambda>s. a * P s) s + t (\<lambda>s. b * Q s) s"
    by(simp add:scalingD healthy_scalingD)
  also from saP sbQ sat
  have "t (\<lambda>s. a * P s) s + t (\<lambda>s. b * Q s) s \<le>
        t (\<lambda>s. a * P s + b * Q s) s" by(blast)
  finally
  have notm: "a * t P s + b * t Q s \<le> t (\<lambda>s. a * P s + b * Q s) s" .

  show "a * t P s + b * t Q s \<ominus> c \<le> t (\<lambda>s'. a * P s' + b * Q s' \<ominus> c) s"
  proof(cases "c = 0")
    case True note z = this
    from stabPQ have "\<And>s. 0 \<le> a * t P s + b * t Q s" by(auto)
    moreover from sabPQ
    have "\<And>s. 0 \<le> a * P s + b * Q s" by(auto)
    ultimately show ?thesis by(simp add:z notm)
  next
    case False note nz = this
    from nz and nnc have nni: "0 \<le> inverse c" by(auto)

    have "\<And>s. (inverse c * a) * P s + (inverse c * b) * Q s =
              inverse c * (a * P s + b * Q s)"
      by(simp add: divide_simps)
    with sabPQ and nni
    have si: "sound (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s)"
      by(auto intro:sc_sound)
    hence sim: "sound (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s \<ominus> 1)"
      by(auto intro!:tminus_sound)

    from nz
    have "a * t P s + b * t Q s \<ominus> c =
          (c * inverse c) * a * t P s +
          (c * inverse c) * b * t Q s \<ominus> c"
      by(simp)
    also
    have "... = c * (inverse c * a * t P s) +
                c * (inverse c * b * t Q s) \<ominus> c"
      by(simp add:field_simps)
    also from nnc
    have "... = c * (inverse c * a * t P s + inverse c * b * t Q s \<ominus> 1)"
      by(simp add:distrib_left tminus_left_distrib)
    also {
      have X: "\<And>s. (inverse c * a) * t P s + (inverse c * b) * t Q s =
                   inverse c * (a * t P s + b * t Q s)" by(simp add: divide_simps)
      also from nni and notm
      have "inverse c * (a * t P s + b * t Q s) \<le>
            inverse c * (t (\<lambda>s. a * P s + b * Q s) s)"
        by(blast intro:mult_left_mono)
      also from nni ht sabPQ
      have "... = t (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s) s"
        by(simp add:scalingD[OF healthy_scalingD, OF ht] algebra_simps)
      finally
      have "(inverse c * a) * t P s + (inverse c * b) * t Q s \<ominus> 1 \<le>
            t (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s) s \<ominus> 1"
        by(rule tminus_left_mono)
      also {
        from sdt si
        have "t (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s) s \<ominus> 1 \<le>
              t (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s \<ominus> 1) s"
          by(blast)
      }
      finally
      have "c * (inverse c * a * t P s + inverse c * b * t Q s \<ominus> 1) \<le>
            c * t (\<lambda>s. inverse c * a * P s + inverse c * b * Q s \<ominus> 1) s"
        using nnc by(blast intro:mult_left_mono)
    }
    also from nnc ht sim
    have "c * t (\<lambda>s. inverse c * a * P s + inverse c * b * Q s \<ominus> 1) s
          = t (\<lambda>s. c * (inverse c * a * P s + inverse c * b * Q s \<ominus> 1)) s"
      by(simp add:scalingD healthy_scalingD)
    also from nnc
    have "... = t (\<lambda>s. c * (inverse c * a * P s) +
                       c * (inverse c * b * Q s) \<ominus> c) s"
      by(simp add:distrib_left tminus_left_distrib)
    also have "... = t (\<lambda>s. (c * inverse c) * a * P s +
                            (c * inverse c) * b * Q s \<ominus> c) s"
      by(simp add:field_simps)
    finally
    show "a * t P s + b * t Q s \<ominus> c \<le> t (\<lambda>s'. a * P s' + b * Q s' \<ominus> c) s"
      using nz by(simp)
  qed
qed

definition
  sub_conj :: "(('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real) \<Rightarrow> bool"
where
  "sub_conj t \<equiv> \<forall>P Q. (sound P \<and> sound Q) \<longrightarrow>
                       t P && t Q \<tturnstile> t (P && Q)"

lemma sub_conjI[intro]:
  "\<lbrakk> \<And>P Q. \<lbrakk> sound P; sound Q \<rbrakk> \<Longrightarrow>
           t P && t Q \<tturnstile> t (P && Q) \<rbrakk> \<Longrightarrow> sub_conj t"
  unfolding sub_conj_def by(simp)

lemma sub_conjD[dest]:
  "\<lbrakk> sub_conj t; sound P; sound Q \<rbrakk> \<Longrightarrow> t P && t Q \<tturnstile> t (P && Q)"
  unfolding sub_conj_def by(simp)

lemma sub_conj_wp_twice:
  fixes f::"'s \<Rightarrow> (('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real)"
  assumes all: "\<forall>s. sub_conj (f s)"
  shows "sub_conj (\<lambda>P s. f s P s)"
proof(rule sub_conjI, rule le_funI)
  fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s
  assume sP: "sound P" and sQ: "sound Q"

  have "((\<lambda>s. f s P s) && (\<lambda>s. f s Q s)) s = (f s P && f s Q) s"
    by(simp add:exp_conj_def)
  also {
    from all have "sub_conj (f s)" by(blast)
    with sP and sQ have "(f s P && f s Q) s \<le> f s (P && Q) s"
      by(blast)
  }
  finally show "((\<lambda>s. f s P s) && (\<lambda>s. f s Q s)) s \<le> f s (P && Q) s" .
qed

lemma sublinear_sub_conj:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes slt: "sublinear t"
  shows "sub_conj t"
proof(rule sub_conjI, rule le_funI, unfold exp_conj_def pconj_def)
  fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real"and s::'s
  assume sP: "sound P" and sQ: "sound Q"
  thus "t P s + t Q s \<ominus> 1 \<le> t (\<lambda>s. P s + Q s \<ominus> 1) s"
    by(rule sublinearD[OF slt, where a=1 and b=1 and c=1, simplified])
qed


lemma equiv_sublinear:
  "\<lbrakk> equiv_trans t u; sublinear t; healthy t \<rbrakk> \<Longrightarrow> sublinear u"
  by(iprover intro:sd_sa_sublinear healthy_equivI
             dest:equiv_sub_distrib equiv_sub_add
                  sublinear_sub_distrib sublinear_subadd
                  healthy_feasibleD)



definition
  additive :: "(('a \<Rightarrow> real) \<Rightarrow> 'a \<Rightarrow> real) \<Rightarrow> bool"
where
  "additive t \<equiv> \<forall>P Q. (sound P \<and> sound Q) \<longrightarrow>
                      t (\<lambda>s. P s + Q s) = (\<lambda>s. t P s + t Q s)"

lemma additiveD:
  "\<lbrakk> additive t; sound P; sound Q \<rbrakk> \<Longrightarrow> t (\<lambda>s. P s + Q s) = (\<lambda>s. t P s + t Q s)"
  by(simp add:additive_def)

lemma additiveI[intro]:
  "\<lbrakk> \<And>P Q s. \<lbrakk> sound P; sound Q \<rbrakk> \<Longrightarrow> t (\<lambda>s. P s + Q s) s = t P s + t Q s \<rbrakk> \<Longrightarrow>
   additive t"
  unfolding additive_def by(blast)

lemma additive_sub_add:
  "additive t \<Longrightarrow> sub_add t"
  by(simp add:sub_addI additiveD)

lemma additive_sum:
  fixes S::"'s set"
  assumes additive: "additive t"
      and healthy:  "healthy t"
      and finite:   "finite S"
      and sPz:      "\<And>z. sound (P z)"
  shows "t (\<lambda>x. \<Sum>y\<in>S. P y x) = (\<lambda>x. \<Sum>y\<in>S. t (P y) x)"
proof(rule finite_induct, simp_all add:assms)
  fix z::'s and T::"'s set"
  assume finT: "finite T"
     and IH: "t (\<lambda>x. \<Sum>y\<in>T. P y x) = (\<lambda>x. \<Sum>y\<in>T. t (P y) x)"

  from additive sPz
  have "t (\<lambda>x. P z x + (\<Sum>y\<in>T. P y x)) =
        (\<lambda>x. t (P z) x +  t (\<lambda>x. \<Sum>y\<in>T. P y x) x)"
    by(auto intro!:sum_sound additiveD)
  also from IH
  have "... = (\<lambda>x. t (P z) x + (\<Sum>y\<in>T. t (P y) x))"
    by(simp)
  finally show "t (\<lambda>x. P z x + (\<Sum>y\<in>T. P y x)) =
                (\<lambda>x. t (P z) x + (\<Sum>y\<in>T. t (P y) x))" .
qed

lemma additive_delta_split:
  fixes t::"('s::finite \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes additive: "additive t"
      and ht: "healthy t"
      and sP: "sound P"
  shows "t P x = (\<Sum>y\<in>UNIV. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"
proof -
  have "\<And>x. (\<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) =
            (\<Sum>y\<in>UNIV. if y = x then P y else 0)"
    by (rule sum.cong) auto
  also have "\<And>x. ... x = P x"
    by(simp add:sum.delta)
  finally
  have "t P x = t (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x"
    by(simp)
  also {
    from sP have "\<And>z. sound (\<lambda>a. P z * \<guillemotleft> \<lambda>za. za = z \<guillemotright> a)"
      by(auto intro!:mult_sound)
    hence "t (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x =
           (\<Sum>y\<in>UNIV. t (\<lambda>x. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x)"
      by(subst additive_sum, simp_all add:assms)
  }
  also from sP
  have "(\<Sum>y\<in>UNIV. t (\<lambda>x. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) =
        (\<Sum>y\<in>UNIV. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"
    by(subst scalingD[OF healthy_scalingD, OF ht], auto)
  finally show "t P x = (\<Sum>y\<in>UNIV. P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> x)" .
qed

lemma additive_guard_split:
  fixes t::"('s::finite \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes additive: "additive t"
      and ht: "healthy t"
      and sP: "sound P"
  shows "t P x = (\<Sum>y\<in>{s.   G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) +
                 (\<Sum>y\<in>{s. \<not> G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"
proof -
  from assms
  have "t P x = (\<Sum>y\<in>UNIV. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"
    by(rule additive_delta_split)
  also {
    have "UNIV = {s. G s} \<union> {s. \<not> G s}"
      by(auto)
    hence "(\<Sum>y\<in>UNIV. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) =
           (\<Sum>y\<in>{s. G s} \<union> {s. \<not> G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"
      by(simp)
  }
  also
  have "(\<Sum>y\<in>{s. G s} \<union> {s. \<not> G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) =
        (\<Sum>y\<in>{s.   G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) +
        (\<Sum>y\<in>{s. \<not> G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"
    by(auto intro:sum.union_disjoint)
  finally show ?thesis .
qed

definition
  maximal :: "(('a \<Rightarrow> real) \<Rightarrow> 'a \<Rightarrow> real) \<Rightarrow> bool"
where
  "maximal t \<equiv> \<forall>c. 0 \<le> c \<longrightarrow> t (\<lambda>_. c) = (\<lambda>_. c)"

lemma maximalI[intro]:
  "\<lbrakk> \<And>c. 0 \<le> c \<Longrightarrow> t (\<lambda>_. c) = (\<lambda>_. c) \<rbrakk> \<Longrightarrow> maximal t"
  by(simp add:maximal_def)

lemma maximalD[dest]:
  "\<lbrakk> maximal t; 0 \<le> c \<rbrakk>  \<Longrightarrow> t (\<lambda>_. c) = (\<lambda>_. c)"
  by(simp add:maximal_def)

definition determ :: "(('a \<Rightarrow> real) \<Rightarrow> 'a \<Rightarrow> real) \<Rightarrow> bool"
where
  "determ t \<equiv> additive t \<and> maximal t"

lemma determI[intro]:
  "\<lbrakk> additive t; maximal t \<rbrakk> \<Longrightarrow> determ t"
  by(simp add:determ_def)

lemma determ_additiveD[intro]:
  "determ t \<Longrightarrow> additive t"
  by(simp add:determ_def)

lemma determ_maximalD[intro]:
  "determ t \<Longrightarrow> maximal t"
  by(simp add:determ_def)

lemma determ_negate:
  assumes determ:  "determ t"
  shows "t \<guillemotleft>P\<guillemotright> s + t \<guillemotleft>\<N> P\<guillemotright> s = 1"
proof -
  have "t \<guillemotleft>P\<guillemotright> s + t \<guillemotleft>\<N> P\<guillemotright> s = t (\<lambda>s. \<guillemotleft>P\<guillemotright> s + \<guillemotleft>\<N> P\<guillemotright> s) s"
    by(simp add:additiveD determ determ_additiveD)
  also {
    have "\<And>s. \<guillemotleft>P\<guillemotright> s + \<guillemotleft>\<N> P\<guillemotright> s = 1"
      by(case_tac "P s", simp_all)
    hence "t (\<lambda>s. \<guillemotleft>P\<guillemotright> s + \<guillemotleft>\<N> P\<guillemotright> s) = t (\<lambda>s. 1)"
      by(simp)
  }
  also have "t (\<lambda>s. 1) = (\<lambda>s. 1)"
    by(simp add:maximalD determ determ_maximalD)
  finally show ?thesis .
qed



lemma entails_combine:
  assumes wp1: "P \<tturnstile> t R"
      and wp2: "Q \<tturnstile> t S"
      and sc:  "sub_conj t"
      and sR:  "sound R"
      and sS:  "sound S"
  shows "P && Q \<tturnstile> t (R && S)"
proof -
  from wp1 and wp2 have "P && Q \<tturnstile> t R && t S"
    by(blast intro:entails_frame)
  also from sc and sR and sS have "... \<le> t (R && S)"
    by(rule sub_conjD)
  finally show ?thesis .
qed


lemma entails_strengthen_post:
  "\<lbrakk> P \<tturnstile> t Q; healthy t; sound R; Q \<tturnstile> R; sound Q \<rbrakk> \<Longrightarrow> P \<tturnstile> t R"
  by(blast intro:entails_trans)

lemma entails_weaken_pre:
  "\<lbrakk> Q \<tturnstile> t R; P \<tturnstile> Q \<rbrakk> \<Longrightarrow> P \<tturnstile> t R"
  by(blast intro:entails_trans)

lemma entails_scale:
  assumes wp: "P \<tturnstile> t Q" and h: "healthy t"
      and sQ: "sound Q" and pos: "0 \<le> c"
  shows "(\<lambda>s. c * P s) \<tturnstile> t (\<lambda>s. c * Q s)"
proof(rule le_funI)
  fix s
  from pos and wp have "c * P s \<le> c * t Q s"
    by(auto intro:mult_left_mono)
  with sQ pos h show "c * P s \<le> t (\<lambda>s. c * Q s) s"
    by(simp add:scalingD healthy_scalingD)
qed



lemma use_premise:
  assumes h: "healthy t" and wP: "\<And>s. P s \<Longrightarrow> 1 \<le> t \<guillemotleft>Q\<guillemotright> s"
  shows "\<guillemotleft>P\<guillemotright> \<tturnstile> t \<guillemotleft>Q\<guillemotright>"
proof(rule entailsI)
  fix s show "\<guillemotleft>P\<guillemotright> s \<le> t \<guillemotleft>Q\<guillemotright> s"
  proof(cases "P s")
    case True with wP show ?thesis by(auto)
  next
    case False with h show ?thesis by(auto)
  qed
qed

lemma fold_premise:
  assumes ht: "healthy t"
  and wp: "\<guillemotleft>P\<guillemotright> \<tturnstile> t \<guillemotleft>Q\<guillemotright>"
  shows "\<forall>s. P s \<longrightarrow> 1 \<le> t \<guillemotleft>Q\<guillemotright> s"
proof(clarify)
  fix s assume "P s"
  hence "1 = \<guillemotleft>P\<guillemotright> s" by(simp)
  also from wp have "... \<le> t \<guillemotleft>Q\<guillemotright> s" by(auto)
  finally show "1 \<le> t \<guillemotleft>Q\<guillemotright> s" .
qed

lemma conj_post:
  "\<lbrakk> P \<tturnstile> t \<guillemotleft>\<lambda>s. Q s \<and> R s\<guillemotright>; healthy t \<rbrakk> \<Longrightarrow> P \<tturnstile> t \<guillemotleft>Q\<guillemotright>"
  by(blast intro:entails_strengthen_post implies_entails)

lemma entails_pconj_assumption:
  assumes f: "feasible t" and wP: "\<And>s. P s \<Longrightarrow> Q s \<le> t R s"
      and uQ: "unitary Q" and uR: "unitary R"
  shows "\<guillemotleft>P\<guillemotright> && Q \<tturnstile> t R"
  unfolding exp_conj_def
proof(rule entailsI)
  fix s show "\<guillemotleft>P\<guillemotright> s .& Q s \<le> t R s"
  proof(cases "P s")
    case True
    moreover from uQ have "0 \<le> Q s" by(auto)
    ultimately show ?thesis by(simp add:pconj_lone wP)
  next
    case False
    moreover from uQ have "Q s \<le> 1" by(auto)
    ultimately show ?thesis using assms by auto
  qed
qed

end
