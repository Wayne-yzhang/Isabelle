theory Coerce
imports HOLCF
begin


functions together, we can coerce values between any two types in

definition coerce :: "'a \<rightarrow> 'b"
  where "coerce \<equiv> prj oo emb"

constants are being used. To alleviate this problem, we define special
input and output syntax to indicate the types. \medskip\<close>
typed_print_translation \<open>
let
  fun emb_tr' (ctxt : Proof.context) (Type(_, [T, _])) [] =
    Syntax.const @{syntax_const "_emb"} $ Syntax_Phases.term_of_typ ctxt T
  fun prj_tr' ctxt (Type(_, [_, T])) [] =
    Syntax.const @{syntax_const "_prj"} $ Syntax_Phases.term_of_typ ctxt T
  fun coerce_tr' ctxt (Type(_, [T, U])) [] =
    Syntax.const @{syntax_const "_coerce"} $
      Syntax_Phases.term_of_typ ctxt T $ Syntax_Phases.term_of_typ ctxt U
in
  [(@{const_syntax emb}, emb_tr'),
   (@{const_syntax prj}, prj_tr'),
   (@{const_syntax coerce}, coerce_tr')]
end
\<close>
text \<open>Certain type instances of \<open>coerce\<close> may reduce to the
identity function, \<open>emb\<close>, or \<open>prj\<close>. \medskip\<close>
subsection \<open>More lemmas about emb and prj\<close>
text \<open>@{term "DEFL(udom)"}\<close>
subsection \<open>Coercing various datatypes\<close>
text \<open>Coercing from the strict product type @{typ "'a \<otimes> 'b"} to
another strict product type @{typ "'c \<otimes> 'd"} is equivalent to mapping
of the several type constructors defined in HOLCF satisfies a similar
property, with respect to its own map combinator. \medskip\<close>
subsection \<open>Simplifying coercions\<close>
text \<open>When simplifying applications of the \<open>coerce\<close> function,
rewrite rules are always oriented to replace \<open>coerce\<close> at complex
types with other applications of \<open>coerce\<close> at simpler types.\<close>
text \<open>The safest rewrite rules for \<open>coerce\<close> are given the
\<open>[simp]\<close> attribute. For other rules that do not belong in the
global simpset, we use dynamic theorem list called \<open>coerce_simp\<close>,
