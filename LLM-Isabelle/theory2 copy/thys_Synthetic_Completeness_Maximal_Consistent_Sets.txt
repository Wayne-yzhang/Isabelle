theory Maximal_Consistent_Sets imports "HOL-Cardinals.Cardinal_Order_Relation" begin


  by blast

  by (simp add: Set_Diff_Un Un_commute)

  by (meson Diff_cancel Diff_eq_empty_iff Diff_mono infinite_super)

lemma finite_bound:
  using assms by (induct X rule: finite_induct) force+

lemma infinite_UNIV_size:
proof
    using finite_bound by fastforce
    using assms .
  ultimately show False
    using leD by blast
qed

lemma split_finite_sets:
  using assms subset_UnE by fastforce

lemma split_list:
  by (metis List.finite_set finite_Un finite_list set_append)

lemma struct_split:
proof -
    using assms(3) split_list by meson
  then show ?thesis
    using C by blast
qed

context wo_rel begin

  by (meson BNF_Least_Fixpoint.underS_Field REFL Refl_under_in in_mono under_ofilter ofilter_linord)

lemma finite_underS_bound:
  using assms
proof (induct X rule: finite_induct)
  case (insert x F)
  then show ?case
    case True
    then show ?thesis
      using insert underS_bound by fast
  next
    case False
    then show ?thesis
      using insert underS_bound by (metis TRANS insert_absorb insert_iff insert_subset under_trans)
  qed
qed simp

lemma finite_bound_under:
  using assms
proof (induct rule: finite_induct)
  case (insert x p)
    by fast
    using insert(4) by blast
    using REFL Refl_under_in by fast
    by fast
  then show ?case
    by (metis SUP_union Un_commute insert_is_Un sup.absorb_iff2 ofilter_linord under_ofilter)
qed simp

  by (meson ANTISYM TRANS underS_underS_trans)

end

lemma card_of_infinite_smaller_Union:
  using assms by (metis (full_types) Field_card_of card_of_UNION_ordLeq_infinite
      card_of_well_order_on ordLeq_iff_ordLess_or_ordIso ordLess_or_ordLeq)

lemma card_of_params_marker_lists:
proof -
    by simp
    using assms(2) by (simp add: cinfinite_def cprod_cinfinite_bound ordLess_imp_ordLeq)
    unfolding cprod_def by simp
    using assms infinite_iff_card_of_nat by blast
    using ordLeq_transitive by blast
    using assms by (simp add: cinfinite_def)
    using csum_absorb1 by blast
    unfolding csum_def by simp
    using ordIso_iff_ordLeq by blast
    using assms by simp
    by (metis card_of_lists_infinite lists_UNIV)
    using ordIso_ordLeq_trans by blast
  then show ?thesis
    using ordLeq_transitive by blast
qed


locale MCS_Base =
begin


end


locale MCS_Lim_Ord = MCS_Base +
begin

  by (simp add: WELL wo_rel.intro)

  using Cinfinite_r card_order_infinite_isLimOrd cinfinite_def by blast






  unfolding extendL_def wo_rel.adm_woL_def[OF wo_rel_r] by blast


proof (induct n rule: wo_rel.well_order_inductZSL[OF wo_rel_r])
  case 1
  then show ?case
    unfolding extend_def wo_rel.worecZSL_zero[OF wo_rel_r adm_woL_extendL]
    by simp
next
  case (2 i)
    by (meson FieldI1 wo_rel.succ_in wo_rel_r)
  ultimately show ?case
    unfolding extend_def extendS_def wo_rel.worecZSL_succ[OF wo_rel_r adm_woL_extendL 2(1)]
    by auto
next
  case (3 i)
  then show ?case
    unfolding extend_def extendL_def wo_rel.worecZSL_isLim[OF wo_rel_r adm_woL_extendL 3(1-2)]
    using wo_rel.zero_in_Field[OF wo_rel_r] wo_rel.zero_smallest[OF wo_rel_r]
    by (metis SUP_upper2 emptyE underS_I)
qed

  unfolding Extend_def using extend_subset by fast

proof (induct n rule: wo_rel.well_order_inductZSL[OF wo_rel_r])
  case 1
  then show ?case
    unfolding extend_def using wo_rel.underS_zero[OF wo_rel_r] by fast
next
  case (2 i)
    by (metis wo_rel.less_succ[OF wo_rel_r] underS_E underS_I)
  ultimately show ?case
    unfolding extend_def extendS_def wo_rel.worecZSL_succ[OF wo_rel_r adm_woL_extendL 2(1)] by auto
next
  case (3 i)
  then show ?case
    unfolding extend_def extendL_def wo_rel.worecZSL_isLim[OF wo_rel_r adm_woL_extendL 3(1-2)]
    by blast
qed

  using extend_underS wo_rel.supr_greater[OF wo_rel_r] wo_rel.supr_under[OF wo_rel_r]
  by (metis emptyE in_Above_under set_eq_subset underS_I under_Field under_empty)


lemma params_origin:
  using assms
proof (induct n rule: wo_rel.well_order_inductZSL[OF wo_rel_r])
  case 1
  then show ?case
    unfolding extend_def wo_rel.worecZSL_zero[OF wo_rel_r adm_woL_extendL]
    by blast
next
  case (2 i)
    using wo_rel.worecZSL_succ[OF wo_rel_r adm_woL_extendL 2(1)] extendS_def extend_def
    by (metis (no_types, lifting) UN_Un UnE)
  then show ?case
  proof cases
    case here
      by (meson WELL 2(1) well_order_on_domain wo_rel.succ_in_diff[OF wo_rel_r])
    ultimately show ?thesis
      using 2(1) by (metis Refl_under_in wo_rel.underS_succ[OF wo_rel_r] wo_rel.REFL[OF wo_rel_r])
  next
    case there
    then show ?thesis
      using 2 by (metis in_mono underS_subset_under wo_rel.underS_succ[OF wo_rel_r])
  next
  qed
next
  case (3 i)
    unfolding extend_def extendL_def wo_rel.worecZSL_isLim[OF wo_rel_r adm_woL_extendL 3(1-2)]
    by blast
  then show ?case
    using 3 wo_rel.underS_trans[OF wo_rel_r, of _ j i] by meson
qed

lemma consistent_extend:
  using assms(1)
proof (induct n rule: wo_rel.well_order_inductZSL[OF wo_rel_r])
  case 1
  then show ?case
    unfolding extend_def wo_rel.worecZSL_zero[OF wo_rel_r adm_woL_extendL]
    by blast
next
  case (2 i)
    by (meson WELL  well_order_on_domain wo_rel.succ_in_diff[OF wo_rel_r])
    using card_of_underS by (simp add: Cinfinite_r)
    case True
      by (simp add: finite_params finite_witness_params)
    then show ?thesis
      using Cinfinite_r assms(2) unfolding cinfinite_def by (simp add: finite_ordLess_infinite)
  next
    case False
      by (simp add: finite_params finite_witness_params)
      using False by simp
      using card_of_infinite_smaller_Union by fast
    then show ?thesis
      using * ordLeq_ordLess_trans by blast
  qed
    using assms(2) ordLess_ordLeq_trans by blast
    using assms(2) Cinfinite_r unfolding cinfinite_def by (metis Field_card_of ordLeq_finite_Field)
    using card_of_Un_diff_infinite by blast
    using params_origin by simp
    by fast
    using infinite_Diff_subset by (metis (no_types, lifting) Set_Diff_Un)
  with 2 show ?case
    unfolding extend_def extendS_def wo_rel.worecZSL_succ[OF wo_rel_r adm_woL_extendL 2(1)]
    using consistent_witness by auto
next
  case (3 i)
  show ?case
  proof (rule ccontr)
      unfolding extend_def extendL_def wo_rel.worecZSL_isLim[OF wo_rel_r adm_woL_extendL 3(1-2)]
      using inconsistent_finite by auto
      by (metis finite_subset_Union finite_subset_image)
      using S'(3) assms calculation(1) consistent_hereditary by auto
      using wo_rel.finite_underS_bound wo_rel_r ns by (meson subset_iff)
      using extend_under by fast
      using S' ns(1) by blast
    then show False
      by (meson BNF_Least_Fixpoint.underS_Field)
  qed
qed

lemma consistent_Extend:
  unfolding Extend_def
proof (rule ccontr)
    using inconsistent_finite by metis
    using wo_rel.finite_bound_under[OF wo_rel_r] assms consistent_hereditary
    by (metis Sup_empty emptyE image_empty subsetI under_empty)
    using extend_under by fast
  ultimately show False
qed

  unfolding Extend_def by blast



  unfolding maximal'_def
proof safe
  fix p
    unfolding Extend_def by blast
    using * consistent_hereditary by blast
    using * isLimOrd_r wo_rel.isLimOrd_aboveS[OF wo_rel_r] by blast
    using wo_rel.succ_in_Field[OF wo_rel_r] by blast
    using ** unfolding extend_def extendS_def wo_rel.worecZSL_succ[OF wo_rel_r adm_woL_extendL succ]
    by simp
    using Extend_bound by fast
qed



lemma saturated'_Extend:
  unfolding saturated'_def
proof safe
  fix p
    unfolding Extend_def by blast
    using assms(1) * consistent_hereditary by auto
    using * isLimOrd_r wo_rel.isLimOrd_aboveS wo_rel_r by fast
    using wo_rel_r by (simp add: wo_rel.succ_in_Field)
    unfolding extend_def extendS_def wo_rel.worecZSL_succ[OF wo_rel_r adm_woL_extendL succ]
    by simp
    by fast
qed

end


locale MCS_Saturation = MCS_Base +

proof
    by simp
next
    unfolding cinfinite_def using infinite_UNIV by simp
next
  fix p
    by (metis MCS_Saturation_axioms MCS_Saturation_axioms_def MCS_Saturation_def)
next
  fix p S
    by (metis MCS_Saturation_axioms MCS_Saturation_axioms_def MCS_Saturation_def)
next
  fix p S
    by (metis MCS_Saturation_axioms MCS_Saturation_axioms_def MCS_Saturation_def)
qed

context MCS_Saturation begin

  by (simp add: Extend_subset')

  unfolding maximal_def maximal'_def by simp

  using maximal'_Extend maximal_maximal' by fast


  unfolding saturated_def saturated'_def by simp

lemma saturated_Extend:
  using assms saturated'_Extend saturated_saturated' by blast

theorem MCS_Extend:
  using assms consistent_Extend maximal_Extend saturated_Extend by blast+

end


locale MCS_No_Saturation = MCS_Base +

proof
    using MCS_No_Saturation_axioms MCS_No_Saturation_axioms_def MCS_No_Saturation_def by blast
next
next
    by fast
next
  fix p S
    by simp
qed

context MCS_No_Saturation begin

  unfolding saturated_def by simp

theorem MCS_Extend':
  using assms consistent_Extend maximal_Extend by simp_all

end


locale Truth_Base =

locale Truth_Saturation = MCS_Saturation + Truth_Base +
begin

theorem truth_lemma_saturation:
  using Hintikka_model MCS_Hintikka assms .

end

locale Truth_No_Saturation = MCS_No_Saturation + Truth_Base +
begin

theorem truth_lemma_no_saturation:
  using Hintikka_model MCS_Hintikka assms .

end

end
