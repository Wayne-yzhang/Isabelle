theory Data_List
  imports
    Type_Classes
    Data_Function
    Data_Bool
    Data_Tuple
    Data_Integer
    Numeral_Cpo
begin

no_notation (ASCII)
  Set.member  ("'(:')") and
  Set.member  ("(_/ : _)" [51, 51] 50)


domain 'a list ("[_]") =
  Nil ("[]") |
  Cons (lazy head :: 'a) (lazy tail :: "['a]") (infixr ":" 65)



syntax
  "_Cons_section" :: "'a \<rightarrow> ['a] \<rightarrow> ['a]" ("'(:')")
  "_Cons_section_left" :: "'a \<Rightarrow> ['a] \<rightarrow> ['a]" ("'(_:')")
translations
  "(x:)" == "(CONST Rep_cfun) (CONST Cons) x"

abbreviation Cons_section_right :: "['a] \<Rightarrow> 'a \<rightarrow> ['a]" ("'(:_')") where
  "(:xs) \<equiv> \<Lambda> x. x:xs"

syntax
  "_lazy_list" :: "args \<Rightarrow> ['a]" ("[(_)]")
translations
  "[x, xs]" == "x : [xs]"
  "[x]" == "x : []"

abbreviation null :: "['a] \<rightarrow> tr" where "null \<equiv> is_Nil"



instantiation list :: (Eq) Eq_strict
begin

fixrec eq_list :: "['a] \<rightarrow> ['a] \<rightarrow> tr" where
  "eq_list\<cdot>[]\<cdot>[] = TT" |
  "eq_list\<cdot>(x : xs)\<cdot>[] = FF" |
  "eq_list\<cdot>[]\<cdot>(y : ys) = FF" |
  "eq_list\<cdot>(x : xs)\<cdot>(y : ys) = (eq\<cdot>x\<cdot>y andalso eq_list\<cdot>xs\<cdot>ys)"

instance proof
  fix xs :: "['a]"
  show "eq\<cdot>xs\<cdot>\<bottom> = \<bottom>"
    by (cases xs, fixrec_simp+)
  show "eq\<cdot>\<bottom>\<cdot>xs = \<bottom>"
    by fixrec_simp
qed

end

instance list :: (Eq_sym) Eq_sym
proof
  fix xs ys :: "['a]"
  show "eq\<cdot>xs\<cdot>ys = eq\<cdot>ys\<cdot>xs"
  proof (induct xs arbitrary: ys)
    case Nil
    show ?case by (cases ys; simp)
  next
    case Cons
    then show ?case by (cases ys; simp add: eq_sym)
  qed simp_all
qed

instance list :: (Eq_equiv) Eq_equiv
proof
  fix xs ys zs :: "['a]"
  show "eq\<cdot>xs\<cdot>xs \<noteq> FF"
    by (induct xs, simp_all)
  assume "eq\<cdot>xs\<cdot>ys = TT" and "eq\<cdot>ys\<cdot>zs = TT" then show "eq\<cdot>xs\<cdot>zs = TT"
  proof (induct xs arbitrary: ys zs)
    case (Nil ys zs) then show ?case by (cases ys, simp_all)
  next
    case (Cons x xs ys zs)
    from Cons.prems show ?case
      by (cases ys; cases zs) (auto intro: eq_trans Cons.hyps)
  qed simp_all
qed

instance list :: (Eq_eq) Eq_eq
proof
  fix xs ys :: "['a]"
  show "eq\<cdot>xs\<cdot>xs \<noteq> FF"
    by (induct xs) simp_all
  assume "eq\<cdot>xs\<cdot>ys = TT" then show "xs = ys"
  proof (induct xs arbitrary: ys)
    case Nil
    then show ?case by (cases ys) auto
  next
    case Cons
    then show ?case by (cases ys) auto
  qed auto
qed

instantiation list :: (Ord) Ord_strict
begin

fixrec compare_list :: "['a] \<rightarrow> ['a] \<rightarrow> Ordering" where
  "compare_list\<cdot>[]\<cdot>[] = EQ" |
  "compare_list\<cdot>(x : xs)\<cdot>[] = GT" |
  "compare_list\<cdot>[]\<cdot>(y : ys) = LT" |
  "compare_list\<cdot>(x : xs)\<cdot>(y : ys) =
    thenOrdering\<cdot>(compare\<cdot>x\<cdot>y)\<cdot>(compare_list\<cdot>xs\<cdot>ys)"

instance
  by standard (fixrec_simp, rename_tac x, case_tac x, fixrec_simp+)

end

instance list :: (Ord_linear) Ord_linear
proof
  fix xs ys zs :: "['a]"
  show "oppOrdering\<cdot>(compare\<cdot>xs\<cdot>ys) = compare\<cdot>ys\<cdot>xs"
  proof (induct xs arbitrary: ys)
    case Nil
    show ?case by (cases ys; simp)
  next
    case Cons
    then show ?case by (cases ys; simp add: oppOrdering_thenOrdering)
  qed simp_all
  show "xs = ys" if "compare\<cdot>xs\<cdot>ys = EQ"
    using that
  proof (induct xs arbitrary: ys)
    case Nil
    then show ?case by (cases ys; simp)
  next
    case Cons
    then show ?case by (cases ys; auto elim: compare_EQ_dest)
  qed simp_all
  show "compare\<cdot>xs\<cdot>zs = LT" if "compare\<cdot>xs\<cdot>ys = LT" and "compare\<cdot>ys\<cdot>zs = LT"
    using that
  proof (induct xs arbitrary: ys zs)
    case Nil
    then show ?case by (cases ys; cases zs; simp)
  next
    case (Cons a xs)
    then show ?case
      by (cases ys; cases zs) (auto dest: compare_EQ_dest compare_LT_trans)
  qed simp_all
  show "eq\<cdot>xs\<cdot>ys = is_EQ\<cdot>(compare\<cdot>xs\<cdot>ys)"
  proof (induct xs arbitrary: ys)
    case Nil
    show ?case by (cases ys; simp)
  next
    case Cons
    then show ?case by (cases ys; simp add: eq_conv_compare)
  qed simp_all
  show "compare\<cdot>xs\<cdot>xs \<sqsubseteq> EQ"
    by (induct xs) simp_all
qed

fixrec zipWith :: "('a \<rightarrow> 'b \<rightarrow> 'c) \<rightarrow> ['a] \<rightarrow> ['b] \<rightarrow> ['c]" where
  "zipWith\<cdot>f\<cdot>(x : xs)\<cdot>(y : ys) = f\<cdot>x\<cdot>y : zipWith\<cdot>f\<cdot>xs\<cdot>ys" |
  "zipWith\<cdot>f\<cdot>(x : xs)\<cdot>[] = []" |
  "zipWith\<cdot>f\<cdot>[]\<cdot>ys = []"

definition zip :: "['a] \<rightarrow> ['b] \<rightarrow> [\<langle>'a, 'b\<rangle>]" where
  "zip = zipWith\<cdot>\<langle>,\<rangle>"

fixrec zipWith3 :: "('a \<rightarrow> 'b \<rightarrow> 'c \<rightarrow> 'd) \<rightarrow> ['a] \<rightarrow> ['b] \<rightarrow> ['c] \<rightarrow> ['d]" where
  "zipWith3\<cdot>f\<cdot>(x : xs)\<cdot>(y : ys)\<cdot>(z : zs) = f\<cdot>x\<cdot>y\<cdot>z : zipWith3\<cdot>f\<cdot>xs\<cdot>ys\<cdot>zs" |
  (unchecked) "zipWith3\<cdot>f\<cdot>xs\<cdot>ys\<cdot>zs = []"

definition zip3 :: "['a] \<rightarrow> ['b] \<rightarrow> ['c] \<rightarrow> [\<langle>'a, 'b, 'c\<rangle>]" where
  "zip3 = zipWith3\<cdot>\<langle>,,\<rangle>"

fixrec map :: "('a \<rightarrow> 'b) \<rightarrow> ['a] \<rightarrow> ['b]" where
  "map\<cdot>f\<cdot>[] = []" |
  "map\<cdot>f\<cdot>(x : xs) = f\<cdot>x : map\<cdot>f\<cdot>xs"

fixrec filter :: "('a \<rightarrow> tr) \<rightarrow> ['a] \<rightarrow> ['a]" where
  "filter\<cdot>P\<cdot>[] = []" |
  "filter\<cdot>P\<cdot>(x : xs) =
    If (P\<cdot>x) then x : filter\<cdot>P\<cdot>xs else filter\<cdot>P\<cdot>xs"

fixrec repeat :: "'a \<rightarrow> ['a]" where
  [simp del]: "repeat\<cdot>x = x : repeat\<cdot>x"

fixrec takeWhile :: "('a \<rightarrow> tr) \<rightarrow> ['a] \<rightarrow> ['a]" where
 "takeWhile\<cdot>p\<cdot>[]     =  []" |
 "takeWhile\<cdot>p\<cdot>(x:xs) = If p\<cdot>x then x : takeWhile\<cdot>p\<cdot>xs else  []"

fixrec dropWhile :: "('a \<rightarrow> tr) \<rightarrow> ['a] \<rightarrow> ['a]" where
 "dropWhile\<cdot>p\<cdot>[]     =  []" |
 "dropWhile\<cdot>p\<cdot>(x:xs) = If p\<cdot>x then dropWhile\<cdot>p\<cdot>xs else (x:xs)"

fixrec span :: "('a -> tr) -> ['a] -> \<langle>['a],['a]\<rangle>" where
 "span\<cdot>p\<cdot>[]     = \<langle>[],[]\<rangle>" |
 "span\<cdot>p\<cdot>(x:xs) = If p\<cdot>x then (case span\<cdot>p\<cdot>xs of \<langle>ys, zs\<rangle> \<Rightarrow> \<langle>x:ys,zs\<rangle>) else \<langle>[], x:xs\<rangle>"

fixrec break :: "('a -> tr) -> ['a] -> \<langle>['a],['a]\<rangle>" where
 "break\<cdot>p = span\<cdot>(neg oo p)"

fixrec nth :: "['a] \<rightarrow> Integer \<rightarrow> 'a" where
  "nth\<cdot>[]\<cdot>n = \<bottom>" |
  nth_Cons [simp del]:
  "nth\<cdot>(x : xs)\<cdot>n = If eq\<cdot>n\<cdot>0 then x else nth\<cdot>xs\<cdot>(n - 1)"

abbreviation nth_syn :: "['a] \<Rightarrow> Integer \<Rightarrow> 'a" (infixl "!!" 100) where
  "xs !! n \<equiv> nth\<cdot>xs\<cdot>n"

definition partition :: "('a \<rightarrow> tr) \<rightarrow> ['a] \<rightarrow> \<langle>['a], ['a]\<rangle>" where
  "partition = (\<Lambda> P xs. \<langle>filter\<cdot>P\<cdot>xs, filter\<cdot>(neg oo P)\<cdot>xs\<rangle>)"

fixrec iterate :: "('a \<rightarrow> 'a) \<rightarrow> 'a \<rightarrow> ['a]" where
  "iterate\<cdot>f\<cdot>x = x : iterate\<cdot>f\<cdot>(f\<cdot>x)"

fixrec foldl ::  "('a -> 'b -> 'a) -> 'a -> ['b] -> 'a" where
  "foldl\<cdot>f\<cdot>z\<cdot>[]     = z" |
  "foldl\<cdot>f\<cdot>z\<cdot>(x:xs) = foldl\<cdot>f\<cdot>(f\<cdot>z\<cdot>x)\<cdot>xs"

fixrec foldl1 ::  "('a -> 'a -> 'a) -> ['a] -> 'a" where
  "foldl1\<cdot>f\<cdot>[]     = \<bottom>" |
  "foldl1\<cdot>f\<cdot>(x:xs) = foldl\<cdot>f\<cdot>x\<cdot>xs"

fixrec foldr :: "('a \<rightarrow> 'b \<rightarrow> 'b) \<rightarrow> 'b \<rightarrow> ['a] \<rightarrow> 'b" where
  "foldr\<cdot>f\<cdot>d\<cdot>[] = d" |
  "foldr\<cdot>f\<cdot>d\<cdot>(x : xs) = f\<cdot>x\<cdot>(foldr\<cdot>f\<cdot>d\<cdot>xs)"

fixrec foldr1 :: "('a \<rightarrow> 'a \<rightarrow> 'a) \<rightarrow> ['a] \<rightarrow> 'a" where
  "foldr1\<cdot>f\<cdot>[] = \<bottom>" |
  "foldr1\<cdot>f\<cdot>[x] = x" |
  "foldr1\<cdot>f\<cdot>(x : (x':xs)) = f\<cdot>x\<cdot>(foldr1\<cdot>f\<cdot>(x':xs))"

fixrec elem :: "'a::Eq \<rightarrow> ['a] \<rightarrow> tr" where
  "elem\<cdot>x\<cdot>[] = FF" |
  "elem\<cdot>x\<cdot>(y : ys) = (eq\<cdot>y\<cdot>x orelse elem\<cdot>x\<cdot>ys)"

fixrec notElem :: "'a::Eq \<rightarrow> ['a] \<rightarrow> tr" where
  "notElem\<cdot>x\<cdot>[] = TT" |
  "notElem\<cdot>x\<cdot>(y : ys) = (neq\<cdot>y\<cdot>x andalso notElem\<cdot>x\<cdot>ys)"

fixrec append :: "['a] \<rightarrow> ['a] \<rightarrow> ['a]" where
  "append\<cdot>[]\<cdot>ys = ys" |
  "append\<cdot>(x : xs)\<cdot>ys = x : append\<cdot>xs\<cdot>ys"

abbreviation append_syn :: "['a] \<Rightarrow> ['a] \<Rightarrow> ['a]" (infixr "++" 65) where
  "xs ++ ys \<equiv> append\<cdot>xs\<cdot>ys"

definition concat :: "[['a]] \<rightarrow> ['a]" where
  "concat = foldr\<cdot>append\<cdot>[]"

definition concatMap :: "('a \<rightarrow> ['b]) \<rightarrow> ['a] \<rightarrow> ['b]" where
  "concatMap = (\<Lambda> f. concat oo map\<cdot>f)"

fixrec last :: "['a] -> 'a" where
  "last\<cdot>[x] = x" |
  "last\<cdot>(_:(x:xs)) = last\<cdot>(x:xs)"

fixrec init :: "['a] -> ['a]" where
  "init\<cdot>[x] = []" |
  "init\<cdot>(x:(y:xs)) = x:(init\<cdot>(y:xs))"

fixrec reverse :: "['a] -> ['a]" where
  [simp del]:"reverse = foldl\<cdot>(flip\<cdot>(:))\<cdot>[]"

fixrec the_and :: "[tr] \<rightarrow> tr" where
  "the_and = foldr\<cdot>trand\<cdot>TT"

fixrec the_or :: "[tr] \<rightarrow> tr" where
  "the_or = foldr\<cdot>tror\<cdot>FF"

fixrec all :: "('a \<rightarrow> tr) \<rightarrow> ['a] \<rightarrow> tr" where
  "all\<cdot>P = the_and oo (map\<cdot>P)"

fixrec any :: "('a \<rightarrow> tr) \<rightarrow> ['a] \<rightarrow> tr" where
  "any\<cdot>P = the_or oo (map\<cdot>P)"

fixrec tails :: "['a] \<rightarrow> [['a]]" where
  "tails\<cdot>[] = [[]]" |
  "tails\<cdot>(x : xs) = (x : xs) : tails\<cdot>xs"

fixrec inits :: "['a] \<rightarrow> [['a]]" where
  "inits\<cdot>[] = [[]]" |
  "inits\<cdot>(x : xs) = [[]] ++ map\<cdot>(x:)\<cdot>(inits\<cdot>xs)"

fixrec scanr :: "('a \<rightarrow> 'b \<rightarrow> 'b) \<rightarrow> 'b \<rightarrow> ['a] \<rightarrow> ['b]"
where
  "scanr\<cdot>f\<cdot>q0\<cdot>[] = [q0]" |
  "scanr\<cdot>f\<cdot>q0\<cdot>(x : xs) = (
    let qs = scanr\<cdot>f\<cdot>q0\<cdot>xs in
    (case qs of
      [] \<Rightarrow> \<bottom>
    | q : qs' \<Rightarrow> f\<cdot>x\<cdot>q : qs))"

fixrec scanr1 :: "('a \<rightarrow> 'a \<rightarrow> 'a) \<rightarrow> ['a] \<rightarrow> ['a]"
where
  "scanr1\<cdot>f\<cdot>[] = []" |
  "scanr1\<cdot>f\<cdot>(x : xs) =
    (case xs of
      [] \<Rightarrow> [x]
    | x' : xs' \<Rightarrow> (
      let qs = scanr1\<cdot>f\<cdot>xs in
      (case qs of
        [] \<Rightarrow> \<bottom>
      | q : qs' \<Rightarrow> f\<cdot>x\<cdot>q : qs)))"

fixrec scanl :: "('a \<rightarrow> 'b \<rightarrow> 'a) \<rightarrow> 'a \<rightarrow> ['b] \<rightarrow> ['a]" where
  "scanl\<cdot>f\<cdot>q\<cdot>ls = q : (case ls of
    [] \<Rightarrow> []
  | x : xs \<Rightarrow> scanl\<cdot>f\<cdot>(f\<cdot>q\<cdot>x)\<cdot>xs)"

definition scanl1 :: "('a \<rightarrow> 'a \<rightarrow> 'a) \<rightarrow> ['a] \<rightarrow> ['a]" where
  "scanl1 = (\<Lambda> f ls. (case ls of
    [] \<Rightarrow> []
  | x : xs \<Rightarrow> scanl\<cdot>f\<cdot>x\<cdot>xs))"


fixrec upto :: "Integer \<rightarrow> Integer \<rightarrow> [Integer]" where
  [simp del]: "upto\<cdot>x\<cdot>y = If le\<cdot>x\<cdot>y then x : upto\<cdot>(x+1)\<cdot>y else []"

fixrec intsFrom :: "Integer \<rightarrow> [Integer]" where
  [simp del]: "intsFrom\<cdot>x = seq\<cdot>x\<cdot>(x : intsFrom\<cdot>(x+1))"

class Enum =
  fixes toEnum :: "Integer \<rightarrow> 'a"
    and fromEnum :: "'a \<rightarrow> Integer"
begin

definition succ :: "'a \<rightarrow> 'a" where
  "succ = toEnum oo (+1) oo fromEnum"

definition pred :: "'a \<rightarrow> 'a" where
  "pred = toEnum oo (-1) oo fromEnum"

definition enumFrom :: "'a \<rightarrow> ['a]" where
  "enumFrom = (\<Lambda> x. map\<cdot>toEnum\<cdot>(intsFrom\<cdot>(fromEnum\<cdot>x)))"

definition enumFromTo :: "'a \<rightarrow> 'a \<rightarrow> ['a]" where
  "enumFromTo = (\<Lambda> x y. map\<cdot>toEnum\<cdot>(upto\<cdot>(fromEnum\<cdot>x)\<cdot>(fromEnum\<cdot>y)))"

end

abbreviation enumFrom_To_syn :: "'a::Enum \<Rightarrow> 'a \<Rightarrow> ['a]" ("(1[_../_])") where
  "[m..n] \<equiv> enumFromTo\<cdot>m\<cdot>n"

abbreviation enumFrom_syn :: "'a::Enum \<Rightarrow> ['a]" ("(1[_..])") where
  "[n..] \<equiv> enumFrom\<cdot>n"

instantiation Integer :: Enum
begin
definition [simp]: "toEnum = ID"
definition [simp]: "fromEnum = ID"
instance ..
end

fixrec take :: "Integer \<rightarrow> ['a] \<rightarrow> ['a]" where
  [simp del]: "take\<cdot>n\<cdot>xs = If le\<cdot>n\<cdot>0 then [] else
    (case xs of [] \<Rightarrow> [] | y : ys \<Rightarrow> y : take\<cdot>(n - 1)\<cdot>ys)"

fixrec drop :: "Integer \<rightarrow> ['a] \<rightarrow> ['a]" where
  [simp del]: "drop\<cdot>n\<cdot>xs = If le\<cdot>n\<cdot>0 then xs else
    (case xs of [] \<Rightarrow> [] | y : ys \<Rightarrow> drop\<cdot>(n - 1)\<cdot>ys)"

fixrec isPrefixOf :: "['a::Eq] \<rightarrow> ['a] \<rightarrow> tr" where
  "isPrefixOf\<cdot>[]\<cdot>_ = TT" |
  "isPrefixOf\<cdot>(x:xs)\<cdot>[] = FF" |
  "isPrefixOf\<cdot>(x:xs)\<cdot>(y:ys) = (eq\<cdot>x\<cdot>y andalso isPrefixOf\<cdot>xs\<cdot>ys)"

fixrec isSuffixOf :: "['a::Eq] \<rightarrow> ['a] \<rightarrow> tr" where
  "isSuffixOf\<cdot>x\<cdot>y = isPrefixOf\<cdot>(reverse\<cdot>x)\<cdot>(reverse\<cdot>y)"

fixrec intersperse :: "'a \<rightarrow> ['a] \<rightarrow> ['a]" where
  "intersperse\<cdot>sep\<cdot>[] = []" |
  "intersperse\<cdot>sep\<cdot>[x] = [x]" |
  "intersperse\<cdot>sep\<cdot>(x:y:xs) = x:sep:intersperse\<cdot>sep\<cdot>(y:xs)"

fixrec intercalate :: "['a] \<rightarrow> [['a]] \<rightarrow> ['a]" where
  "intercalate\<cdot>xs\<cdot>xss = concat\<cdot>(intersperse\<cdot>xs\<cdot>xss)"

definition replicate :: "Integer \<rightarrow> 'a \<rightarrow> ['a]" where
  "replicate = (\<Lambda> n x. take\<cdot>n\<cdot>(repeat\<cdot>x))"

definition findIndices :: "('a \<rightarrow> tr) \<rightarrow> ['a] \<rightarrow> [Integer]" where
  "findIndices = (\<Lambda> P xs.
    map\<cdot>snd\<cdot>(filter\<cdot>(\<Lambda> \<langle>x, i\<rangle>. P\<cdot>x)\<cdot>(zip\<cdot>xs\<cdot>[0..])))"

fixrec length :: "['a] \<rightarrow> Integer" where
  "length\<cdot>[] = 0" |
  "length\<cdot>(x : xs) = length\<cdot>xs + 1"

fixrec delete :: "'a::Eq \<rightarrow> ['a] \<rightarrow> ['a]" where
  "delete\<cdot>x\<cdot>[] = []" |
  "delete\<cdot>x\<cdot>(y : ys) = If eq\<cdot>x\<cdot>y then ys else y : delete\<cdot>x\<cdot>ys"

fixrec diff :: "['a::Eq] \<rightarrow> ['a] \<rightarrow> ['a]" where
  "diff\<cdot>xs\<cdot>[] = xs" |
  "diff\<cdot>xs\<cdot>(y : ys) = diff\<cdot>(delete\<cdot>y\<cdot>xs)\<cdot>ys"

abbreviation diff_syn :: "['a::Eq] \<Rightarrow> ['a] \<Rightarrow> ['a]" (infixl "\\\\" 70) where
  "xs \\\\ ys \<equiv> diff\<cdot>xs\<cdot>ys"



inductive finite_list :: "['a] \<Rightarrow> bool" where
  Nil [intro!, simp]: "finite_list []" |
  Cons [intro!, simp]: "\<And>x xs. finite_list xs \<Longrightarrow> finite_list (x : xs)"

inductive_cases finite_listE [elim!]: "finite_list (x : xs)"

lemma finite_list_upwards:
  assumes "finite_list xs" and "xs \<sqsubseteq> ys"
  shows "finite_list ys"
using assms
proof (induct xs arbitrary: ys)
  case Nil
  then have "ys = []" by (cases ys) simp+
  then show ?case by auto
next
  case (Cons x xs)
  then have "finite_list ys'" by (rule Cons.hyps)
qed

lemma adm_finite_list [simp]: "adm finite_list"
  by (metis finite_list_upwards adm_upward)

lemma bot_not_finite_list [simp]:
  "finite_list \<bottom> = False"
  by (rule, cases rule: finite_list.cases) auto

inductive listmem :: "'a \<Rightarrow> ['a] \<Rightarrow> bool" where
  "listmem x (x : xs)" |
  "listmem x xs \<Longrightarrow> listmem x (y : xs)"

lemma listmem_simps [simp]:
  shows "\<not> listmem x \<bottom>" and "\<not> listmem x []"
  and "listmem x (y : ys) \<longleftrightarrow> x = y \<or> listmem x ys"
  by (auto elim: listmem.cases intro: listmem.intros)

definition set :: "['a] \<Rightarrow> 'a set" where
  "set xs = {x. listmem x xs}"

lemma set_simps [simp]:
  shows "set \<bottom> = {}" and "set [] = {}"
  and "set (x : xs) = insert x (set xs)"
  unfolding set_def by auto

inductive distinct :: "['a] \<Rightarrow> bool" where
  Nil [intro!, simp]: "distinct []" |
  Cons [intro!, simp]: "\<And>x xs. distinct xs \<Longrightarrow> x \<notin> set xs \<Longrightarrow> distinct (x : xs)"



lemma map_strict [simp]:
  "map\<cdot>P\<cdot>\<bottom> = \<bottom>"
  by (fixrec_simp)

lemma map_ID [simp]:
  "map\<cdot>ID\<cdot>xs = xs"
  by (induct xs) simp_all

lemma enumFrom_intsFrom_conv [simp]:
  "enumFrom = intsFrom"
  by (intro cfun_eqI) (simp add: enumFrom_def)

lemma enumFromTo_upto_conv [simp]:
  "enumFromTo = upto"
  by (intro cfun_eqI) (simp add: enumFromTo_def)

lemma zipWith_strict [simp]:
  "zipWith\<cdot>f\<cdot>\<bottom>\<cdot>ys = \<bottom>"
  "zipWith\<cdot>f\<cdot>(x : xs)\<cdot>\<bottom> = \<bottom>"
  by fixrec_simp+

lemma zip_simps [simp]:
  "zip\<cdot>(x : xs)\<cdot>(y : ys) = \<langle>x, y\<rangle> : zip\<cdot>xs\<cdot>ys"
  "zip\<cdot>(x : xs)\<cdot>[] = []"
  "zip\<cdot>(x : xs)\<cdot>\<bottom> = \<bottom>"
  "zip\<cdot>[]\<cdot>ys = []"
  "zip\<cdot>\<bottom>\<cdot>ys = \<bottom>"
  unfolding zip_def by simp_all

lemma zip_Nil2 [simp]:
  "xs \<noteq> \<bottom> \<Longrightarrow> zip\<cdot>xs\<cdot>[] = []"
  by (cases xs) simp_all

lemma nth_strict [simp]:
  "nth\<cdot>\<bottom>\<cdot>n = \<bottom>"
  "nth\<cdot>xs\<cdot>\<bottom> = \<bottom>"
  by (fixrec_simp) (cases xs, fixrec_simp+)

lemma upto_strict [simp]:
  "upto\<cdot>\<bottom>\<cdot>y = \<bottom>"
  "upto\<cdot>x\<cdot>\<bottom> = \<bottom>"
  by fixrec_simp+

lemma upto_simps [simp]:
  "n < m \<Longrightarrow> upto\<cdot>(MkI\<cdot>m)\<cdot>(MkI\<cdot>n) = []"
  "m \<le> n \<Longrightarrow> upto\<cdot>(MkI\<cdot>m)\<cdot>(MkI\<cdot>n) = MkI\<cdot>m : [MkI\<cdot>m+1..MkI\<cdot>n]"
  by (subst upto.simps, simp)+

lemma filter_strict [simp]:
  "filter\<cdot>P\<cdot>\<bottom> = \<bottom>"
  by (fixrec_simp)

lemma nth_Cons_simp [simp]:
  "eq\<cdot>n\<cdot>0 = TT \<Longrightarrow> nth\<cdot>(x : xs)\<cdot>n = x"
  "eq\<cdot>n\<cdot>0 = FF \<Longrightarrow> nth\<cdot>(x : xs)\<cdot>n = nth\<cdot>xs\<cdot>(n - 1)"
  by (subst nth.simps, simp)+

lemma nth_Cons_split:
   "P (nth\<cdot>(x : xs)\<cdot>n) = ((eq\<cdot>n\<cdot>0 = FF \<longrightarrow> P (nth\<cdot>(x : xs)\<cdot>n)) \<and>
                              (eq\<cdot>n\<cdot>0 = TT \<longrightarrow> P (nth\<cdot>(x : xs)\<cdot>n)) \<and>
                              (n = \<bottom> \<longrightarrow> P (nth\<cdot>(x : xs)\<cdot>n)))"
apply (cases n, simp)
apply (cases "n = 0", simp_all add: zero_Integer_def)
done



lemma nth_Cons_numeral [simp]:
  "(x : xs) !! 0 = x"
  "(x : xs) !! 1 = xs !! 0"
  "(x : xs) !! numeral (Num.Bit0 k) = xs !! numeral (Num.BitM k)"
  "(x : xs) !! numeral (Num.Bit1 k) = xs !! numeral (Num.Bit0 k)"
  by (simp_all add: nth_Cons numeral_Integer_eq
    zero_Integer_def one_Integer_def)

lemma take_strict [simp]:
  "take\<cdot>\<bottom>\<cdot>xs = \<bottom>"
  by (fixrec_simp)

lemma take_strict_2 [simp]:
  "le\<cdot>1\<cdot>i = TT \<Longrightarrow> take\<cdot>i\<cdot>\<bottom> = \<bottom>"
  by (subst take.simps, cases "le\<cdot>i\<cdot>0") (auto dest: le_trans)

lemma drop_strict [simp]:
  "drop\<cdot>\<bottom>\<cdot>xs = \<bottom>"
  by (fixrec_simp)

lemma isPrefixOf_strict [simp]:
  "isPrefixOf\<cdot>\<bottom>\<cdot>xs = \<bottom>"
  "isPrefixOf\<cdot>(x:xs)\<cdot>\<bottom> = \<bottom>"
  by (fixrec_simp)+

lemma last_strict[simp]:
  "last\<cdot>\<bottom>= \<bottom>"
  "last\<cdot>(x:\<bottom>) = \<bottom>"
  by (fixrec_simp+)

lemma last_nil [simp]:
  "last\<cdot>[] = \<bottom>"
  by (fixrec_simp)

lemma last_spine_strict: "\<not> finite_list xs \<Longrightarrow> last\<cdot>xs = \<bottom>"
proof (induct xs)
  case (Cons a xs)
  then show ?case by (cases xs) auto
qed auto

lemma init_strict [simp]:
  "init\<cdot>\<bottom>= \<bottom>"
  "init\<cdot>(x:\<bottom>) = \<bottom>"
  by (fixrec_simp+)

lemma init_nil [simp]:
  "init\<cdot>[] = \<bottom>"
  by (fixrec_simp)

lemma strict_foldr_strict2 [simp]:
  "(\<And>x. f\<cdot>x\<cdot>\<bottom> = \<bottom>) \<Longrightarrow> foldr\<cdot>f\<cdot>\<bottom>\<cdot>xs = \<bottom>"
  by (induct xs, auto) fixrec_simp

lemma foldr_strict [simp]:
  "foldr\<cdot>f\<cdot>d\<cdot>\<bottom> = \<bottom>"
  "foldr\<cdot>f\<cdot>\<bottom>\<cdot>[] = \<bottom>"
  "foldr\<cdot>\<bottom>\<cdot>d\<cdot>(x : xs) = \<bottom>"
  by fixrec_simp+

lemma foldr_Cons_Nil [simp]:
  "foldr\<cdot>(:)\<cdot>[]\<cdot>xs = xs"
  by (induct xs) simp+

lemma append_strict1 [simp]:
  "\<bottom> ++ ys = \<bottom>"
  by fixrec_simp

lemma foldr_append [simp]:
  "foldr\<cdot>f\<cdot>a\<cdot>(xs ++ ys) = foldr\<cdot>f\<cdot>(foldr\<cdot>f\<cdot>a\<cdot>ys)\<cdot>xs"
  by (induct xs) simp+

lemma foldl_strict [simp]:
  "foldl\<cdot>f\<cdot>d\<cdot>\<bottom> = \<bottom>"
  "foldl\<cdot>f\<cdot>\<bottom>\<cdot>[] = \<bottom>"
  by fixrec_simp+

lemma foldr1_strict [simp]:
  "foldr1\<cdot>f\<cdot>\<bottom>= \<bottom>"
  "foldr1\<cdot>f\<cdot>(x:\<bottom>)= \<bottom>"
  by fixrec_simp+

lemma foldl1_strict [simp]:
  "foldl1\<cdot>f\<cdot>\<bottom>= \<bottom>"
  by fixrec_simp

lemma foldl_spine_strict:
  "\<not> finite_list xs \<Longrightarrow> foldl\<cdot>f\<cdot>x\<cdot>xs = \<bottom>"
  by (induct xs arbitrary: x) auto

lemma foldl_assoc_foldr:
  assumes "finite_list xs"
    and assoc: "\<And>x y z. f\<cdot>(f\<cdot>x\<cdot>y)\<cdot>z = f\<cdot>x\<cdot>(f\<cdot>y\<cdot>z)"
    and neutr1: "\<And>x. f\<cdot>z\<cdot>x = x"
    and neutr2: "\<And>x. f\<cdot>x\<cdot>z = x"
  shows "foldl\<cdot>f\<cdot>z\<cdot>xs = foldr\<cdot>f\<cdot>z\<cdot>xs"
proof (induct xs)
  case (Cons x xs)
  proof (induct xs)
    case (Cons x xs y)
    have "f\<cdot>y\<cdot>(foldl\<cdot>f\<cdot>z\<cdot>(x : xs)) = f\<cdot>y\<cdot>(foldl\<cdot>f\<cdot>(f\<cdot>z\<cdot>x)\<cdot>xs)" by auto
    also have "... = f\<cdot>y\<cdot>(f\<cdot>x\<cdot>(foldl\<cdot>f\<cdot>z\<cdot>xs))" by (simp only: Cons.hyps)
    also have "... = f\<cdot>(f\<cdot>y\<cdot>x)\<cdot>(foldl\<cdot>f\<cdot>z\<cdot>xs)" by (simp only: assoc)
    also have "... = foldl\<cdot>f\<cdot>(f\<cdot>z\<cdot>(f\<cdot>y\<cdot>x))\<cdot>xs" by (simp only: Cons.hyps)
    also have "... = foldl\<cdot>f\<cdot>(f\<cdot>(f\<cdot>z\<cdot>y)\<cdot>x)\<cdot>xs" by (simp only: assoc)
    also have "... = foldl\<cdot>f\<cdot>(f\<cdot>z\<cdot>y)\<cdot>(x : xs)" by auto
    finally show ?case.
  qed (simp add: neutr1 neutr2)

  have "foldl\<cdot>f\<cdot>z\<cdot>(x : xs) = foldl\<cdot>f\<cdot>(f\<cdot>z\<cdot>x)\<cdot>xs" by auto
  also have "... = f\<cdot>x\<cdot>(foldl\<cdot>f\<cdot>z\<cdot>xs)" by (simp only: step)
  also have "... = f\<cdot>x\<cdot>(foldr\<cdot>f\<cdot>z\<cdot>xs)" by (simp only: Cons.hyps)
  also have "... = (foldr\<cdot>f\<cdot>z\<cdot>(x:xs))" by auto
  finally show ?case .
qed auto

lemma elem_strict [simp]:
  "elem\<cdot>x\<cdot>\<bottom> = \<bottom>"
  by fixrec_simp

lemma notElem_strict [simp]:
  "notElem\<cdot>x\<cdot>\<bottom> = \<bottom>"
  by fixrec_simp

lemma list_eq_nil[simp]:
  "eq\<cdot>l\<cdot>[] = TT \<longleftrightarrow> l = []"
  "eq\<cdot>[]\<cdot>l = TT \<longleftrightarrow> l = []"
  by (cases l, auto)+

lemma take_Nil [simp]:
  "n \<noteq> \<bottom> \<Longrightarrow> take\<cdot>n\<cdot>[] = []"
  by (subst take.simps) (cases "le\<cdot>n\<cdot>0"; simp)

lemma take_0 [simp]:
  "take\<cdot>0\<cdot>xs = []"
  "take\<cdot>(MkI\<cdot>0)\<cdot>xs = []"
  by (subst take.simps, simp add: zero_Integer_def)+

lemma take_Cons [simp]:
  "le\<cdot>1\<cdot>i = TT \<Longrightarrow> take\<cdot>i\<cdot>(x:xs) = x : take\<cdot>(i - 1)\<cdot>xs"
  by (subst take.simps, cases "le\<cdot>i\<cdot>0") (auto dest: le_trans)

lemma take_MkI_Cons [simp]:
  "0 < n \<Longrightarrow> take\<cdot>(MkI\<cdot>n)\<cdot>(x : xs) = x : take\<cdot>(MkI\<cdot>(n - 1))\<cdot>xs"
  by (subst take.simps) (simp add: zero_Integer_def one_Integer_def)

lemma take_numeral_Cons [simp]:
  "take\<cdot>1\<cdot>(x : xs) = [x]"
  "take\<cdot>(numeral (Num.Bit0 k))\<cdot>(x : xs) = x : take\<cdot>(numeral (Num.BitM k))\<cdot>xs"
  "take\<cdot>(numeral (Num.Bit1 k))\<cdot>(x : xs) = x : take\<cdot>(numeral (Num.Bit0 k))\<cdot>xs"
  by (subst take.simps,
      simp add: zero_Integer_def one_Integer_def numeral_Integer_eq)+

lemma drop_0 [simp]:
  "drop\<cdot>0\<cdot>xs = xs"
  "drop\<cdot>(MkI\<cdot>0)\<cdot>xs = xs"
  by (subst drop.simps, simp add: zero_Integer_def)+

lemma drop_pos [simp]:
  "le\<cdot>n\<cdot>0 = FF \<Longrightarrow> drop\<cdot>n\<cdot>xs = (case xs of [] \<Rightarrow> [] | y : ys \<Rightarrow> drop\<cdot>(n - 1)\<cdot>ys)"
  by (subst drop.simps, simp)

lemma drop_numeral_Cons [simp]:
  "drop\<cdot>1\<cdot>(x : xs) = xs"
  "drop\<cdot>(numeral (Num.Bit0 k))\<cdot>(x : xs) = drop\<cdot>(numeral (Num.BitM k))\<cdot>xs"
  "drop\<cdot>(numeral (Num.Bit1 k))\<cdot>(x : xs) = drop\<cdot>(numeral (Num.Bit0 k))\<cdot>xs"
  by (subst drop.simps,
      simp add: zero_Integer_def one_Integer_def numeral_Integer_eq)+

lemma take_drop_append:
  "take\<cdot>(MkI\<cdot>i)\<cdot>xs ++ drop\<cdot>(MkI\<cdot>i)\<cdot>xs = xs"
proof (cases i)
  case (nonneg n)
  then show ?thesis
  proof (induct n arbitrary : i xs)
    case (Suc n)
    thus ?case
      apply (subst drop.simps)
      apply (subst take.simps)
      apply (cases xs)
        apply (auto simp add: zero_Integer_def one_Integer_def )
      done
  qed simp
next
  case (neg nat)
  then show ?thesis
    apply (subst drop.simps)
    apply (subst take.simps)
    apply (auto simp add: zero_Integer_def one_Integer_def )
    done
qed

lemma take_intsFrom_enumFrom [simp]:
  "take\<cdot>(MkI\<cdot>n)\<cdot>[MkI\<cdot>i..] = [MkI\<cdot>i..MkI\<cdot>(n+i) - 1]"
proof (cases n)
  fix m
  assume "n = int m"
  then show ?thesis
  proof (induct m arbitrary: n i)
    case 0 then show ?case by (simp add: one_Integer_def)
  next
    case (Suc m)
    then have "n - 1 = int m" by simp
    from Suc(1) [OF this]
    have "take\<cdot>(MkI\<cdot>(n - 1))\<cdot>[MkI\<cdot>(i+1)..] = [MkI\<cdot>(i+1)..MkI\<cdot>(n - 1 + (i+1)) - 1]" .
    moreover have "(n - 1) + (i+1) - 1 = n + i - 1" by arith
    ultimately have IH: "take\<cdot>(MkI\<cdot>(n - 1))\<cdot>[MkI\<cdot>(i+1)..] = [MkI\<cdot>(i+1)..MkI\<cdot>(n+i) - 1]" by simp
    from Suc(2) have gt: "n > 0" by simp
    moreover have "[MkI\<cdot>i..] = MkI\<cdot>i : [MkI\<cdot>i + 1..]" by (simp, subst intsFrom.simps) simp
    ultimately
    have *: "take\<cdot>(MkI\<cdot>n)\<cdot>[MkI\<cdot>i..] = MkI\<cdot>i : take\<cdot>(MkI\<cdot>(n - 1))\<cdot>[MkI\<cdot>(i+1)..]"
      by (simp add: one_Integer_def)
    show ?case unfolding IH * using gt by (simp add: one_Integer_def)
  qed
next
  fix m
  assume "n = - int m"
  then have "n \<le> 0" by simp
  then show ?thesis
    by (subst take.simps) (simp add: zero_Integer_def one_Integer_def)
qed

lemma drop_intsFrom_enumFrom [simp]:
  assumes "n \<ge> 0"
  shows "drop\<cdot>(MkI\<cdot>n)\<cdot>[MkI\<cdot>i..] = [MkI\<cdot>(n+i)..]"
proof-
  from assms obtain n' where "n = int n'" by (cases n, auto)
  then show ?thesis
    apply(induct n' arbitrary: n i )
     apply simp
    apply (subst intsFrom.simps[unfolded enumFrom_intsFrom_conv[symmetric]])
    apply (subst drop.simps)
    apply (auto simp add: zero_Integer_def one_Integer_def)
    apply (rule cfun_arg_cong)
    apply (rule cfun_arg_cong)
    apply arith
    done
qed

lemma last_append_singleton:
  "finite_list xs \<Longrightarrow> last\<cdot>(xs ++ [x]) = x"
proof (induct xs rule:finite_list.induct)
  case (Cons x xs)
  then show ?case by (cases xs) auto
qed auto

lemma init_append_singleton:
  "finite_list xs \<Longrightarrow> init\<cdot>(xs ++ [x]) = xs"
proof (induct xs rule:finite_list.induct)
  case (Cons x xs)
  then show ?case by (cases xs) auto
qed auto

lemma append_Nil2 [simp]:
  "xs ++ [] = xs"
  by (induct xs) simp_all

lemma append_assoc [simp]:
  "(xs ++ ys) ++ zs = xs ++ ys ++ zs"
  by (induct xs) simp_all

lemma concat_simps [simp]:
  "concat\<cdot>[] = []"
  "concat\<cdot>(xs : xss) = xs ++ concat\<cdot>xss"
  "concat\<cdot>\<bottom> = \<bottom>"
  unfolding concat_def by simp_all

lemma concatMap_simps [simp]:
  "concatMap\<cdot>f\<cdot>[] = []"
  "concatMap\<cdot>f\<cdot>(x : xs) = f\<cdot>x ++ concatMap\<cdot>f\<cdot>xs"
  "concatMap\<cdot>f\<cdot>\<bottom> = \<bottom>"
  unfolding concatMap_def by simp_all

lemma filter_append [simp]:
  "filter\<cdot>P\<cdot>(xs ++ ys) = filter\<cdot>P\<cdot>xs ++ filter\<cdot>P\<cdot>ys"
proof (induct xs)
  case (Cons x xs) then show ?case by (cases "P\<cdot>x") (auto simp: If_and_if)
qed simp_all

lemma elem_append [simp]:
  "elem\<cdot>x\<cdot>(xs ++ ys) = (elem\<cdot>x\<cdot>xs orelse elem\<cdot>x\<cdot>ys)"
    by (induct xs) auto

lemma filter_filter [simp]:
  "filter\<cdot>P\<cdot>(filter\<cdot>Q\<cdot>xs) = filter\<cdot>(\<Lambda> x. Q\<cdot>x andalso P\<cdot>x)\<cdot>xs"
  by (induct xs) (auto simp: If2_def [symmetric] split: split_If2)

lemma filter_const_TT [simp]:
  "filter\<cdot>(\<Lambda> _. TT)\<cdot>xs = xs"
  by (induct xs) simp_all

lemma tails_strict [simp]:
  "tails\<cdot>\<bottom> = \<bottom>"
  by fixrec_simp

lemma inits_strict [simp]:
  "inits\<cdot>\<bottom> = \<bottom>"
  by fixrec_simp

lemma the_and_strict [simp]:
  "the_and\<cdot>\<bottom> = \<bottom>"
  by fixrec_simp

lemma the_or_strict [simp]:
  "the_or\<cdot>\<bottom> = \<bottom>"
  by fixrec_simp

lemma all_strict [simp]:
  "all\<cdot>P\<cdot>\<bottom> = \<bottom>"
  by fixrec_simp

lemma any_strict [simp]:
  "any\<cdot>P\<cdot>\<bottom> = \<bottom>"
  by fixrec_simp

lemma tails_neq_Nil [simp]:
  "tails\<cdot>xs \<noteq> []"
  by (cases xs) simp_all

lemma inits_neq_Nil [simp]:
  "inits\<cdot>xs \<noteq> []"
  by (cases xs) simp_all

lemma Nil_neq_tails [simp]:
  "[] \<noteq> tails\<cdot>xs"
  by (cases xs) simp_all

lemma Nil_neq_inits [simp]:
  "[] \<noteq> inits\<cdot>xs"
  by (cases xs) simp_all

lemma finite_list_not_bottom [simp]:
  assumes "finite_list xs" shows "xs \<noteq> \<bottom>"
  using assms by (cases) simp_all

lemma head_append [simp]:
  "head\<cdot>(xs ++ ys) = If null\<cdot>xs then head\<cdot>ys else head\<cdot>xs"
  by (cases xs) simp_all

lemma filter_cong:
  "\<forall>x\<in>set xs. p\<cdot>x = q\<cdot>x \<Longrightarrow> filter\<cdot>p\<cdot>xs = filter\<cdot>q\<cdot>xs"
proof (induct arbitrary: xs rule: filter.induct)
  case (3 x)
  then show ?case by (cases xs) auto
qed simp_all

lemma filter_TT [simp]:
  assumes "\<forall>x\<in>set xs. P\<cdot>x = TT"
  shows "filter\<cdot>P\<cdot>xs = xs"
  by (rule filter_cong [of xs P "\<Lambda> _. TT", simplified, OF assms])

lemma filter_FF [simp]:
  assumes "finite_list xs"
    and "\<forall>x\<in>set xs. P\<cdot>x = FF"
  shows "filter\<cdot>P\<cdot>xs = []"
  using assms by (induct xs) simp_all

lemma map_cong:
  "\<forall>x\<in>set xs. p\<cdot>x = q\<cdot>x \<Longrightarrow> map\<cdot>p\<cdot>xs = map\<cdot>q\<cdot>xs"
proof (induct arbitrary: xs rule: map.induct)
  case (3 x)
  then show ?case by (cases xs) auto
qed simp_all

lemma finite_list_upto:
  "finite_list (upto\<cdot>(MkI\<cdot>m)\<cdot>(MkI\<cdot>n))" (is "?P m n")
proof (cases "n - m")
  fix d
  assume "n - m = int d"
  then show "?P m n"
  proof (induct d arbitrary: m n)
    case (Suc d)
    then have "n - (m + 1) = int d" and le: "m \<le> n" by simp_all
    from Suc(1) [OF this(1)] have IH: "?P (m+1) n" .
    then show ?case using le by (simp add: one_Integer_def)
  qed (simp add: one_Integer_def)
next
  fix d
  assume "n - m = - int d"
  then have "n \<le> m" by auto
  moreover
  have "?P m n" if "n = m" using that by (simp add: one_Integer_def)
  moreover
  have "?P m n" if "n < m" using that by (simp add: one_Integer_def)
  ultimately show ?thesis by arith
qed

lemma filter_commute:
  assumes "\<forall>x\<in>set xs. (Q\<cdot>x andalso P\<cdot>x) = (P\<cdot>x andalso Q\<cdot>x)"
  shows "filter\<cdot>P\<cdot>(filter\<cdot>Q\<cdot>xs) = filter\<cdot>Q\<cdot>(filter\<cdot>P\<cdot>xs)"
  using filter_cong [of xs "\<Lambda> x. Q\<cdot>x andalso P\<cdot>x" "\<Lambda> x. P\<cdot>x andalso Q\<cdot>x"]
    and assms by simp

lemma upto_append_intsFrom [simp]:
  assumes "m \<le> n"
  shows "upto\<cdot>(MkI\<cdot>m)\<cdot>(MkI\<cdot>n) ++ intsFrom\<cdot>(MkI\<cdot>n+1) = intsFrom\<cdot>(MkI\<cdot>m)"
    (is "?u m n ++ _ = ?i m")
proof (cases "n - m")
  case (nonneg i)
  with assms show ?thesis
  proof (induct i arbitrary: m n)
    case (Suc i)
    then have "m + 1 \<le> n" and "n - (m + 1) = int i" by simp_all
    from Suc(1) [OF this]
    have IH: "?u (m+1) n ++ ?i (n+1) = ?i (m+1)" by (simp add: one_Integer_def)
    then have "?u m n ++ ?i (n+1) = (MkI\<cdot>m : ?u (m+1) n) ++ ?i (n+1)"
      by (simp add: one_Integer_def)
    also have "\<dots> = MkI\<cdot>m : ?i (m+1)" by (simp add: IH)
    finally show ?case by (subst (2) intsFrom.simps) (simp add: one_Integer_def)
  qed (subst (2) intsFrom.simps, simp add: one_Integer_def)
next
  case (neg i)
  then have "n < m" by simp
  with assms show ?thesis by simp
qed

lemma set_upto [simp]:
  "set (upto\<cdot>(MkI\<cdot>m)\<cdot>(MkI\<cdot>n)) = {MkI\<cdot>i | i. m \<le> i \<and> i \<le> n}"
  (is "set (?u m n) = ?R m n")
proof (cases "n - m")
  case (nonneg i)
  then show ?thesis
  proof (induct i arbitrary: m n)
    case (Suc i)
    then have *: "n - (m + 1) = int i" by simp
    from Suc(1) [OF *] have IH: "set (?u (m+1) n) = ?R (m+1) n" .
    from * have "m \<le> n" by simp
    then have "set (?u m n) = set (MkI\<cdot>m : ?u (m+1) n)" by (simp add: one_Integer_def)
    also have "\<dots> = insert (MkI\<cdot>m) (?R (m+1) n)" by (simp add: IH)
    finally show ?case .
  qed (force simp: one_Integer_def)
qed simp

lemma Nil_append_iff [iff]:
  "xs ++ ys = [] \<longleftrightarrow> xs = [] \<and> ys = []"
  by (induct xs) simp_all


lemma bottom_neq_Nil [simp]: "\<bottom> \<noteq> []"
  by simp





lemma set_append [simp]:
  assumes "finite_list xs"
  shows "set (xs ++ ys) = set xs \<union> set ys"
  using assms by (induct) simp_all

lemma distinct_Cons [simp]:
  "distinct (x : xs) \<longleftrightarrow> distinct xs \<and> x \<notin> set xs"
  (is "?l = ?r")
proof
  assume ?l then show ?r by (cases) simp_all
next
  assume ?r then show ?l by auto
qed

lemma finite_list_append [iff]:
  "finite_list (xs ++ ys) \<longleftrightarrow> finite_list xs \<and> finite_list ys"
  (is "?l = ?r")
proof
  presume "finite_list xs" and "finite_list ys"
  then show ?l by (induct) simp_all
next
  assume "?l" then show "?r"
  proof (induct "xs ++ ys" arbitrary: xs ys)
    case (Cons x xs)
    then show ?case by (cases xs) auto
  qed simp
qed simp_all

lemma distinct_append [simp]:
  assumes "finite_list (xs ++ ys)"
  shows "distinct (xs ++ ys) \<longleftrightarrow> distinct xs \<and> distinct ys \<and> set xs \<inter> set ys = {}"
    (is "?P xs ys")
  using assms
proof (induct "xs ++ ys" arbitrary: xs ys)
  case Cons': (Cons z zs)
  show ?case
  proof (cases xs)
    case (Cons u us)
    with Cons' have "finite_list us"
      and [simp]: "zs = us ++ ys" "?P us ys" by simp_all
    then show ?thesis by (auto simp: Cons)
  qed (use Cons' in simp_all)
qed simp

lemma finite_set [simp]:
  assumes "distinct xs"
  shows "finite (set xs)"
  using assms by induct auto

lemma distinct_card:
  assumes "distinct xs"
  shows "MkI\<cdot>(int (card (set xs))) = length\<cdot>xs"
  using assms
  by (induct)
     (simp_all add: zero_Integer_def plus_MkI_MkI [symmetric] one_Integer_def ac_simps)

lemma set_delete [simp]:
  fixes xs :: "['a::Eq_eq]"
  assumes "distinct xs"
    and "\<forall>x\<in>set xs. eq\<cdot>a\<cdot>x \<noteq> \<bottom>"
  shows "set (delete\<cdot>a\<cdot>xs) = set xs - {a}"
  using assms
proof induct
  case (Cons x xs)
  then show ?case by (cases "eq\<cdot>a\<cdot>x", force+)
qed simp

lemma distinct_delete [simp]:
  fixes xs :: "['a::Eq_eq]"
  assumes "distinct xs"
    and "\<forall>x\<in>set xs. eq\<cdot>a\<cdot>x \<noteq> \<bottom>"
  shows "distinct (delete\<cdot>a\<cdot>xs)"
  using assms
proof induct
  case (Cons x xs)
  then show ?case by (cases "eq\<cdot>a\<cdot>x", force+)
qed simp

lemma set_diff [simp]:
  fixes xs ys :: "['a::Eq_eq]"
  assumes "distinct ys" and "distinct xs"
    and "\<forall>a\<in>set ys. \<forall>x\<in>set xs. eq\<cdot>a\<cdot>x \<noteq> \<bottom>"
  shows "set (xs \\\\ ys) = set xs - set ys"
  using assms
proof (induct arbitrary: xs)
  case Nil then show ?case by (induct xs rule: distinct.induct) simp_all
next
  case (Cons y ys)
  let ?xs = "delete\<cdot>y\<cdot>xs"
  from Cons have *: "\<forall>x\<in>set xs. eq\<cdot>y\<cdot>x \<noteq> \<bottom>" by simp
  have **: "set ?xs = set xs - {y}" .
  with Cons have "\<forall>a\<in>set ys. \<forall>x\<in>set ?xs. eq\<cdot>a\<cdot>x \<noteq> \<bottom>" by simp
  ultimately have "set (?xs \\\\ ys) = set ?xs - set ys"
    using Cons by blast
  then show ?case by (force simp: **)
lemma If_eq_bottom_iff [simp]: (* FIXME: move *)
lemma seq_eq_bottom_iff [simp]: (* FIXME: move *)
