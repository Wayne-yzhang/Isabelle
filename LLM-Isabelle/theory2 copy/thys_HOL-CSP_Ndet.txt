theory  Ndet 
imports Process
begin


definition
        Ndet     :: "['\<alpha> process,'\<alpha> process] \<Rightarrow> '\<alpha> process"   (infixl "|-|" 80)
where   "P |-| Q \<equiv> Abs_process(\<F> P \<union> \<F> Q , \<D> P \<union> \<D> Q)"

notation
  Ndet (infixl "\<sqinter>" 80)


lemma is_process_REP_Ndet:
"is_process (\<F> P \<union> \<F> Q , \<D> P \<union> \<D> Q)"
proof(simp only: fst_conv snd_conv Rep_process is_process_def DIVERGENCES_def FAILURES_def,
      intro conjI)
    show "([], {}) \<in> (\<F> P \<union> \<F> Q)"
         by(simp add: is_processT1)
next
    show "\<forall>s X. (s, X) \<in> (\<F> P \<union> \<F> Q) \<longrightarrow> front_tickFree s"
         by(auto simp: is_processT2)
next
    show "\<forall>s t.   (s @ t, {}) \<in>(\<F> P \<union> \<F> Q) \<longrightarrow> (s, {}) \<in> (\<F> P \<union> \<F> Q)"
         by (auto simp: is_processT1 dest!: is_processT3[rule_format])
next
    show "\<forall>s X Y. (s, Y) \<in> (\<F> P \<union> \<F> Q) \<and> X \<subseteq> Y \<longrightarrow> (s, X) \<in> (\<F> P \<union> \<F> Q)"
         by(auto dest: is_processT4[rule_format,OF conj_commute[THEN iffD1], OF conjI])
next
    show "\<forall>sa X Y. (sa, X) \<in> (\<F> P \<union> \<F> Q) \<and> (\<forall>c. c \<in> Y \<longrightarrow> (sa @ [c], {}) \<notin> (\<F> P \<union> \<F> Q))
          \<longrightarrow> (sa, X \<union> Y) \<in> (\<F> P \<union> \<F> Q)"
         by(auto simp: is_processT5 T_F)
next
    show "\<forall>s X. (s @ [tick], {}) \<in> (\<F> P \<union> \<F> Q) \<longrightarrow> (s, X - {tick}) \<in> (\<F> P \<union> \<F> Q)"
         apply((rule allI)+, rule impI)
         apply(rename_tac s X, case_tac "s=[]", simp_all add: is_processT6[rule_format] T_F_spec)
         apply(erule disjE,simp_all add: is_processT6[rule_format] T_F_spec)
         apply(erule disjE,simp_all add: is_processT6[rule_format] T_F_spec)
         done
next
    show "\<forall>s t. s \<in> \<D> P \<union> \<D> Q \<and> tickFree s \<and> front_tickFree t \<longrightarrow> s @ t \<in> \<D> P \<union> \<D> Q"
         by(auto simp: is_processT7)
next
    show "\<forall>s X. s \<in> \<D> P \<union> \<D> Q \<longrightarrow> (s, X) \<in> (\<F> P \<union> \<F> Q)"
         by(auto simp: is_processT8[rule_format])
next
    show "\<forall>s. s @ [tick] \<in> \<D> P \<union> \<D> Q \<longrightarrow> s \<in> \<D> P \<union> \<D> Q"
         by(auto intro!:is_processT9[rule_format])
qed


lemma Rep_Abs_Ndet:
"Rep_process(Abs_process(\<F> P \<union> \<F> Q , \<D> P \<union> \<D> Q)) = (\<F> P \<union> \<F> Q , \<D> P \<union> \<D> Q)"
  by(simp only:CollectI Rep_process Abs_process_inverse is_process_REP_Ndet)


lemma F_Ndet : "\<F> (P \<sqinter> Q) = \<F> P \<union> \<F> Q"
  apply (subst Failures_def)
  apply (simp only: Ndet_def)
  by (simp add: FAILURES_def Rep_Abs_Ndet)


lemma D_Ndet : "\<D>(P \<sqinter> Q) = \<D> P \<union> \<D> Q"
  by(subst D_def, simp only: Ndet_def Rep_Abs_Ndet DIVERGENCES_def snd_conv)


lemma T_Ndet : "\<T> (P \<sqinter> Q) = \<T> P \<union> \<T> Q"
apply(subst Traces_def, simp only: Ndet_def Rep_Abs_Ndet TRACES_def FAILURES_def
                             fst_def snd_conv)
apply(auto simp: T_F F_T is_processT1 Nil_elem_T)
apply(rule_tac x="{}" in exI, simp add: T_F F_T is_processT1 Nil_elem_T)+
done

lemma Ndet_commute: "(P \<sqinter> Q) = (Q \<sqinter> P)"
by(auto simp: Process_eq_spec F_Ndet D_Ndet)

lemma  mono_Ndet1: "P \<sqsubseteq> Q \<Longrightarrow> \<D> (Q \<sqinter> S) \<subseteq> \<D> (P \<sqinter> S)"
apply(drule le_approx1)
by (auto simp: Process_eq_spec F_Ndet D_Ndet)

lemma mono_Ndet2: "P \<sqsubseteq> Q \<Longrightarrow> (\<forall> s. s \<notin> \<D> (P \<sqinter> S) \<longrightarrow> Ra (P \<sqinter> S) s = Ra (Q \<sqinter> S) s)"
apply(subst (asm) le_approx_def)
by (auto simp: Process_eq_spec F_Ndet D_Ndet Ra_def)

lemma mono_Ndet3: "P \<sqsubseteq> Q \<Longrightarrow> min_elems (\<D> (P \<sqinter> S)) \<subseteq> \<T> (Q \<sqinter> S)"
apply(auto dest!:le_approx3 simp: min_elems_def subset_iff F_Ndet D_Ndet T_Ndet)
apply(erule_tac x="t" in allE, auto)
by (erule_tac x="[]" in allE, auto simp: less_list_def Nil_elem_T D_T)

lemma mono_Ndet[simp] : "P \<sqsubseteq> Q \<Longrightarrow> (P \<sqinter> S) \<sqsubseteq> (Q \<sqinter> S)"
by(auto simp:le_approx_def mono_Ndet1 mono_Ndet2 mono_Ndet3)

lemma mono_Ndet_sym[simp] : "P \<sqsubseteq> Q \<Longrightarrow> (S \<sqinter> P) \<sqsubseteq> (S \<sqinter> Q)"
by (auto simp: Ndet_commute)


lemma cont_Ndet1: 
assumes chain:"chain Y"
shows  "((\<Squnion> i. Y i) \<sqinter> S) = (\<Squnion> i. (Y i \<sqinter> S))"
proof -
   have A : "chain (\<lambda>i. Y i \<sqinter> S)"
        apply(insert chain,rule chainI)
        apply(frule_tac i="i" in chainE)
        by(simp)
   show ?thesis using chain
        by(auto simp add: limproc_is_thelub Process_eq_spec D_Ndet F_Ndet F_LUB D_LUB A)
qed


lemma Ndet_cont[simp]: 
assumes f: "cont f"
and     g: "cont g"
shows      "cont (\<lambda>x. f x \<sqinter> g x)"
proof -
   have A:"\<And>x. cont f \<Longrightarrow> cont g \<Longrightarrow> cont (\<lambda>X. (f x)\<sqinter> X)"
          apply(rule contI2, rule monofunI)
          apply(auto)
          apply(subst Ndet_commute, subst cont_Ndet1)
          by   (auto simp:Ndet_commute)
   have B:"\<And>y. cont f \<Longrightarrow> cont g \<Longrightarrow> cont (\<lambda>x. f x \<sqinter> y)"
          apply(rule_tac c="(\<lambda> g. g \<sqinter> y)" in cont_compose)
          apply(rule contI2,rule monofunI)
          by   (simp_all add: cont_Ndet1)
   show ?thesis using f g
   by (rule_tac f="(\<lambda> x. (\<lambda> g. f x \<sqinter> g))" in cont_apply, auto simp: A B)
qed


end
