theory Encodings
imports G T E
begin










theorem tags_soundness:
fixes wtFsym :: "'fsym \<Rightarrow> bool" and wtPsym :: "'psym \<Rightarrow> bool"
and arOf :: "'fsym \<Rightarrow> 'tp list" and resOf :: "'fsym \<Rightarrow> 'tp" and parOf :: "'psym \<Rightarrow> 'tp list"
and \<Phi> :: "('fsym, 'psym) prob" and infTp :: "'tp \<Rightarrow> bool"
and tpD :: "'tp \<Rightarrow> bool" and tpFD :: "'tp \<Rightarrow> bool"
and intT :: "'tp \<Rightarrow> univ \<Rightarrow> bool"
and intF :: "'fsym \<Rightarrow> univ list \<Rightarrow> univ" and intP :: "'psym \<Rightarrow> univ list \<Rightarrow> bool"
defines "TE_wtFsym \<equiv> ProblemIkTpart.TE_wtFsym wtFsym resOf"
and "TE_arOf \<equiv> ProblemIkTpart.TE_arOf arOf"
and "TE_resOf \<equiv> ProblemIkTpart.TE_resOf resOf"
defines "TE_\<Phi> \<equiv> ProblemIkTpart.tPB wtFsym arOf resOf \<Phi> tpD tpFD"
and "U_arOf \<equiv> length \<circ> TE_arOf"
and "U_parOf \<equiv> length \<circ> parOf"
defines "U_\<Phi> \<equiv> TE_\<Phi>"
defines "intTI \<equiv> MonotProblem.intTI TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\<Phi>"
and "intFI \<equiv> MonotProblem.intFI TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\<Phi>"
and "intPI \<equiv> MonotProblem.intPI TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\<Phi>"
defines "intFF \<equiv> InfModel.intFF TE_arOf TE_resOf intTI intFI"
and "intPF \<equiv> InfModel.intPF parOf intTI intPI"
defines "U_intT \<equiv> InfModel.intTF (any::'tp)"

assumes
P: "ProblemIkTpart wtFsym wtPsym arOf resOf parOf \<Phi> infTp tpD tpFD"
and M: "CM.Model wtFsym wtPsym arOf resOf parOf \<Phi> intT intF intP"

shows "CU.Model TE_wtFsym wtPsym U_arOf U_parOf U_\<Phi> U_intT intFF intPF"

unfolding U_arOf_def U_parOf_def U_\<Phi>_def
unfolding U_intT_def intTI_def intFI_def intPI_def intFF_def intPF_def
apply(rule M_MonotModel.M_U_soundness)
unfolding M_MonotModel_def MonotModel_def apply safe
  unfolding TE_wtFsym_def TE_arOf_def TE_resOf_def TE_\<Phi>_def
  apply(rule ProblemIkTpart.T_monotonic)
   apply(rule P)
   apply(rule ModelIkTpart.T_soundness) unfolding ModelIkTpart_def apply safe
     apply(rule P)
     apply(rule M)
done





theorem guards_soundness:
fixes wtFsym :: "'fsym \<Rightarrow> bool" and wtPsym :: "'psym \<Rightarrow> bool"
and arOf :: "'fsym \<Rightarrow> 'tp list" and resOf :: "'fsym \<Rightarrow> 'tp" and parOf :: "'psym \<Rightarrow> 'tp list"
and \<Phi> :: "('fsym, 'psym) prob" and infTp :: "'tp \<Rightarrow> bool"
and tpD :: "'tp \<Rightarrow> bool" and tpFD :: "'tp \<Rightarrow> bool" and tpCD :: "'tp \<Rightarrow> bool"
and intT :: "'tp \<Rightarrow> univ \<Rightarrow> bool"
and intF :: "'fsym \<Rightarrow> univ list \<Rightarrow> univ"
and intP :: "'psym \<Rightarrow> univ list \<Rightarrow> bool"
defines "GE_wtFsym \<equiv> ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD"
and "GE_wtPsym \<equiv> ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD"
and "GE_arOf \<equiv> ProblemIkTpartG.GE_arOf arOf"
and "GE_resOf \<equiv> ProblemIkTpartG.GE_resOf resOf"
and "GE_parOf \<equiv> ProblemIkTpartG.GE_parOf parOf"

defines "GE_\<Phi> \<equiv> ProblemIkTpartG.gPB wtFsym arOf resOf \<Phi> tpD tpFD tpCD"
and "U_arOf \<equiv> length \<circ> GE_arOf"
and "U_parOf \<equiv> length \<circ> GE_parOf"

defines "U_\<Phi> \<equiv> GE_\<Phi>"

defines "intTI \<equiv> MonotProblem.intTI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\<Phi>"
and "intFI \<equiv> MonotProblem.intFI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\<Phi>"
and "intPI \<equiv> MonotProblem.intPI GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\<Phi>"

defines "intFF \<equiv> InfModel.intFF GE_arOf GE_resOf intTI intFI"
and "intPF \<equiv> InfModel.intPF GE_parOf intTI intPI"

defines "U_intT \<equiv> InfModel.intTF (any::'tp)"

assumes
P: "ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \<Phi> infTp tpD tpFD tpCD"
and M: "CM.Model wtFsym wtPsym arOf resOf parOf \<Phi> intT intF intP"

shows "CU.Model GE_wtFsym GE_wtPsym U_arOf U_parOf U_\<Phi> U_intT intFF intPF"

unfolding U_arOf_def U_parOf_def U_\<Phi>_def
unfolding U_intT_def intTI_def intFI_def intPI_def intFF_def intPF_def
apply(rule M_MonotModel.M_U_soundness)
unfolding M_MonotModel_def MonotModel_def apply safe
  unfolding GE_wtFsym_def GE_wtPsym_def GE_arOf_def GE_resOf_def GE_parOf_def GE_\<Phi>_def
  apply(rule ProblemIkTpartG.G_monotonic)
   apply(rule P)
   apply(rule ModelIkTpartG.G_soundness)
   unfolding ModelIkTpartG_def ModelIkTpart_def apply safe
     apply(rule P)
     using P unfolding ProblemIkTpartG_def apply fastforce
     apply(rule M)
done







theorem tags_completeness:
fixes wtFsym :: "'fsym \<Rightarrow> bool" and wtPsym :: "'psym \<Rightarrow> bool"
and arOf :: "'fsym \<Rightarrow> 'tp list" and resOf :: "'fsym \<Rightarrow> 'tp" and parOf :: "'psym \<Rightarrow> 'tp list"
and \<Phi> :: "('fsym, 'psym) prob" and infTp :: "'tp \<Rightarrow> bool"
and tpD :: "'tp \<Rightarrow> bool" and tpFD :: "'tp \<Rightarrow> bool"

and D :: "univ \<Rightarrow> bool"
and eintF :: "('fsym,'tp) T.efsym \<Rightarrow> univ list \<Rightarrow> univ"
and eintP :: "'psym \<Rightarrow> univ list \<Rightarrow> bool"

defines "TE_wtFsym \<equiv> ProblemIkTpart.TE_wtFsym wtFsym resOf"
and "TE_arOf \<equiv> ProblemIkTpart.TE_arOf arOf"
and "TE_resOf \<equiv> ProblemIkTpart.TE_resOf resOf"
defines "TE_\<Phi> \<equiv> ProblemIkTpart.tPB wtFsym arOf resOf \<Phi> tpD tpFD"
and "U_arOf \<equiv> length \<circ> TE_arOf"
and "U_parOf \<equiv> length \<circ> parOf"
defines "U_\<Phi> \<equiv> TE_\<Phi>"

defines "intT \<equiv> ProblemIkTpart_TEModel.intT tpD tpFD (\<lambda>\<sigma>::'tp. D) eintF"
and "intF \<equiv> ProblemIkTpart_TEModel.intF arOf resOf tpD tpFD (\<lambda>\<sigma>::'tp. D) eintF"
and "intP \<equiv> ProblemIkTpart_TEModel.intP parOf tpD tpFD (\<lambda>\<sigma>::'tp. D) eintF eintP"

assumes
P: "ProblemIkTpart wtFsym wtPsym arOf resOf parOf \<Phi> infTp tpD tpFD" and
M: "CU.Model TE_wtFsym wtPsym (length o TE_arOf)
            (length o parOf) TE_\<Phi> D eintF eintP"

shows "CM.Model wtFsym wtPsym arOf resOf parOf \<Phi> intT intF intP"
proof-
  have UM: "UM_Model TE_wtFsym wtPsym TE_arOf TE_resOf parOf TE_\<Phi> D eintF eintP"
  unfolding UM_Model_def UM_Struct_def
  using M unfolding CU.Model_def CU.Struct_def U.Model_def
  using ProblemIkTpart.T_monotonic[OF P,
  unfolded TE_wtFsym_def[symmetric] TE_arOf_def[symmetric]
           TE_resOf_def[symmetric] TE_\<Phi>_def[symmetric]]
  by (auto simp: MonotProblem_def M_Problem_def M_Signature_def M.Problem_def)
  show ?thesis
  unfolding intT_def intF_def intP_def
  apply(rule ProblemIkTpart_TEModel.T_completeness)
  unfolding ProblemIkTpart_TEModel_def apply safe
  apply(rule P)
  apply(rule UM_Model.M_U_completeness)
  apply(rule UM[unfolded TE_wtFsym_def TE_arOf_def TE_resOf_def TE_\<Phi>_def])
  done
qed


theorem guards_completeness:
fixes wtFsym :: "'fsym \<Rightarrow> bool" and wtPsym :: "'psym \<Rightarrow> bool"
and arOf :: "'fsym \<Rightarrow> 'tp list" and resOf :: "'fsym \<Rightarrow> 'tp" and parOf :: "'psym \<Rightarrow> 'tp list"
and \<Phi> :: "('fsym, 'psym) prob" and infTp :: "'tp \<Rightarrow> bool"
and tpD :: "'tp \<Rightarrow> bool" and tpFD :: "'tp \<Rightarrow> bool" and tpCD :: "'tp \<Rightarrow> bool"

and D :: "univ \<Rightarrow> bool"
and eintF :: "('fsym,'tp) G.efsym \<Rightarrow> univ list \<Rightarrow> univ"
and eintP :: "('psym,'tp) G.epsym \<Rightarrow> univ list \<Rightarrow> bool"

defines "GE_wtFsym \<equiv> ProblemIkTpartG.GE_wtFsym wtFsym resOf tpCD"
and "GE_wtPsym \<equiv> ProblemIkTpartG.GE_wtPsym wtPsym tpD tpFD"
and "GE_arOf \<equiv> ProblemIkTpartG.GE_arOf arOf"
and "GE_resOf \<equiv> ProblemIkTpartG.GE_resOf resOf"
and "GE_parOf \<equiv> ProblemIkTpartG.GE_parOf parOf"
defines "GE_\<Phi> \<equiv> ProblemIkTpartG.gPB wtFsym arOf resOf \<Phi> tpD tpFD tpCD"
and "U_arOf \<equiv> length \<circ> GE_arOf"
and "U_parOf \<equiv> length \<circ> GE_parOf"
defines "U_\<Phi> \<equiv> GE_\<Phi>"

defines "intT \<equiv> ProblemIkTpartG_GEModel.intT tpD tpFD (\<lambda>\<sigma>::'tp. D) eintP"
and "intF \<equiv> ProblemIkTpartG_GEModel.intF eintF"
and "intP \<equiv> ProblemIkTpartG_GEModel.intP eintP"

assumes
P: "ProblemIkTpartG wtFsym wtPsym arOf resOf parOf \<Phi> infTp tpD tpFD tpCD" and
M: "CU.Model GE_wtFsym GE_wtPsym (length o GE_arOf)
            (length o GE_parOf) GE_\<Phi> D eintF eintP"

shows "CM.Model wtFsym wtPsym arOf resOf parOf \<Phi> intT intF intP"
proof-
  have UM: "UM_Model GE_wtFsym GE_wtPsym GE_arOf GE_resOf GE_parOf GE_\<Phi> D eintF eintP"
  unfolding UM_Model_def UM_Struct_def
  using M unfolding CU.Model_def CU.Struct_def U.Model_def
  using ProblemIkTpartG.G_monotonic[OF P,
  unfolded GE_wtFsym_def[symmetric] GE_arOf_def[symmetric]
           GE_wtPsym_def[symmetric] GE_parOf_def[symmetric]
           GE_resOf_def[symmetric] GE_\<Phi>_def[symmetric]]
  by (auto simp: MonotProblem_def M_Problem_def M_Signature_def M.Problem_def)
  show ?thesis
  unfolding intT_def intF_def intP_def
  apply(rule ProblemIkTpartG_GEModel.G_completeness)
  unfolding ProblemIkTpartG_GEModel_def apply safe
  apply(rule P)
  apply(rule UM_Model.M_U_completeness)
  apply(rule UM[unfolded GE_wtFsym_def GE_wtPsym_def GE_parOf_def
             GE_arOf_def GE_resOf_def GE_\<Phi>_def])
  done
qed

end
