theory Contrasim_Word_Game
imports
  Simple_Game
  Contrasimulation
begin

datatype ('s, 'a) c_word_game_node =
  AttackerNode 's 's |
  DefenderNode "'a list" 's 's

fun (in lts_tau) c_word_game_moves ::
                             
  simulation_challenge:

  simulation_answer:                        
                                             
  c_word_game_moves_no_step:               




locale c_word_game =
  lts_tau trans \<tau> +
  simple_game c_word_game_moves c_word_game_defender_node
for
begin


lemma cwg_atknodes_precede_defnodes_in_plays: 
  assumes 
proof -
    by (metis list.inject list.sel(1) plays.cases)     
    by (metis c_word_game_node.inject(2) c_word_game_defender_node.simps(1) c_word_game_moves.elims(2))
  thus ?thesis using mov by auto
qed

lemma cwg_second_play_elem_in_play_set : 
  assumes 
proof - 
    using plays.cases by blast 
qed

lemma cwg_contrasim_contains_all_strat_consistent_atknodes:
  assumes 
  using assms(4)
proof (induct arbitrary: p q rule: plays_for_0strategy.induct[OF assms(4)])
  case 1 
  fix p q
next 
  case p0moved: (2 n0 play)
  from p0moved.prems have
    by simp
    by simp
  proof (rule disjE)
  next
      by (metis (no_types, lifting) A c_word_game_node.inject(1) 
          c_word_game_defender_node.elims(2))
    then obtain A ppred where 
      by (metis assms(3) c_word_game.cwg_atknodes_precede_defnodes_in_plays
          simulation_challenge p0moved.hyps(1, 3) strategy0_plays_subset)
      using cwg_atknodes_precede_defnodes_in_plays strategy0_plays_subset[OF p0moved.hyps(1)]
      by (simp add: assms(3) n0_def  p0moved.hyps(3)) 
      using cwg_second_play_elem_in_play_set strategy0_plays_subset[OF p0moved.hyps(1)] assms(3)
      by (auto simp add: n0_def)
      by (simp add: qpred_def p0moved.hyps(1) p0moved.hyps(2))
     unfolding contrasimulation_def by blast
  qed
next
  case p1moved: (3 n1 play n1')
  proof (rule disjE)
  next
     by (metis c_word_game_defender_node.simps(2) c_word_game_moves.elims(2) p1moved.hyps(4))
 qed
qed

lemma contrasim_word_game_complete:
  assumes 
    unfolding player0_winning_strategy_def 
proof (safe)
  fix play
    unfolding player1_wins_immediately_def
  proof - 
    proof (induct rule: simple_game.plays_for_0strategy.induct[OF A1])
      case init: 1 
      then show ?case ..
    next
      case p0moved: (2 n0 play)
        by (meson c_word_game_defender_node.elims(2)) 
        using p0moved.hyps(4) c_word_game_moves.elims(2)
        by force 
      then show ?case ..
    next
      case p1moved: (3 n1 play n1')
        using c_word_game_defender_node.elims(3) by auto
        using cwg_contrasim_contains_all_strat_consistent_atknodes[OF assms,
        by auto
        using c_word_game_defender_node.elims(2)[OF is_def] by auto
        using p1moved.hyps n1_def n1'_def by auto
      from assms(1) have Contra:
        unfolding contrasimulation_def by auto
        using same_q n1'_def by auto
      then show ?case by auto
    qed
  qed
qed


lemma cwg_strategy_from_contrasim_sound: 
  assumes
  shows
  unfolding sound_0strategy_def
proof (safe)
  fix n0 play
  assume A:
    using c_word_game_defender_node.elims(2) by blast 
    using n0_def A cwg_atknodes_precede_defnodes_in_plays assms(3) strategy0_plays_subset 
    by blast
    using A n0_def 
    by (metis assms(3) cwg_atknodes_precede_defnodes_in_plays strategy0_plays_subset)
    using cwg_contrasim_contains_all_strat_consistent_atknodes A assms
      cwg_second_play_elem_in_play_set n0_def strategy0_plays_subset
    by fastforce
    using assms(2) unfolding contrasimulation_def by blast
  from n0_def have
    by auto
  then obtain q' where
    using q'_def by (simp add: n0_def) 
qed

lemma contrasim_word_game_sound: 
  assumes
  defines
  shows
proof (safe) 
  fix p q p1 A
    using R_def by auto
  from this obtain play where play_def:
    using player0_winning_strategy_def play_def by auto
    using player1_wins_immediately_def by auto
  hence Def_not_stuck: 
    by auto
  proof -
      by (metis hd_Cons_tl play_def strategy0_plays_subset no_empty_plays) 
      using plays_for_0strategy.p1move[OF inF pl1 mov0] .
      by (simp add: sym[OF play_split])
  qed
    by (simp add: A1)
    using assms(1) player0_winning_strategy_def by auto
    using player1_wins_immediately_def by auto
    using assms(2) def_in_f sound_0strategy_def by auto
    using plays_for_0strategy.p0move[OF def_in_f] by auto
  obtain n1 where
    using move_ex by auto
  from this obtain q1 where
    using q1_def move_ex n1_def by auto
    using q1_def n1_def in_f by auto
  then obtain R_play where
qed

theorem winning_strategy_in_c_word_game_iff_contrasim:
  assumes
  shows 
proof
  assume
  then obtain f where
    using contrasim_word_game_sound by blast
  moreover have
    using assms plays_for_0strategy.init[of _ f] by (meson list.sel(1))
next
  assume
    using contrasim_word_game_complete[OF _ _ assms]
         cwg_strategy_from_contrasim_sound[OF _ _ assms] by blast
qed

end                         
end