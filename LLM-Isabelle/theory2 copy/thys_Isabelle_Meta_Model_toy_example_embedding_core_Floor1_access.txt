theory  Floor1_access
imports Core_init
begin

definition "print_access_oid_uniq_gen Thy_def D_toy_oid_start_upd def_rewrite =
  (\<lambda>expr env.
      (\<lambda>(l, oid_start). (L.map Thy_def l, D_toy_oid_start_upd env oid_start))
      (let (l, (acc, _)) = fold_class (\<lambda>isub_name name l_attr l_inh _ _ cpt.
         let l_inh = L.map (\<lambda> ToyClass _ l _ \<Rightarrow> l) (of_inh l_inh) in
         let (l, cpt) = L.mapM (L.mapM
           (\<lambda> (attr, ToyTy_object (ToyTyObj (ToyTyCore ty_obj) _)) \<Rightarrow>
                                            (let obj_oid = TyObj_ass_id ty_obj
                                               ; obj_name_from_nat = TyObjN_ass_switch (TyObj_from ty_obj) in \<lambda>(cpt, rbt) \<Rightarrow>
             let (cpt_obj, cpt_rbt) =
               case RBT.lookup rbt obj_oid of
                 None \<Rightarrow> (cpt, oidSucAssoc cpt, RBT.insert obj_oid cpt rbt)
               | Some cpt_obj \<Rightarrow> (cpt_obj, cpt, rbt) in
             ( [def_rewrite obj_name_from_nat name isub_name attr (oidGetAssoc cpt_obj)]
             , cpt_rbt))
            | _ \<Rightarrow> \<lambda>cpt. ([], cpt)))
           (l_attr # l_inh) cpt in
         (L.flatten (L.flatten l), cpt)) (D_toy_oid_start env, RBT.empty) expr in
       (L.flatten l, acc)))"
definition "print_access_oid_uniq =
  print_access_oid_uniq_gen
    O.definition
    (\<lambda>env oid_start. env \<lparr> D_toy_oid_start := oid_start \<rparr>)
    (\<lambda>obj_name_from_nat _ isub_name attr cpt_obj.
      Definition (Term_rewrite
                   (Term_basic [print_access_oid_uniq_name obj_name_from_nat isub_name attr])

definition "print_access_choose_switch
              lets mk_var expr
              print_access_choose_n
              sexpr_list sexpr_function sexpr_pair =
  L.flatten
       (L.map
          (\<lambda>n.
           let l = L.upto 0 (n - 1) in
           L.map (let l = sexpr_list (L.map mk_var l) in (\<lambda>(i,j).
             (lets
                (print_access_choose_n n i j)
                (sexpr_function [(l, (sexpr_pair (mk_var i) (mk_var j)))]))))
             ((L.flatten o L.flatten) (L.map (\<lambda>i. L.map (\<lambda>j. if i = j then [] else [(i, j)]) l) l)))
          (class_arity expr))"
definition "print_access_choose = start_map'''' O.definition o (\<lambda>expr _.
  (let a = \<lambda>f x. Term_app f [x]
     ; b = \<lambda>s. Term_basic [s]
        [ lets l_flatten (let fun_foldl = \<lambda>f base.
                           fun_foldl (\<lambda>var_acc.
                             fun_foldl (\<lambda>var_acc.
                  ; f_map = a var_map in
                Term_lambdas0 (Term_pair (b var_x) (b var_l1))
                  (Term_case (f_map (b var_x))
                      , (Term_some (b var_l0), a l_flatten (Term_list (L.map b [var_l0, var_l1])))])))
  L.flatten
  [ let a = \<lambda>f x. Term_app f [x]
      ; b = \<lambda>s. Term_basic [s]
    print_access_choose_switch
      lets mk_var expr
      print_access_choose_name
      Term_list Term_function Term_pair
  , []] ))"

end
