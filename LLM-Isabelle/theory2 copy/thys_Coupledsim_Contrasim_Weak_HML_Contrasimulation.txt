theory Weak_HML_Contrasimulation
  imports
    Contrasim_Set_Game
    HM_Logic_Infinitary
begin


locale c_game_with_attacker_strategy  =
  c_set_game trans \<tau>
for
fixes
  attacker_order
defines
assumes
  finite_win:
  strat_stays_winning:
  defender_keeps_losing:
begin

  attacker strategy. (If it's winning and sound, the constructed formula should be distinguishing.)\<close>
function attack_formula :: \<open>('s, 'a) c_set_game_node \<Rightarrow> ('a,'s) HML_formula\<close> where
  \<open>attack_formula (AttackerNode p Q) =
    (if (AttackerNode p Q) \<in> attacker_winning_region
      then attack_formula (strat (AttackerNode p Q))
      else HML_true)\<close>
| \<open>attack_formula (DefenderSimNode a p Q) =
    (if (DefenderSimNode a p Q) \<in> attacker_winning_region
      then \<langle>\<tau>\<rangle>\<langle>a\<rangle>(attack_formula (AttackerNode p (dsuccs a Q)))
      else HML_true)\<close>
| \<open>attack_formula (DefenderSwapNode p Q) =
    (if Q = {} \<or> DefenderSwapNode p Q \<notin> attacker_winning_region
      then HML_true
      else (HML_weaknor (weak_tau_succs Q)
        (\<lambda>q. if q \<in> (weak_tau_succs Q)
              then (attack_formula (AttackerNode q {p}))
              else HML_true )))\<close>
  assume \<open>AttackerNode p Q \<in> attacker_winning_region\<close>
  thus \<open>(strat (AttackerNode p Q), AttackerNode p Q) \<in> attacker_order\<close>
  assume attacker_wins: \<open>DefenderSimNode a p Q \<in> attacker_winning_region\<close>
  hence \<open>AttackerNode p (dsuccs a Q) \<in> attacker_winning_region\<close>
    \<open>(AttackerNode p (dsuccs a Q), DefenderSimNode a p Q) \<in> attacker_order\<close>
    \<open>q' \<in> weak_tau_succs Q\<close>
    \<open>(AttackerNode q' {p}, DefenderSwapNode p Q) \<notin> attacker_order\<close>
    \<open>DefenderSwapNode p Q \<in> attacker_winning_region\<close>
    \<open>q \<in> Q\<close>
  hence \<open>AttackerNode q' {p} \<notin> attacker_winning_region\<close>
  moreover from case_assms have \<open>AttackerNode q' {p} \<in> attacker_winning_region\<close>
  ultimately show \<open>q \<in> {}\<close> by blast
    \<open>(AttackerNode p Q) \<in> attacker_winning_region\<close>
    \<open>(\<exists>a p'. (strat (AttackerNode p Q)) = (DefenderSimNode a p' Q) \<and> p  =\<rhd>a p' \<and> \<not>tau a)
    \<or>(\<exists>p'. (strat (AttackerNode p Q)) = (DefenderSwapNode p' Q) \<and> p \<longmapsto>* tau p' )\<close>
  using strat_stays_winning[OF assms] by (cases \<open>strat (AttackerNode p Q)\<close>, auto)
    \<open>(AttackerNode p Q) \<in> attacker_winning_region\<close>
    \<open>(\<exists>a p'. p =\<rhd>a p' \<and> \<not>tau a \<and> strat (AttackerNode p Q) = (DefenderSimNode a p' Q) \<and>
      attack_formula (AttackerNode p Q)
      = \<langle>\<tau>\<rangle>\<langle>a\<rangle>(attack_formula (AttackerNode p' (dsuccs a Q))))
    \<or> (\<exists>p'. p \<longmapsto>* tau p' \<and> strat (AttackerNode p Q) = (DefenderSwapNode p' Q) \<and>
      attack_formula (AttackerNode p Q) =
      (HML_weaknor (weak_tau_succs Q) (\<lambda>q. 
        if q \<in> (weak_tau_succs Q)
          then (attack_formula (AttackerNode q {p'}))
          else HML_true )))
    \<or> (Q = {} \<and> attack_formula (AttackerNode p Q) = HML_true)\<close>
    \<open>attack_formula (AttackerNode p Q) = attack_formula (strat (AttackerNode p Q))\<close>
    \<open>(\<exists>a p'. (strat (AttackerNode p Q)) = (DefenderSimNode a p' Q) \<and> p  =\<rhd>a p' \<and> \<not>tau a)
    \<or> (\<exists>p'. (strat (AttackerNode p Q)) = (DefenderSwapNode p' Q) \<and> p \<longmapsto>* tau p')\<close>
    \<open> (\<exists>a p'. (strat (AttackerNode p Q)) = (DefenderSimNode a p' Q) \<and>
      (attack_formula (AttackerNode p Q))
       = attack_formula (DefenderSimNode a p' Q) \<and> p  =\<rhd>a p' \<and> \<not>tau a)
    \<or> (\<exists>p'. (strat (AttackerNode p Q)) = (DefenderSwapNode p' Q) \<and>
      (attack_formula (AttackerNode p Q))
       = attack_formula (DefenderSwapNode p' Q) \<and> p \<longmapsto>* tau p')\<close>
  moreover from assms have \<open>strat (AttackerNode p Q) \<in> attacker_winning_region\<close>
    \<open>pQ == AttackerNode p Q\<close>
    \<open>\<phi> == attack_formula pQ\<close>
    \<open>pQ \<in> attacker_winning_region\<close>
    \<open>p \<Turnstile> \<phi> \<and> (\<forall>q\<in>Q. \<not> q \<Turnstile> \<phi>)\<close>
    assume \<open>\<exists>a p'. p =\<rhd> a  p' \<and> \<not> tau a \<and>
      strat (AttackerNode p Q) = DefenderSimNode a p' Q \<and>
      attack_formula (AttackerNode p Q) = \<langle>\<tau>\<rangle>\<langle>a\<rangle>attack_formula (AttackerNode p' (dsuccs a Q))\<close>
      \<open>p =\<rhd> a  p' \<and> \<not> tau a\<close>
      \<open>strat (AttackerNode p Q) = DefenderSimNode a p' Q\<close>
      \<open>attack_formula (AttackerNode p Q)
      = \<langle>\<tau>\<rangle>\<langle>a\<rangle>attack_formula (AttackerNode p' (dsuccs a Q))\<close> by blast
      \<open>c_set_game_moves (AttackerNode p Q) (DefenderSimNode a p' Q)\<close>
      \<open>c_set_game_moves (DefenderSimNode a p' Q) (AttackerNode p' (dsuccs a Q))\<close> by auto
      \<open>(AttackerNode p' (dsuccs a Q)) \<in> attacker_winning_region\<close>
      \<open>(DefenderSimNode a p' Q) \<in> attacker_winning_region\<close>
      \<open>(AttackerNode p' (dsuccs a Q), DefenderSimNode a p' Q) \<in> attacker_order\<close>
      \<open>(DefenderSimNode a p' Q, AttackerNode p Q) \<in> attacker_order\<close>
    hence \<open>(AttackerNode p' (dsuccs a Q), AttackerNode p Q) \<in> attacker_order\<close>
      \<open>p' \<Turnstile> attack_formula (AttackerNode p' (dsuccs a Q)) \<and>
      (\<forall>q\<in>(dsuccs a Q). \<not> q \<Turnstile> attack_formula (AttackerNode p' (dsuccs a Q)))\<close>
      \<open>p \<Turnstile> \<langle>\<tau>\<rangle>\<langle>a\<rangle>attack_formula (AttackerNode p' (dsuccs a Q))\<close>
      \<open>\<forall>q\<in>Q. \<not>q \<Turnstile> \<langle>\<tau>\<rangle>\<langle>a\<rangle>attack_formula (AttackerNode p' (dsuccs a Q))\<close>
    assume \<open>(\<exists>p'. p \<longmapsto>* tau  p' \<and> strat (AttackerNode p Q) = DefenderSwapNode p' Q \<and>
        attack_formula (AttackerNode p Q)
        = HML_weaknor (weak_tau_succs Q) (\<lambda>q.
          if q \<in> (weak_tau_succs Q)
            then attack_formula (AttackerNode q {p'})
            else HML_true)) \<or>
      Q = {} \<and> attack_formula (AttackerNode p Q) = HML_true\<close>
      assume \<open>\<exists>p'. p \<longmapsto>* tau  p' \<and> strat (AttackerNode p Q) = DefenderSwapNode p' Q \<and>
        attack_formula (AttackerNode p Q)
        = HML_weaknor (weak_tau_succs Q) (\<lambda>q.
          if q \<in> (weak_tau_succs Q)
            then attack_formula (AttackerNode q {p'})
            else HML_true)\<close>
        \<open>p \<longmapsto>* tau  p'\<close>
        \<open>strat (AttackerNode p Q) = DefenderSwapNode p' Q\<close>
        \<open>attack_formula (AttackerNode p Q)
        = HML_weaknor (weak_tau_succs Q) (\<lambda>q.
          if q \<in> (weak_tau_succs Q)
          then attack_formula (AttackerNode q {p'})
          else HML_true)\<close>
        \<open>c_set_game_moves (AttackerNode p Q) (DefenderSwapNode p' Q)\<close>
        \<open>\<forall>q'\<in>(weak_tau_succs Q).
          c_set_game_moves (DefenderSwapNode p' Q) (AttackerNode q' {p'})\<close>
          \<open>(DefenderSwapNode p' Q) \<in> attacker_winning_region\<close>
          \<open>\<forall>q'\<in>(weak_tau_succs Q). (AttackerNode q' {p'}) \<in> attacker_winning_region\<close>
        \<open>\<forall>q'\<in> weak_tau_succs Q. (AttackerNode q' {p'}, DefenderSwapNode p' Q) \<in> attacker_order\<close>
        \<open>(DefenderSwapNode p' Q, AttackerNode p Q) \<in> attacker_order\<close>
      hence \<open>\<forall>q'\<in> weak_tau_succs Q. (AttackerNode q' {p'}, AttackerNode p Q) \<in> attacker_order\<close>
        \<open>\<forall>q'\<in> weak_tau_succs Q.
          q' \<Turnstile> attack_formula (AttackerNode q' {p'}) \<and>
          \<not> p' \<Turnstile> attack_formula (AttackerNode q' {p'})\<close>
        \<open>p' \<Turnstile> HML_conj (weak_tau_succs Q)
          (\<lambda>q'. HML_neg (attack_formula (AttackerNode q' {p'})))\<close>
        \<open>\<forall>q'\<in> weak_tau_succs Q.
          \<not> q' \<Turnstile> HML_conj (weak_tau_succs Q)
          (\<lambda>qq'. HML_neg (attack_formula (AttackerNode qq' {p'})))\<close>
        \<open>p \<Turnstile> HML_weaknor (weak_tau_succs Q)
          (\<lambda>q. if q \<in> (weak_tau_succs Q)
            then attack_formula (AttackerNode q {p'})
            else HML_true)\<close>
        \<open>\<forall>q\<in>Q. \<not>q \<Turnstile>  HML_weaknor (weak_tau_succs Q)
          (\<lambda>q. if q \<in> (weak_tau_succs Q)
            then attack_formula (AttackerNode q {p'})
            else HML_true)\<close>
      assume \<open>Q = {} \<and> attack_formula (AttackerNode p Q) = HML_true\<close>
    \<open>pQ == AttackerNode p Q\<close>
    \<open>\<phi> == attack_formula pQ\<close>
    \<open>pQ \<in> attacker_winning_region\<close>
    \<open>\<phi> \<in> HML_weak_formulas\<close>
  hence \<open>\<forall>q' \<in> weak_tau_succs Q. attack_formula (AttackerNode q' {p}) \<in> HML_weak_formulas\<close>
    using HML_weak_formulas.Base \<open>DefenderSwapNode p Q \<in> attacker_winning_region\<close>
subsection \<open>Attacker Wins on Pairs with Distinguishing Formulas\<close>
  trans :: \<open>'s \<Rightarrow> 'a \<Rightarrow> 's \<Rightarrow> bool\<close> and
  \<tau> :: \<open>'a\<close> 
inductive_set attacker_winning_region :: \<open>('s, 'a) c_set_game_node set\<close> where
  Base: \<open>DefenderSwapNode _ {} \<in> attacker_winning_region\<close> |
  Atk: \<open>(c_set_game_moves (AttackerNode p Q) g' \<and> g' \<in> attacker_winning_region)
    \<Longrightarrow> (AttackerNode p Q) \<in> attacker_winning_region\<close> |
  Def: \<open>c_set_game_defender_node g \<Longrightarrow>
    (\<And>g'. c_set_game_moves g g' \<Longrightarrow> g' \<in> attacker_winning_region)
    \<Longrightarrow> g \<in> attacker_winning_region\<close>
    \<open>Q = {}\<close>
    \<open>AttackerNode p Q \<in> attacker_winning_region\<close>
  have atk_move: \<open>c_set_game_moves (AttackerNode p Q) (DefenderSwapNode p Q)\<close> 
  have \<open>DefenderSwapNode p Q \<in> attacker_winning_region\<close>
    \<open>AttackerNode p' (dsuccs a Q) \<in> attacker_winning_region\<close>
    \<open>p =\<rhd>a p'\<close>
    \<open>\<not>tau a\<close>
    \<open>AttackerNode p Q \<in> attacker_winning_region\<close>
  have AtkToSim: \<open>c_set_game_moves (AttackerNode p Q) (DefenderSimNode a p' Q)\<close>
  have \<open>\<forall>g. c_set_game_moves 
        (DefenderSimNode a p' Q) g 
        \<longrightarrow> (g = AttackerNode p' (dsuccs a Q))\<close>
  hence \<open>(DefenderSimNode a p' Q) \<in> attacker_winning_region\<close> 
    \<open>\<phi> \<in> HML_weak_formulas\<close>
    \<open>distinguishes_from_set \<phi> p Q\<close>
    \<open>(AttackerNode p Q) \<in> attacker_winning_region\<close>
proof (cases \<open>Q = {}\<close>)
    have \<open>\<forall>q. q \<Turnstile> HML_true\<close> by simp
    hence \<open>False\<close> 
    then obtain p' where p'_def: \<open>p =\<rhd>a p' \<and> p' \<Turnstile> \<phi> \<close> 
    have \<open>\<forall>q. q \<in> Q \<longrightarrow> \<not> q \<Turnstile> \<langle>\<tau>\<rangle>\<langle>a\<rangle>\<phi>\<close> using Obs by auto
    hence \<open>\<forall>q. q \<in> Q \<longrightarrow> (\<forall>q'.  \<not>q  =\<rhd>a  q' \<or> \<not>q' \<Turnstile> \<phi>)\<close>
    hence \<open>\<forall>q'. q' \<in> dsuccs a Q \<longrightarrow> \<not> q' \<Turnstile> \<phi>\<close> 
    hence phi_distinguishing: \<open>distinguishes_from_set \<phi> p' (dsuccs a Q)\<close> 
    proof (cases \<open>dsuccs a Q = {}\<close>)
      proof (cases \<open>tau a\<close>)
        hence \<open>{q1. \<exists>q\<in> Q. q \<longmapsto>* tau q1} = {}\<close> using dsuccs_def dsuccs_empty by auto
        hence \<open>Q = {}\<close> using steps.refl by blast
        hence \<open>AttackerNode p' (dsuccs a Q) \<in> attacker_winning_region\<close> 
        \<open>AttackerNode p' (dsuccs a Q) \<in> attacker_winning_region\<close> 
      proof(cases \<open>tau a\<close>)
        hence \<open>\<forall>p. (p \<Turnstile> \<langle>\<tau>\<rangle>\<langle>a\<rangle>\<phi>) = (p  \<Turnstile> \<phi>)\<close>
        hence \<open>distinguishes_from_set \<phi> p Q\<close> using Obs.prems by auto
    then obtain p' where \<open>p \<Rightarrow>^\<tau> p'\<close> and p_sat:  \<open>p' \<Turnstile> HML_conj I (\<lambda>f. HML_neg (F f))\<close>
    have \<open>\<And>q . q \<in> Q  \<Longrightarrow> \<not>q  \<Turnstile>  HML_poss \<tau> (HML_conj I (\<lambda>f. HML_neg (F f)))\<close>
    hence \<open>\<And>q q'. q \<in> Q \<Longrightarrow> \<not>q \<Rightarrow>^\<tau> q' \<or> \<not>q'  \<Turnstile> HML_conj I (\<lambda>f. HML_neg (F f))\<close>
    hence \<open>\<And>q'. \<not>q' \<in> (weak_tau_succs Q) \<or> \<not>q'  \<Turnstile> HML_conj I (\<lambda>f. HML_neg (F f))\<close>
    hence Ex: \<open>\<And>q'.  q' \<in> (weak_tau_succs Q) \<Longrightarrow> (\<exists>i. i \<in> I \<and> q'  \<Turnstile>  (F i))\<close>
    have atk_move: \<open>c_set_game_moves (AttackerNode p Q) (DefenderSwapNode p' Q)\<close>
      using \<open>p \<Rightarrow>^\<tau> p'\<close> by auto
      \<open>\<forall>q1 P1. c_set_game_moves (DefenderSwapNode p' Q) (AttackerNode q1 P1) \<longrightarrow>
        (\<exists>i. i \<in> I \<and> q1  \<Turnstile>  (F i)) \<and> P1 = {p'}\<close>
    hence \<open>\<forall>q1 P1.
      c_set_game_moves (DefenderSwapNode p' Q) (AttackerNode q1 P1)
      \<longrightarrow> (\<exists>i. i \<in> I \<and> q1  \<Turnstile>  (F i) \<and> (\<forall>p'. p' \<in> P1 \<longrightarrow> \<not> p' \<Turnstile> (F i)))\<close>
    hence  \<open>\<forall>q1 P1. 
      c_set_game_moves (DefenderSwapNode p' Q) (AttackerNode q1 P1)
      \<longrightarrow> (\<exists>i. i \<in> I \<and> distinguishes_from_set (F i) q1 P1)\<close> 
      \<open>\<forall>q1 P1. c_set_game_moves (DefenderSwapNode p' Q) (AttackerNode q1 P1)
        \<longrightarrow> (AttackerNode q1 P1 \<in> attacker_winning_region)\<close> 
    hence \<open>\<forall>g. c_set_game_moves (DefenderSwapNode p' Q) g
        \<longrightarrow> (\<exists> q1 P1. g = (AttackerNode q1 P1))\<close> 
    hence \<open>\<forall>g. c_set_game_moves (DefenderSwapNode p' Q) g
        \<longrightarrow> g \<in> attacker_winning_region\<close> 
    hence \<open>DefenderSwapNode p' Q \<in> attacker_winning_region\<close> 
