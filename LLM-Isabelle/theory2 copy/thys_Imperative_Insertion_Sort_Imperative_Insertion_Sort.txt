theory Imperative_Insertion_Sort
imports
  Imperative_Loops
  "HOL-Library.Multiset"
begin


abbreviation
  array_update :: "'a::heap array \<Rightarrow> nat \<Rightarrow> 'a \<Rightarrow> 'a array Heap" ("(_.'(_') \<leftarrow>/ _)" [1000, 0, 13] 14)
where
  "a.(i) \<leftarrow> x \<equiv> Array.upd i x a"

abbreviation array_nth :: "'a::heap array \<Rightarrow> nat \<Rightarrow> 'a Heap" ("_.'(_')" [1000, 0] 14)
where
  "a.(i) \<equiv> Array.nth a i"

definition
  "insertion_sort a = do {
    l \<leftarrow> Array.len a;
    for [1 ..< l] (\<lambda>j. do {
      key \<leftarrow> a.(j);
      i \<leftarrow> ref j;
      while (do {
        i' \<leftarrow> ! i;
        if i' > 0 then do {x \<leftarrow> a.(i' - 1); return (x > key)}
        else return False})
      (do {
        i' \<leftarrow> ! i;
        x \<leftarrow> a.(i' - 1);
        a.(i') \<leftarrow> x;
        i := i' - 1
      });
      i' \<leftarrow> ! i;
      a.(i') \<leftarrow> key
    })
  }"

definition "shiftr_p a (key::'a::{heap, linorder}) i =
  (do {i' \<leftarrow> ! i; if i' > 0 then do {x \<leftarrow> a.(i' - 1); return (x > key)} else return False})"

definition "shiftr_f a i = do {
  i' \<leftarrow> ! i;
  x \<leftarrow> a.(i' - 1);
  a.(i') \<leftarrow> x;
  i := i' - 1
}"

definition "shiftr a key i = while (shiftr_p a key i) (shiftr_f a i)"

definition "insert_elt a = (\<lambda>j. do {
  key \<leftarrow> a.(j);
  i \<leftarrow> ref j;
  shiftr a key i;
  i' \<leftarrow> ! i;
  a.(i') \<leftarrow> key
})"

definition "sort_upto a = (\<lambda>l. for [1 ..< l] (insert_elt a))"

lemma insertion_sort_alt_def:
  "insertion_sort a = (Array.len a \<bind> sort_upto a)"
  by (simp add: insertion_sort_def sort_upto_def shiftr_def shiftr_p_def shiftr_f_def insert_elt_def)



lemma effect_shiftr_f:
  assumes "effect (shiftr_f a i) h h' u"
  shows "Ref.get h' i = Ref.get h i - 1 \<and>
    Array.get h' a = list_update (Array.get h a) (Ref.get h i) (Array.get h a ! (Ref.get h i - 1))"
  using assms by (auto simp: shiftr_f_def elim!: effect_elims)

lemma success_shiftr_p:
  "Ref.get h i < Array.length h a \<Longrightarrow> success (shiftr_p a key i) h"
  by (auto simp: success_def shiftr_p_def execute_simps)

interpretation ro_shiftr_p: ro_cond "shiftr_p a key i" for a key i
  by (unfold_locales)
     (auto simp: shiftr_p_def success_def execute_simps execute_bind_case split: option.split, metis effectI effect_nthE)

definition [simp]: "ini h a j = take j (Array.get h a)"
definition [simp]: "left h a i = take (Ref.get h i) (Array.get h a)"
definition [simp]: "right h a j i = take (j - Ref.get h i) (drop (Ref.get h i + 1) (Array.get h a))"
definition [simp]: "both h a j i = left h a i @ right h a j i"

lemma effect_shiftr:
  assumes "Ref.get h i = j" (is "?i h = _")
    and "j < Array.length h a"
    and "sorted (take j (Array.get h a))"
    and "effect (while (shiftr_p a key i) (shiftr_f a i)) h h' u"
  shows "Array.length h a = Array.length h' a \<and>
    ?i h' \<le> j \<and>
    mset (list_update (Array.get h a) j key) =
      mset (list_update (Array.get h' a) (?i h') key) \<and>
    ini h a j = both h' a j i \<and>
    sorted (both h' a j i) \<and>
    (\<forall>x \<in> set (right h' a j i). x > key)"
using assms(4, 2)
proof (induction rule: ro_shiftr_p.effect_while_induct)
  case base
  show ?case using assms by auto
next
  case (step h' h'' u)
    have "?i h' > 0" and
    key: "Array.get h' a ! (?i h' - 1) > key"
    by (auto dest!: ro_shiftr_p.success_cond_effect)
       (auto simp: shiftr_p_def elim!: effect_elims effect_ifE)
    have [simp]: "?i h'' = ?i h' - 1"
    "Array.get h'' a = list_update (Array.get h' a) (?i h') (Array.get h' a ! (?i h' - 1))"
    by auto
  from step have *: "?i h' < length (Array.get h' a)"
    and **: "?i h' - (Suc 0) \<le> ?i h'" "?i h' \<le> length (Array.get h' a)"
    and "?i h' \<le> j"
    and "?i h' < Suc j"
    and IH: "ini h a j = both h' a j i"
    by (auto simp add: Array.length_def)
  have "Array.length h a = Array.length h'' a" using step by (simp add: Array.length_def)
  moreover
  have "?i h'' \<le> j" using step by auto
  moreover
  have "mset (list_update (Array.get h a) j key) =
    mset (list_update (Array.get h'' a) (?i h'') key)"
  proof -
    have "?i h' < length (Array.get h' a)"
      and "?i h' - 1 < length (Array.get h' a)" using * by auto
    then show ?thesis
      using step by (simp add: mset_update ac_simps nth_list_update)
  qed
  moreover
  have "ini h a j = both h'' a j i"
    by (auto simp: upd_conv_take_nth_drop Suc_diff_le min_absorb1)
       (metis Suc_lessD Suc_pred take_Suc_conv_app_nth)

  moreover
  have "sorted (both h'' a j i)"
    by (auto simp: IH upd_conv_take_nth_drop Suc_diff_le min_absorb1)
       (metis Suc_lessD Suc_pred append.simps append_assoc take_Suc_conv_app_nth)
  moreover
  have "\<forall>x \<in> set (right h'' a j i). x > key"
    by (auto simp: upd_conv_take_nth_drop Suc_diff_le)
  ultimately show ?case by blast
qed

lemma sorted_take_nth:
  assumes "0 < i" and "i < length xs" and "xs ! (i - 1) \<le> y"
    and "sorted (take i xs)"
  shows "\<forall>x \<in> set (take i xs). x \<le> y"
proof -
  have "take i xs = take (i - 1) xs @ [xs ! (i - 1)]"
    by (metis Suc_diff_1 less_imp_diff_less take_Suc_conv_app_nth)
  then show ?thesis
    by (auto simp: sorted_append)
qed

lemma effect_for_insert_elt:
  assumes "l \<le> Array.length h a"
    and "1 \<le> l"
    and "effect (for [1 ..< l] (insert_elt a)) h h' u"
  shows "Array.length h a = Array.length h' a \<and>
    sorted (take l (Array.get h' a)) \<and>
    mset (Array.get h a) = mset (Array.get h' a)"
using assms(2-)
proof (induction l h' rule: effect_for_induct)
  case base
  show ?case by (cases "Array.get h a") simp_all
next
  case (step j h' h'' u)
  with assms(1) have "j < Array.length h' a" by auto
  from step have sorted: "sorted (take j (Array.get h' a))" by blast
  from step(3) [unfolded insert_elt_def]
    obtain key and h\<^sub>1 and i and h\<^sub>2 and i'
    where key: "key = Array.get h' a ! j"
      and "effect (ref j) h' h\<^sub>1 i"
      and ref\<^sub>1: "Ref.get h\<^sub>1 i = j"
      and shiftr': "effect (shiftr a key i) h\<^sub>1 h\<^sub>2 ()"
      and [simp]: "Ref.get h\<^sub>2 i = i'"
      and [simp]: "h'' = Array.update a i' key h\<^sub>2"
      and "i' < Array.length h\<^sub>2 a"
      by (elim effect_bindE effect_nthE effect_lookupE effect_updE)
         (auto intro: effect_intros, metis effect_refE)

    by (metis array_get_alloc effectE execute_ref option.sel)

  have [simp]: "Array.length h\<^sub>1 a = Array.length h' a" by (simp add: Array.length_def)

  from step and assms(1)
    have "j < Array.length h\<^sub>1 a" "sorted (take j (Array.get h\<^sub>1 a))" by auto
  note shiftr = effect_shiftr [OF ref\<^sub>1 this shiftr' [unfolded shiftr_def], simplified]
  have "i' \<le> j" using shiftr by simp

  have "i' < length (Array.get h\<^sub>2 a)"
  have [simp]: "min (length (Array.get h\<^sub>2 a)) i' = i'"
  have take_Suc_j: "take (Suc j) (list_update (Array.get h\<^sub>2 a) i' key) =
    take i' (Array.get h\<^sub>2 a) @ key # take (j - i') (drop (Suc i') (Array.get h\<^sub>2 a))"

  have "Array.length h a = Array.length h'' a"
    using shiftr by (auto) (metis step.IH)
  moreover
  have "mset (Array.get h a) = mset (Array.get h'' a)"
    using shiftr and step by (simp add: key)
  moreover
  have "sorted (take (Suc j) (Array.get h'' a))"
  proof -
    from ro_shiftr_p.effect_while_post [OF shiftr' [unfolded shiftr_def]]
      have "i' = 0 \<or> (0 < i' \<and> key \<ge> Array.get h\<^sub>2 a ! (i' - 1))"
      by (auto dest!: ro_shiftr_p.success_not_cond_effect)
         (auto elim!: effect_elims simp: shiftr_p_def)
    then show ?thesis
    proof
      assume [simp]: "i' = 0"
      have *: "take (Suc j) (list_update (Array.get h\<^sub>2 a) 0 key) =
        key # take j (drop 1 (Array.get h\<^sub>2 a))"
      from sorted and shiftr
        have "sorted (take j (drop 1 (Array.get h\<^sub>2 a)))"
        and "\<forall>x \<in> set (take j (drop 1 (Array.get h\<^sub>2 a))). key < x" by simp_all
      then have "sorted (key # take j (drop 1 (Array.get h\<^sub>2 a)))"
        by (metis less_imp_le sorted_simps(2))
      then show ?thesis by (simp add: *)
