theory Type_Classes
  imports HOLCF_Main
begin



class Eq =
  fixes eq :: "'a \<rightarrow> 'a \<rightarrow> tr"

fixrec neq :: "'a::Eq \<rightarrow> 'a \<rightarrow> tr" where
  "neq\<cdot>x\<cdot>y = neg\<cdot>(eq\<cdot>x\<cdot>y)"

class Eq_strict = Eq +
  assumes eq_strict [simp]:
    "eq\<cdot>x\<cdot>\<bottom> = \<bottom>"
    "eq\<cdot>\<bottom>\<cdot>y = \<bottom>"

class Eq_sym = Eq_strict +
  assumes eq_sym: "eq\<cdot>x\<cdot>y = eq\<cdot>y\<cdot>x"

class Eq_equiv = Eq_sym +
  assumes eq_self_neq_FF [simp]: "eq\<cdot>x\<cdot>x \<noteq> FF"
    and eq_trans: "eq\<cdot>x\<cdot>y = TT \<Longrightarrow> eq\<cdot>y\<cdot>z = TT \<Longrightarrow> eq\<cdot>x\<cdot>z = TT"
begin

lemma eq_refl: "eq\<cdot>x\<cdot>x \<noteq> \<bottom> \<Longrightarrow> eq\<cdot>x\<cdot>x = TT"
  by (cases "eq\<cdot>x\<cdot>x") simp+

end

class Eq_eq = Eq_sym +
  assumes eq_self_neq_FF': "eq\<cdot>x\<cdot>x \<noteq> FF"
    and eq_TT_dest: "eq\<cdot>x\<cdot>y = TT \<Longrightarrow> x = y"
begin

subclass Eq_equiv
  by standard (auto simp: eq_self_neq_FF' dest: eq_TT_dest)

lemma eqD [dest]:
  "eq\<cdot>x\<cdot>y = TT \<Longrightarrow> x = y"
  "eq\<cdot>x\<cdot>y = FF \<Longrightarrow> x \<noteq> y"
  by (auto elim: eq_TT_dest)

end


instantiation lift :: (countable) Eq_eq
begin

definition "eq \<equiv> (\<Lambda>(Def x) (Def y). Def (x = y))"

instance
  by standard (auto simp: eq_lift_def flift1_def split: lift.splits)

end

lemma eq_ONE_ONE [simp]: "eq\<cdot>ONE\<cdot>ONE = TT"
  unfolding ONE_def eq_lift_def by simp



domain Ordering = LT | EQ | GT

definition oppOrdering :: "Ordering \<rightarrow> Ordering" where
  "oppOrdering = (\<Lambda> x. case x of LT \<Rightarrow> GT | EQ \<Rightarrow> EQ | GT \<Rightarrow> LT)"

lemma oppOrdering_simps [simp]:
  "oppOrdering\<cdot>LT = GT"
  "oppOrdering\<cdot>EQ = EQ"
  "oppOrdering\<cdot>GT = LT"
  "oppOrdering\<cdot>\<bottom> = \<bottom>"
  unfolding oppOrdering_def by simp_all

class Ord = Eq +
  fixes compare :: "'a \<rightarrow> 'a \<rightarrow> Ordering"
begin

definition lt :: "'a \<rightarrow> 'a \<rightarrow> tr" where
  "lt = (\<Lambda> x y. case compare\<cdot>x\<cdot>y of LT \<Rightarrow> TT | EQ \<Rightarrow> FF | GT \<Rightarrow> FF)"

definition le :: "'a \<rightarrow> 'a \<rightarrow> tr" where
  "le = (\<Lambda> x y. case compare\<cdot>x\<cdot>y of LT \<Rightarrow> TT | EQ \<Rightarrow> TT | GT \<Rightarrow> FF)"

lemma lt_eq_TT_iff: "lt\<cdot>x\<cdot>y = TT \<longleftrightarrow> compare\<cdot>x\<cdot>y = LT"
  by (cases "compare\<cdot>x\<cdot>y") (simp add: lt_def)+

end

class Ord_strict = Ord +
  assumes compare_strict [simp]:
    "compare\<cdot>\<bottom>\<cdot>y = \<bottom>"
    "compare\<cdot>x\<cdot>\<bottom> = \<bottom>"
begin

lemma lt_strict [simp]:
  shows "lt\<cdot>\<bottom>\<cdot>x = \<bottom>"
    and "lt\<cdot>x\<cdot>\<bottom> = \<bottom>"
  by (simp add: lt_def)+

lemma le_strict [simp]:
  shows "le\<cdot>\<bottom>\<cdot>x = \<bottom>"
    and "le\<cdot>x\<cdot>\<bottom> = \<bottom>"
  by (simp add: le_def)+

end

