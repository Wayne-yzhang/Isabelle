theory SourceTargetRelation
  imports Encodings SimulationRelations
begin




inductive_set (in encoding) indRelR
    :: "((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
  where
  encR: "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> indRelR"

abbreviation (in encoding) indRelRinfix ::
    "('procS, 'procT) Proc \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool" ("_ \<R>\<lbrakk>\<cdot>\<rbrakk>R _" [75, 75] 80)
  where
  "P \<R>\<lbrakk>\<cdot>\<rbrakk>R Q \<equiv> (P, Q) \<in> indRelR"

inductive_set (in encoding) indRelRPO
    :: "((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
  where
  encR:   "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> indRelRPO" |
  source: "(SourceTerm S, SourceTerm S) \<in> indRelRPO" |
  target: "(TargetTerm T, TargetTerm T) \<in> indRelRPO" |
  trans:  "\<lbrakk>(P, Q) \<in> indRelRPO; (Q, R) \<in> indRelRPO\<rbrakk> \<Longrightarrow> (P, R) \<in> indRelRPO"

abbreviation (in encoding) indRelRPOinfix ::
    "('procS, 'procT) Proc \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool" ("_ \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R _" [75, 75] 80)
  where
  "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R Q \<equiv> (P, Q) \<in> indRelRPO"

lemma (in encoding) indRelRPO_refl:
  shows "refl indRelRPO"
    unfolding refl_on_def
proof auto
  fix P
  show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R P"
  proof (cases P)
    case (SourceTerm SP)
    assume "SP \<in>S P"
    thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R P"
      by (simp add: indRelRPO.source)
  next
    case (TargetTerm TP)
    assume "TP \<in>T P"
    thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R P"
      by (simp add: indRelRPO.target)
  qed
qed

lemma (in encoding) indRelRPO_is_preorder:
  shows "preorder indRelRPO"
    unfolding preorder_on_def
proof
  show "refl indRelRPO"
    by (rule indRelRPO_refl)
next
  show "trans indRelRPO"
    unfolding trans_def
  proof clarify
    fix P Q R
    assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R Q" and "Q \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R R"
    thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R R"
      by (rule indRelRPO.trans)
  qed
qed

lemma (in encoding) refl_trans_closure_of_indRelR:
  shows "indRelRPO = indRelR\<^sup>*"
proof auto
  fix P Q
  assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R Q"
  thus "(P, Q) \<in> indRelR\<^sup>*"
  proof induct
    case (encR S)
    show "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> indRelR\<^sup>*"
        using indRelR.encR[of S]
      by simp
  next
    case (source S)
    show "(SourceTerm S, SourceTerm S) \<in> indRelR\<^sup>*"
      by simp
  next
    case (target T)
    show "(TargetTerm T, TargetTerm T) \<in> indRelR\<^sup>*"
      by simp
  next
    case (trans P Q R)
    assume "(P, Q) \<in> indRelR\<^sup>*" and "(Q, R) \<in> indRelR\<^sup>*"
    thus "(P, R) \<in> indRelR\<^sup>*"
      by simp
  qed
next
  fix P Q
  assume "(P, Q) \<in> indRelR\<^sup>*"
  thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R Q"
  proof induct
    show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R P"
        using indRelRPO_refl
        unfolding refl_on_def
      by simp
  next
    case (step Q R)
    assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R Q"
    moreover assume "Q \<R>\<lbrakk>\<cdot>\<rbrakk>R R"
    hence "Q \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R R"
      by (induct, simp add: indRelRPO.encR)
    ultimately show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R R"
      by (rule indRelRPO.trans)
  qed
qed


lemma (in encoding) indRelR_impl_exists_source_target_relation:
  fixes PredA :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) set \<Rightarrow> bool"
    and PredB :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  shows "PredA indRelR \<Longrightarrow> \<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> PredA Rel"
    and "\<forall>(P, Q) \<in> indRelR. PredB (P, Q)
         \<Longrightarrow> \<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> (\<forall>(P, Q) \<in> Rel. PredB (P, Q))"
proof -
  have A: "\<forall>S. SourceTerm S \<R>\<lbrakk>\<cdot>\<rbrakk>R TargetTerm (\<lbrakk>S\<rbrakk>)"
    by (simp add: indRelR.encR)
  thus "PredA indRelR \<Longrightarrow> \<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> PredA Rel"
    by blast
  with A show "\<forall>(P, Q) \<in> indRelR. PredB (P, Q)
   \<Longrightarrow> \<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> (\<forall>(P, Q) \<in> Rel. PredB (P, Q))"
    by blast
qed

lemma (in encoding) source_target_relation_impl_indRelR:
  fixes Rel  :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) set"
    and Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  assumes encRRel: "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel"
      and condRel: "\<forall>(P, Q) \<in> Rel. Pred (P, Q)"
  shows "\<forall>(P, Q) \<in> indRelR. Pred (P, Q)"
proof clarify
  fix P Q
  assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>R Q"
  with encRRel have "(P, Q) \<in> Rel"
    by (auto simp add: indRelR.simps)
  with condRel show "Pred (P, Q)"
    by simp
qed

lemma (in encoding) indRelR_iff_exists_source_target_relation:
  fixes Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  shows "(\<forall>(P, Q) \<in> indRelR. Pred (P, Q))
         = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> (\<forall>(P, Q) \<in> Rel. Pred (P, Q)))"
      using indRelR_impl_exists_source_target_relation(2)[where PredB="Pred"]
            source_target_relation_impl_indRelR[where Pred="Pred"]
    by blast

lemma (in encoding) indRelR_modulo_pred_impl_indRelRPO_modulo_pred:
  fixes Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  assumes reflCond:  "\<forall>P. Pred (P, P)"
      and transCond: "\<forall>P Q R. Pred (P, Q) \<and> Pred (Q, R) \<longrightarrow> Pred (P, R)"
  shows "(\<forall>(P, Q) \<in> indRelR. Pred (P, Q)) = (\<forall>(P, Q) \<in> indRelRPO. Pred (P, Q))"
proof auto
  fix P Q
  assume A: "\<forall>x \<in> indRelR. Pred x"
  assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R Q"
  thus "Pred (P, Q)"
  proof induct
    case (encR S)
    have "SourceTerm S \<R>\<lbrakk>\<cdot>\<rbrakk>R TargetTerm (\<lbrakk>S\<rbrakk>)"
      by (simp add: indRelR.encR)
    with A show "Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>))"
      by simp
  next
    case (source S)
    from reflCond show "Pred (SourceTerm S, SourceTerm S)"
      by simp
  next
    case (target T)
    from reflCond show "Pred (TargetTerm T, TargetTerm T)"
      by simp
  next
    case (trans P Q R)
    assume "Pred (P, Q)" and "Pred (Q, R)"
    with transCond show "Pred (P, R)"
      by blast
  qed
next
  fix P Q
  assume "\<forall>x \<in> indRelRPO. Pred x" and "P \<R>\<lbrakk>\<cdot>\<rbrakk>R Q"
  thus "Pred (P, Q)"
    by (auto simp add: indRelRPO.encR indRelR.simps)
qed

lemma (in encoding) indRelRPO_iff_exists_source_target_relation:
  fixes Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  shows "(\<forall>(P, Q) \<in> indRelRPO. Pred (P, Q)) = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
         \<and> (\<forall>(P, Q) \<in> Rel. Pred (P, Q)) \<and> preorder Rel)"
proof (rule iffI)
  have "\<forall>S. SourceTerm S \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R TargetTerm (\<lbrakk>S\<rbrakk>)"
    by (simp add: indRelRPO.encR)
  moreover have "preorder indRelRPO"
      using indRelRPO_is_preorder
    by blast
  moreover assume "\<forall>(P, Q) \<in> indRelRPO. Pred (P, Q)"
  ultimately show "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
                   \<and> (\<forall>(P, Q) \<in> Rel. Pred (P, Q)) \<and> preorder Rel"
    by blast
next
  assume "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
          \<and> (\<forall>(P, Q) \<in> Rel. Pred (P, Q)) \<and> preorder Rel"
  from this obtain Rel where A1: "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel"
                         and A2: "\<forall>(P, Q) \<in> Rel. Pred (P, Q)" and A3: "preorder Rel"
    by blast
  show "\<forall>(P, Q) \<in> indRelRPO. Pred (P, Q)"
  proof clarify
    fix P Q
    assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>R Q"
    hence "(P, Q) \<in> Rel"
    proof induct
      case (encR S)
      from A1 show "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel"
        by simp
    next
      case (source S)
      from A3 show "(SourceTerm S, SourceTerm S) \<in> Rel"
          unfolding preorder_on_def refl_on_def
        by simp
    next
      case (target T)
      from A3 show "(TargetTerm T, TargetTerm T) \<in> Rel"
          unfolding preorder_on_def refl_on_def
        by simp
    next
      case (trans P Q R)
      assume "(P, Q) \<in> Rel" and "(Q, R) \<in> Rel"
      with A3 show "(P, R) \<in> Rel"
          unfolding preorder_on_def trans_def
        by blast
    qed
    with A2 show "Pred (P, Q)"
      by simp
  qed
qed


lemma (in encoding) enc_satisfies_pred_impl_indRelR_satisfies_pred:
  fixes Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  assumes encCond: "\<forall>S. Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>))"
  shows "\<forall>(P, Q) \<in> indRelR. Pred (P, Q)"
    by (auto simp add: encCond indRelR.simps)

lemma (in encoding) indRelR_satisfies_pred_impl_enc_satisfies_pred:
  fixes Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  assumes relCond: "\<forall>(P, Q) \<in> indRelR. Pred (P, Q)"
  shows "\<forall>S. Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>))"
      using relCond indRelR.encR
    by simp

lemma (in encoding) enc_satisfies_pred_iff_indRelR_satisfies_pred:
  fixes Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  shows "(\<forall>S. Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>))) = (\<forall>(P, Q) \<in> indRelR. Pred (P, Q))"
      using enc_satisfies_pred_impl_indRelR_satisfies_pred[where Pred="Pred"]
            indRelR_satisfies_pred_impl_enc_satisfies_pred[where Pred="Pred"]
    by blast

lemma (in encoding) enc_satisfies_binary_pred_iff_indRelR_satisfies_binary_pred:
  fixes Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> 'b \<Rightarrow> bool"
  shows "(\<forall>S a. Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) a) = (\<forall>(P, Q) \<in> indRelR. \<forall>a. Pred (P, Q) a)"
      using enc_satisfies_pred_iff_indRelR_satisfies_pred
    by simp

lemma (in encoding) enc_preserves_pred_iff_indRelR_preserves_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_preserves_pred Pred = rel_preserves_pred indRelR Pred"
      using enc_satisfies_pred_iff_indRelR_satisfies_pred[where Pred="\<lambda>(P, Q). Pred P \<longrightarrow> Pred Q"]
    by blast

lemma (in encoding) enc_preserves_binary_pred_iff_indRelR_preserves_binary_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "enc_preserves_binary_pred Pred = rel_preserves_binary_pred indRelR Pred"
      using enc_satisfies_binary_pred_iff_indRelR_satisfies_binary_pred[where
             Pred="\<lambda>(P, Q) a. Pred P a \<longrightarrow> Pred Q a"]
    by blast

lemma (in encoding) enc_preserves_pred_iff_indRelRPO_preserves_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_preserves_pred Pred = rel_preserves_pred indRelRPO Pred"
      using enc_preserves_pred_iff_indRelR_preserves_pred[where Pred="Pred"]
            indRelR_modulo_pred_impl_indRelRPO_modulo_pred[where
             Pred="\<lambda>(P, Q). Pred P \<longrightarrow> Pred Q"]
    by blast

lemma (in encoding) enc_reflects_pred_iff_indRelR_reflects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_reflects_pred Pred = rel_reflects_pred indRelR Pred"
      using enc_satisfies_pred_iff_indRelR_satisfies_pred[where Pred="\<lambda>(P, Q). Pred Q \<longrightarrow> Pred P"]
    by blast

lemma (in encoding) enc_reflects_binary_pred_iff_indRelR_reflects_binary_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "enc_reflects_binary_pred Pred = rel_reflects_binary_pred indRelR Pred"
      using enc_satisfies_binary_pred_iff_indRelR_satisfies_binary_pred[where
             Pred="\<lambda>(P, Q) a. Pred Q a \<longrightarrow> Pred P a"]
    by blast

lemma (in encoding) enc_reflects_pred_iff_indRelRPO_reflects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_reflects_pred Pred = rel_reflects_pred indRelRPO Pred"
      using enc_reflects_pred_iff_indRelR_reflects_pred[where Pred="Pred"]
            indRelR_modulo_pred_impl_indRelRPO_modulo_pred[where
             Pred="\<lambda>(P, Q). Pred Q \<longrightarrow> Pred P"]
    by blast

lemma (in encoding) enc_respects_pred_iff_indRelR_respects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_respects_pred Pred = rel_respects_pred indRelR Pred"
      using enc_preserves_pred_iff_indRelR_preserves_pred[where Pred="Pred"]
            enc_reflects_pred_iff_indRelR_reflects_pred[where Pred="Pred"]
    by blast

lemma (in encoding) enc_respects_binary_pred_iff_indRelR_respects_binary_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "enc_respects_binary_pred Pred = rel_respects_binary_pred indRelR Pred"
      using enc_preserves_binary_pred_iff_indRelR_preserves_binary_pred[where Pred="Pred"]
            enc_reflects_binary_pred_iff_indRelR_reflects_binary_pred[where Pred="Pred"]
    by blast

lemma (in encoding) enc_respects_pred_iff_indRelRPO_respects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_respects_pred Pred = rel_respects_pred indRelRPO Pred"
      using enc_respects_pred_iff_indRelR_respects_pred[where Pred="Pred"]
            indRelR_modulo_pred_impl_indRelRPO_modulo_pred[where Pred="\<lambda>(P, Q). Pred Q = Pred P"]
    apply simp by blast


lemma (in encoding) enc_satisfies_pred_iff_source_target_satisfies_pred:
  fixes Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  shows "(\<forall>S. Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)))
         = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> (\<forall>(P, Q) \<in> Rel. Pred (P, Q)))"
    and "\<lbrakk>\<forall>P Q R. Pred (P, Q) \<and> Pred (Q, R) \<longrightarrow> Pred (P, R); \<forall>P. Pred (P, P)\<rbrakk> \<Longrightarrow>
         (\<forall>S. Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>))) = (\<exists>Rel. (\<forall>S.
         (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> (\<forall>(P, Q) \<in> Rel. Pred (P, Q)) \<and> preorder Rel)"
proof -
  show "(\<forall>S. Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)))
        = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> (\<forall>(P, Q) \<in> Rel. Pred (P, Q)))"
      using enc_satisfies_pred_iff_indRelR_satisfies_pred[where Pred="Pred"]
            indRelR_iff_exists_source_target_relation[where Pred="Pred"]
    by simp
next
  have "(\<forall>S. Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>))) = (\<forall>(P, Q) \<in> indRelR. Pred (P, Q))"
      using enc_satisfies_pred_iff_indRelR_satisfies_pred[where Pred="Pred"]
    by simp
  moreover assume "\<forall>P Q R. Pred (P, Q) \<and> Pred (Q, R) \<longrightarrow> Pred (P, R)" and "\<forall>P. Pred (P, P)"
  hence "(\<forall>(P, Q) \<in> indRelR. Pred (P, Q)) = (\<forall>(P, Q) \<in> indRelRPO. Pred (P, Q))"
      using indRelR_modulo_pred_impl_indRelRPO_modulo_pred[where Pred="Pred"]
    by blast
  ultimately show "(\<forall>S. Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>))) = (\<exists>Rel.
   (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> (\<forall>(P, Q) \<in> Rel. Pred (P, Q)) \<and> preorder Rel)"
      using indRelRPO_iff_exists_source_target_relation[where Pred="Pred"]
    by simp
qed

lemma (in encoding) enc_preserves_pred_iff_source_target_rel_preserves_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_preserves_pred Pred
         = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_preserves_pred Rel Pred)"
    and "enc_preserves_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
         \<and> rel_preserves_pred Rel Pred \<and> preorder Rel)"
proof -
  have A1: "enc_preserves_pred Pred
            = (\<forall>S. (\<lambda>(P, Q). Pred P \<longrightarrow> Pred Q) (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)))"
    by blast
  moreover have A2: "\<And>Rel. rel_preserves_pred Rel Pred
                     = (\<forall>(P, Q) \<in> Rel. (\<lambda>(P, Q). Pred P \<longrightarrow> Pred Q) (P, Q))"
    by blast
  ultimately show "enc_preserves_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
                   \<and> rel_preserves_pred Rel Pred)"
      using enc_satisfies_pred_iff_source_target_satisfies_pred(1)[where
             Pred="\<lambda>(P, Q). Pred P \<longrightarrow> Pred Q"]
    by simp
  from A1 A2 show "enc_preserves_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
                   \<and> rel_preserves_pred Rel Pred \<and> preorder Rel)"
      using enc_satisfies_pred_iff_source_target_satisfies_pred(2)[where
             Pred="\<lambda>(P, Q). Pred P \<longrightarrow> Pred Q"]
    by simp
qed

lemma (in encoding) enc_preserves_binary_pred_iff_source_target_rel_preserves_binary_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "enc_preserves_binary_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
         \<and> rel_preserves_binary_pred Rel Pred)"
proof -
  have "enc_preserves_binary_pred Pred
        = (\<forall>S. (\<lambda>(P, Q). \<forall>a. Pred P a \<longrightarrow> Pred Q a) (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)))"
    by blast
  moreover have "\<And>Rel. rel_preserves_binary_pred Rel Pred
                 = (\<forall>(P, Q) \<in> Rel. (\<lambda>(P, Q). \<forall>a. Pred P a \<longrightarrow> Pred Q a) (P, Q))"
    by blast
  ultimately show "enc_preserves_binary_pred Pred = (\<exists>Rel. (\<forall>S.
                   (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_preserves_binary_pred Rel Pred)"
      using enc_satisfies_pred_iff_source_target_satisfies_pred(1)[where
             Pred="\<lambda>(P, Q). \<forall>a. Pred P a \<longrightarrow> Pred Q a"]
    by simp
qed

lemma (in encoding) enc_reflects_pred_iff_source_target_rel_reflects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_reflects_pred Pred
         = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_reflects_pred Rel Pred)"
    and "enc_reflects_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
         \<and> rel_reflects_pred Rel Pred \<and> preorder Rel)"
proof -
  have A1: "enc_reflects_pred Pred
        = (\<forall>S. (\<lambda>(P, Q). Pred Q \<longrightarrow> Pred P) (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)))"
    by blast
  moreover have A2: "\<And>Rel. rel_reflects_pred Rel Pred
                     = (\<forall>(P, Q) \<in> Rel. (\<lambda>(P, Q). Pred Q \<longrightarrow> Pred P) (P, Q))"
    by blast
  ultimately show "enc_reflects_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
                   \<and> rel_reflects_pred Rel Pred)"
      using enc_satisfies_pred_iff_source_target_satisfies_pred(1)[where
             Pred="\<lambda>(P, Q). Pred Q \<longrightarrow> Pred P"]
    by simp
  from A1 A2 show "enc_reflects_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
                   \<and> rel_reflects_pred Rel Pred \<and> preorder Rel)"
      using enc_satisfies_pred_iff_source_target_satisfies_pred(2)[where
             Pred="\<lambda>(P, Q). Pred Q \<longrightarrow> Pred P"]
    by simp
qed

lemma (in encoding) enc_reflects_binary_pred_iff_source_target_rel_reflects_binary_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "enc_reflects_binary_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
         \<and> rel_reflects_binary_pred Rel Pred)"
proof -
  have "enc_reflects_binary_pred Pred
        = (\<forall>S. (\<lambda>(P, Q). \<forall>a. Pred Q a \<longrightarrow> Pred P a) (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)))"
    by blast
  moreover have "\<And>Rel. rel_reflects_binary_pred Rel Pred
                 = (\<forall>(P, Q) \<in> Rel. (\<lambda>(P, Q). \<forall>a. Pred Q a \<longrightarrow> Pred P a) (P, Q))"
    by blast
  ultimately show "enc_reflects_binary_pred Pred = (\<exists>Rel. (\<forall>S.
                   (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_reflects_binary_pred Rel Pred)"
      using enc_satisfies_pred_iff_source_target_satisfies_pred(1)[where
             Pred="\<lambda>(P, Q). \<forall>a. Pred Q a \<longrightarrow> Pred P a"]
    by simp
qed

lemma (in encoding) enc_respects_pred_iff_source_target_rel_respects_pred_encR:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_respects_pred Pred
         = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_pred Rel Pred)"
    and "enc_respects_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
         \<and> rel_respects_pred Rel Pred \<and> preorder Rel)"
proof -
  have A1: "enc_respects_pred Pred
            = (\<forall>S. (\<lambda>(P, Q). Pred P = Pred Q) (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)))"
    by blast
  moreover
  have A2: "\<And>Rel. rel_respects_pred Rel Pred = (\<forall>(P, Q) \<in> Rel. (\<lambda>(P, Q). Pred P = Pred Q) (P, Q))"
    by blast
  ultimately show "enc_respects_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
                   \<and> rel_respects_pred Rel Pred)"
      using enc_satisfies_pred_iff_source_target_satisfies_pred(1)[where
             Pred="\<lambda>(P, Q). Pred P = Pred Q"]
    by simp
  from A1 A2 show "enc_respects_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
                   \<and> rel_respects_pred Rel Pred \<and> preorder Rel)"
      using enc_satisfies_pred_iff_source_target_satisfies_pred(2)[where
             Pred="\<lambda>(P, Q). Pred P = Pred Q"]
    by simp
qed

lemma (in encoding) enc_respects_binary_pred_iff_source_target_rel_respects_binary_pred_encR:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "enc_respects_binary_pred Pred = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
         \<and> rel_respects_binary_pred Rel Pred)"
proof -
  have "enc_respects_binary_pred Pred
        = (\<forall>S. (\<lambda>(P, Q). \<forall>a. Pred P a = Pred Q a) (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)))"
    by blast
  moreover have "\<And>Rel. rel_respects_binary_pred Rel Pred
                 = (\<forall>(P, Q) \<in> Rel. (\<lambda>(P, Q). \<forall>a. Pred P a = Pred Q a) (P, Q))"
    by blast
  ultimately show "enc_respects_binary_pred Pred = (\<exists>Rel. (\<forall>S.
                   (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_binary_pred Rel Pred)"
      using enc_satisfies_pred_iff_source_target_satisfies_pred(1)[where
             Pred="\<lambda>(P, Q). \<forall>a. Pred P a = Pred Q a"]
    by simp
qed


inductive_set (in encoding) indRelL
    :: "((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
  where
  encL: "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> indRelL"

abbreviation (in encoding) indRelLinfix ::
    "('procS, 'procT) Proc \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool" ("_ \<R>\<lbrakk>\<cdot>\<rbrakk>L _" [75, 75] 80)
  where
  "P \<R>\<lbrakk>\<cdot>\<rbrakk>L Q \<equiv> (P, Q) \<in> indRelL"

inductive_set (in encoding) indRelLPO
    :: "((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
  where
  encL:   "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> indRelLPO" |
  source: "(SourceTerm S, SourceTerm S) \<in> indRelLPO" |
  target: "(TargetTerm T, TargetTerm T) \<in> indRelLPO" |
  trans:  "\<lbrakk>(P, Q) \<in> indRelLPO; (Q, R) \<in> indRelLPO\<rbrakk> \<Longrightarrow> (P, R) \<in> indRelLPO"

abbreviation (in encoding) indRelLPOinfix ::
    "('procS, 'procT) Proc \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool" ("_ \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L _" [75, 75] 80)
  where
  "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L Q \<equiv> (P, Q) \<in> indRelLPO"

lemma (in encoding) indRelLPO_refl:
  shows "refl indRelLPO"
    unfolding refl_on_def
proof auto
  fix P
  show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L P"
  proof (cases P)
    case (SourceTerm SP)
    assume "SP \<in>S P"
    thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L P"
      by (simp add: indRelLPO.source)
  next
    case (TargetTerm TP)
    assume "TP \<in>T P"
    thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L P"
      by (simp add: indRelLPO.target)
  qed
qed

lemma (in encoding) indRelLPO_is_preorder:
  shows "preorder indRelLPO"
    unfolding preorder_on_def
proof
  show "refl indRelLPO"
    by (rule indRelLPO_refl)
next
  show "trans indRelLPO"
    unfolding trans_def
  proof clarify
    fix P Q R
    assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L Q" and "Q \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L R"
    thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L R"
      by (rule indRelLPO.trans)
  qed
qed

lemma (in encoding) refl_trans_closure_of_indRelL:
  shows "indRelLPO = indRelL\<^sup>*"
proof auto
  fix P Q
  assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L Q"
  thus "(P, Q) \<in> indRelL\<^sup>*"
  proof induct
    case (encL S)
    show "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> indRelL\<^sup>*"
        using indRelL.encL[of S]
      by simp
  next
    case (source S)
    show "(SourceTerm S, SourceTerm S) \<in> indRelL\<^sup>*"
      by simp
  next
    case (target T)
    show "(TargetTerm T, TargetTerm T) \<in> indRelL\<^sup>*"
      by simp
  next
    case (trans P Q R)
    assume "(P, Q) \<in> indRelL\<^sup>*" and "(Q, R) \<in> indRelL\<^sup>*"
    thus "(P, R) \<in> indRelL\<^sup>*"
      by simp
  qed
next
  fix P Q
  assume "(P, Q) \<in> indRelL\<^sup>*"
  thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L Q"
  proof induct
    show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L P"
        using indRelLPO_refl
        unfolding refl_on_def
      by simp
  next
    case (step Q R)
    assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L Q"
    moreover assume "Q \<R>\<lbrakk>\<cdot>\<rbrakk>L R"
    hence "Q \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L R"
      by (induct, simp add: indRelLPO.encL)
    ultimately show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>L R"
      by (simp add: indRelLPO.trans[of P Q R])
  qed
qed


lemma (in encoding) indRelR_preserves_pred_iff_indRelL_reflects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "rel_preserves_pred indRelR Pred = rel_reflects_pred indRelL Pred"
proof
  assume preservation: "rel_preserves_pred indRelR Pred"
  show "rel_reflects_pred indRelL Pred"
  proof clarify
    fix P Q
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>L Q"
    from this obtain S where "S \<in>S Q" and "\<lbrakk>S\<rbrakk> \<in>T P"
      by (induct, blast)
    hence "Q \<R>\<lbrakk>\<cdot>\<rbrakk>R P"
      by (simp add: indRelR.encR)
    moreover assume "Pred Q"
    ultimately show "Pred P"
        using preservation
      by blast
  qed
next
  assume reflection: "rel_reflects_pred indRelL Pred"
  show "rel_preserves_pred indRelR Pred"
  proof clarify
    fix P Q
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>R Q"
    from this obtain S where "S \<in>S P" and "\<lbrakk>S\<rbrakk> \<in>T Q"
      by (induct, blast)
    hence "Q \<R>\<lbrakk>\<cdot>\<rbrakk>L P"
      by (simp add: indRelL.encL)
    moreover assume "Pred P"
    ultimately show "Pred Q"
        using reflection
      by blast
  qed
qed

lemma (in encoding) indRelR_preserves_binary_pred_iff_indRelL_reflects_binary_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "rel_preserves_binary_pred indRelR Pred = rel_reflects_binary_pred indRelL Pred"
proof
  assume preservation: "rel_preserves_binary_pred indRelR Pred"
  show "rel_reflects_binary_pred indRelL Pred"
  proof clarify
    fix P Q x
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>L Q"
    from this obtain S where "S \<in>S Q" and "\<lbrakk>S\<rbrakk> \<in>T P"
      by (induct, blast)
    hence "Q \<R>\<lbrakk>\<cdot>\<rbrakk>R P"
      by (simp add: indRelR.encR)
    moreover assume "Pred Q x"
    ultimately show "Pred P x"
        using preservation
      by blast
  qed
next
  assume reflection: "rel_reflects_binary_pred indRelL Pred"
  show "rel_preserves_binary_pred indRelR Pred"
  proof clarify
    fix P Q x
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>R Q"
    from this obtain S where "S \<in>S P" and "\<lbrakk>S\<rbrakk> \<in>T Q"
      by (induct, blast)
    hence "Q \<R>\<lbrakk>\<cdot>\<rbrakk>L P"
      by (simp add: indRelL.encL)
    moreover assume "Pred P x"
    ultimately show "Pred Q x"
        using reflection
      by blast
  qed
qed

lemma (in encoding) indRelR_reflects_pred_iff_indRelL_preserves_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "rel_reflects_pred indRelR Pred = rel_preserves_pred indRelL Pred"
proof
  assume reflection: "rel_reflects_pred indRelR Pred"
  show "rel_preserves_pred indRelL Pred"
  proof clarify
    fix P Q
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>L Q"
    from this obtain S where "S \<in>S Q" and "\<lbrakk>S\<rbrakk> \<in>T P"
      by (induct, blast)
    hence "Q \<R>\<lbrakk>\<cdot>\<rbrakk>R P"
      by (simp add: indRelR.encR)
    moreover assume "Pred P"
    ultimately show "Pred Q"
        using reflection
      by blast
  qed
next
  assume preservation: "rel_preserves_pred indRelL Pred"
  show "rel_reflects_pred indRelR Pred"
  proof clarify
    fix P Q
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>R Q"
    from this obtain S where "S \<in>S P" and "\<lbrakk>S\<rbrakk> \<in>T Q"
      by (induct, blast)
    hence "Q \<R>\<lbrakk>\<cdot>\<rbrakk>L P"
      by (simp add: indRelL.encL)
    moreover assume "Pred Q"
    ultimately show "Pred P"
        using preservation
      by blast
  qed
qed

lemma (in encoding) indRelR_reflects_binary_pred_iff_indRelL_preserves_binary_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "rel_reflects_binary_pred indRelR Pred = rel_preserves_binary_pred indRelL Pred"
proof
  assume reflection: "rel_reflects_binary_pred indRelR Pred"
  show "rel_preserves_binary_pred indRelL Pred"
  proof clarify
    fix P Q x
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>L Q"
    from this obtain S where "S \<in>S Q" and "\<lbrakk>S\<rbrakk> \<in>T P"
      by (induct, blast)
    hence "Q \<R>\<lbrakk>\<cdot>\<rbrakk>R P"
      by (simp add: indRelR.encR)
    moreover assume "Pred P x"
    ultimately show "Pred Q x"
        using reflection
      by blast
  qed
next
  assume preservation: "rel_preserves_binary_pred indRelL Pred"
  show "rel_reflects_binary_pred indRelR Pred"
  proof clarify
    fix P Q x
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>R Q"
    from this obtain S where "S \<in>S P" and "\<lbrakk>S\<rbrakk> \<in>T Q"
      by (induct, blast)
    hence "Q \<R>\<lbrakk>\<cdot>\<rbrakk>L P"
      by (simp add: indRelL.encL)
    moreover assume "Pred Q x"
    ultimately show "Pred P x"
        using preservation
      by blast
  qed
qed

lemma (in encoding) indRelR_respects_pred_iff_indRelL_respects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "rel_respects_pred indRelR Pred = rel_respects_pred indRelL Pred"
      using indRelR_preserves_pred_iff_indRelL_reflects_pred[where Pred="Pred"]
            indRelR_reflects_pred_iff_indRelL_preserves_pred[where Pred="Pred"]
    by blast

lemma (in encoding) indRelR_respects_binary_pred_iff_indRelL_respects_binary_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow>'b \<Rightarrow> bool"
  shows "rel_respects_binary_pred indRelR Pred = rel_respects_binary_pred indRelL Pred"
      using indRelR_preserves_binary_pred_iff_indRelL_reflects_binary_pred[where Pred="Pred"]
            indRelR_reflects_binary_pred_iff_indRelL_preserves_binary_pred[where Pred="Pred"]
    by blast

lemma (in encoding) indRelR_cond_preservation_iff_indRelL_cond_reflection:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "(\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_preserves_pred Rel Pred)
         = (\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_reflects_pred Rel Pred)"
proof
  assume "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_preserves_pred Rel Pred"
  then obtain Rel where A1: "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel"
                    and A2: "rel_preserves_pred Rel Pred"
    by blast
  from A1 have "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel\<inverse>"
    by simp
  moreover from A2 have "rel_reflects_pred (Rel\<inverse>) Pred"
    by simp
  ultimately show "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_reflects_pred Rel Pred"
    by blast
next
  assume "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_reflects_pred Rel Pred"
  then obtain Rel where B1: "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel"
                    and B2: "rel_reflects_pred Rel Pred"
    by blast
  from B1 have "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel\<inverse>"
    by simp
  moreover from B2 have "rel_preserves_pred (Rel\<inverse>) Pred"
    by blast
  ultimately
  show "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_preserves_pred Rel Pred"
    by blast
qed

lemma (in encoding) indRelR_cond_binary_preservation_iff_indRelL_cond_binary_reflection:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "(\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_preserves_binary_pred Rel Pred)
         = (\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel)
            \<and> rel_reflects_binary_pred Rel Pred)"
proof
  assume "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_preserves_binary_pred Rel Pred"
  then obtain Rel where A1: "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel"
                    and A2: "rel_preserves_binary_pred Rel Pred"
    by blast
  from A1 have "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel\<inverse>"
    by simp
  moreover from A2 have "rel_reflects_binary_pred (Rel\<inverse>) Pred"
    by simp
  ultimately
  show "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_reflects_binary_pred Rel Pred"
    by blast
next
  assume "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_reflects_binary_pred Rel Pred"
  then obtain Rel where B1: "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel"
                    and B2: "rel_reflects_binary_pred Rel Pred"
    by blast
  from B1 have "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel\<inverse>"
    by simp
  moreover from B2 have "rel_preserves_binary_pred (Rel\<inverse>) Pred"
    by simp
  ultimately
  show "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_preserves_binary_pred Rel Pred"
    by blast
qed

lemma (in encoding) indRelR_cond_reflection_iff_indRelL_cond_preservation:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "(\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_reflects_pred Rel Pred)
         = (\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_preserves_pred Rel Pred)"
proof
  assume "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_reflects_pred Rel Pred"
  then obtain Rel where A1: "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel"
                    and A2: "rel_reflects_pred Rel Pred"
    by blast
  from A1 have "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel\<inverse>"
    by simp
  moreover from A2 have "rel_preserves_pred (Rel\<inverse>) Pred"
    by blast
  ultimately
  show "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_preserves_pred Rel Pred"
    by blast
next
  assume "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_preserves_pred Rel Pred"
  then obtain Rel where B1: "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel"
                    and B2: "rel_preserves_pred Rel Pred"
    by blast
  from B1 have "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel\<inverse>"
    by simp
  moreover from B2 have "rel_reflects_pred (Rel\<inverse>) Pred"
    by simp
  ultimately
  show "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_reflects_pred Rel Pred"
    by blast
qed

lemma (in encoding) indRelR_cond_binary_reflection_iff_indRelL_cond_binary_preservation:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "(\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_reflects_binary_pred Rel Pred)
         = (\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel)
            \<and> rel_preserves_binary_pred Rel Pred)"
proof
  assume "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_reflects_binary_pred Rel Pred"
  then obtain Rel where A1: "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel"
                    and A2: "rel_reflects_binary_pred Rel Pred"
    by blast
  from A1 have "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel\<inverse>"
    by simp
  moreover from A2 have "rel_preserves_binary_pred (Rel\<inverse>) Pred"
    by blast
  ultimately
  show "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_preserves_binary_pred Rel Pred"
    by blast
next
  assume "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_preserves_binary_pred Rel Pred"
  then obtain Rel where B1: "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel"
                    and B2: "rel_preserves_binary_pred Rel Pred"
    by blast
  from B1 have "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel\<inverse>"
    by simp
  moreover from B2 have "rel_reflects_binary_pred (Rel\<inverse>) Pred"
    by simp
  ultimately
  show "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_reflects_binary_pred Rel Pred"
    by blast
qed

lemma (in encoding) indRelR_cond_respection_iff_indRelL_cond_respection:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "(\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_pred Rel Pred)
         = (\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_respects_pred Rel Pred)"
proof
  assume "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_pred Rel Pred"
  from this obtain Rel where A1: "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel"
                         and A2: "rel_respects_pred Rel Pred"
    by blast
  from A1 have "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> {(a, b). (b, a) \<in> Rel}"
    by simp
  moreover from A2 have "rel_respects_pred {(a, b). (b, a) \<in> Rel} Pred"
    by blast
  ultimately show "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_respects_pred Rel Pred"
    by blast
next
  assume "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_respects_pred Rel Pred"
  from this obtain Rel where A1: "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel"
                         and A2: "rel_respects_pred Rel Pred"
    by blast
  from A1 have "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> {(a, b). (b, a) \<in> Rel}"
    by simp
  moreover from A2 have "rel_respects_pred {(a, b). (b, a) \<in> Rel} Pred"
    by blast
  ultimately show "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_pred Rel Pred"
    by blast
qed

lemma (in encoding) indRelR_cond_binary_respection_iff_indRelL_cond_binary_respection:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "(\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_binary_pred Rel Pred)
         = (\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel)
            \<and> rel_respects_binary_pred Rel Pred)"
proof
  assume "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_binary_pred Rel Pred"
  from this obtain Rel where A1: "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel"
                         and A2: "rel_respects_binary_pred Rel Pred"
    by blast
  from A1 have "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> {(a, b). (b, a) \<in> Rel}"
    by simp
  moreover from A2 have "rel_respects_binary_pred {(a, b). (b, a) \<in> Rel} Pred"
    by blast
  ultimately
  show "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_respects_binary_pred Rel Pred"
    by blast
next
  assume "\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_respects_binary_pred Rel Pred"
  from this obtain Rel where A1: "\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel"
                         and A2: "rel_respects_binary_pred Rel Pred"
    by blast
  from A1 have "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> {(a, b). (b, a) \<in> Rel}"
    by simp
  moreover from A2 have "rel_respects_binary_pred {(a, b). (b, a) \<in> Rel} Pred"
    by blast
  ultimately
  show "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_binary_pred Rel Pred"
    by blast
qed


lemma (in encoding) enc_preserves_pred_iff_indRelL_reflects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_preserves_pred Pred = rel_reflects_pred indRelL Pred"
      using enc_preserves_pred_iff_indRelR_preserves_pred[where Pred="Pred"]
            indRelR_preserves_pred_iff_indRelL_reflects_pred[where Pred="Pred"]
    by blast

lemma (in encoding) enc_reflects_pred_iff_indRelL_preserves_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_reflects_pred Pred = rel_preserves_pred indRelL Pred"
      using enc_reflects_pred_iff_indRelR_reflects_pred[where Pred="Pred"]
            indRelR_reflects_pred_iff_indRelL_preserves_pred[where Pred="Pred"]
    by blast

lemma (in encoding) enc_respects_pred_iff_indRelL_respects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_respects_pred Pred = rel_respects_pred indRelL Pred"
      using enc_preserves_pred_iff_indRelL_reflects_pred[where Pred="Pred"]
            enc_reflects_pred_iff_indRelL_preserves_pred[where Pred="Pred"]
    by blast


lemma (in encoding) enc_preserves_pred_iff_source_target_rel_reflects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_preserves_pred Pred
         = (\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_reflects_pred Rel Pred)"
      using enc_preserves_pred_iff_source_target_rel_preserves_pred[where Pred="Pred"]
            indRelR_cond_preservation_iff_indRelL_cond_reflection[where Pred="Pred"]
    by simp

lemma (in encoding) enc_reflects_pred_iff_source_target_rel_preserves_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_reflects_pred Pred
         = (\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_preserves_pred Rel Pred)"
      using enc_reflects_pred_iff_source_target_rel_reflects_pred[where Pred="Pred"]
            indRelR_cond_reflection_iff_indRelL_cond_preservation[where Pred="Pred"]
    by simp

lemma (in encoding) enc_respects_pred_iff_source_target_rel_respects_pred_encL:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_respects_pred Pred
         = (\<exists>Rel. (\<forall>S. (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_respects_pred Rel Pred)"
      using enc_respects_pred_iff_source_target_rel_respects_pred_encR[where Pred="Pred"]
            indRelR_cond_respection_iff_indRelL_cond_respection[where Pred="Pred"]
    by simp


inductive_set (in encoding) indRel
    :: "((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
  where
  encR: "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> indRel" |
  encL: "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> indRel"

abbreviation (in encoding) indRelInfix ::
    "('procS, 'procT) Proc \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool" ("_ \<R>\<lbrakk>\<cdot>\<rbrakk> _" [75, 75] 80)
  where
  "P \<R>\<lbrakk>\<cdot>\<rbrakk> Q \<equiv> (P, Q) \<in> indRel"

lemma (in encoding) indRel_symm:
  shows "sym indRel"
      unfolding sym_def
    by (auto simp add: indRel.simps indRel.encR indRel.encL)

inductive_set (in encoding) indRelEQ
    :: "((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
  where
  encR:   "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> indRelEQ" |
  encL:   "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> indRelEQ" |
  target: "(TargetTerm T, TargetTerm T) \<in> indRelEQ" |
  trans:  "\<lbrakk>(P, Q) \<in> indRelEQ; (Q, R) \<in> indRelEQ\<rbrakk> \<Longrightarrow> (P, R) \<in> indRelEQ"

abbreviation (in encoding) indRelEQinfix ::
    "('procS, 'procT) Proc \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool" ("_ \<sim>\<lbrakk>\<cdot>\<rbrakk> _" [75, 75] 80)
  where
  "P \<sim>\<lbrakk>\<cdot>\<rbrakk> Q \<equiv> (P, Q) \<in> indRelEQ"

lemma (in encoding) indRelEQ_refl:
  shows "refl indRelEQ"
    unfolding refl_on_def
proof auto
  fix P
  show "P \<sim>\<lbrakk>\<cdot>\<rbrakk> P"
  proof (cases P)
    case (SourceTerm SP)
    assume "SP \<in>S P"
    moreover have "SourceTerm SP \<sim>\<lbrakk>\<cdot>\<rbrakk> TargetTerm (\<lbrakk>SP\<rbrakk>)"
      by (rule indRelEQ.encR)
    moreover have "TargetTerm (\<lbrakk>SP\<rbrakk>) \<sim>\<lbrakk>\<cdot>\<rbrakk> SourceTerm SP"
      by (rule indRelEQ.encL)
    ultimately show "P \<sim>\<lbrakk>\<cdot>\<rbrakk> P"
      by (simp add: indRelEQ.trans[where P="SourceTerm SP" and Q="TargetTerm (\<lbrakk>SP\<rbrakk>)"])
  next
    case (TargetTerm TP)
    assume "TP \<in>T P"
    thus "P \<sim>\<lbrakk>\<cdot>\<rbrakk> P"
      by (simp add: indRelEQ.target)
  qed
qed

lemma (in encoding) indRelEQ_is_preorder:
  shows "preorder indRelEQ"
    unfolding preorder_on_def
proof
  show "refl indRelEQ"
    by (rule indRelEQ_refl)
next
  show "trans indRelEQ"
    unfolding trans_def
  proof clarify
    fix P Q R
    assume "P \<sim>\<lbrakk>\<cdot>\<rbrakk> Q" and "Q \<sim>\<lbrakk>\<cdot>\<rbrakk> R"
    thus "P \<sim>\<lbrakk>\<cdot>\<rbrakk> R"
      by (rule indRelEQ.trans)
  qed
qed

lemma (in encoding) indRelEQ_symm:
  shows "sym indRelEQ"
    unfolding sym_def
proof clarify
  fix P Q
  assume "P \<sim>\<lbrakk>\<cdot>\<rbrakk> Q"
  thus "Q \<sim>\<lbrakk>\<cdot>\<rbrakk> P"
  proof induct
    case (encR S)
    show "TargetTerm (\<lbrakk>S\<rbrakk>) \<sim>\<lbrakk>\<cdot>\<rbrakk> SourceTerm S"
      by (rule indRelEQ.encL)
  next
    case (encL S)
    show "SourceTerm S \<sim>\<lbrakk>\<cdot>\<rbrakk> TargetTerm (\<lbrakk>S\<rbrakk>)"
      by (rule indRelEQ.encR)
  next
    case (target T)
    show "TargetTerm T \<sim>\<lbrakk>\<cdot>\<rbrakk> TargetTerm T"
      by (rule indRelEQ.target)
  next
    case (trans P Q R)
    assume "R \<sim>\<lbrakk>\<cdot>\<rbrakk> Q" and "Q \<sim>\<lbrakk>\<cdot>\<rbrakk> P"
    thus "R \<sim>\<lbrakk>\<cdot>\<rbrakk> P"
      by (rule indRelEQ.trans)
  qed
qed

lemma (in encoding) indRelEQ_is_equivalence:
  shows "equivalence indRelEQ"
      using indRelEQ_is_preorder indRelEQ_symm
      unfolding equiv_def preorder_on_def
    by blast

lemma (in encoding) refl_trans_closure_of_indRel:
  shows "indRelEQ = indRel\<^sup>*"
proof auto
  fix P Q
  assume "P \<sim>\<lbrakk>\<cdot>\<rbrakk> Q"
  thus "(P, Q) \<in> indRel\<^sup>*"
  proof induct
    case (encR S)
    show "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> indRel\<^sup>*"
        using indRel.encR[of S]
      by simp
  next
    case (encL S)
    show "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> indRel\<^sup>*"
        using indRel.encL[of S]
      by simp
  next
    case (target T)
    show "(TargetTerm T, TargetTerm T) \<in> indRel\<^sup>*"
      by simp
  next
    case (trans P Q R)
    assume "(P, Q) \<in> indRel\<^sup>*" and "(Q, R) \<in> indRel\<^sup>*"
    thus "(P, R) \<in> indRel\<^sup>*"
      by simp
  qed
next
  fix P Q
  assume "(P, Q) \<in> indRel\<^sup>*"
  thus "P \<sim>\<lbrakk>\<cdot>\<rbrakk> Q"
  proof induct
    show "P \<sim>\<lbrakk>\<cdot>\<rbrakk> P"
        using indRelEQ_refl
        unfolding refl_on_def
      by simp
  next
    case (step Q R)
    assume "P \<sim>\<lbrakk>\<cdot>\<rbrakk> Q"
    moreover assume "Q \<R>\<lbrakk>\<cdot>\<rbrakk> R"
    hence "Q \<sim>\<lbrakk>\<cdot>\<rbrakk> R"
      by (induct, simp_all add: indRelEQ.encR indRelEQ.encL)
    ultimately show "P \<sim>\<lbrakk>\<cdot>\<rbrakk> R"
      by (rule indRelEQ.trans)
  qed
qed

lemma (in encoding) refl_symm_trans_closure_of_indRel:
  shows "indRelEQ = (symcl (indRel\<^sup>=))\<^sup>+"
proof -
  have "(symcl (indRel\<^sup>=))\<^sup>+ = (symcl indRel)\<^sup>*"
    by (rule refl_symm_trans_closure_is_symm_refl_trans_closure[where Rel="indRel"])
  moreover have "symcl indRel = indRel"
    by (simp add: indRel_symm symm_closure_of_symm_rel[where Rel="indRel"])
  ultimately show "indRelEQ = (symcl (indRel\<^sup>=))\<^sup>+"
    by (simp add: refl_trans_closure_of_indRel)
qed

lemma (in encoding) symm_closure_of_indRelR:
  shows "indRel = symcl indRelR"
    and "indRelEQ = (symcl (indRelR\<^sup>=))\<^sup>+"
proof -
  show "indRel = symcl indRelR"
  proof auto
    fix P Q
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk> Q"
    thus "(P, Q) \<in> symcl indRelR"
      by (induct, simp_all add: symcl_def indRelR.encR)
  next
    fix P Q
    assume "(P, Q) \<in> symcl indRelR"
    thus "P \<R>\<lbrakk>\<cdot>\<rbrakk> Q"
      by (auto simp add: symcl_def indRelR.simps indRel.encR indRel.encL)
  qed
  thus "indRelEQ = (symcl (indRelR\<^sup>=))\<^sup>+"
      using refl_symm_trans_closure_is_symm_refl_trans_closure[where Rel="indRelR"]
            refl_trans_closure_of_indRel
    by simp
qed

lemma (in encoding) symm_closure_of_indRelL:
  shows "indRel = symcl indRelL"
    and "indRelEQ = (symcl (indRelL\<^sup>=))\<^sup>+"
proof -
  show "indRel = symcl indRelL"
  proof auto
    fix P Q
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk> Q"
    thus "(P, Q) \<in> symcl indRelL"
     by (induct, simp_all add: symcl_def indRelL.encL)
  next
    fix P Q
    assume "(P, Q) \<in> symcl indRelL"
    thus "P \<R>\<lbrakk>\<cdot>\<rbrakk> Q"
      by (auto simp add: symcl_def indRelL.simps indRel.encR indRel.encL)
  qed
  thus "indRelEQ = (symcl (indRelL\<^sup>=))\<^sup>+"
      using refl_symm_trans_closure_is_symm_refl_trans_closure[where Rel="indRelL"]
            refl_trans_closure_of_indRel
    by simp
qed


lemma (in encoding) indRel_respects_pred_iff_indRelR_respects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "rel_respects_pred indRel Pred = rel_respects_pred indRelR Pred"
proof
  assume respection: "rel_respects_pred indRel Pred"
  show "rel_respects_pred indRelR Pred"
  proof auto
    fix P Q
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>R Q"
    from this obtain S where "S \<in>S P" and "\<lbrakk>S\<rbrakk> \<in>T Q"
      by (induct, blast)
    hence "P \<R>\<lbrakk>\<cdot>\<rbrakk> Q"
      by (simp add: indRel.encR)
    moreover assume "Pred P"
    ultimately show "Pred Q"
        using respection
      by blast
  next
    fix P Q
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>R Q"
    from this obtain S where "S \<in>S P" and "\<lbrakk>S\<rbrakk> \<in>T Q"
      by (induct, blast)
    hence "P \<R>\<lbrakk>\<cdot>\<rbrakk> Q"
      by (simp add: indRel.encR)
    moreover assume "Pred Q"
    ultimately show "Pred P"
        using respection
      by blast
  qed
next
  assume "rel_respects_pred indRelR Pred"
  thus "rel_respects_pred indRel Pred"
      using symm_closure_of_indRelR(1)
            respection_and_closures(2)[where Rel="indRelR" and Pred="Pred"]
    by blast
qed

lemma (in encoding) indRel_respects_binary_pred_iff_indRelR_respects_binary_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "rel_respects_binary_pred indRel Pred = rel_respects_binary_pred indRelR Pred"
proof
  assume respection: "rel_respects_binary_pred indRel Pred"
  show "rel_respects_binary_pred indRelR Pred"
  proof auto
    fix P Q x
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>R Q"
    from this obtain S where "S \<in>S P" and "\<lbrakk>S\<rbrakk> \<in>T Q"
      by (induct, blast)
    hence "P \<R>\<lbrakk>\<cdot>\<rbrakk> Q"
      by (simp add: indRel.encR)
    moreover assume "Pred P x"
    ultimately show "Pred Q x"
        using respection
      by blast
  next
    fix P Q x
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>R Q"
    from this obtain S where "S \<in>S P" and "\<lbrakk>S\<rbrakk> \<in>T Q"
      by (induct, blast)
    hence "P \<R>\<lbrakk>\<cdot>\<rbrakk> Q"
      by (simp add: indRel.encR)
    moreover assume "Pred Q x"
    ultimately show "Pred P x"
        using respection
      by blast
  qed
next
  assume "rel_respects_binary_pred indRelR Pred"
  thus "rel_respects_binary_pred indRel Pred"
      using symm_closure_of_indRelR(1)
            respection_of_binary_predicates_and_closures(2)[where Rel="indRelR" and Pred="Pred"]
    by blast
qed

lemma (in encoding) indRel_cond_respection_iff_indRelR_cond_respection:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "(\<exists>Rel.
          (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel \<and> (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel)
          \<and> rel_respects_pred Rel Pred)
         = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_pred Rel Pred)"
proof
  assume "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel
          \<and> (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_respects_pred Rel Pred"
  from this obtain Rel
    where "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel \<and> (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel"
    and "rel_respects_pred Rel Pred"
    by blast
  thus "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_pred Rel Pred"
    by blast
next
  assume "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_pred Rel Pred"
  from this obtain Rel where A1: "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel"
                         and A2: "rel_respects_pred Rel Pred"
    by blast
  from A1 have "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> symcl Rel
                \<and> (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> symcl Rel"
    by (simp add: symcl_def)
  moreover from A2 have "rel_respects_pred (symcl Rel) Pred"
      using respection_and_closures(2)[where Rel="Rel" and Pred="Pred"]
    by blast
  ultimately
  show "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel \<and> (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel)
        \<and> rel_respects_pred Rel Pred"
    by blast
qed

lemma (in encoding) indRel_cond_binary_respection_iff_indRelR_cond_binary_respection:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> 'b \<Rightarrow> bool"
  shows "(\<exists>Rel.
          (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel \<and> (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel)
          \<and> rel_respects_binary_pred Rel Pred)
         = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel)
            \<and> rel_respects_binary_pred Rel Pred)"
proof
  assume "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel
          \<and> (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel) \<and> rel_respects_binary_pred Rel Pred"
  from this obtain Rel
    where "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel \<and> (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel"
    and "rel_respects_binary_pred Rel Pred"
    by blast
  thus "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_binary_pred Rel Pred"
    by blast
next
  assume "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> rel_respects_binary_pred Rel Pred"
  from this obtain Rel where A1: "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel"
                         and A2: "rel_respects_binary_pred Rel Pred"
    by blast
  from A1 have "\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> symcl Rel
                \<and> (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> symcl Rel"
    by (simp add: symcl_def)
  moreover from A2 have "rel_respects_binary_pred (symcl Rel) Pred"
      using respection_of_binary_predicates_and_closures(2)[where Rel="Rel" and Pred="Pred"]
    by blast
  ultimately
  show "\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel \<and> (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel)
        \<and> rel_respects_binary_pred Rel Pred"
    by blast
qed


lemma (in encoding) enc_respects_pred_iff_indRel_respects_pred:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_respects_pred Pred = rel_respects_pred indRel Pred"
      using enc_respects_pred_iff_indRelR_respects_pred[where Pred="Pred"]
            indRel_respects_pred_iff_indRelR_respects_pred[where Pred="Pred"]
    by simp


lemma (in encoding) enc_respects_pred_iff_source_target_rel_respects_pred_encRL:
  fixes Pred :: "('procS, 'procT) Proc \<Rightarrow> bool"
  shows "enc_respects_pred Pred
         = (\<exists>Rel.
            (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel \<and> (TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> Rel)
            \<and> rel_respects_pred Rel Pred)"
      using enc_respects_pred_iff_source_target_rel_respects_pred_encR[where Pred="Pred"]
            indRel_cond_respection_iff_indRelR_cond_respection[where Pred="Pred"]
    by simp



inductive_set (in encoding) indRelRT
    :: "('procT \<times> 'procT) set \<Rightarrow> ((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
    for TRel :: "('procT \<times> 'procT) set"
  where
  encR:   "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> indRelRT TRel" |
  target: "(T1, T2) \<in> TRel \<Longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> indRelRT TRel"

abbreviation (in encoding) indRelRTinfix
    :: "('procS, 'procT) Proc \<Rightarrow> ('procT \<times> 'procT) set \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool"
       ("_ \<R>\<lbrakk>\<cdot>\<rbrakk>RT<_> _" [75, 75, 75] 80)
  where
  "P \<R>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> Q \<equiv> (P, Q) \<in> indRelRT TRel"

inductive_set (in encoding) indRelRTPO
    :: "('procT \<times> 'procT) set \<Rightarrow> ((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
    for TRel :: "('procT \<times> 'procT) set"
  where
  encR:   "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> indRelRTPO TRel" |
  source: "(SourceTerm S, SourceTerm S) \<in> indRelRTPO TRel" |
  target: "(T1, T2) \<in> TRel \<Longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> indRelRTPO TRel" |
  trans:  "\<lbrakk>(P, Q) \<in> indRelRTPO TRel; (Q, R) \<in> indRelRTPO TRel\<rbrakk> \<Longrightarrow> (P, R) \<in> indRelRTPO TRel"

abbreviation (in encoding) indRelRTPOinfix
    :: "('procS, 'procT) Proc \<Rightarrow> ('procT \<times> 'procT) set \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool"
       ("_ \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<_> _" [75, 75, 75] 80)
  where
  "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> Q \<equiv> (P, Q) \<in> indRelRTPO TRel"

lemma (in encoding) indRelRTPO_refl:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes refl: "refl TRel"
  shows "refl (indRelRTPO TRel)"
    unfolding refl_on_def
proof auto
  fix P
  show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> P"
  proof (cases P)
    case (SourceTerm SP)
    assume "SP \<in>S P"
    thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> P"
      by (simp add: indRelRTPO.source)
  next
    case (TargetTerm TP)
    assume "TP \<in>T P"
    with refl show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> P"
        unfolding refl_on_def
      by (simp add: indRelRTPO.target)
  qed
qed

lemma (in encoding) refl_trans_closure_of_indRelRT:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes refl: "refl TRel"
  shows "indRelRTPO TRel = (indRelRT TRel)\<^sup>*"
proof auto
  fix P Q
  assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> Q"
  thus "(P, Q) \<in> (indRelRT TRel)\<^sup>*"
  proof induct
    case (encR S)
    show "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> (indRelRT TRel)\<^sup>*"
        using indRelRT.encR[of S TRel]
      by simp
  next
    case (source S)
    show "(SourceTerm S, SourceTerm S) \<in> (indRelRT TRel)\<^sup>*"
      by simp
  next
    case (target T1 T2)
    assume "(T1, T2) \<in> TRel"
    thus "(TargetTerm T1, TargetTerm T2) \<in> (indRelRT TRel)\<^sup>*"
        using indRelRT.target[of T1 T2 TRel]
      by simp
  next
    case (trans P Q R)
    assume "(P, Q) \<in> (indRelRT TRel)\<^sup>*" and "(Q, R) \<in> (indRelRT TRel)\<^sup>*"
    thus "(P, R) \<in> (indRelRT TRel)\<^sup>*"
      by simp
  qed
next
  fix P Q
  assume "(P, Q) \<in> (indRelRT TRel)\<^sup>*"
  thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> Q"
  proof induct
    from refl show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> P"
        using indRelRTPO_refl[of TRel]
        unfolding refl_on_def
      by simp
  next
    case (step Q R)
    assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> Q"
    moreover assume "Q \<R>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> R"
    hence "Q \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> R"
      by (induct, simp_all add: indRelRTPO.encR indRelRTPO.target)
    ultimately show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> R"
      by (rule indRelRTPO.trans)
  qed
qed

lemma (in encoding) indRelRTPO_is_preorder:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes reflT: "refl TRel"
  shows "preorder (indRelRTPO TRel)"
    unfolding preorder_on_def
proof
  from reflT show "refl (indRelRTPO TRel)"
    by (rule indRelRTPO_refl)
next
  show "trans (indRelRTPO TRel)"
    unfolding trans_def
  proof clarify
    fix P Q R
    assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> Q" and "Q \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> R"
    thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> R"
        using indRelRTPO.trans
      by blast
  qed
qed

lemma (in encoding) transitive_closure_of_TRel_to_indRelRTPO:
  fixes TRel  :: "('procT \<times> 'procT) set"
    and TP TQ :: "'procT"
  shows "(TP, TQ) \<in> TRel\<^sup>+ \<Longrightarrow> TargetTerm TP \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> TargetTerm TQ"
proof -
  assume "(TP, TQ) \<in> TRel\<^sup>+"
  thus "TargetTerm TP \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> TargetTerm TQ"
  proof induct
    fix TQ
    assume "(TP, TQ) \<in> TRel"
    thus "TargetTerm TP \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> TargetTerm TQ"
      by (rule indRelRTPO.target)
  next
    case (step TQ TR)
    assume "TargetTerm TP \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> TargetTerm TQ"
    moreover assume "(TQ, TR) \<in> TRel"
    hence "TargetTerm TQ \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> TargetTerm TR"
      by (simp add: indRelRTPO.target)
    ultimately show "TargetTerm TP \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> TargetTerm TR"
      by (rule indRelRTPO.trans)
  qed
qed


lemma (in encoding) indRelR_modulo_pred_impl_indRelRT_modulo_pred:
  fixes Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  shows "(\<forall>(P, Q) \<in> indRelR. Pred (P, Q)) = (\<forall>TRel. (\<forall>(TP, TQ) \<in> TRel.
         Pred (TargetTerm TP, TargetTerm TQ)) \<longleftrightarrow> (\<forall>(P, Q) \<in> indRelRT TRel. Pred (P, Q)))"
proof (rule iffI)
  assume A: "\<forall>(P, Q) \<in> indRelR. Pred (P, Q)"
  show "\<forall>TRel. (\<forall>(TP, TQ) \<in> TRel. Pred (TargetTerm TP, TargetTerm TQ))
        = (\<forall>(P, Q) \<in> indRelRT TRel. Pred (P, Q))"
  proof (rule allI, rule iffI)
    fix TRel
    assume "\<forall>(TP, TQ) \<in> TRel. Pred (TargetTerm TP, TargetTerm TQ)"
    with A show "\<forall>(P, Q) \<in> indRelRT TRel. Pred (P, Q)"
      by (auto simp add: indRelR.encR indRelRT.simps)
  next
    fix TRel
    assume "\<forall>(P, Q) \<in> indRelRT TRel. Pred (P, Q)"
    thus "\<forall>(TP, TQ) \<in> TRel. Pred (TargetTerm TP, TargetTerm TQ)"
      by (auto simp add: indRelRT.target)
  qed
next
  assume "\<forall>TRel. (\<forall>(TP, TQ) \<in> TRel. Pred (TargetTerm TP, TargetTerm TQ))
          \<longleftrightarrow> (\<forall>(P, Q) \<in> indRelRT TRel. Pred (P, Q))"
  hence B: "\<And>TRel. (\<forall>(TP, TQ) \<in> TRel. Pred (TargetTerm TP, TargetTerm TQ))
            \<longleftrightarrow> (\<forall>(P, Q) \<in> indRelRT TRel. Pred (P, Q))"
    by blast
  have "\<And>S. Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>))"
      using B[of "{}"]
    by (simp add: indRelRT.simps)
  thus "\<forall>(P, Q) \<in> indRelR. Pred (P, Q)"
    by (auto simp add: indRelR.simps)
qed

lemma (in encoding) indRelRT_iff_exists_source_target_relation:
  fixes Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  shows "(\<forall>TRel. (\<forall>(TP, TQ) \<in> TRel. Pred (TargetTerm TP, TargetTerm TQ))
          \<longleftrightarrow> (\<forall>(P, Q) \<in> indRelRT TRel. Pred (P, Q)))
         = (\<exists>Rel. (\<forall>S. (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> Rel) \<and> (\<forall>(P, Q) \<in> Rel. Pred (P, Q)))"
      using indRelR_iff_exists_source_target_relation[where Pred="Pred"]
            indRelR_modulo_pred_impl_indRelRT_modulo_pred[where Pred="Pred"]
    by simp

lemma (in encoding) indRelRT_modulo_pred_impl_indRelRTPO_modulo_pred:
  fixes TRel :: "('procT \<times> 'procT) set"
    and Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  assumes reflCond:  "\<forall>P. Pred (P, P)"
      and transCond: "\<forall>P Q R. Pred (P, Q) \<and> Pred (Q, R) \<longrightarrow> Pred (P, R)"
  shows "(\<forall>(P, Q) \<in> indRelRT TRel. Pred (P, Q)) = (\<forall>(P, Q) \<in> indRelRTPO TRel. Pred (P, Q))"
proof auto
  fix P Q
  assume A: "\<forall>x \<in> indRelRT TRel. Pred x"
  assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> Q"
  thus "Pred (P, Q)"
  proof induct
    case (encR S)
    have "SourceTerm S \<R>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> TargetTerm (\<lbrakk>S\<rbrakk>)"
      by (simp add: indRelRT.encR)
    with A show "Pred (SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>))"
      by simp
  next
    case (source S)
    from reflCond show "Pred (SourceTerm S, SourceTerm S)"
      by simp
  next
    case (target T1 T2)
    assume "(T1, T2) \<in> TRel"
    hence "TargetTerm T1 \<R>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> TargetTerm T2"
      by (simp add: indRelRT.target)
    with A show "Pred (TargetTerm T1, TargetTerm T2)"
      by simp
  next
    case (trans P Q R)
    assume "Pred (P, Q)" and "Pred (Q, R)"
    with transCond show "Pred (P, R)"
      by blast
  qed
next
  fix P Q
  assume "\<forall>x \<in> indRelRTPO TRel. Pred x" and "P \<R>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> Q"
  thus "Pred (P, Q)"
    by (auto simp add: indRelRTPO.encR indRelRTPO.target indRelRT.simps)
qed

lemma (in encoding) indRelR_modulo_pred_impl_indRelRTPO_modulo_pred:
  fixes Pred :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) \<Rightarrow> bool"
  assumes "\<forall>P. Pred (P, P)"
      and "\<forall>P Q R. Pred (P, Q) \<and> Pred (Q, R) \<longrightarrow> Pred (P, R)"
  shows "(\<forall>(P, Q) \<in> indRelR. Pred (P, Q))
         = (\<forall>TRel. (\<forall>(TP, TQ) \<in> TRel. Pred (TargetTerm TP, TargetTerm TQ))
            \<longleftrightarrow> (\<forall>(P, Q) \<in> indRelRTPO TRel. Pred (P, Q)))"
proof -
  have "(\<forall>(P, Q)\<in>indRelR. Pred (P, Q)) = (\<forall>TRel. (\<forall>(TP, TQ) \<in> TRel.
        Pred (TargetTerm TP, TargetTerm TQ)) \<longleftrightarrow> (\<forall>(P, Q) \<in> indRelRT TRel. Pred (P, Q)))"
      using indRelR_modulo_pred_impl_indRelRT_modulo_pred[where Pred="Pred"]
    by simp
  moreover
  have "\<forall>TRel. (\<forall>(P, Q)\<in>indRelRT TRel. Pred (P, Q)) = (\<forall>(P, Q)\<in>indRelRTPO TRel. Pred (P, Q))"
      using assms indRelRT_modulo_pred_impl_indRelRTPO_modulo_pred[where Pred="Pred"]
    by blast
  ultimately show ?thesis
    by simp
qed


inductive_set (in encoding) indRelLT
    :: "('procT \<times> 'procT) set \<Rightarrow> ((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
    for TRel :: "('procT \<times> 'procT) set"
  where
  encL:   "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> indRelLT TRel" |
  target: "(T1, T2) \<in> TRel \<Longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> indRelLT TRel"

abbreviation (in encoding) indRelLTinfix
    :: "('procS, 'procT) Proc \<Rightarrow> ('procT \<times> 'procT) set \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool"
       ("_ \<R>\<lbrakk>\<cdot>\<rbrakk>LT<_> _" [75, 75, 75] 80)
  where
  "P \<R>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> Q \<equiv> (P, Q) \<in> indRelLT TRel"

inductive_set (in encoding) indRelLTPO
    :: "('procT \<times> 'procT) set \<Rightarrow> ((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
    for TRel :: "('procT \<times> 'procT) set"
  where
  encL:   "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> indRelLTPO TRel" |
  source: "(SourceTerm S, SourceTerm S) \<in> indRelLTPO TRel" |
  target: "(T1, T2) \<in> TRel \<Longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> indRelLTPO TRel" |
  trans:  "\<lbrakk>(P, Q) \<in> indRelLTPO TRel; (Q, R) \<in> indRelLTPO TRel\<rbrakk> \<Longrightarrow> (P, R) \<in> indRelLTPO TRel"

abbreviation (in encoding) indRelLTPOinfix
    :: "('procS, 'procT) Proc \<Rightarrow> ('procT \<times> 'procT) set \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool"
       ("_ \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<_> _" [75, 75, 75] 80)
  where
  "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> Q \<equiv> (P, Q) \<in> indRelLTPO TRel"

lemma (in encoding) indRelLTPO_refl:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes refl: "refl TRel"
  shows "refl (indRelLTPO TRel)"
    unfolding refl_on_def
proof auto
  fix P
  show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> P"
  proof (cases P)
    case (SourceTerm SP)
    assume "SP \<in>S P"
    thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> P"
      by (simp add: indRelLTPO.source)
  next
    case (TargetTerm TP)
    assume "TP \<in>T P"
    with refl show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> P"
        using indRelLTPO.target[of TP TP TRel]
        unfolding refl_on_def
      by simp
  qed
qed

lemma (in encoding) refl_trans_closure_of_indRelLT:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes refl: "refl TRel"
  shows "indRelLTPO TRel = (indRelLT TRel)\<^sup>*"
proof auto
  fix P Q
  assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> Q"
  thus "(P, Q) \<in> (indRelLT TRel)\<^sup>*"
  proof induct
    case (encL S)
    show "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> (indRelLT TRel)\<^sup>*"
        using indRelLT.encL[of S TRel]
      by simp
  next
    case (source S)
    show "(SourceTerm S, SourceTerm S) \<in> (indRelLT TRel)\<^sup>*"
      by simp
  next
    case (target T1 T2)
    assume "(T1, T2) \<in> TRel"
    thus "(TargetTerm T1, TargetTerm T2) \<in> (indRelLT TRel)\<^sup>*"
        using indRelLT.target[of T1 T2 TRel]
      by simp
  next
    case (trans P Q R)
    assume "(P, Q) \<in> (indRelLT TRel)\<^sup>*" and "(Q, R) \<in> (indRelLT TRel)\<^sup>*"
    thus "(P, R) \<in> (indRelLT TRel)\<^sup>*"
      by simp
  qed
next
  fix P Q
  assume "(P, Q) \<in> (indRelLT TRel)\<^sup>*"
  thus "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> Q"
  proof induct
    from refl show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> P"
        using indRelLTPO_refl[of TRel]
        unfolding refl_on_def
      by simp
  next
    case (step Q R)
    assume "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> Q"
    moreover assume "Q \<R>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> R"
    hence "Q \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> R"
      by (induct, simp_all add: indRelLTPO.encL indRelLTPO.target)
    ultimately show "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> R"
      by (rule indRelLTPO.trans)
  qed
qed

inductive_set (in encoding) indRelT
    :: "('procT \<times> 'procT) set \<Rightarrow> ((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
    for TRel :: "('procT \<times> 'procT) set"
  where
  encR:   "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> indRelT TRel" |
  encL:   "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> indRelT TRel" |
  target: "(T1, T2) \<in> TRel \<Longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> indRelT TRel"

abbreviation (in encoding) indRelTinfix
    :: "('procS, 'procT) Proc \<Rightarrow> ('procT \<times> 'procT) set \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool"
       ("_ \<R>\<lbrakk>\<cdot>\<rbrakk>T<_> _" [75, 75, 75] 80)
  where
  "P \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q \<equiv> (P, Q) \<in> indRelT TRel"

lemma (in encoding) indRelT_symm:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes symm: "sym TRel"
  shows "sym (indRelT TRel)"
    unfolding sym_def
proof clarify
  fix P Q
  assume "(P, Q) \<in> indRelT TRel"
  thus "(Q, P) \<in> indRelT TRel"
      using symm
      unfolding sym_def
    by (induct, simp_all add: indRelT.encL indRelT.encR indRelT.target)
qed

inductive_set (in encoding) indRelTEQ
    :: "('procT \<times> 'procT) set \<Rightarrow> ((('procS, 'procT) Proc) \<times> (('procS, 'procT) Proc)) set"
    for TRel :: "('procT \<times> 'procT) set"
  where
  encR:   "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> indRelTEQ TRel" |
  encL:   "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> indRelTEQ TRel" |
  target: "(T1, T2) \<in> TRel \<Longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> indRelTEQ TRel" |
  trans:  "\<lbrakk>(P, Q) \<in> indRelTEQ TRel; (Q, R) \<in> indRelTEQ TRel\<rbrakk> \<Longrightarrow> (P, R) \<in> indRelTEQ TRel"

abbreviation (in encoding) indRelTEQinfix
    :: "('procS, 'procT) Proc \<Rightarrow> ('procT \<times> 'procT) set \<Rightarrow> ('procS, 'procT) Proc \<Rightarrow> bool"
       ("_ \<sim>\<lbrakk>\<cdot>\<rbrakk>T<_> _" [75, 75, 75] 80)
  where
  "P \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q \<equiv> (P, Q) \<in> indRelTEQ TRel"

lemma (in encoding) indRelTEQ_refl:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes refl: "refl TRel"
  shows "refl (indRelTEQ TRel)"
    unfolding refl_on_def
proof auto
  fix P
  show "P \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> P"
  proof (cases P)
    case (SourceTerm SP)
    assume "SP \<in>S P"
    moreover have "SourceTerm SP \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> TargetTerm (\<lbrakk>SP\<rbrakk>)"
      by (rule indRelTEQ.encR)
    moreover have "TargetTerm (\<lbrakk>SP\<rbrakk>) \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> SourceTerm SP"
      by (rule indRelTEQ.encL)
    ultimately show "P \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> P"
      by (simp add: indRelTEQ.trans[where P="SourceTerm SP" and Q="TargetTerm (\<lbrakk>SP\<rbrakk>)"])
  next
    case (TargetTerm TP)
    assume "TP \<in>T P"
    with refl show "P \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> P"
        unfolding refl_on_def
      by (simp add: indRelTEQ.target)
  qed
qed

lemma (in encoding) indRelTEQ_symm:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes symm: "sym TRel"
  shows "sym (indRelTEQ TRel)"
    unfolding sym_def
proof clarify
  fix P Q
  assume "P \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q"
  thus "Q \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> P"
  proof induct
    case (encR S)
    show "TargetTerm (\<lbrakk>S\<rbrakk>) \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> SourceTerm S"
      by (rule indRelTEQ.encL)
  next
    case (encL S)
    show "SourceTerm S \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> TargetTerm (\<lbrakk>S\<rbrakk>)"
      by (rule indRelTEQ.encR)
  next
    case (target T1 T2)
    assume "(T1, T2) \<in> TRel"
    with symm show "TargetTerm T2 \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> TargetTerm T1"
        unfolding sym_def
      by (simp add: indRelTEQ.target)
  next
    case (trans P Q R)
    assume "R \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q" and "Q \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> P"
    thus "R \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> P"
      by (rule indRelTEQ.trans)
  qed
qed

lemma (in encoding) refl_trans_closure_of_indRelT:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes refl: "refl TRel"
  shows "indRelTEQ TRel = (indRelT TRel)\<^sup>*"
proof auto
  fix P Q
  assume "P \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q"
  thus "(P, Q) \<in> (indRelT TRel)\<^sup>*"
  proof induct
    case (encR S)
    show "(SourceTerm S, TargetTerm (\<lbrakk>S\<rbrakk>)) \<in> (indRelT TRel)\<^sup>*"
        using indRelT.encR[of S TRel]
      by simp
  next
    case (encL S)
    show "(TargetTerm (\<lbrakk>S\<rbrakk>), SourceTerm S) \<in> (indRelT TRel)\<^sup>*"
        using indRelT.encL[of S TRel]
      by simp
  next
    case (target T1 T2)
    assume "(T1, T2) \<in> TRel"
    thus "(TargetTerm T1, TargetTerm T2) \<in> (indRelT TRel)\<^sup>*"
        using indRelT.target[of T1 T2 TRel]
      by simp
  next
    case (trans P Q R)
    assume "(P, Q) \<in> (indRelT TRel)\<^sup>*" and "(Q, R) \<in> (indRelT TRel)\<^sup>*"
    thus "(P, R) \<in> (indRelT TRel)\<^sup>*"
      by simp
  qed
next
  fix P Q
  assume "(P, Q) \<in> (indRelT TRel)\<^sup>*"
  thus "P \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q"
  proof induct
    from refl show "P \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> P"
        using indRelTEQ_refl[of TRel]
        unfolding refl_on_def
      by simp
  next
    case (step Q R)
    assume "P \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q"
    moreover assume "Q \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> R"
    hence "Q \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> R"
      by (induct, simp_all add: indRelTEQ.encR indRelTEQ.encL indRelTEQ.target)
    ultimately show "P \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> R"
      by (rule indRelTEQ.trans)
  qed
qed

lemma (in encoding) refl_symm_trans_closure_of_indRelT:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes refl: "refl TRel"
      and symm: "sym TRel"
  shows "indRelTEQ TRel = (symcl ((indRelT TRel)\<^sup>=))\<^sup>+"
proof -
  have "(symcl ((indRelT TRel)\<^sup>=))\<^sup>+ = (symcl (indRelT TRel))\<^sup>*"
    by (rule refl_symm_trans_closure_is_symm_refl_trans_closure[where Rel="indRelT TRel"])
  moreover from symm have "symcl (indRelT TRel) = indRelT TRel"
      using indRelT_symm[where TRel="TRel"] symm_closure_of_symm_rel[where Rel="indRelT TRel"]
    by blast
  ultimately show "indRelTEQ TRel = (symcl ((indRelT TRel)\<^sup>=))\<^sup>+"
      using refl refl_trans_closure_of_indRelT[where TRel="TRel"]
    by simp
qed

lemma (in encoding) symm_closure_of_indRelRT:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes refl: "refl TRel"
      and symm: "sym TRel"
  shows "indRelT TRel = symcl (indRelRT TRel)"
    and "indRelTEQ TRel = (symcl ((indRelRT TRel)\<^sup>=))\<^sup>+"
proof -
  show "indRelT TRel = symcl (indRelRT TRel)"
  proof auto
    fix P Q
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q"
    thus "(P, Q) \<in> symcl (indRelRT TRel)"
      by (induct, simp_all add: symcl_def indRelRT.encR indRelRT.target)
  next
    fix P Q
    assume "(P, Q) \<in> symcl (indRelRT TRel)"
    thus "P \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q"
    proof (auto simp add: symcl_def indRelRT.simps)
      fix S
      show "SourceTerm S \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> TargetTerm (\<lbrakk>S\<rbrakk>)"
        by (rule indRelT.encR)
    next
      fix T1 T2
      assume "(T1, T2) \<in> TRel"
      thus "TargetTerm T1 \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> TargetTerm T2"
        by (rule indRelT.target)
    next
      fix S
      show "TargetTerm (\<lbrakk>S\<rbrakk>) \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> SourceTerm S"
        by (rule indRelT.encL)
    next
      fix T1 T2
      assume "(T1, T2) \<in> TRel"
      with symm show "TargetTerm T2 \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> TargetTerm T1"
          unfolding sym_def
        by (simp add: indRelT.target)
    qed
  qed
  with refl show "indRelTEQ TRel = (symcl ((indRelRT TRel)\<^sup>=))\<^sup>+"
      using refl_symm_trans_closure_is_symm_refl_trans_closure[where Rel="indRelRT TRel"]
            refl_trans_closure_of_indRelT
    by simp
qed

lemma (in encoding) symm_closure_of_indRelLT:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes refl: "refl TRel"
      and symm: "sym TRel"
  shows "indRelT TRel = symcl (indRelLT TRel)"
    and "indRelTEQ TRel = (symcl ((indRelLT TRel)\<^sup>=))\<^sup>+"
proof -
  show "indRelT TRel = symcl (indRelLT TRel)"
  proof auto
    fix P Q
    assume "P \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q"
    thus "(P, Q) \<in> symcl (indRelLT TRel)"
      by (induct, simp_all add: symcl_def indRelLT.encL indRelLT.target)
  next
    fix P Q
    assume "(P, Q) \<in> symcl (indRelLT TRel)"
    thus "P \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q"
    proof (auto simp add: symcl_def indRelLT.simps)
      fix S
      show "SourceTerm S \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> TargetTerm (\<lbrakk>S\<rbrakk>)"
        by (rule indRelT.encR)
    next
      fix T1 T2
      assume "(T1, T2) \<in> TRel"
      thus "TargetTerm T1 \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> TargetTerm T2"
        by (rule indRelT.target)
    next
      fix S
      show "TargetTerm (\<lbrakk>S\<rbrakk>) \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> SourceTerm S"
        by (rule indRelT.encL)
    next
      fix T1 T2
      assume "(T1, T2) \<in> TRel"
      with symm show "TargetTerm T2 \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> TargetTerm T1"
          unfolding sym_def
        by (simp add: indRelT.target)
    qed
  qed
  with refl show "indRelTEQ TRel = (symcl ((indRelLT TRel)\<^sup>=))\<^sup>+"
      using refl_symm_trans_closure_is_symm_refl_trans_closure[where Rel="indRelLT TRel"]
            refl_trans_closure_of_indRelT
    by simp
qed


lemma (in encoding) indRelRT_to_TRel:
  fixes TRel  :: "('procT \<times> 'procT) set"
    and TP TQ :: "'procT"
  assumes rel: "TargetTerm TP \<R>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> TargetTerm TQ"
  shows "(TP, TQ) \<in> TRel"
      using rel
    by (simp add: indRelRT.simps)

lemma (in encoding) indRelLT_to_TRel:
  fixes TRel  :: "('procT \<times> 'procT) set"
    and TP TQ :: "'procT"
  assumes rel: "TargetTerm TP \<R>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> TargetTerm TQ"
  shows "(TP, TQ) \<in> TRel"
      using rel
    by (simp add: indRelLT.simps)

lemma (in encoding) indRelT_to_TRel:
  fixes TRel  :: "('procT \<times> 'procT) set"
    and TP TQ :: "'procT"
  assumes rel: "TargetTerm TP \<R>\<lbrakk>\<cdot>\<rbrakk>T<TRel> TargetTerm TQ"
  shows "(TP, TQ) \<in> TRel"
      using rel
    by (simp add: indRelT.simps)


lemma (in encoding) indRelRTPO_to_TRel:
  fixes TRel :: "('procT \<times> 'procT) set"
    and P Q  :: "('procS, 'procT) Proc"
  assumes rel: "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> Q"
  shows "\<forall>SP SQ. SP \<in>S P \<and> SQ \<in>S Q \<longrightarrow> SP = SQ"
    and "\<forall>SP TQ. SP \<in>S P \<and> TQ \<in>T Q
         \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    and "\<forall>TP SQ. TP \<in>T P \<and> SQ \<in>S Q \<longrightarrow> False"
    and "\<forall>TP TQ. TP \<in>T P \<and> TQ \<in>T Q \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
proof -
  have reflTRel: "\<forall>S. (\<lbrakk>S\<rbrakk>, \<lbrakk>S\<rbrakk>) \<in> TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>}"
    by auto
  from rel show "\<forall>SP SQ. SP \<in>S P \<and> SQ \<in>S Q \<longrightarrow> SP = SQ"
            and "\<forall>SP TQ. SP \<in>S P \<and> TQ \<in>T Q
                 \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
            and "\<forall>TP SQ. TP \<in>T P \<and> SQ \<in>S Q \<longrightarrow> False"
            and "\<forall>TP TQ. TP \<in>T P \<and> TQ \<in>T Q \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
  proof induct
    case (encR S)
    show "\<forall>SP SQ. SP \<in>S SourceTerm S \<and> SQ \<in>S TargetTerm (\<lbrakk>S\<rbrakk>) \<longrightarrow> SP = SQ"
     and "\<forall>TP SQ. TP \<in>T SourceTerm S \<and> SQ \<in>S TargetTerm (\<lbrakk>S\<rbrakk>) \<longrightarrow> False"
     and "\<forall>TP TQ. TP \<in>T SourceTerm S \<and> TQ \<in>T TargetTerm (\<lbrakk>S\<rbrakk>) \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
      by simp_all
    from reflTRel show "\<forall>SP TQ. SP \<in>S SourceTerm S \<and> TQ \<in>T TargetTerm (\<lbrakk>S\<rbrakk>)
                        \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
      by blast
  next
    case (source S)
    show "\<forall>SP SQ. SP \<in>S SourceTerm S \<and> SQ \<in>S SourceTerm S \<longrightarrow> SP = SQ"
      by simp
    show "\<forall>SP TQ. SP \<in>S SourceTerm S \<and> TQ \<in>T SourceTerm S
          \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
     and "\<forall>TP SQ. TP \<in>T SourceTerm S \<and> SQ \<in>S SourceTerm S \<longrightarrow> False"
     and "\<forall>TP TQ. TP \<in>T SourceTerm S \<and> TQ \<in>T SourceTerm S \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
      by simp_all
  next
    case (target T1 T2)
    show "\<forall>SP SQ. SP \<in>S TargetTerm T1 \<and> SQ \<in>S TargetTerm T2 \<longrightarrow> SP = SQ"
     and "\<forall>SP TQ. SP \<in>S TargetTerm T1 \<and> TQ \<in>T TargetTerm T2
          \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
     and "\<forall>TP SQ. TP \<in>T TargetTerm T1 \<and> SQ \<in>S TargetTerm T2 \<longrightarrow> False"
      by simp_all
    assume "(T1, T2) \<in> TRel"
    thus "\<forall>TP TQ. TP \<in>T TargetTerm T1 \<and> TQ \<in>T TargetTerm T2 \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
      by simp
  next
    case (trans P Q R)
    assume A1: "\<forall>SP SQ. SP \<in>S P \<and> SQ \<in>S Q \<longrightarrow> SP = SQ"
       and A2: "\<forall>SP TQ. SP \<in>S P \<and> TQ \<in>T Q
                \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
       and A3: "\<forall>TP SQ. TP \<in>T P \<and> SQ \<in>S Q \<longrightarrow> False"
       and A4: "\<forall>TP TQ. TP \<in>T P \<and> TQ \<in>T Q \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
       and A5: "\<forall>SQ SR. SQ \<in>S Q \<and> SR \<in>S R \<longrightarrow> SQ = SR"
       and A6: "\<forall>SQ TR. SQ \<in>S Q \<and> TR \<in>T R
                \<longrightarrow> (\<lbrakk>SQ\<rbrakk>, TR) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
       and A7: "\<forall>TQ SR. TQ \<in>T Q \<and> SR \<in>S R \<longrightarrow> False"
       and A8: "\<forall>TQ TR. TQ \<in>T Q \<and> TR \<in>T R \<longrightarrow> (TQ, TR) \<in> TRel\<^sup>+"
    show "\<forall>SP SR. SP \<in>S P \<and> SR \<in>S R \<longrightarrow> SP = SR"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A1 A5 show "\<forall>SP SR. SP \<in>S P \<and> SR \<in>S R \<longrightarrow> SP = SR"
        by blast
    next
      case (TargetTerm TQ)
      assume "TQ \<in>T Q"
      with A7 show ?thesis
        by blast
    qed
    show "\<forall>SP TR. SP \<in>S P \<and> TR \<in>T R
          \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TR) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A1 A6 show ?thesis
        by blast
    next
      case (TargetTerm TQ)
      assume A9: "TQ \<in>T Q"
      show "\<forall>SP TR. SP \<in>S P \<and> TR \<in>T R
            \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TR) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
      proof clarify
        fix SP TR
        assume "SP \<in>S P"
        with A2 A9 have "(\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
          by simp
        moreover assume "TR \<in>T R"
        with A8 A9 have "(TQ, TR) \<in> TRel\<^sup>+"
          by simp
        hence "(TQ, TR) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
        proof induct
          fix T2
          assume "(TQ, T2) \<in> TRel"
          thus "(TQ, T2) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
            by blast
        next
          case (step T2 T3)
          assume "(TQ, T2) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
          moreover assume "(T2, T3) \<in> TRel"
          hence "(T2, T3) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
            by blast
          ultimately show "(TQ, T3) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
            by simp
        qed
        ultimately show "(\<lbrakk>SP\<rbrakk>, TR) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
          by simp
      qed
    qed
    show "\<forall>TP SR. TP \<in>T P \<and> SR \<in>S R \<longrightarrow> False"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A3 show ?thesis
        by blast
    next
      case (TargetTerm TQ)
      assume "TQ \<in>T Q"
      with A7 show ?thesis
        by blast
    qed
    show "\<forall>TP TR. TP \<in>T P \<and> TR \<in>T R \<longrightarrow> (TP, TR) \<in> TRel\<^sup>+"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A3 show ?thesis
        by blast
    next
      case (TargetTerm TQ)
      assume "TQ \<in>T Q"
      with A4 A8 show "\<forall>TP TR. TP \<in>T P \<and> TR \<in>T R \<longrightarrow> (TP, TR) \<in> TRel\<^sup>+"
        by auto
    qed
  qed
qed

lemma (in encoding) indRelLTPO_to_TRel:
  fixes TRel :: "('procT \<times> 'procT) set"
    and P Q  :: "('procS, 'procT) Proc"
  assumes rel: "P \<lesssim>\<lbrakk>\<cdot>\<rbrakk>LT<TRel> Q"
  shows "\<forall>SP SQ. SP \<in>S P \<and> SQ \<in>S Q \<longrightarrow> SP = SQ"
    and "\<forall>SP TQ. SP \<in>S P \<and> TQ \<in>T Q \<longrightarrow> False"
    and "\<forall>TP SQ. TP \<in>T P \<and> SQ \<in>S Q
         \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    and "\<forall>TP TQ. TP \<in>T P \<and> TQ \<in>T Q \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
proof -
  have reflTRel: "\<forall>S. (\<lbrakk>S\<rbrakk>, \<lbrakk>S\<rbrakk>) \<in> TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>}"
    by auto
  from rel show "\<forall>SP SQ. SP \<in>S P \<and> SQ \<in>S Q \<longrightarrow> SP = SQ"
            and "\<forall>SP TQ. SP \<in>S P \<and> TQ \<in>T Q \<longrightarrow> False"
            and "\<forall>TP SQ. TP \<in>T P \<and> SQ \<in>S Q
                 \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
            and "\<forall>TP TQ. TP \<in>T P \<and> TQ \<in>T Q \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
  proof induct
    case (encL S)
    show "\<forall>SP SQ. SP \<in>S TargetTerm (\<lbrakk>S\<rbrakk>) \<and> SQ \<in>S SourceTerm S  \<longrightarrow> SP = SQ"
     and "\<forall>SP TQ. SP \<in>S TargetTerm (\<lbrakk>S\<rbrakk>) \<and> TQ \<in>T SourceTerm S \<longrightarrow> False"
     and "\<forall>TP TQ. TP \<in>T TargetTerm (\<lbrakk>S\<rbrakk>) \<and> TQ \<in>T SourceTerm S \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
      by simp_all
    from reflTRel show "\<forall>TP SQ. TP \<in>T TargetTerm (\<lbrakk>S\<rbrakk>) \<and> SQ \<in>S SourceTerm S
                        \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
      by blast
  next
    case (source S)
    show "\<forall>SP SQ. SP \<in>S SourceTerm S \<and> SQ \<in>S SourceTerm S \<longrightarrow> SP = SQ"
      by simp
    show "\<forall>SP TQ. SP \<in>S SourceTerm S \<and> TQ \<in>T SourceTerm S \<longrightarrow> False"
     and "\<forall>TP SQ. TP \<in>T SourceTerm S \<and> SQ \<in>S SourceTerm S
          \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
     and "\<forall>TP TQ. TP \<in>T SourceTerm S \<and> TQ \<in>T SourceTerm S \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
      by simp_all
  next
    case (target T1 T2)
    show "\<forall>SP SQ. SP \<in>S TargetTerm T1 \<and> SQ \<in>S TargetTerm T2 \<longrightarrow> SP = SQ"
     and "\<forall>SP TQ. SP \<in>S TargetTerm T1 \<and> TQ \<in>T TargetTerm T2 \<longrightarrow> False"
     and "\<forall>TP SQ. TP \<in>T TargetTerm T1 \<and> SQ \<in>S TargetTerm T2
          \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
      by simp_all
    assume "(T1, T2) \<in> TRel"
    thus "\<forall>TP TQ. TP \<in>T TargetTerm T1 \<and> TQ \<in>T TargetTerm T2 \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
      by simp
  next
    case (trans P Q R)
    assume A1: "\<forall>SP SQ. SP \<in>S P \<and> SQ \<in>S Q \<longrightarrow> SP = SQ"
       and A2: "\<forall>SP TQ. SP \<in>S P \<and> TQ \<in>T Q \<longrightarrow> False"
       and A3: "\<forall>TP SQ. TP \<in>T P \<and> SQ \<in>S Q
                \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
       and A4: "\<forall>TP TQ. TP \<in>T P \<and> TQ \<in>T Q \<longrightarrow> (TP, TQ) \<in> TRel\<^sup>+"
       and A5: "\<forall>SQ SR. SQ \<in>S Q \<and> SR \<in>S R \<longrightarrow> SQ = SR"
       and A6: "\<forall>SQ TR. SQ \<in>S Q \<and> TR \<in>T R \<longrightarrow> False"
       and A7: "\<forall>TQ SR. TQ \<in>T Q \<and> SR \<in>S R
                \<longrightarrow> (TQ, \<lbrakk>SR\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
       and A8: "\<forall>TQ TR. TQ \<in>T Q \<and> TR \<in>T R \<longrightarrow> (TQ, TR) \<in> TRel\<^sup>+"
    show "\<forall>SP SR. SP \<in>S P \<and> SR \<in>S R \<longrightarrow> SP = SR"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A1 A5 show "\<forall>SP SR. SP \<in>S P \<and> SR \<in>S R \<longrightarrow> SP = SR"
        by blast
    next
      case (TargetTerm TQ)
      assume "TQ \<in>T Q"
      with A2 show ?thesis
        by blast
    qed
    show "\<forall>SP TR. SP \<in>S P \<and> TR \<in>T R \<longrightarrow> False"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A6 show ?thesis
        by blast
    next
      case (TargetTerm TQ)
      assume "TQ \<in>T Q"
      with A2 show ?thesis
        by blast
    qed
    show "\<forall>TP SR. TP \<in>T P \<and> SR \<in>S R
          \<longrightarrow> (TP, \<lbrakk>SR\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A3 A5 show "\<forall>TP SR. TP \<in>T P \<and> SR \<in>S R
                       \<longrightarrow> (TP, \<lbrakk>SR\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
        by blast
    next
      case (TargetTerm TQ)
      assume A9: "TQ \<in>T Q"
      show "\<forall>TP SR. TP \<in>T P \<and> SR \<in>S R
            \<longrightarrow> (TP, \<lbrakk>SR\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
      proof clarify
        fix TP SR
        assume "TP \<in>T P"
        with A4 A9 have "(TP, TQ) \<in> TRel\<^sup>+"
          by simp
        hence "(TP, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
        proof induct
          fix T2
          assume "(TP, T2) \<in> TRel"
          thus "(TP, T2) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
            by blast
        next
          case (step T2 T3)
          assume "(TP, T2) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
          moreover assume "(T2, T3) \<in> TRel"
          hence "(T2, T3) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
            by blast
          ultimately show "(TP, T3) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
            by simp
        qed
        moreover assume "SR \<in>S R"
        with A7 A9 have "(TQ, \<lbrakk>SR\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
          by simp
        ultimately show "(TP, \<lbrakk>SR\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
          by simp
      qed
    qed
    show "\<forall>TP TR. TP \<in>T P \<and> TR \<in>T R \<longrightarrow> (TP, TR) \<in> TRel\<^sup>+"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A6 show ?thesis
        by blast
    next
      case (TargetTerm TQ)
      assume "TQ \<in>T Q"
      with A4 A8 show "\<forall>TP TR. TP \<in>T P \<and> TR \<in>T R \<longrightarrow> (TP, TR) \<in> TRel\<^sup>+"
        by auto
    qed
  qed
qed

lemma (in encoding) indRelTEQ_to_TRel:
  fixes TRel :: "('procT \<times> 'procT) set"
    and P Q  :: "('procS, 'procT) Proc"
  assumes rel: "P \<sim>\<lbrakk>\<cdot>\<rbrakk>T<TRel> Q"
  shows "\<forall>SP SQ. SP \<in>S P \<and> SQ \<in>S Q
         \<longrightarrow> (\<lbrakk>SP\<rbrakk>, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    and "\<forall>SP TQ. SP \<in>S P \<and> TQ \<in>T Q
         \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    and "\<forall>TP SQ. TP \<in>T P \<and> SQ \<in>S Q
         \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    and "\<forall>TP TQ. TP \<in>T P \<and> TQ \<in>T Q
         \<longrightarrow> (TP, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
proof -
  have reflTRel: "\<forall>S. (\<lbrakk>S\<rbrakk>, \<lbrakk>S\<rbrakk>) \<in> TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>}"
    by auto
  from rel show "\<forall>SP SQ. SP \<in>S P \<and> SQ \<in>S Q
                 \<longrightarrow> (\<lbrakk>SP\<rbrakk>, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
            and "\<forall>SP TQ. SP \<in>S P \<and> TQ \<in>T Q
                 \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
            and "\<forall>TP SQ. TP \<in>T P \<and> SQ \<in>S Q
                 \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
            and "\<forall>TP TQ. TP \<in>T P \<and> TQ \<in>T Q
                 \<longrightarrow> (TP, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
  proof induct
    case (encR S)
    show "\<forall>SP SQ. SP \<in>S SourceTerm S \<and> SQ \<in>S TargetTerm (\<lbrakk>S\<rbrakk>)
          \<longrightarrow> (\<lbrakk>SP\<rbrakk>, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
     and "\<forall>TP SQ. TP \<in>T SourceTerm S \<and> SQ \<in>S TargetTerm (\<lbrakk>S\<rbrakk>)
          \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
     and "\<forall>TP TQ. TP \<in>T SourceTerm S \<and> TQ \<in>T TargetTerm (\<lbrakk>S\<rbrakk>)
          \<longrightarrow> (TP, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
      by simp+
    from reflTRel show "\<forall>SP TQ. SP \<in>S SourceTerm S \<and> TQ \<in>T TargetTerm (\<lbrakk>S\<rbrakk>)
                        \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
      by blast
  next
    case (encL S)
    show "\<forall>SP SQ. SP \<in>S TargetTerm (\<lbrakk>S\<rbrakk>) \<and> SQ \<in>S SourceTerm S
          \<longrightarrow> (\<lbrakk>SP\<rbrakk>, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
     and "\<forall>SP TQ. SP \<in>S TargetTerm (\<lbrakk>S\<rbrakk>) \<and> TQ \<in>T SourceTerm S
          \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
     and "\<forall>TP TQ. TP \<in>T TargetTerm (\<lbrakk>S\<rbrakk>) \<and> TQ \<in>T SourceTerm S
          \<longrightarrow> (TP, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
      by simp+
    from reflTRel show "\<forall>TP SQ. TP \<in>T TargetTerm (\<lbrakk>S\<rbrakk>) \<and> SQ \<in>S SourceTerm S
                        \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
      by blast
  next
    case (target T1 T2)
    show "\<forall>SP SQ. SP \<in>S TargetTerm T1 \<and> SQ \<in>S TargetTerm T2
          \<longrightarrow> (\<lbrakk>SP\<rbrakk>, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
     and "\<forall>SP TQ. SP \<in>S TargetTerm T1 \<and> TQ \<in>T TargetTerm T2
          \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
     and "\<forall>TP SQ. TP \<in>T TargetTerm T1 \<and> SQ \<in>S TargetTerm T2
          \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
      by simp+
    assume "(T1, T2) \<in> TRel"
    thus "\<forall>TP TQ. TP \<in>T TargetTerm T1 \<and> TQ \<in>T TargetTerm T2
          \<longrightarrow> (TP, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
      by blast
  next
    case (trans P Q R)
    assume A1: "\<forall>SP SQ. SP \<in>S P \<and> SQ \<in>S Q
                \<longrightarrow> (\<lbrakk>SP\<rbrakk>, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
       and A2: "\<forall>SP TQ. SP \<in>S P \<and> TQ \<in>T Q
                \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
       and A3: "\<forall>TP SQ. TP \<in>T P \<and> SQ \<in>S Q
                \<longrightarrow> (TP, \<lbrakk>SQ\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
       and A4: "\<forall>TP TQ. TP \<in>T P \<and> TQ \<in>T Q
                \<longrightarrow> (TP, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
       and A5: "\<forall>SQ SR. SQ \<in>S Q \<and> SR \<in>S R
                \<longrightarrow> (\<lbrakk>SQ\<rbrakk>, \<lbrakk>SR\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
       and A6: "\<forall>SQ TR. SQ \<in>S Q \<and> TR \<in>T R
                \<longrightarrow> (\<lbrakk>SQ\<rbrakk>, TR) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
       and A7: "\<forall>TQ SR. TQ \<in>T Q \<and> SR \<in>S R
                \<longrightarrow> (TQ, \<lbrakk>SR\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
       and A8: "\<forall>TQ TR. TQ \<in>T Q \<and> TR \<in>T R
                \<longrightarrow> (TQ, TR) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    show "\<forall>SP SR. SP \<in>S P \<and> SR \<in>S R
          \<longrightarrow> (\<lbrakk>SP\<rbrakk>, \<lbrakk>SR\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A1 A5 show ?thesis
        by auto
    next
      case (TargetTerm TQ)
      assume "TQ \<in>T Q"
      with A2 A7 show ?thesis
        by auto
    qed
    show "\<forall>SP TR. SP \<in>S P \<and> TR \<in>T R \<longrightarrow> (\<lbrakk>SP\<rbrakk>, TR) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A1 A6 show ?thesis
        by auto
    next
      case (TargetTerm TQ)
      assume "TQ \<in>T Q"
      with A2 A8 show ?thesis
        by auto
    qed
    show "\<forall>TP SR. TP \<in>T P \<and> SR \<in>S R \<longrightarrow> (TP, \<lbrakk>SR\<rbrakk>) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A3 A5 show ?thesis
        by auto
    next
      case (TargetTerm TQ)
      assume "TQ \<in>T Q"
      with A4 A7 show ?thesis
        by auto
    qed
    show "\<forall>TP TR. TP \<in>T P \<and> TR \<in>T R \<longrightarrow> (TP, TR) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
    proof (cases Q)
      case (SourceTerm SQ)
      assume "SQ \<in>S Q"
      with A3 A6 show ?thesis
        by auto
    next
      case (TargetTerm TQ)
      assume "TQ \<in>T Q"
      with A4 A8 show ?thesis
        by auto
    qed
  qed
qed

lemma (in encoding) trans_closure_of_TRel_refl_cond:
  fixes TRel  :: "('procT \<times> 'procT) set"
    and TP TQ :: "'procT"
  assumes "(TP, TQ) \<in> (TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>})\<^sup>+"
  shows "(TP, TQ) \<in> TRel\<^sup>*"
    using assms
proof induct
  fix TQ
  assume "(TP, TQ) \<in> TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>}"
  thus "(TP, TQ) \<in> TRel\<^sup>*"
    by auto
next
  case (step TQ TR)
  assume "(TP, TQ) \<in> TRel\<^sup>*"
  moreover assume "(TQ, TR) \<in> TRel \<union> {(T1, T2). \<exists>S. T1 = \<lbrakk>S\<rbrakk> \<and> T2 = \<lbrakk>S\<rbrakk>}"
  hence "(TQ, TR) \<in> TRel\<^sup>*"
    by blast
  ultimately show "(TP, TR) \<in> TRel\<^sup>*"
    by simp
qed


lemma (in encoding) indRelRTPO_relates_source_target:
  fixes TRel :: "('procT \<times> 'procT) set"
    and S    :: "'procS"
    and T    :: "'procT"
  assumes pair: "SourceTerm S \<lesssim>\<lbrakk>\<cdot>\<rbrakk>RT<TRel> TargetTerm T"
  shows "(TargetTerm (\<lbrakk>S\<rbrakk>), TargetTerm T) \<in> (indRelRTPO TRel)\<^sup>="
proof -
  from pair have "(\<lbrakk>S\<rbrakk>, T) \<in> TRel\<^sup>*"
      using indRelRTPO_to_TRel(2)[where TRel="TRel"] trans_closure_of_TRel_refl_cond
    by simp
  hence "\<lbrakk>S\<rbrakk> = T \<or> (\<lbrakk>S\<rbrakk>, T) \<in> TRel\<^sup>+"
      using rtrancl_eq_or_trancl[of "\<lbrakk>S\<rbrakk>" T TRel]
    by blast
  moreover have "\<lbrakk>S\<rbrakk> = T \<Longrightarrow> (TargetTerm (\<lbrakk>S\<rbrakk>), TargetTerm T) \<in> (indRelRTPO TRel)\<^sup>="
    by simp
  moreover
  have "(\<lbrakk>S\<rbrakk>, T) \<in> TRel\<^sup>+ \<Longrightarrow> (TargetTerm (\<lbrakk>S\<rbrakk>), TargetTerm T) \<in> (indRelRTPO TRel)\<^sup>="
      using transitive_closure_of_TRel_to_indRelRTPO[where TRel="TRel"]
    by simp
  ultimately show "(TargetTerm (\<lbrakk>S\<rbrakk>), TargetTerm T) \<in> (indRelRTPO TRel)\<^sup>="
    by blast
qed


lemma (in encoding_wrt_barbs) rel_with_target_impl_TRel_preserves_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
    and Rel  :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) set"
  assumes preservation: "rel_preserves_barbs Rel (STCalWB SWB TWB)"
      and targetInRel:  "\<forall>T1 T2. (T1, T2) \<in> TRel \<longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> Rel"
  shows "rel_preserves_barbs TRel TWB"
proof clarify
  fix TP TQ a
  assume "(TP, TQ) \<in> TRel"
  with targetInRel have "(TargetTerm TP, TargetTerm TQ) \<in> Rel"
    by blast
  moreover assume "TP\<down><TWB>a"
  hence "TargetTerm TP\<down>.a"
    by simp
  ultimately have "TargetTerm TQ\<down>.a"
      using preservation preservation_of_barbs_in_barbed_encoding[where Rel="Rel"]
    by blast
  thus "TQ\<down><TWB>a"
    by simp
qed

lemma (in encoding_wrt_barbs) indRelRTPO_impl_TRel_preserves_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes preservation: "rel_preserves_barbs (indRelRTPO TRel) (STCalWB SWB TWB)"
  shows "rel_preserves_barbs TRel TWB"
      using preservation
            rel_with_target_impl_TRel_preserves_barbs[where Rel="indRelRTPO TRel" and TRel="TRel"]
    by (simp add: indRelRTPO.target)

lemma (in encoding_wrt_barbs) indRelLTPO_impl_TRel_preserves_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes preservation: "rel_preserves_barbs (indRelLTPO TRel) (STCalWB SWB TWB)"
  shows "rel_preserves_barbs TRel TWB"
      using preservation
            rel_with_target_impl_TRel_preserves_barbs[where Rel="indRelLTPO TRel" and TRel="TRel"]
    by (simp add: indRelLTPO.target)

lemma (in encoding_wrt_barbs) indRelTEQ_impl_TRel_preserves_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes preservation: "rel_preserves_barbs (indRelTEQ TRel) (STCalWB SWB TWB)"
  shows "rel_preserves_barbs TRel TWB"
      using preservation
            rel_with_target_impl_TRel_preserves_barbs[where Rel="indRelTEQ TRel" and TRel="TRel"]
    by (simp add: indRelTEQ.target)

lemma (in encoding_wrt_barbs) rel_with_target_impl_TRel_weakly_preserves_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
    and Rel  :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) set"
  assumes preservation: "rel_weakly_preserves_barbs Rel (STCalWB SWB TWB)"
      and targetInRel:  "\<forall>T1 T2. (T1, T2) \<in> TRel \<longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> Rel"
  shows "rel_weakly_preserves_barbs TRel TWB"
proof clarify
  fix TP TQ a TP'
  assume "(TP, TQ) \<in> TRel"
  with targetInRel have "(TargetTerm TP, TargetTerm TQ) \<in> Rel"
    by blast
  moreover assume "TP \<longmapsto>(Calculus TWB)* TP'" and "TP'\<down><TWB>a"
  hence "TargetTerm TP\<Down>.a"
    by blast
  ultimately have "TargetTerm TQ\<Down>.a"
      using preservation weak_preservation_of_barbs_in_barbed_encoding[where Rel="Rel"]
    by blast
  thus "TQ\<Down><TWB>a"
    by simp
qed

lemma (in encoding_wrt_barbs) indRelRTPO_impl_TRel_weakly_preserves_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes preservation: "rel_weakly_preserves_barbs (indRelRTPO TRel) (STCalWB SWB TWB)"
  shows "rel_weakly_preserves_barbs TRel TWB"
      using preservation rel_with_target_impl_TRel_weakly_preserves_barbs[where
                          Rel="indRelRTPO TRel" and TRel="TRel"]
    by (simp add: indRelRTPO.target)

lemma (in encoding_wrt_barbs) indRelLTPO_impl_TRel_weakly_preserves_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes preservation: "rel_weakly_preserves_barbs (indRelLTPO TRel) (STCalWB SWB TWB)"
  shows "rel_weakly_preserves_barbs TRel TWB"
      using preservation rel_with_target_impl_TRel_weakly_preserves_barbs[where
                          Rel="indRelLTPO TRel" and TRel="TRel"]
    by (simp add: indRelLTPO.target)

lemma (in encoding_wrt_barbs) indRelTEQ_impl_TRel_weakly_preserves_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes preservation: "rel_weakly_preserves_barbs (indRelTEQ TRel) (STCalWB SWB TWB)"
  shows "rel_weakly_preserves_barbs TRel TWB"
      using preservation rel_with_target_impl_TRel_weakly_preserves_barbs[where
                          Rel="indRelTEQ TRel" and TRel="TRel"]
    by (simp add: indRelTEQ.target)


lemma (in encoding_wrt_barbs) rel_with_target_impl_TRel_reflects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
    and Rel  :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) set"
  assumes reflection: "rel_reflects_barbs Rel (STCalWB SWB TWB)"
      and targetInRel:  "\<forall>T1 T2. (T1, T2) \<in> TRel \<longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> Rel"
  shows "rel_reflects_barbs TRel TWB"
proof clarify
  fix TP TQ a
  assume "(TP, TQ) \<in> TRel"
  with targetInRel have "(TargetTerm TP, TargetTerm TQ) \<in> Rel"
    by blast
  moreover assume "TQ\<down><TWB>a"
  hence "TargetTerm TQ\<down>.a"
    by simp
  ultimately have "TargetTerm TP\<down>.a"
      using reflection reflection_of_barbs_in_barbed_encoding[where Rel="Rel"]
    by blast
  thus "TP\<down><TWB>a"
    by simp
qed

lemma (in encoding_wrt_barbs) indRelRTPO_impl_TRel_reflects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes reflection: "rel_reflects_barbs (indRelRTPO TRel) (STCalWB SWB TWB)"
  shows "rel_reflects_barbs TRel TWB"
      using reflection
            rel_with_target_impl_TRel_reflects_barbs[where Rel="indRelRTPO TRel" and TRel="TRel"]
    by (simp add: indRelRTPO.target)

lemma (in encoding_wrt_barbs) indRelLTPO_impl_TRel_reflects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes reflection: "rel_reflects_barbs (indRelLTPO TRel) (STCalWB SWB TWB)"
  shows "rel_reflects_barbs TRel TWB"
      using reflection
            rel_with_target_impl_TRel_reflects_barbs[where Rel="indRelLTPO TRel" and TRel="TRel"]
    by (simp add: indRelLTPO.target)

lemma (in encoding_wrt_barbs) indRelTEQ_impl_TRel_reflects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes reflection: "rel_reflects_barbs (indRelTEQ TRel) (STCalWB SWB TWB)"
  shows "rel_reflects_barbs TRel TWB"
      using reflection
            rel_with_target_impl_TRel_reflects_barbs[where Rel="indRelTEQ TRel" and TRel="TRel"]
    by (simp add: indRelTEQ.target)

lemma (in encoding_wrt_barbs) rel_with_target_impl_TRel_weakly_reflects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
    and Rel  :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) set"
  assumes reflection: "rel_weakly_reflects_barbs Rel (STCalWB SWB TWB)"
      and targetInRel:  "\<forall>T1 T2. (T1, T2) \<in> TRel \<longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> Rel"
  shows "rel_weakly_reflects_barbs TRel TWB"
proof clarify
  fix TP TQ a TQ'
  assume "(TP, TQ) \<in> TRel"
  with targetInRel have "(TargetTerm TP, TargetTerm TQ) \<in> Rel"
    by blast
  moreover assume "TQ \<longmapsto>(Calculus TWB)* TQ'" and "TQ'\<down><TWB>a"
  hence "TargetTerm TQ\<Down>.a"
    by blast
  ultimately have "TargetTerm TP\<Down>.a"
      using reflection weak_reflection_of_barbs_in_barbed_encoding[where Rel="Rel"]
    by blast
  thus "TP\<Down><TWB>a"
    by simp
qed

lemma (in encoding_wrt_barbs) indRelRTPO_impl_TRel_weakly_reflects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes reflection: "rel_weakly_reflects_barbs (indRelRTPO TRel) (STCalWB SWB TWB)"
  shows "rel_weakly_reflects_barbs TRel TWB"
      using reflection rel_with_target_impl_TRel_weakly_reflects_barbs[where
                        Rel="indRelRTPO TRel" and TRel="TRel"]
    by (simp add: indRelRTPO.target)

lemma (in encoding_wrt_barbs) indRelLTPO_impl_TRel_weakly_reflects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes reflection: "rel_weakly_reflects_barbs (indRelLTPO TRel) (STCalWB SWB TWB)"
  shows "rel_weakly_reflects_barbs TRel TWB"
      using reflection rel_with_target_impl_TRel_weakly_reflects_barbs[where
                        Rel="indRelLTPO TRel" and TRel="TRel"]
    by (simp add: indRelLTPO.target)

lemma (in encoding_wrt_barbs) indRelTEQ_impl_TRel_weakly_reflects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes reflection: "rel_weakly_reflects_barbs (indRelTEQ TRel) (STCalWB SWB TWB)"
  shows "rel_weakly_reflects_barbs TRel TWB"
      using reflection rel_with_target_impl_TRel_weakly_reflects_barbs[where
                        Rel="indRelTEQ TRel" and TRel="TRel"]
    by (simp add: indRelTEQ.target)


lemma (in encoding_wrt_barbs) indRelRTPO_impl_TRel_respects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes respection: "rel_respects_barbs (indRelRTPO TRel) (STCalWB SWB TWB)"
  shows "rel_respects_barbs TRel TWB"
      using respection indRelRTPO_impl_TRel_preserves_barbs[where TRel="TRel"]
            indRelRTPO_impl_TRel_reflects_barbs[where TRel="TRel"]
    by blast

lemma (in encoding_wrt_barbs) indRelLTPO_impl_TRel_respects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes respection: "rel_respects_barbs (indRelLTPO TRel) (STCalWB SWB TWB)"
  shows "rel_respects_barbs TRel TWB"
      using respection indRelLTPO_impl_TRel_preserves_barbs[where TRel="TRel"]
            indRelLTPO_impl_TRel_reflects_barbs[where TRel="TRel"]
    by blast

lemma (in encoding_wrt_barbs) indRelTEQ_impl_TRel_respects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes respection: "rel_respects_barbs (indRelTEQ TRel) (STCalWB SWB TWB)"
  shows "rel_respects_barbs TRel TWB"
      using respection indRelTEQ_impl_TRel_preserves_barbs[where TRel="TRel"]
            indRelTEQ_impl_TRel_reflects_barbs[where TRel="TRel"]
    by blast

lemma (in encoding_wrt_barbs) indRelRTPO_impl_TRel_weakly_respects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes respection: "rel_weakly_respects_barbs (indRelRTPO TRel) (STCalWB SWB TWB)"
  shows "rel_weakly_respects_barbs TRel TWB"
      using respection indRelRTPO_impl_TRel_weakly_preserves_barbs[where TRel="TRel"]
            indRelRTPO_impl_TRel_weakly_reflects_barbs[where TRel="TRel"]
    by blast

lemma (in encoding_wrt_barbs) indRelLTPO_impl_TRel_weakly_respects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes respection: "rel_weakly_respects_barbs (indRelLTPO TRel) (STCalWB SWB TWB)"
  shows "rel_weakly_respects_barbs TRel TWB"
      using respection indRelLTPO_impl_TRel_weakly_preserves_barbs[where TRel="TRel"]
            indRelLTPO_impl_TRel_weakly_reflects_barbs[where TRel="TRel"]
    by blast

lemma (in encoding_wrt_barbs) indRelTEQ_impl_TRel_weakly_respects_barbs:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes respection: "rel_weakly_respects_barbs (indRelTEQ TRel) (STCalWB SWB TWB)"
  shows "rel_weakly_respects_barbs TRel TWB"
      using respection indRelTEQ_impl_TRel_weakly_preserves_barbs[where TRel="TRel"]
            indRelTEQ_impl_TRel_weakly_reflects_barbs[where TRel="TRel"]
    by blast


lemma (in encoding) rel_with_target_impl_transC_TRel_is_weak_reduction_simulation:
  fixes TRel :: "('procT \<times> 'procT) set"
    and Rel  :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) set"
  assumes sim:    "weak_reduction_simulation Rel (STCal Source Target)"
      and target: "\<forall>T1 T2. (T1, T2) \<in> TRel \<longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> Rel"
      and trel:   "\<forall>T1 T2. (TargetTerm T1, TargetTerm T2) \<in> Rel \<longrightarrow> (T1, T2) \<in> TRel\<^sup>+"
  shows "weak_reduction_simulation (TRel\<^sup>+) Target"
proof clarify
  fix TP TQ TP'
  assume "(TP, TQ) \<in> TRel\<^sup>+" and "TP \<longmapsto>Target* TP'"
  thus "\<exists>TQ'. TQ \<longmapsto>Target* TQ' \<and> (TP', TQ') \<in> TRel\<^sup>+"
  proof (induct arbitrary: TP')
    fix TQ TP'
    assume "(TP, TQ) \<in> TRel"
    with target have "(TargetTerm TP, TargetTerm TQ) \<in> Rel"
      by simp
    moreover assume "TP \<longmapsto>Target* TP'"
    hence "TargetTerm TP \<longmapsto>(STCal Source Target)* (TargetTerm TP')"
      by (simp add: STCal_steps)
    ultimately obtain Q' where A2: "TargetTerm TQ \<longmapsto>(STCal Source Target)* Q'"
                           and A3: "(TargetTerm TP', Q') \<in> Rel"
        using sim
      by blast
    from A2 obtain TQ' where A4: "TQ \<longmapsto>Target* TQ'" and A5: "TQ' \<in>T Q'"
      by (auto simp add: STCal_steps)
    from A3 A5 trel have "(TP', TQ') \<in> TRel\<^sup>+"
      by simp
    with A4 show "\<exists>TQ'. TQ \<longmapsto>Target* TQ' \<and> (TP', TQ') \<in> TRel\<^sup>+"
      by blast
  next
    case (step TQ TR)
    assume "TP \<longmapsto>Target* TP'"
       and "\<And>TP'. TP \<longmapsto>Target* TP' \<Longrightarrow> \<exists>TQ'. TQ \<longmapsto>Target* TQ' \<and> (TP', TQ') \<in> TRel\<^sup>+"
    from this obtain TQ' where B1: "TQ \<longmapsto>Target* TQ'" and B2: "(TP', TQ') \<in> TRel\<^sup>+"
      by blast
    assume "(TQ, TR) \<in> TRel"
    with target have "(TargetTerm TQ, TargetTerm TR) \<in> Rel"
      by simp
    moreover from B1 have "TargetTerm TQ \<longmapsto>(STCal Source Target)* (TargetTerm TQ')"
      by (simp add: STCal_steps)
    ultimately obtain R' where B3: "TargetTerm TR \<longmapsto>(STCal Source Target)* R'"
                           and B4: "(TargetTerm TQ', R') \<in> Rel"
        using sim
      by blast
    from B3 obtain TR' where B5: "TR' \<in>T R'" and B6: "TR \<longmapsto>Target* TR'"
      by (auto simp add: STCal_steps)
    from B4 B5 trel have "(TQ', TR') \<in> TRel\<^sup>+"
      by simp
    with B2 have "(TP', TR') \<in> TRel\<^sup>+"
      by simp
    with B6 show "\<exists>TR'. TR \<longmapsto>Target* TR' \<and> (TP', TR') \<in> TRel\<^sup>+"
      by blast
  qed
qed

lemma (in encoding) indRelRTPO_impl_TRel_is_weak_reduction_simulation:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes sim: "weak_reduction_simulation (indRelRTPO TRel) (STCal Source Target)"
  shows "weak_reduction_simulation (TRel\<^sup>+) Target"
      using sim indRelRTPO.target[where TRel="TRel"] indRelRTPO_to_TRel(4)[where TRel="TRel"]
            rel_with_target_impl_transC_TRel_is_weak_reduction_simulation[where
             Rel="indRelRTPO TRel" and TRel="TRel"]
    by blast

lemma (in encoding) indRelLTPO_impl_TRel_is_weak_reduction_simulation:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes sim: "weak_reduction_simulation (indRelLTPO TRel) (STCal Source Target)"
  shows "weak_reduction_simulation (TRel\<^sup>+) Target"
      using sim indRelLTPO.target[where TRel="TRel"] indRelLTPO_to_TRel(4)[where TRel="TRel"]
            rel_with_target_impl_transC_TRel_is_weak_reduction_simulation[where
             Rel="indRelLTPO TRel" and TRel="TRel"]
    by blast

lemma (in encoding) rel_with_target_impl_transC_TRel_is_weak_reduction_simulation_rev:
  fixes TRel :: "('procT \<times> 'procT) set"
    and Rel  :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) set"
  assumes sim:    "weak_reduction_simulation (Rel\<inverse>) (STCal Source Target)"
      and target: "\<forall>T1 T2. (T1, T2) \<in> TRel \<longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> Rel"
      and trel:   "\<forall>T1 T2. (TargetTerm T1, TargetTerm T2) \<in> Rel \<longrightarrow> (T1, T2) \<in> TRel\<^sup>+"
  shows "weak_reduction_simulation ((TRel\<^sup>+)\<inverse>) Target"
proof clarify
  fix TP TQ TP'
  assume "(TQ, TP) \<in> TRel\<^sup>+"
  moreover assume "TP \<longmapsto>Target* TP'"
  ultimately show "\<exists>TQ'. TQ \<longmapsto>Target* TQ' \<and> (TP', TQ') \<in> (TRel\<^sup>+)\<inverse>"
  proof (induct arbitrary: TP')
    fix TP TP'
    assume "(TQ, TP) \<in> TRel"
    with target have "(TargetTerm TP, TargetTerm TQ) \<in> Rel\<inverse>"
      by simp
    moreover assume "TP \<longmapsto>Target* TP'"
    hence "TargetTerm TP \<longmapsto>(STCal Source Target)* (TargetTerm TP')"
      by (simp add: STCal_steps)
    ultimately obtain Q' where A2: "TargetTerm TQ \<longmapsto>(STCal Source Target)* Q'"
                           and A3: "(TargetTerm TP', Q') \<in> Rel\<inverse>"
        using sim
      by blast
    from A2 obtain TQ' where A4: "TQ \<longmapsto>Target* TQ'" and A5: "TQ' \<in>T Q'"
      by (auto simp add: STCal_steps(2))
    from A3 A5 trel have "(TP', TQ') \<in> (TRel\<^sup>+)\<inverse>"
      by simp
    with A4 show "\<exists>TQ'. TQ \<longmapsto>Target* TQ' \<and> (TP', TQ') \<in> (TRel\<^sup>+)\<inverse>"
      by blast
  next
    case (step TR TP TP')
    assume "TP \<longmapsto>Target* TP'"
    hence "TargetTerm TP \<longmapsto>(STCal Source Target)* (TargetTerm TP')"
      by (simp add: STCal_steps)
    moreover assume "(TR, TP) \<in> TRel"
    with target have "(TargetTerm TP, TargetTerm TR) \<in> Rel\<inverse>"
      by simp
    ultimately obtain R' where B1: "TargetTerm TR \<longmapsto>(STCal Source Target)* R'"
                           and B2: "(TargetTerm TP', R') \<in> Rel\<inverse>"
        using sim
      by blast
    from B1 obtain TR' where B3: "TR' \<in>T R'" and B4: "TR \<longmapsto>Target* TR'"
      by (auto simp add: STCal_steps)
    assume "\<And>TR'. TR \<longmapsto>Target* TR' \<Longrightarrow> \<exists>TQ'. TQ \<longmapsto>Target* TQ' \<and> (TR', TQ') \<in> (TRel\<^sup>+)\<inverse>"
    with B4 obtain TQ' where B5: "TQ \<longmapsto>Target* TQ'" and B6: "(TR', TQ') \<in> (TRel\<^sup>+)\<inverse>"
      by blast
    from B6 have "(TQ', TR') \<in> TRel\<^sup>+"
      by simp
    moreover from B2 B3 trel have "(TR', TP') \<in> TRel\<^sup>+"
      by simp
    ultimately have "(TP', TQ') \<in> (TRel\<^sup>+)\<inverse>"
      by simp
    with B5 show "\<exists>TQ'. TQ \<longmapsto>Target* TQ' \<and> (TP', TQ') \<in> (TRel\<^sup>+)\<inverse>"
      by blast
  qed
qed

lemma (in encoding) indRelRTPO_impl_TRel_is_weak_reduction_simulation_rev:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes sim: "weak_reduction_simulation ((indRelRTPO TRel)\<inverse>) (STCal Source Target)"
  shows "weak_reduction_simulation ((TRel\<^sup>+)\<inverse>) Target"
      using sim indRelRTPO.target[where TRel="TRel"] indRelRTPO_to_TRel(4)[where TRel="TRel"]
            rel_with_target_impl_transC_TRel_is_weak_reduction_simulation_rev[where
             Rel="indRelRTPO TRel" and TRel="TRel"]
    by blast

lemma (in encoding) indRelLTPO_impl_TRel_is_weak_reduction_simulation_rev:
  fixes TRel :: "('procT \<times> 'procT) set"
  assumes sim: "weak_reduction_simulation ((indRelLTPO TRel)\<inverse>) (STCal Source Target)"
  shows "weak_reduction_simulation ((TRel\<^sup>+)\<inverse>) Target"
      using sim indRelLTPO.target[where TRel="TRel"] indRelLTPO_to_TRel(4)[where TRel="TRel"]
            rel_with_target_impl_transC_TRel_is_weak_reduction_simulation_rev[where
             Rel="indRelLTPO TRel" and TRel="TRel"]
    by blast

lemma (in encoding) rel_with_target_impl_reflC_transC_TRel_is_weak_reduction_simulation:
  fixes TRel :: "('procT \<times> 'procT) set"
    and Rel  :: "(('procS, 'procT) Proc \<times> ('procS, 'procT) Proc) set"
  assumes sim:    "weak_reduction_simulation Rel (STCal Source Target)"
      and target: "\<forall>T1 T2. (T1, T2) \<in> TRel \<longrightarrow> (TargetTerm T1, TargetTerm T2) \<in> Rel"
      and trel:   "\<forall>T1 T2. (TargetTerm T1, TargetTerm T2) \<in> Rel \<longrightarrow> (T1, T2) \<in> TRel\<^sup>*"
  shows "weak_reduction_simulation (TRel\<^sup>*) Target"
