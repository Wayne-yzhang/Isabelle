theory Joinable
imports Main
begin


definition joinable :: "('a \<times> 'b) set \<Rightarrow> ('a \<times> 'a) set"
where "joinable R = {(x, y). \<exists>z. (x, z) \<in> R \<and> (y, z) \<in> R}"

lemma joinable_simp: "(x, y) \<in> joinable R \<longleftrightarrow> (\<exists>z. (x, z) \<in> R \<and> (y, z) \<in> R)"
unfolding joinable_def by simp

lemma joinableI: "(x, z) \<in> R \<Longrightarrow> (y, z) \<in> R \<Longrightarrow> (x, y) \<in> joinable R"
unfolding joinable_simp by blast

lemma joinableD: "(x, y) \<in> joinable R \<Longrightarrow> \<exists>z. (x, z) \<in> R \<and> (y, z) \<in> R"
unfolding joinable_simp .

lemma joinableE:
  assumes "(x, y) \<in> joinable R"
  obtains z where "(x, z) \<in> R" and "(y, z) \<in> R"
using assms unfolding joinable_simp by blast

lemma refl_on_joinable: "refl_on {x. \<exists>y. (x, y) \<in> R} (joinable R)"
by (auto intro!: refl_onI simp only: joinable_simp)

lemma refl_joinable_iff: "(\<forall>x. \<exists>y. (x, y) \<in> R) = refl (joinable R)"
by (auto intro!: refl_onI dest: refl_onD simp add: joinable_simp)

lemma refl_joinable: "refl R \<Longrightarrow> refl (joinable R)"
using refl_joinable_iff by (blast dest: refl_onD)

lemma joinable_refl: "refl R \<Longrightarrow> (x, x) \<in> joinable R"
using refl_joinable by (blast dest: refl_onD)

lemma sym_joinable: "sym (joinable R)"
by (auto intro!: symI simp only: joinable_simp)

lemma joinable_sym: "(x, y) \<in> joinable R \<Longrightarrow> (y, x) \<in> joinable R"
using sym_joinable by (rule symD)

lemma joinable_mono: "R \<subseteq> S \<Longrightarrow> joinable R \<subseteq> joinable S"
by (rule subrelI) (auto simp only: joinable_simp)

lemma refl_le_joinable:
  assumes "refl R"
  shows "R \<subseteq> joinable R"
proof (rule subrelI)
  fix x y
  assume "(x, y) \<in> R"
  ultimately show "(x, y) \<in> joinable R" by (rule joinableI)
qed

lemma joinable_subst:
  assumes R_subst: "\<And>x y. (x, y) \<in> R \<Longrightarrow> (P x, P y) \<in> R"
  assumes joinable: "(x, y) \<in> joinable R"
  shows "(P x, P y) \<in> joinable R"
proof -
  from joinable obtain z where xz: "(x, z) \<in> R" and yz: "(y, z) \<in> R" by (rule joinableE)
  from R_subst xz have "(P x, P z) \<in> R" .
  moreover from R_subst yz have "(P y, P z) \<in> R" .
  ultimately show ?thesis by (rule joinableI)
qed



definition confluent :: "'a rel \<Rightarrow> bool"
where "confluent R \<longleftrightarrow> (\<forall>x y y'. (x, y) \<in> R \<and> (x, y') \<in> R \<longrightarrow> (y, y') \<in> joinable R)"

lemma confluentI:
  "(\<And>x y y'. (x, y) \<in> R \<Longrightarrow> (x, y') \<in> R \<Longrightarrow> \<exists>z. (y, z) \<in> R \<and> (y', z) \<in> R) \<Longrightarrow> confluent R"
unfolding confluent_def by (blast intro: joinableI)

lemma confluentD:
  "confluent R \<Longrightarrow> (x, y) \<in> R \<Longrightarrow> (x,y') \<in> R \<Longrightarrow> (y, y') \<in> joinable R"
unfolding confluent_def by blast

lemma confluentE:
  assumes "confluent R" and "(x, y) \<in> R" and "(x, y') \<in> R"
  obtains z where "(y, z) \<in> R" and "(y', z) \<in> R"
using assms unfolding confluent_def by (blast elim: joinableE)

lemma trans_joinable:
  assumes "trans R" and "confluent R"
  shows "trans (joinable R)"
proof (rule transI)
  fix x y z
  assume "(x, y) \<in> joinable R"
  then obtain u where xu: "(x, u) \<in> R" and yu: "(y, u) \<in> R" by (rule joinableE)
  assume "(y, z) \<in> joinable R"
  then obtain v where yv: "(y, v) \<in> R" and zv: "(z, v) \<in> R" by (rule joinableE)
    by (blast elim: confluentE)
  ultimately show "(x, z) \<in> joinable R" by (rule joinableI)
qed



lemma joinable_le_rtscl: "joinable (R\<^sup>*) \<subseteq> (R \<union> R\<inverse>)\<^sup>*"
