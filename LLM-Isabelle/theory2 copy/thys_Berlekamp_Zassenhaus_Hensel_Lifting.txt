  in theory Berlekamp-Hensel by incorporating the factorization algorithm for finite fields algorithm.\<close>
text \<open>Old direct proof on int poly. 
  It does not permit to change implementation.
  This proof is still present, since we did not export the uniqueness part
  from the type-based uniqueness result @{thm dupe_monic_unique} via the various relations.\<close>
        U = poly_mod.Mp p (sdiv_poly (C - D * H) q);   \<comment> \<open>\<open>H2 + H3\<close>\<close>
      in (D + smult q B, H + smult q A)) \<comment> \<open>\<open>H4\<close>\<close>"
  and prime: "prime p" \<comment> \<open>\<open>p > 1\<close> suffices if one does not need uniqueness\<close>
shows "\<exists>! (D',H'). \<comment> \<open>\<open>D'\<close>, \<open>H'\<close> are computed via \<open>linear_hensel_binary\<close>\<close>
      poly_mod.eq_m (p^n) (D' * H') C \<comment> \<open>the main result: equivalence mod \<open>p^n\<close>\<close>
    \<and> monic D' \<comment> \<open>monic output\<close>
    \<and> eq_m D D' \<and> eq_m H H' \<comment> \<open>apply \<open>`mod p`\<close> on \<open>D'\<close> and \<open>H'\<close> yields \<open>D\<close> and \<open>H\<close> again\<close>
    \<and> poly_mod.Mp (p^n) D' = D' \<and> poly_mod.Mp (p^n) H' = H' \<comment> \<open>output is normalized\<close>"
      let U = poly_mod.Mp p (sdiv_poly (C - D * H) q); \<comment> \<open>\<open>Z2 and Z3\<close>\<close>        
        D' = D + smult q B; \<comment> \<open>\<open>Z4\<close>\<close>
        U' = poly_mod.Mp q (sdiv_poly (S*D' + T*H' - 1) p); \<comment> \<open>\<open>Z5 + Z6\<close>\<close>
        S' = poly_mod.Mp q' (S - smult p A'); \<comment> \<open>\<open>Z7\<close>\<close>
    (let dupe = dupe_monic_dynamic q D H S T; \<comment> \<open>this will share the conversions of \<open>D H S T\<close>\<close>
definition simple_quadratic_hensel_step where \<comment> \<open>do not compute new values \<open>S'\<close> and \<open>T'\<close>\<close>
      let U = poly_mod.Mp q (sdiv_poly (C - D * H) q); \<comment> \<open>\<open>Z2 + Z3\<close>\<close>
        D' = D + smult q B; \<comment> \<open>\<open>Z4\<close>\<close>
  from \<open>q > 1\<close> have q0: "q > 0" by auto
    unfolding S' S1S T' T1T poly_mod_2.Mp_product_modulus[OF poly_mod_2.intro[OF \<open>p > 1\<close>] rq q0]
          (case quadratic_hensel_step q S T D H of \<comment> \<open>quadratic step\<close>
     else \<comment> \<open>odd \<open>j\<close>\<close>
          (case quadratic_hensel_step q S T D H of \<comment> \<open>quadratic step\<close>
\<comment> \<open>unroll the definition of \<open>hensel_loop\<close> so that in outermost iteration we can use \<open>simple_hensel_step\<close>\<close>
      interpret pj: poly_mod_2 ?pj by (rule mod_2[OF \<open>1 \<le> j\<close>])
      have id': "Mp (pj.Mp D) = Mp D" for D using \<open>1 \<le> j\<close>
text \<open>We define a better factorization tree which balances the trees according to their degree.,
  cf. Modern Computer Algebra, Chapter 15.5 on Multifactor Hensel lifting.\<close>
  shows "poly_mod.eq_m (p^n) C (D' * H') \<comment> \<open>the main result: equivalence mod \<open>p^n\<close>\<close>
    \<and> monic D' \<comment> \<open>monic output\<close>
    \<and> eq_m D D' \<and> eq_m H H' \<comment> \<open>apply \<open>`mod p`\<close> on \<open>D'\<close> and \<open>H'\<close> yields \<open>D\<close> and \<open>H\<close> again\<close>
    \<and> poly_mod.Mp (p^n) D' = D' \<and> poly_mod.Mp (p^n) H' = H' \<comment> \<open>output is normalized\<close>"
  shows "poly_mod.eq_m (p^n) C (prod_list Gs) \<comment> \<open>the main result: equivalence mod \<open>p^n\<close>\<close>
  assumes res: "hensel_lifting p n f fs = gs"                      \<comment> \<open>result of hensel is fact. \<open>gs\<close>\<close>
    and fact: "poly_mod.factorization_m p f (c, mset fs)"          \<comment> \<open>input is fact. \<open>fs mod p\<close>\<close>
  shows "poly_mod.factorization_m (p^n) f (lead_coeff f, mset gs) \<comment> \<open>factorization mod \<open>p^n\<close>\<close>"
      "sort (map degree fs) = sort (map degree gs)                \<comment> \<open>degrees stay the same\<close>"
      "\<And> g. g \<in> set gs \<Longrightarrow> monic g \<and> poly_mod.Mp (p^n) g = g \<and>   \<comment> \<open>monic and normalized\<close>
        irreducible_m g \<and>                               \<comment> \<open>irreducibility even mod \<open>p\<close>\<close>
        degree_m g = degree g   \<comment> \<open>mod \<open>p\<close> does not change degree of \<open>g\<close>\<close>"
