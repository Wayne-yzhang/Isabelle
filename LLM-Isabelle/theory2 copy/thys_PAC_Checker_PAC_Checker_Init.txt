theory PAC_Checker_Init
  imports  PAC_Checker WB_Sort PAC_Checker_Relation
begin



   we refine it to executable code and try to improve efficiency.
\<close>
fun swap_ternary :: \<open>_\<Rightarrow>nat\<Rightarrow>nat\<Rightarrow> ('a \<times> 'a \<times> 'a) \<Rightarrow> ('a \<times> 'a \<times> 'a)\<close> where
  \<open>swap_ternary f m n  =
    (if (m = 0 \<and> n = 1)
    then (\<lambda>(a, b, c). if f a b then (a, b, c)
      else (b,a,c))
    else if (m = 0 \<and> n = 2)
    then (\<lambda>(a, b, c). if f a c then (a, b, c)
      else (c,b,a))
    else if (m = 1 \<and> n = 2)
    then (\<lambda>(a, b, c). if f b c then (a, b, c)
      else (a,c,b))
    else (\<lambda>(a, b, c). (a,b,c)))\<close>
  fixes xs :: \<open>'a :: linorder list\<close>
  shows \<open>msort (\<le>) xs = msort2 (\<le>) xs\<close>
  apply (induction  \<open>(\<le>) :: 'a \<Rightarrow> 'a \<Rightarrow> bool\<close> xs rule: msort2.induct)
subsection \<open>Sorting applied to monomials\<close>
  \<open>(RETURN o merge_coeffs) p =
   REC\<^sub>T(\<lambda>f p.
     (case p of
       [] \<Rightarrow> RETURN []
     | [_] => RETURN p
     | ((xs, n) # (ys, m) # p) \<Rightarrow>
      (if xs = ys
       then if n + m \<noteq> 0 then f ((xs, n + m) # p) else f p
       else do {p \<leftarrow> f ((ys, m) # p); RETURN ((xs, n) # p)})))
    p\<close>
  \<open>is_pure R \<Longrightarrow> hn_invalid R = (\<lambda>x y. R x y * true)\<close>
  \<open>is_pure R \<Longrightarrow> invalid_assn R = (\<lambda>x y. R x y * true)\<close>
  \<open>invalid_assn monom_assn \<times>\<^sub>a invalid_assn int_assn = invalid_assn (monom_assn \<times>\<^sub>a int_assn)\<close>
  \<open>hn_ctxt (invalid_assn monom_assn \<times>\<^sub>a invalid_assn int_assn) xb
        x'a \<or>\<^sub>A
       hn_ctxt monomial_assn xb x'a \<Longrightarrow>\<^sub>t
       hn_ctxt (monomial_assn) xb x'a\<close>
  \<open>hn_ctxt (invalid_assn monom_assn \<times>\<^sub>a invalid_assn int_assn) xb x'a *
       (hn_invalid poly_assn la l'a * hn_invalid int_assn a2' a2 *
        hn_invalid monom_assn a1' a1 *
        hn_invalid poly_assn l l' *
        hn_invalid monomial_assn xa x' *
        hn_invalid poly_assn ax px) \<Longrightarrow>\<^sub>t
       hn_ctxt (monomial_assn) xb x'a *
       hn_ctxt poly_assn
        la l'a *
       hn_ctxt poly_assn l l' *
       (hn_invalid int_assn a2' a2 *
        hn_invalid monom_assn a1' a1 *
        hn_invalid monomial_assn xa x' *
        hn_invalid poly_assn ax px)\<close>
  \<open>hn_ctxt (invalid_assn monom_assn \<times>\<^sub>a invalid_assn int_assn) xa x' *
       (hn_ctxt poly_assn l l' * hn_invalid poly_assn ax px) \<Longrightarrow>\<^sub>t
       hn_ctxt (monomial_assn) xa x' *
       hn_ctxt poly_assn l l' *
       hn_ctxt poly_assn ax px *
       emp\<close>
text \<open>The refinement frameword is completely lost here when synthesizing the constants -- it does
  not understant what is pure (actually everything) and what must be destroyed.\<close>
  is \<open>RETURN o merge_coeffs\<close>
  :: \<open>poly_assn\<^sup>d \<rightarrow>\<^sub>a poly_assn\<close>
  apply (rewrite in \<open>_\<close> annotate_assn[where A=\<open>poly_assn\<close>])
  \<open>full_quicksort_poly = full_quicksort_ref (\<lambda>x y. x = y \<or> (x, y) \<in> term_order_rel) fst\<close>
lemma down_eq_id_list_rel: \<open>\<Down>(\<langle>Id\<rangle>list_rel) x = x\<close>
definition quicksort_poly:: \<open>nat \<Rightarrow> nat \<Rightarrow> llist_polynomial \<Rightarrow> (llist_polynomial) nres\<close> where
  \<open>quicksort_poly x y  z = quicksort_ref (\<le>) fst (x, y, z)\<close>
definition partition_between_poly :: \<open>nat \<Rightarrow> nat \<Rightarrow> llist_polynomial \<Rightarrow> (llist_polynomial \<times> nat) nres\<close> where
  \<open>partition_between_poly = partition_between_ref (\<le>) fst\<close>
definition partition_main_poly :: \<open>nat \<Rightarrow> nat \<Rightarrow> llist_polynomial \<Rightarrow> (llist_polynomial \<times> nat) nres\<close> where
  \<open>partition_main_poly = partition_main (\<le>)  fst\<close>
  \<open>(xa ::char list list, ya) \<in> lexord (lexord {(x, y). x < y}) \<Longrightarrow>
  (ya, z) \<in> lexord (lexord {(x, y). x < y}) \<Longrightarrow>
    (xa, z) \<in> lexord (lexord {(x, y). x < y})\<close>
  \<open>(full_quicksort_poly, sort_poly_spec) \<in> \<langle>Id\<rangle>list_rel \<rightarrow>\<^sub>f \<langle>\<langle>Id\<rangle>list_rel\<rangle>nres_rel\<close>
  have xs: \<open>(xs, xs) \<in> \<langle>Id\<rangle>list_rel\<close> and \<open>\<Down>(\<langle>Id\<rangle>list_rel) x = x\<close> for x xs
    apply (rule full_quicksort_correct_sorted[where R = \<open>(\<lambda>x y. x = y \<or> (x, y) \<in> term_order_rel)\<close> and h = \<open>fst\<close>,
subsection \<open>Lifting to polynomials\<close>
definition merge_sort_poly :: \<open>_\<close> where
\<open>merge_sort_poly = msort (\<lambda>a b. fst a \<le> fst b)\<close>
definition merge_monoms_poly :: \<open>_\<close> where
\<open>merge_monoms_poly = msort (\<le>)\<close>
definition merge_poly :: \<open>_\<close> where
\<open>merge_poly = merge (\<lambda>a b. fst a \<le> fst b)\<close>
definition merge_monoms :: \<open>_\<close> where
\<open>merge_monoms = merge (\<le>)\<close>
definition msort_poly_impl :: \<open>(String.literal list \<times> int) list \<Rightarrow> _\<close> where
\<open>msort_poly_impl = msort (\<lambda>a b. fst a \<le> fst b)\<close>
definition msort_monoms_impl :: \<open>(String.literal list) \<Rightarrow> _\<close> where
\<open>msort_monoms_impl = msort (\<le>)\<close>
  \<open>msort_poly_impl xs =
    (case xs of
      [] \<Rightarrow> []
     | [a] \<Rightarrow> [a]
     | [a,b] \<Rightarrow> if fst a \<le> fst b then [a,b]else [b,a]
     | xs \<Rightarrow> merge_poly
                      (msort_poly_impl (take ((length xs) div 2) xs))
                      (msort_poly_impl (drop ((length xs) div 2) xs)))\<close>
  \<open>(\<le>) = (\<lambda>x y. x = y \<or>  term_order_rel' x y)\<close>
  \<open>lexord_eq [] _ = True\<close> |
  \<open>lexord_eq (x # xs) (y # ys) = (x < y \<or> (x = y \<and> lexord_eq xs ys))\<close> |
  \<open>lexord_eq _ _ = False\<close>
  \<open>lexord_eq [] [] = True\<close>
  \<open>lexord_eq (a # b)[] = False\<close>
  \<open>lexord_eq [] (a # b) = True\<close>
  \<open>(\<le>) = (\<lambda>x y. x = y \<or> (x,y) \<in> var_order_rel)\<close>
  \<open>(x,y) \<in> var_order_rel \<longleftrightarrow> x < y\<close>
  \<open>a \<le> b = lexord_eq a b\<close> for a b :: \<open>String.literal list\<close>
  \<open>(RETURN oo lexord_eq) xs ys =
     REC\<^sub>T (\<lambda>f (xs, ys).
        case (xs, ys) of
           ([], _) \<Rightarrow> RETURN True
         | (x # xs, y # ys) \<Rightarrow>
            if x < y then RETURN True
            else if x = y then f (xs, ys) else RETURN False
        | _ \<Rightarrow> RETURN False)
        (xs, ys)\<close>
  [simp]: \<open>var_order' = var_order\<close>
  \<open>(\<in>)$(x,y)$var_order_rel \<equiv> var_order'$x$y\<close>
  \<open>var_order_rel = p2rel char.lexordp\<close>
  \<open>(x, y) \<in> var_order_rel \<longleftrightarrow> var_order x y\<close>
  \<open>((<), var_order') \<in> string_rel \<rightarrow> string_rel \<rightarrow> bool_rel\<close>
  \<open>( (\<le>), (\<le>)) \<in> monom_rel \<rightarrow> monom_rel \<rightarrow>bool_rel\<close>
  \<open>( (<), (<)) \<in> string_rel \<rightarrow> string_rel \<rightarrow>bool_rel\<close>
  have [iff]: \<open>ord.lexordp (<) (literal.explode a) (literal.explode aa) \<longleftrightarrow>
       List.lexordp (<) (literal.explode a) (literal.explode aa)\<close> for a aa
lemma lexordp_char_char: \<open>ord_class.lexordp = char.lexordp\<close>
  \<open>( (\<le>), (\<le>)) \<in> string_rel \<rightarrow> string_rel \<rightarrow>bool_rel\<close>
  is \<open>uncurry (RETURN oo lexord_eq)\<close>
  :: \<open>monom_assn\<^sup>k *\<^sub>a monom_assn\<^sup>k \<rightarrow>\<^sub>a bool_assn\<close>
  \<open>(a, aa) \<in> term_order_rel \<Longrightarrow>
       (aa, ab) \<in> term_order_rel \<Longrightarrow> (a, ab) \<in> term_order_rel\<close>
  \<open>(RETURN o merge_sort_poly, sort_poly_spec) \<in> \<langle>Id\<rangle>list_rel \<rightarrow>\<^sub>f \<langle>\<langle>Id\<rangle>list_rel\<rangle>nres_rel\<close>
  \<open>RETURN o (msort f) =
     REC\<^sub>T (\<lambda>g xs.
        case xs of
          [] \<Rightarrow> RETURN []
        | [x] \<Rightarrow> RETURN [x]
        | _ \<Rightarrow> do {
           a \<leftarrow> g (take (size xs div 2) xs);
           b \<leftarrow> g (drop (size xs div 2) xs);
           RETURN (merge f a b)})\<close>
  \<open>(x, a, b) \<in> monomial_rel \<Longrightarrow>
       (y, aa, bb) \<in> monomial_rel \<Longrightarrow>
       fst x \<le> fst y \<longleftrightarrow> a \<le> aa\<close>
  fixes K :: \<open>('olbl \<times> 'lbl) set\<close>
    \<open>pure (p2rel (\<langle>K, V, R\<rangle>pac_step_rel_raw)) = pac_step_rel_assn (pure K) (pure V) (pure R)\<close>
    \<open>monomial_assn = pure (monom_rel \<times>\<^sub>r int_rel)\<close> and
    \<open>poly_assn = pure (\<langle>monom_rel \<times>\<^sub>r int_rel\<rangle>list_rel)\<close>
  \<open>(merge_poly, merge_poly)
   \<in> poly_rel \<rightarrow> poly_rel \<rightarrow> poly_rel\<close>
    apply (induction \<open>(\<lambda>(a :: String.literal list \<times> int)
      (b :: String.literal list \<times> int). fst a \<le> fst b)\<close> a aa
  \<open>(a, b) \<in> poly_rel \<Longrightarrow> (a', b') \<in> poly_rel \<Longrightarrow>
    (merge_poly a a', merge_poly b b') \<in> poly_rel\<close>
  \<open>(a, b) \<in> \<langle>R\<rangle>list_rel \<Longrightarrow> (n, n')\<in> Id \<Longrightarrow> (take n a, take n' b) \<in> \<langle>R\<rangle>list_rel\<close>
  \<open>(a, b) \<in> \<langle>R\<rangle>list_rel \<Longrightarrow> (n, n')\<in> Id \<Longrightarrow> (drop n a, drop n' b) \<in> \<langle>R\<rangle>list_rel\<close>
  \<open>(msort_poly_impl, merge_sort_poly)
   \<in> poly_rel \<rightarrow> poly_rel\<close>
    apply (induction \<open>(\<lambda>(a :: String.literal list \<times> int)
      (b :: String.literal list \<times> int). fst a \<le> fst b)\<close> a
  is \<open>uncurry2 partition_main_poly\<close>
  :: \<open>nat_assn\<^sup>k *\<^sub>a nat_assn\<^sup>k *\<^sub>a poly_assn\<^sup>k \<rightarrow>\<^sub>a prod_assn poly_assn nat_assn \<close>
  is \<open>uncurry2 partition_between_poly\<close>
  :: \<open>nat_assn\<^sup>k *\<^sub>a nat_assn\<^sup>k *\<^sub>a poly_assn\<^sup>k \<rightarrow>\<^sub>a prod_assn poly_assn nat_assn \<close>
  is \<open>uncurry2 quicksort_poly\<close>
  :: \<open>nat_assn\<^sup>k *\<^sub>a nat_assn\<^sup>k *\<^sub>a poly_assn\<^sup>k \<rightarrow>\<^sub>a poly_assn\<close>
  is \<open>full_quicksort_poly\<close>
  :: \<open>poly_assn\<^sup>k \<rightarrow>\<^sub>a poly_assn\<close>
  is \<open>normalize_poly\<close>
  :: \<open>poly_assn\<^sup>k \<rightarrow>\<^sub>a poly_assn\<close>
  \<open>full_quicksort_vars = full_quicksort_ref (\<lambda>x y. x = y \<or> (x, y) \<in> var_order_rel) id\<close>
definition quicksort_vars:: \<open>nat \<Rightarrow> nat \<Rightarrow> string list \<Rightarrow> (string list) nres\<close> where
  \<open>quicksort_vars x y  z = quicksort_ref (\<le>) id (x, y, z)\<close>
definition partition_between_vars :: \<open>nat \<Rightarrow> nat \<Rightarrow> string list \<Rightarrow> (string list \<times> nat) nres\<close> where
  \<open>partition_between_vars = partition_between_ref (\<le>) id\<close>
definition partition_main_vars :: \<open>nat \<Rightarrow> nat \<Rightarrow> string list \<Rightarrow> (string list \<times> nat) nres\<close> where
  \<open>partition_main_vars = partition_main (\<le>) id\<close>
  \<open>xs \<noteq> ys \<Longrightarrow> (xs, ys) \<notin> lexord (less_than_char) \<longleftrightarrow>
       (ys, xs) \<in> lexord less_than_char\<close>
   using lexord_linear[of \<open>less_than_char\<close> xs ys]
   using lexord_linear[of \<open>less_than_char\<close>] less_than_char_linear
  \<open>(xa, ya) \<in> lexord {(x::char, y::char). x < y} \<Longrightarrow>
  (ya, z) \<in> lexord {(x::char, y::char). x < y} \<Longrightarrow>
  (xa, z) \<in> lexord {(x::char, y::char). x < y}\<close>
  \<open>(full_quicksort_vars, sort_coeff) \<in> \<langle>Id\<rangle>list_rel \<rightarrow>\<^sub>f \<langle>\<langle>Id\<rangle>list_rel\<rangle>nres_rel\<close>
  have xs: \<open>(xs, xs) \<in> \<langle>Id\<rangle>list_rel\<close> and \<open>\<Down>(\<langle>Id\<rangle>list_rel) x = x\<close> for x xs
    apply (rule full_quicksort_correct_sorted[where R = \<open>(\<lambda>x y. x = y \<or> (x, y) \<in> var_order_rel)\<close> and h = \<open>id\<close>,
  is \<open>uncurry2 partition_main_vars\<close>
  :: \<open>nat_assn\<^sup>k *\<^sub>a nat_assn\<^sup>k *\<^sub>a (monom_assn)\<^sup>k \<rightarrow>\<^sub>a prod_assn (monom_assn) nat_assn\<close>
  is \<open>uncurry2 partition_between_vars\<close>
  :: \<open>nat_assn\<^sup>k *\<^sub>a nat_assn\<^sup>k *\<^sub>a monom_assn\<^sup>k \<rightarrow>\<^sub>a prod_assn monom_assn nat_assn \<close>
  is \<open>uncurry2 quicksort_vars\<close>
  :: \<open>nat_assn\<^sup>k *\<^sub>a nat_assn\<^sup>k *\<^sub>a monom_assn\<^sup>k \<rightarrow>\<^sub>a monom_assn\<close>
  \<open>(\<le>) = (\<lambda>x y. x = y \<or> (x, y) \<in> var_order_rel)\<close>
  is \<open>full_quicksort_vars\<close>
  :: \<open>monom_assn\<^sup>k \<rightarrow>\<^sub>a monom_assn\<close>
  \<open>(x, a) \<in> string_rel \<Longrightarrow>
       (y, aa) \<in> string_rel \<Longrightarrow>
       x \<le> y \<longleftrightarrow> a \<le> aa\<close>
  \<open>(merge_monoms, merge_monoms) \<in> monom_rel \<rightarrow> monom_rel \<rightarrow> monom_rel\<close>
    apply (induction \<open>(\<lambda>(a :: String.literal)
      (b :: String.literal). a \<le> b)\<close> a aa
  \<open>(a, b) \<in> monom_rel \<Longrightarrow> (a', b') \<in> monom_rel \<Longrightarrow>
    (merge_monoms a a', merge_monoms b b') \<in> monom_rel\<close>
  \<open>(msort_monoms_impl, merge_monoms_poly)
   \<in> monom_rel \<rightarrow> monom_rel\<close>
    apply (induction \<open>(\<lambda>(a :: String.literal)
      (b :: String.literal). a \<le> b)\<close> a
  \<open>(RETURN o merge_monoms_poly, sort_coeff) \<in> \<langle>Id\<rangle>list_rel \<rightarrow>\<^sub>f \<langle>\<langle>Id\<rangle>list_rel\<rangle>nres_rel\<close>
  \<open>(return o msort_monoms_impl, sort_coeff) \<in> monom_assn\<^sup>k \<rightarrow>\<^sub>a monom_assn\<close>
  is \<open>sort_all_coeffs\<close>
  :: \<open>poly_assn\<^sup>k \<rightarrow>\<^sub>a poly_assn\<close>
  \<open>(RETURN o merge_coeffs0) p =
   REC\<^sub>T(\<lambda>f p.
     (case p of
       [] \<Rightarrow> RETURN []
     | [p] => if snd p = 0 then RETURN [] else RETURN [p]
     | ((xs, n) # (ys, m) # p) \<Rightarrow>
      (if xs = ys
       then if n + m \<noteq> 0 then f ((xs, n + m) # p) else f p
       else if n = 0 then
          do {p \<leftarrow> f ((ys, m) # p);
            RETURN p}
       else do {p \<leftarrow> f ((ys, m) # p);
            RETURN ((xs, n) # p)})))
    p\<close>
text \<open>Again, Sepref does not understand what is going here.\<close>
  is \<open>RETURN o merge_coeffs0\<close>
  :: \<open>poly_assn\<^sup>k \<rightarrow>\<^sub>a poly_assn\<close>
  is \<open>full_normalize_poly\<close>
  :: \<open>poly_assn\<^sup>k \<rightarrow>\<^sub>a poly_assn\<close>
