theory ProcessCalculi
  imports Relations
begin





record 'proc processCalculus =
  Reductions :: "'proc \<Rightarrow> 'proc \<Rightarrow> bool"


abbreviation step :: "'proc \<Rightarrow> 'proc processCalculus \<Rightarrow> 'proc \<Rightarrow> bool"
    ("_ \<longmapsto>_ _" [70, 70, 70] 80)
  where
  "P \<longmapsto>Cal Q \<equiv> Reductions Cal P Q"


primrec nSteps
  :: "'proc \<Rightarrow> 'proc processCalculus \<Rightarrow> nat \<Rightarrow> 'proc \<Rightarrow> bool"
    ("_ \<longmapsto>_\<^bsup>_\<^esup> _" [70, 70, 70, 70] 80)
  where
  "P \<longmapsto>Cal\<^bsup>0\<^esup> Q     = (P = Q)" |
  "P \<longmapsto>Cal\<^bsup>Suc n\<^esup> Q = (\<exists>P'. P \<longmapsto>Cal\<^bsup>n\<^esup> P' \<and> P' \<longmapsto>Cal Q)"

definition steps
  :: "'proc \<Rightarrow> 'proc processCalculus \<Rightarrow> 'proc \<Rightarrow> bool"
    ("_ \<longmapsto>_* _" [70, 70, 70] 80)
  where
  "P \<longmapsto>Cal* Q \<equiv> \<exists>n. P \<longmapsto>Cal\<^bsup>n\<^esup> Q"


definition divergent
  :: "'proc \<Rightarrow> 'proc processCalculus \<Rightarrow> bool"
    ("_ \<longmapsto>_\<omega>" [70, 70] 80)
  where
  "P \<longmapsto>(Cal)\<omega> \<equiv> \<forall>P'. P \<longmapsto>Cal* P' \<longrightarrow> (\<exists>P''. P' \<longmapsto>Cal P'')"


lemma steps_refl:
  fixes Cal :: "'proc processCalculus"
    and P   :: "'proc"
  shows "P \<longmapsto>Cal* P"
proof -
  have "P \<longmapsto>Cal\<^bsup>0\<^esup> P"
    by simp
  hence "\<exists>n. P \<longmapsto>Cal\<^bsup>n\<^esup> P"
    by blast
  thus "P \<longmapsto>Cal* P"
    by (simp add: steps_def)
qed


lemma step_to_steps:
  fixes Cal  :: "'proc processCalculus"
    and P P' :: "'proc"
  assumes step: "P \<longmapsto>Cal P'"
  shows "P \<longmapsto>Cal* P'"
proof -
  from step have "P \<longmapsto>Cal\<^bsup>1\<^esup> P'"
    by simp
  thus ?thesis
    unfolding steps_def
    by blast
qed


lemma nSteps_add:
  fixes Cal   :: "'proc processCalculus"
    and n1 n2 :: "nat"
  shows "\<forall>P Q R. P \<longmapsto>Cal\<^bsup>n1\<^esup> Q \<and> Q \<longmapsto>Cal\<^bsup>n2\<^esup> R \<longrightarrow> P \<longmapsto>Cal\<^bsup>(n1 + n2)\<^esup> R"
proof (induct n2, simp)
  case (Suc n)
  assume IH: "\<forall>P Q R. P \<longmapsto>Cal\<^bsup>n1\<^esup> Q \<and> Q \<longmapsto>Cal\<^bsup>n\<^esup> R \<longrightarrow> P \<longmapsto>Cal\<^bsup>(n1 + n)\<^esup> R"
  show ?case
  proof clarify
    fix P Q R
    assume "Q \<longmapsto>Cal\<^bsup>Suc n\<^esup> R"
    from this obtain Q' where A1: "Q \<longmapsto>Cal\<^bsup>n\<^esup> Q'" and A2: "Q' \<longmapsto>Cal R"
      by auto
    assume "P \<longmapsto>Cal\<^bsup>n1\<^esup> Q"
    with A1 IH have "P \<longmapsto>Cal\<^bsup>(n1 + n)\<^esup> Q'"
      by blast
    with A2 show "P \<longmapsto>Cal\<^bsup>(n1 + Suc n)\<^esup> R"
      by auto
  qed
qed

lemma steps_add:
  fixes Cal   :: "'proc processCalculus"
    and P Q R :: "'proc"
  assumes A1: "P \<longmapsto>Cal* Q"
      and A2: "Q \<longmapsto>Cal* R"
  shows "P \<longmapsto>Cal* R"
proof -
  from A1 obtain n1 where "P \<longmapsto>Cal\<^bsup>n1\<^esup> Q"
    by (auto simp add: steps_def)
  moreover from A2 obtain n2 where "Q \<longmapsto>Cal\<^bsup>n2\<^esup> R"
    by (auto simp add: steps_def)
  ultimately have "P \<longmapsto>Cal\<^bsup>(n1 + n2)\<^esup> R"
    using nSteps_add[where Cal="Cal"]
    by blast
  thus "P \<longmapsto>Cal* R"
    by (simp add: steps_def, blast)
qed



record ('proc, 'barbs) calculusWithBarbs =
  Calculus :: "'proc processCalculus"
  HasBarb  :: "'proc \<Rightarrow> 'barbs \<Rightarrow> bool" ("_\<down>_" [70, 70] 80)

abbreviation hasBarb
  :: "'proc \<Rightarrow> ('proc, 'barbs) calculusWithBarbs \<Rightarrow> 'barbs \<Rightarrow> bool"
    ("_\<down><_>_" [70, 70, 70] 80)
  where
  "P\<down><CWB>a \<equiv> HasBarb CWB P a"


abbreviation reachesBarb
  :: "'proc \<Rightarrow> ('proc, 'barbs) calculusWithBarbs \<Rightarrow> 'barbs \<Rightarrow> bool"
    ("_\<Down><_>_" [70, 70, 70] 80)
  where
  "P\<Down><CWB>a \<equiv> \<exists>P'. P \<longmapsto>(Calculus CWB)* P' \<and> P'\<down><CWB>a"


abbreviation rel_preserves_barb_set
    :: "('proc \<times> 'proc) set \<Rightarrow> ('proc, 'barbs) calculusWithBarbs \<Rightarrow> 'barbs set \<Rightarrow> bool"
  where
  "rel_preserves_barb_set Rel CWB Barbs \<equiv>
   rel_preserves_binary_pred Rel (\<lambda>P a. a \<in> Barbs \<and> P\<down><CWB>a)"

abbreviation rel_preserves_barbs
    :: "('proc \<times> 'proc) set \<Rightarrow> ('proc, 'barbs) calculusWithBarbs \<Rightarrow> bool"
  where
  "rel_preserves_barbs Rel CWB \<equiv> rel_preserves_binary_pred Rel (HasBarb CWB)"

lemma preservation_of_barbs_and_set_of_barbs:
  fixes Rel :: "('proc \<times> 'proc) set"
    and CWB :: "('proc, 'barbs) calculusWithBarbs"
  shows "rel_preserves_barbs Rel CWB = (\<forall>Barbs. rel_preserves_barb_set Rel CWB Barbs)"
    by blast


abbreviation rel_reflects_barb_set
    :: "('proc \<times> 'proc) set \<Rightarrow> ('proc, 'barbs) calculusWithBarbs \<Rightarrow> 'barbs set \<Rightarrow> bool"
  where
  "rel_reflects_barb_set Rel CWB Barbs \<equiv>
   rel_reflects_binary_pred Rel (\<lambda>P a. a \<in> Barbs \<and> P\<down><CWB>a)"

abbreviation rel_reflects_barbs
    :: "('proc \<times> 'proc) set \<Rightarrow> ('proc, 'barbs) calculusWithBarbs \<Rightarrow> bool"
  where
  "rel_reflects_barbs Rel CWB \<equiv> rel_reflects_binary_pred Rel (HasBarb CWB)"

lemma reflection_of_barbs_and_set_of_barbs:
  fixes Rel :: "('proc \<times> 'proc) set"
    and CWB :: "('proc, 'barbs) calculusWithBarbs"
  shows "rel_reflects_barbs Rel CWB = (\<forall>Barbs. rel_reflects_barb_set Rel CWB Barbs)"
    by blast


abbreviation rel_respects_barb_set
    :: "('proc \<times> 'proc) set \<Rightarrow> ('proc, 'barbs) calculusWithBarbs \<Rightarrow> 'barbs set \<Rightarrow> bool"
  where
  "rel_respects_barb_set Rel CWB Barbs \<equiv>
   rel_preserves_barb_set Rel CWB Barbs \<and> rel_reflects_barb_set Rel CWB Barbs"

abbreviation rel_respects_barbs
    :: "('proc \<times> 'proc) set \<Rightarrow> ('proc, 'barbs) calculusWithBarbs \<Rightarrow> bool"
  where
  "rel_respects_barbs Rel CWB \<equiv> rel_preserves_barbs Rel CWB \<and> rel_reflects_barbs Rel CWB"

lemma respection_of_barbs_and_set_of_barbs:
  fixes Rel :: "('proc \<times> 'proc) set"
    and CWB :: "('proc, 'barbs) calculusWithBarbs"
  shows "rel_respects_barbs Rel CWB = (\<forall>Barbs. rel_respects_barb_set Rel CWB Barbs)"
    by blast


lemma preservation_of_barbs_and_closures:
  fixes Rel :: "('proc \<times> 'proc) set"
    and CWB :: "('proc, 'barbs) calculusWithBarbs"
  assumes preservation: "rel_preserves_barbs Rel CWB"
  shows "rel_preserves_barbs (Rel\<^sup>=) CWB"
    and "rel_preserves_barbs (Rel\<^sup>+) CWB"
    and "rel_preserves_barbs (Rel\<^sup>*) CWB"
