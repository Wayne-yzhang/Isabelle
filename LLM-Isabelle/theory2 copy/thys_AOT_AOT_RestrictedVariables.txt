theory AOT_RestrictedVariables
  imports AOT_PLM
  keywords "AOT_register_rigid_restricted_type" :: thy_goal
       and "AOT_register_restricted_type" :: thy_goal
begin


locale AOT_restriction_condition =


locale AOT_rigid_restriction_condition = AOT_restriction_condition +
begin
  using rigid[THEN "\<forall>E"(2)] RN by simp
  by (metis "instantiation" mem_Collect_eq "res-var:2")
end

locale AOT_restricted_type = AOT_rigid_restriction_condition +
  fixes Rep and Abs
  assumes AOT_restricted_type_definition[AOT_no_atp]:
begin

proof -
  interpret type_definition Rep Abs "{ \<alpha> . [w\<^sub>0 \<Turnstile> \<psi>{\<alpha>}]}"
    using AOT_restricted_type_definition.
  AOT_actually {
      using AOT_sem_imp Rep "res-var:3" by auto
  }
  moreover AOT_actually {
      using AOT_sem_box rigid_condition by presburger
      by (metis AOT_model.AOT_term_of_var_cases AOT_sem_denotes that)
  }
    using AOT_sem_box AOT_sem_imp by blast
qed
lemmas "\<psi>" = restricted_var_condition

proof(rule GEN; rule "\<rightarrow>I")
  interpret type_definition Rep Abs "{ \<alpha> . [w\<^sub>0 \<Turnstile> \<psi>{\<alpha>}]}"
    using AOT_restricted_type_definition.
  fix \<alpha>
    by (metis AOT_model_axiom_def AOT_sem_box AOT_sem_imp act_closure rigid_condition)
  {
    fix \<tau>
      unfolding \<alpha>_def
      using assms by blast
  }
    using Rep_cases[simplified, OF 0]
    by blast
qed
lemmas "\<forall>I" = GEN

end


lemma AOT_restricted_type_intro[AOT_no_atp, no_atp]:
  by (auto intro!: assms AOT_restricted_type_axioms.intro AOT_restricted_type.intro)





attribute_setup "unconstrain" =
  "Generalize a statement about restricted variables to a statement about
   unrestricted variables with explicit restriction condition."



context AOT_restricted_type
begin

AOT_theorem "rule-ui":
proof -
    by (auto simp:  \<psi>)
  ultimately show ?thesis by blast
qed
lemmas "\<forall>E" = "rule-ui"

AOT_theorem "instantiation":
proof -
    using assms(1)
    by (simp add: "deduction-theorem")
    using GEN by simp
qed
lemmas "\<exists>E" = "instantiation"

  by (meson AOT_restricted_type.\<psi> AOT_restricted_type_axioms assms
            "&I" "existential:2[const_var]")
lemmas "\<exists>I" = existential
end


context AOT_rigid_restriction_condition
begin

AOT_theorem "res-var-bound-reas[1]":
proof(safe intro!: "\<equiv>I" "\<rightarrow>I" GEN)
  fix \<beta> \<alpha>
next
  fix \<alpha> \<beta>
qed

AOT_theorem "res-var-bound-reas[BF]":
proof(safe intro!: "\<rightarrow>I")
    using "\<forall>E"(2) by blast
    by (metis "sc-eq-box-box:6" rigid_condition "vdash-properties:6")
    by (rule GEN)
    by (metis "BF" "vdash-properties:6")
qed

AOT_theorem "res-var-bound-reas[CBF]":
proof(safe intro!: "\<rightarrow>I" GEN)
  fix \<alpha>
    by (metis "CBF" "vdash-properties:6")
    using "\<forall>E"(2) by blast
    by (metis "B\<diamond>" "T\<diamond>" rigid_condition "vdash-properties:6")
    using 1 "qml:1"[axiom_inst, THEN "\<rightarrow>E", THEN "\<rightarrow>E"] by blast
qed

AOT_theorem "res-var-bound-reas[2]":
proof(safe intro!: "\<rightarrow>I")
    using "\<forall>E"(2) by blast
    by (metis "sc-eq-box-box:7" rigid_condition "vdash-properties:6")
    by (rule GEN)
    by (metis "\<equiv>E"(2) "logic-actual-nec:3"[axiom_inst])
qed


AOT_theorem "res-var-bound-reas[3]":
proof(safe intro!: "\<rightarrow>I" GEN)
  fix \<alpha>
    by (metis "\<equiv>E"(1) "logic-actual-nec:3"[axiom_inst])
    by (metis "nec-imp-act" "qml:2"[axiom_inst] rigid_condition "\<rightarrow>E")
    using 1 by (metis "act-cond" "\<rightarrow>E")
qed

AOT_theorem "res-var-bound-reas[Buridan]":
proof (rule "\<rightarrow>I")
    using "\<exists>E"[rotated] by blast
    by (metis "KBasic:11" "KBasic:3" "T\<diamond>" "&I" "&E"(1) "&E"(2)
              "\<equiv>E"(2) "reductio-aa:1" rigid_condition "vdash-properties:6")
    by (rule "\<exists>I")
    by (rule Buridan[THEN "\<rightarrow>E"])
qed

AOT_theorem "res-var-bound-reas[BF\<diamond>]":
proof(rule "\<rightarrow>I")
    using "BF\<diamond>"[THEN "\<rightarrow>E"] by blast
    using "\<exists>E"[rotated] by blast
    using "KBasic2:3" "&E" "\<rightarrow>E" by blast+
    using calculation rigid_condition by (metis "B\<diamond>" "K\<diamond>" "\<rightarrow>E")
    using "&I" by blast
    by (rule "\<exists>I")
qed

AOT_theorem "res-var-bound-reas[CBF\<diamond>]":
proof(rule "\<rightarrow>I")
    using "\<exists>E"[rotated] by blast
    using rigid_condition[THEN "qml:2"[axiom_inst, THEN "\<rightarrow>E"], THEN "\<rightarrow>E"] "&E" by blast+
    by (metis "KBasic:16" "con-dis-taut:5" "\<rightarrow>E")
    by (rule "\<exists>I")
    using "CBF\<diamond>"[THEN "\<rightarrow>E"] by fast
qed

AOT_theorem "res-var-bound-reas[A-Exists:1]":
proof(safe intro!: "\<equiv>I" "\<rightarrow>I")
    using "A-Exists:1"[THEN "\<equiv>E"(1)] by blast
     apply (meson "Act-Basic:2" "intro-elim:3:f" "oth-class-taut:3:a")
    by simp
    using "Commutativity of \<equiv>" "intro-elim:3:b" "sc-eq-fur:2"
          "\<rightarrow>E" rigid_condition by blast
next
     apply (meson "sc-eq-fur:2" "\<rightarrow>E" rigid_condition)
    by simp
     using "Act-Basic:2" apply presburger
     by simp
     by (metis "A-Exists:1" "intro-elim:3:b")
qed

end

end
