\footnote{%
  The tutorial has been added to the Archive of Formal Proofs after the release of Isabelle2018.
  Until the subsequent Isabelle release, the tutorial is only available in the development version at
  \url{https://devel.isa-afp.org/entries/Game_Based_Crypto.html}.
  The version for Isabelle2018 is available at \url{http://www.andreas-lochbihler.de/pub/crypthol_tutorial.zip}.
}
It contains this text and all examples, including the security definitions and proofs.
We encourage all readers to download the latest version of the tutorial 
and follow the proofs and examples interactively in Isabelle/HOL.
In particular, a Ctrl-click on a formal entity (function, constant, theorem name, ...) jumps to the definition of the entity.

We split the tutorial into a series of recipes for common formalization tasks. In each section, we cover
a familiar cryptography concept and show how it is formalized in \CryptHOL{}. Simultaneously, we explain
the Isabelle/HOL and functional programming topics that are essential for formalizing game-based proofs. 
\<close>
subsection \<open>Getting started\<close>
text \<open>
Cryptography formalizations based on \CryptHOL{} are arranged in Isabelle theory files that import the relevant libraries.
\<close>
subsection \<open>Getting started\<close>
text \<open>
Cryptography formalizations based on \CryptHOL{} are arranged in Isabelle theory files that import the relevant libraries.
\<close>
text \<open>
The file @{theory CryptHOL.CryptHOL} is the canonical entry point into \CryptHOL{}.
For the hashed Elgamal example in this tutorial, the \CryptHOL{} library contains everything that is needed.
Additional Isabelle libraries can be imported if necessary.
\<close>
section \<open>Modelling cryptography using \CryptHOL{}\<close>
text \<open>
This section demonstrates how the following cryptographic concepts are modelled in \CryptHOL{}.
\begin{itemize}
\item A security property without oracles (\S\ref{section:lcdh})
\item An oracle (\S\ref{section:random-oracle})
\item A cryptographic concept (\S\ref{section:pk-enc})
\item A security property with an oracle (\S\ref{section:ind-cpa})
\item A concrete cryptographic scheme (\S\ref{section:hashed-elgamal-scheme})
\end{itemize}
\<close>
subsection \<open>Security notions without oracles: the CDH assumption \label{section:lcdh}\<close>
text \<open>
In game-based cryptography, a security property is specified using a game between a benign challenger and an adversary.
The probability of an adversary to win the game against the challenger is called its advantage.
A cryptographic construction satisfies a security property if the advantage for any ``feasible'' adversary is ``negligible''.
A typical security proof reduces the security of a construction to the assumed security of its building blocks.
In a concrete security proof, where the security parameter is implicit, it is therefore not necessary to formally define ``feasibility'' and ''negligibility'', 
as the security statement establishes a concrete relation between the advantages of specific adversaries.%
\footnote{%
  The cryptographic literature sometimes abstracts over the adversary and 
  defines the advantage to be the advantage of the best "feasible" adversary against a game.
  Such abstraction would require a formalization of feasibility, for which \CryptHOL{} currently does not offer any support.
  We therefore always consider the advantage of a specific adversary.
}
We return to asymptotic security statements in \S\ref{section:asymptotic}.

A formalization of a security property must therefore specify all of the following:
\begin{itemize}
\item The operations of the scheme (e.g., an algebraic group, an encryption scheme)
\item The type of adversary
\item The game with the challenger
\item The advantage of the adversary as a function of the winning probability
\end{itemize}

For hashed Elgamal, the cyclic group must satisfy the computational Diffie-Hellman assumption.
To keep the proof simple, we formalize the equivalent list version of CDH.

\begin{definition}[The list computational Diffie-Hellman game]
The List Computational Diffie-Hellman (LCDH)
the following \textbf{LCDH game} against a challenger:
  \begin{enumerate}
  \end{enumerate}
\end{definition}

The scheme for LCDH uses only a cyclic group.
To make the LCDH formalisation reusable, we formalize the LCDH game for an arbitrary cyclic group @{term "\<G>"} using Isabelle's module system based on locales.
Basic facts about finite groups are formalized in the \CryptHOL{} theory @{theory CryptHOL.Cyclic_Group}.%
\footnote{%
  The syntax directive @{theory_text "structure"} tells Isabelle that all group operations in the context of the locale refer to the group @{term "\<G>"} unless stated otherwise.

  Isabelle automatically adds the locale parameters and the assumptions on them to all definitions and lemmas inside that locale.
  Of course, we could have made the group @{term "\<G>"} an explicit argument of all functions ourselves, 
  but then we would not benefit from Isabelle's module system, in particular locale instantiation.
}
\<close>
text \<open>
The LCDH game does not need oracles.
The adversary is therefore just a probabilistic function from two group elements to a set of guesses, which are again group elements.
(Subprobability distributions are like probability distributions except that the whole probability mass may be less than 1, i.e., some probability may be ``lost''.
A subprobability distribution is called lossless, written @{term lossless_spmf}, if its probability mass is 1.)
We define the following abbreviation as a shorthand for the type of LCDH adversaries.%
\footnote{%
  Actually, the type of group elements has already been fixed in the locale @{locale list_cdh} to the type variable @{typ "'grp"}.
  Unfortunately, such fixed type variables cannot be used in type declarations inside a locale in Isabelle2018.
}
\<close>
text \<open>
The LCDH game itself is expressed as a function from the adversary @{term "\<A>"} to the subprobability distribution of the adversary winning.
\CryptHOL{} provides operators to express these distributions as probabilistic programs and reason about them using program logics:
\begin{itemize}
  The sampling is independent, unless the distribution @{term p} depends on previously sampled variables.
  At the end of the block, the @{term "return_spmf DUMMY"} returns whether the adversary has won the game.
\item @{term "order \<G>"} denotes the order of @{term "\<G>"} and @{term [source] "([^]) :: 'grp \<Rightarrow> nat \<Rightarrow> 'grp"} is the group exponentiation operator.
\end{itemize}

The LCDH game formalizes the challenger's behavior against an adversary @{term "\<A>"}. 
In the following definition, the challenger randomly (and independently) picks two natural numbers 
@{term "x"} and @{term "y"} that are  between 0 and @{term "\<G>"}'s order and passes them to the adversary.
The adversary then returns a set @{term zs} of guesses for @{term "g ^ (x * y)"}, where @{term "g"} is the 
generator of @{term "\<G>"}. The game finally returns a @{typ bool}ean that indicates whether the 
adversary produced a right guess. Formally, @{term "game \<A>"} is a @{typ bool}ean random variable.
\<close>
text \<open>

The advantage of the adversary is equivalent to its probability of winning the LCDH game.
The function @{term [source] "spmf :: 'a spmf \<Rightarrow> 'a \<Rightarrow> real"} returns the probability of an elementary event under a given subprobability distribution.\<close>
text \<open>
This completes the formalisation of the LCDH game and we close the locale @{locale list_cdh} with @{command end}.
The above definitions are now accessible under the names @{term "list_cdh.game"} and @{term "list_cdh.advantage"}.
Furthermore, when we later instantiate the locale @{locale list_cdh}, they will be specialized to the given pararameters.
We will return to this topic in \S\ref{section:hashed-elgamal-scheme}.
\<close>
subsection \<open>A Random Oracle \label{section:random-oracle}\<close>
text \<open>
A cryptographic oracle grants an adversary black-box access to a certain information or functionality.
In this section, we formalize a random oracle, i.e., an oracle that models a random function with a finite codomain.
In the Elgamal security proof, the random oracle represents the hash function:
the adversary can query the oracle for a value and the oracle responds with the corresponding ``hash''.

\<close>
text \<open>
In \CryptHOL{}, oracles are modeled as probabilistic transition systems that given an initial state
and an input, return a subprobability distribution over the output and the successor state.
The type synonym @{typ [source] "('s, 'a, 'b) oracle'"} abbreviates @{typ "'s \<Rightarrow> 'a \<Rightarrow> ('b \<times> 's) spmf"}.


A random oracle accepts queries of type @{typ "'a"} and generates a random bitstring of length @{term len}.
The state of the random oracle remembers its previous responses in a mapping of type @{typ [source] "'a \<rightharpoonup> bitstring"}.
Upon a query @{term "x"}, the oracle first checks whether this query was received before.
If so, the oracle returns the same answer again.
Otherwise, the oracle randomly samples a bitstring of length @{term "len"}, stores it 
in its state, and returns it alongside with the new state.
\<close>
text \<open>
Initially, the state of a random oracle is the empty map @{term Map.empty}, as no queries have been asked.
For readability, we introduce an abbreviation:\<close>
text \<open>
This actually completes the formalization of the random oracle.
Before we close the locale, we prove two technical lemmas:
\begin{enumerate}
  Many reasoning steps in game-based proofs are only valid for lossless distributions, so it is generally recommended to prove losslessness of all definitions if possible.
  This lemma makes it possible to automatically unfold the random oracle only when it is known that the query is fresh.
\end{enumerate}
\<close>
text \<open>
\paragraph{Remark: Independence is the default.}
Note that @{typ "_ spmf"} represents a discrete probability distribution rather than a random variable.
The difference is that every spmf is independent of all other spmfs.
There is no implicit space of elementary events via which information may be passed from one random variable to the other.
If such information passing is necessary, this must be made explicit in the program.
That is why the random oracle explicitly takes a state of previous responses and returns the updated states.
Later, whenever the random oracle is used, the user must pass the state around as needed.
This also applies to adversaries that may want to store some information.
\<close>
subsection \<open>Cryptographic concepts: public-key encryption \label{section:pk-enc}\<close>
text \<open>
A cryptographic concept consists of a set of operations and their functional behaviour.
We have already seen two simple examples:
the cyclic group in \S\ref{section:lcdh} and the random oracle in \S\ref{section:random-oracle}.
We have formalized both of them as locales; we have not modelled their functional behavior as this is not needed for the proof.
In this section, we now present a more realistic example: public-key encryption with oracle access.

A public-key encryption scheme consists of three algorithms: key generation, encryption, and decryption.
They are all probabilistic and, in the most general case, they may access an oracle jointly with the adversary, e.g., a random oracle modelling a hash function.

\begin{itemize}
  This operation is needed only in the IND-CPA game definition in the next section, but we include it already here for convenience.
\end{itemize}
\<close>
text \<open>
The three actual operations are generative probabilistic values (GPV) of type @{typ [source] "(_, 'query, 'response) gpv"}.
The interface to the oracle is abstracted in the two type parameters @{typ 'query} for queries and @{typ 'response} for responses.
As before, we omit the specification of the functional behavior, namely that decrypting an encryption with a key pair returns the plaintext.
\<close>
subsection \<open>Security notions with oracles: IND-CPA security \label{section:ind-cpa}\<close>
text \<open>
In general, there are several security notions for the same cryptographic concept.
We now formalize the notion indistinguishability under chosen plaintext attacks (IND-CPA) for public-key encryption schemes.

Let @{term key_gen}, @{term encrypt} and @{term decrypt} denote a public-key encryption scheme.
The IND-CPA game is a two-stage game between the \emph{adversary} and a \emph{challenger}:
\begin{description}
\item[Stage 1 (find):]
  \strut
  \begin{enumerate}
  \item The challenger generates a public key @{term pk} using @{term key_gen} and gives the public key to the adversary.
  \item The adversary returns two messages @{term "m\<^sub>0"} and @{term "m\<^sub>1"}.
  \item The challenger checks that the two messages are a valid pair of plaintexts.
    (For example, both messages must have the same length.)
  \end{enumerate}
\item[Stage 2 (guess):]
  \strut
  \begin{enumerate}
  \item The challenger flips a coin @{term b} (either 0 or 1) and gives @{term "encrypt pk m\<^sub>b"} to the adversary.
  \item The adversary returns a bit @{term b'}.
  \end{enumerate}
\end{description}
The adversary wins the game if his guess @{term b'} is the value of @{term b}.
Let @{term "P\<^sub>w\<^sub>i\<^sub>n"} denote the winning probability.
His advantage is @{term "\<bar>P\<^sub>w\<^sub>i\<^sub>n - 1/2\<bar> :: real"}
\end{definition}

Like with the encryption scheme, we will define the game such that the challenger and the adversary have access to a shared oracle, but the oracle is still unspecified.
Consequently, the corresponding \CryptHOL{} game is a GPV, like the operations of the abstract encryption scheme.
When we specialize the definitions in the next section to the hashed Elgamal scheme, the GPV will be connected to the random oracle.

The type of adversary is now more complicated: It is a pair of probabilistic functions with oracle access, one for each stage of the game.
The first computes the pair of plaintext messages and the second guesses the challenge bit.
The additional @{typ 'state} parameter allows the adversary to maintain state between the two stages.
\<close>
text \<open>
The IND-CPA game formalization below follows the above informal definition.
There are three points that need some explanation.
First, this game differs from the simpler LCDH game in that it works with GPVs instead of SPMFs.
Therefore, probability distributions like coin flips @{term coin_spmf} must be lifted from SPMFs to GPVs using the coercion @{term lift_spmf}.
Second, the assertion @{term "assert_gpv (valid_plains m\<^sub>0 m\<^sub>1)"} ensures that the pair of messages is valid.
Third, the construct @{term "TRY DUMMY ELSE DUMMY :: (_, _, _) gpv"} catches a violated assertion.
\<close>
text \<open>
\input{fig-1}

Figure~\ref{fig:1} visualizes this game as a grey box.
The dashed boxes represent parameters of the game or the locale, i.e., parts that have not yet been instantiated.
The actual probabilistic program is shown on the left half, which uses the dashed boxes as sub-programs.
Arrows in the grey box from the left to the right pass the contents of the variables to the sub-program.
Those in the other direction bind the result of the sub-program to new variables.
The arrows leaving box indicate the query-response interaction with an oracle.
The thick arrows emphasize that the adversary's state is passed around explicitly.
The double arrow represents the return value of the game.
We will use this to define the adversary's advantage.

As the oracle is not specified in the game, the advantage, too, is parametrized by the oracle,
given by the transition function @{term [source] "oracle :: ('s, 'query, 'response) oracle'"}
and the initial state @{term [source] "\<sigma> :: 's"} its initial state.
The operator @{term "run_gpv"} connects the game with the oracle, whereby the GPV becomes an SPMF.
\<close>
subsection \<open>Concrete cryptographic constructions: the hashed ElGamal encryption scheme \label{section:hashed-elgamal-scheme}\<close>
text \<open>
With all the above modelling definitions in place,
we are now ready to explain how concrete cryptographic constructions are expressed in \CryptHOL.
In general, a cryptographic construction builds a cryptographic concept from possibly several simpler cryptographic concepts.
Accordingly, the formalisation consists of three steps:

\begin{enumerate}
\item Import the cryptographic concepts on which the construction builds.
\item Define the concrete construction.
\item Instantiate the abstract concepts with the construction.
\end{enumerate}

First, we declare a new locale that imports the two building blocks: 
This ensures that the construction can be used for arbitrary cyclic groups. 
\<close>
text \<open>
Second, we formalize the hashed ElGamal encryption scheme.
Here is the well-known informal definition.

\begin{definition}[Hashed Elgamal encryption scheme]
Let $G$ be a cyclic group of order $q$ that has a generator $g$. Furthermore, let $h$ be a hash
function that maps the elements of $G$ to bitstrings, and $\oplus$ be the xor operator on
bitstrings. The Hashed-ElGamal encryption scheme is given by the following algorithms:
\begin{description}
\item[Key generation]
  Pick an element $x$ randomly from the set $\{0, \dots, q-1\}$
  and output the pair $(g^x, x)$, where $g^x$ is the public key and $x$ is the private key.
\item[Encryption]
  Given the public key $pk$ and the message $m$,
  pick $y$ randomly from the set $\{0, \dots, q-1\}$
  and output the pair $(g^y, h(pk^y) \oplus m)$.
  Here $\oplus$ denotes the bitwise exclusive-or of two bitstrings.
\item[Decryption]
  Given the private key $sk$ and the ciphertext $(\alpha, \beta)$,
  output $h(\alpha^{sk}) \oplus \beta$.
\end{description}
\end{definition}

As we can see, the public key is a group element, the private key a natural number, a plaintext a bitstring, and a ciphertext a pair of a group element and a bitstring.%
\footnote{%
  However, Isabelle/HOL's type system cannot express such properties that depend on locale parameters.
}
For readability, we introduce meaningful abbreviations for these concepts.
\<close>
text \<open>
We next translate the three algorithms into \CryptHOL{} definitions.
The definitions are straightforward except for the hashing.
Since we analyze the security in the random oracle model, 
an application of the hash function $H$ is modelled as a query to the random oracle using the GPV @{term hash}.
Here, @{term "Pause x Done"} calls the oracle with query @{term x} and returns the oracle's response.
Furthermore, we define the plaintext validity predicate to check the length of the adversary's messages produced by the adversary.
\<close>
text\<open>
The third and last step instantiates the interface of the encryption scheme with the hashed Elgamal scheme.
This specializes all definition and theorems in the locale @{locale ind_cpa_pk} to our scheme.
\<close>
text \<open>
Figure~\ref{fig:2} illustrates the instantiation.
In comparison to Fig.~\ref{fig:1}, the boxes for the key generation and the encryption algorithm have been instantiated with the hashed Elgamal definitions from this section.
We nevertheless draw the boxes to indicate that the definitions of these algorithms has not yet been inlined in the game definition.
The thick grey border around the key generation algorithm denotes the @{term lift_spmf} operator, which embeds the probabilistic @{term key_gen} without oracle access into the type of GPVs with oracle access.

\input{fig-2}
\<close>
section \<open>Cryptographic proofs in \CryptHOL{}\<close>
text \<open>
This section explains how cryptographic proofs are expressed in \CryptHOL{}.
We will continue our running example by stating and proving the IND-CPA security of the hashed Elgamal encryption scheme
under the computational Diffie-Hellman assumption in the random oracle model, using the definitions from the previous section.
More precisely, we will formalize a reduction argument (\S\ref{section:reduction}) and bound the IND-CPA advantage using the CDH advantage.
We will \emph{not} formally state the result that CDH hardness in the cyclic group implies IND-CPA security, 
which quantifies over all feasible adversaries--%
to that end, we would have to formally define feasibility, for which \CryptHOL{} currently does not offer any support.

The actual proof of the bound consists of several game transformations.
We will focus on those steps that illustrate common steps in cryptographic proofs (\S\ref{section:ghop-first}--\S\ref{section:combining:hops}) .
\<close>
subsection\<open>The reduction \label{section:reduction}\<close>
text \<open>
The security proof involves a reduction argument:
We will derive a bound on the advantage of an arbitrary adversary in the IND-CPA game @{term "ind_cpa.game"} for hashed Elgamal
that depends on another adversary's advantage in the LCDH game @{term "lcdh.game"} of the underlying group.
The reduction transforms every IND-CPA adversary @{term "\<A>"} into a LCDH adversary @{term "elgamal_reduction \<A>"},
using @{term "\<A>"} as a black box.
In more detail, it simulates an execution of the IND-CPA game including the random oracle.
At the end of the game, the reduction outputs the set of queries that the adversary has sent to the random oracle.
The reduction works as follows given a two part IND-CPA adversary @{term "\<A> = (\<A>\<^sub>1, \<A>\<^sub>2)"}
(Figure~\ref{fig:3} visualizes the reduction as the dotted box):
\begin{enumerate}
\item It receives two group elements @{term "\<alpha>"} and @{term "\<beta>"} from the LCDH challenger.
\item The reduction passes @{term "\<alpha>"} to the adversary as the public key and runs @{term "\<A>\<^sub>1"} to get messages @{term "m\<^sub>1"} and @{term "m\<^sub>2"}.
  The adversary is given access to the random oracle with the initial state @{term ro.initial}.
\item The assertion checks that the adversary returns two valid plaintexts, i.e., @{term m\<^sub>1} and @{term m\<^sub>2} are strings of length @{term len_plain}.
\item Instead of actually performing an encryption, the reduction generates a random bitstring @{term h} of length @{term len_plain} 
(@{term "nlists UNIV len_plain"} denotes the set of all bitstrings of length @{term len_plain} and
@{term spmf_of_set} converts the set into a uniform distribution over the set.)
\item The reduction passes @{term "(\<beta>, h)"} as the challenge ciphertext to the adversary in the second phase of the IND-CPA game.
\item The actual guess @{term b'} of the adversary is ignored; 
  instead the reduction returns the set @{term "dom s'"} of all queries that the adversary made to the random oracle as its guess for the CDH game.
\item If any of the steps after the first phase fails, the reduction's guess is the set @{term "dom s"} of oracle queries made during the first phase.
\end{enumerate}

\input{fig-3}
\<close>
subsection \<open>Concrete security statement \label{section:security:concrete}\<close>
text \<open>
A concrete security statement in \CryptHOL{} has the form:
Subject to some side conditions for the adversary @{term \<A>}, the advantage in one game is bounded
by a function of the transformed adversary's advantage in a different game.%
\footnote{%
  A security proof often involves several reductions.
  The bound then depends on several advantages, one for each reduction.
}
\<close>
text \<open>
For the hashed Elgamal scheme, the theorem looks as follows, i.e., the function @{term f} is the identity function.
\<close>
end %invisible \<comment> \<open>These six lines allow us to show the concrete theorem statement before we define the side condition on \<A>. They should not occur in a normal formalisation.\<close>
local_setup %invisible \<open>Local_Theory.map_background_naming (Name_Space.mandatory_path "ind_cpa")\<close>
  oops%invisible \<comment> \<open>This aborts the proof as we have not yet defined @{term ind_cpa.lossless} properly. We restate the theorem below properly.\<close>
text \<open>
Such a statement captures the essence of a concrete security proof.
For if there was a feasible adversary @{term \<A>} with non-negligible advantage against the @{term ind_cpa.game},
then @{term "elgamal_reduction \<A>"} would be an adversary against the @{term lcdh.game} with at least the same advantage.
This implies the existence of an adversary with non-negligible advantage against the cryptographic primitive that was assumed to be secure.
What we cannot state formally is that the transformed adversary @{term "elgamal_reduction \<A>"} is feasible
as we have not formalized the notion of feasibility.
The readers of the formalization must convince themselves that the reduction preserves feasibility.

In the case of @{term elgamal_reduction}, this should be obvious from the definition (given the theorem's side condition)
as the reduction does nothing more than sampling and redirecting data.

Our proof for the concrete security theorem needs the side condition that the adversary is lossless.
Losslessness for adversaries is similar to losslessness for subprobability distributions.
It ensures that the adversary always terminates and returns an answer to the challenger.
For the IND-CPA game, we define losslessness as follows:
\<close>
text %visible \<open>
So now let's start with the proof.
\<close>
  text %invisible \<open>
    For this proof, we configure Isabelle's simplifier such that the proofs become reasonably short.
    Initially, when writing the proof, we had added those lemmas manually to to invocation
    of the simplifier and then collected the useful rules in a polishing step.
  \<close>
text %visible \<open>
As a preparatory step, we split the adversary @{term "\<A>"} into its two phases @{term "\<A>\<^sub>1"} and @{term "\<A>\<^sub>2"}.
We could have made the two phases explicit in the theorem statement, but our form is easier to read and use.
We also immediately decompose the losslessness assumption on @{term "\<A>"}.%
\footnote{%
  Later in the proof, we will often prove losslessness of the definitions in the proof.
  We will not show them in this document, but they are in the Isabelle sources from which this document is generated.
}
\<close>
subsection \<open>Recording adversary queries \label{section:ghop-first}\<close>
text \<open>
  As can be seen in Fig.~\ref{fig:2}, both the adversary and the encryption of the challenge ciphertext use the random oracle.
  The reduction, however, returns only the queries that the adversary makes to the oracle (in Fig.~\ref{fig:3}, $h$ is generated independently of the random oracle).
  To bridge this gap, we introduce an @{term interceptor} between the adversary and the oracle that records all adversary's queries.
\<close>
text \<open>
  We integrate this interceptor into the @{term "ind_cpa.game"} using the @{term "inline"} function as illustrated in Fig.~\ref{fig:4}
  and name the result @{term "game\<^sub>0"}.

\input{fig-4}
\<close>
text \<open>
We claim that the above modifications do not affect the output of the IND-CPA game at all.
This might seem obvious since we are only logging the adversary's queries without modifying them.
However, in a formal proof, this needs to be precisely justified.

More precisely, we have been very careful that the two games @{term "ind_cpa.game \<A>"} and 
@{term game\<^sub>0} have identical structure. They differ only in that @{term game\<^sub>0} uses the adversary
@{term "(\<lambda>pk. inline interceptor (\<A>\<^sub>1 pk) {}, \<lambda>cipher \<sigma>. inline interceptor (\<A>\<^sub>2 cipher \<sigma>))"}
instead of @{term "\<A>"}. The formal justification for this replacement happens in two steps:
\begin{enumerate}
\item We replace the oracle transformer @{term interceptor} with @{term id_oracle}, which merely passes queries and results to the oracle.
\item Inlining the identity oracle transformer @{term id_oracle} does not change an adversary and can therefore be dropped.
\end{enumerate}

The replacement is controlled by so-called transfer rules of the form @{term "R x y"} which
indicates that @{term x} shall replace @{term y}; the correspondence relation @{term R} captures the 
kind of replacement.
The @{method transfer} proof method then constructs a constraint system with one constraint
for each atom in the proof goal where the correspondence relation and the replacement are unknown.
It then tries to solve the constraint system using the rules that have been declared with 
Atoms that do not have a suitable transfer rule are not changed and their correspondence relation is
instantiated with the identity relation @{term "(=)"}.

The second step is automated using Isabelle's simplifier.  

In the example, the crucial change happens in the state of the oracle transformer:
@{term interceptor} records all queries in a set whereas @{term id_oracle} has no state, which 
is modelled with the singleton type @{typ unit}.
To capture the change, we define the correspondence relation @{term cr} on the states of the oracle transformers.
(As we are in the process of adding this state, this state is irrelevant and @{term cr} is therefore always true.
We nevertheless have to make an explicit definition such that Isabelle does not automatically beta-reduce terms, which would confuse @{method transfer}.) 
We then prove that it relates the initial states and that @{term cr} is a bisimulation relation
The bisimulation proof itself is automated, too: A bit of term rewriting (@{command "unfolding"}) 
makes the two oracle transformers structurally identical except for the state update function.
Having proved that the state update function @{term "\<lambda>_ \<sigma>. \<sigma>"} is a correct replacement for
@{term "insert"} w.r.t. @{term cr}, the @{method transfer_prover} then lifts this replacement
to the bisimulation rule.
Here, @{method transfer_prover} is similar to @{method transfer} except that it works only for
transfer rules and builds the constraint system only for the term to be replaced.

The theory source of this tutorial contains a step-by-step proof to illustrate how transfer works.
\<close>
  have [transfer_rule]: "cr () {}" by(simp add: cr_def) \<comment> \<open>initial states\<close>
  have [transfer_rule]: "((=) ===> cr ===> cr) (\<lambda>_ \<sigma>. \<sigma>) insert" \<comment> \<open>state update\<close>
  have [transfer_rule]: \<comment> \<open>@{term cr} is a bisimulation for the oracle transformers\<close> 
{ % invisible text \<open>And now the same proof again, but step by step.\<close>
  have [transfer_rule]: "cr () {}" by(simp add: cr_def) \<comment> \<open>initial states\<close>
  have [transfer_rule]: "((=) ===> cr ===> cr) (\<lambda>_ \<sigma>. \<sigma>) insert" \<comment> \<open>state update\<close>
  have [transfer_rule]: \<comment> \<open>@{term cr} is a bisimulation for the oracle transformers\<close> 
    text \<open>1. Unfold the definitions of the oracle transformers and massage them to have the same structure.\<close>
    text \<open>2. Build the constraint system for the second argument of the correspondence relation, namely @{term interceptor} with the rewrite rules applied.\<close>
    text \<open>3. Solve the constraint system prolog-style by resolving with the rules from @{thm [source] transfer_raw}.\<close>
        apply transfer_step \<comment> \<open>This step uses the state update transfer rule proven in the previous @{command have}.\<close>
    text \<open>4. Check that the found solution is the expected one, namely the first argument of the correspondence relation, here @{term id_oracle} with the rewrite rules applied.\<close>
    text \<open>1. Unfold the definitions\<close>
    text \<open>2. Build the constraint system for the whole subgoal. The \<open>fixing\<close> tells transfer
The latter is automated using \<open>monad_normalisation\<close>~\<^cite>\<open>"Schneider2017"\<close>.%
  The tool \<open>monad_normalisation\<close> augments Isabelle's simplifier with a normalization procedure for commutative monads based on higher-order ordered rewriting.
  It can also commute across control structures like \<open>if\<close> and \<open>case\<close>.
Suppose that two games behave the same except when a so-called failure event occurs \<^cite>\<open>Shoup2004IACR\<close>.
For hashed Elgamal, the simulation breaks if the adversary queries the random oracle with the same query @{term "\<^bold>g [^] (x * y)"} that is used for encrypting the chosen message \<open>m\<^sub>b\<close>.
It is easy to prove that @{term game\<^sub>0} combined with the random oracle is a projection of @{term game\<^sub>1} with the sampling added, as formalized in \<open>game\<^sub>0_game\<^sub>1\<close>.
  In Shoup's terminology \<^cite>\<open>Shoup2004IACR\<close>, such a step makes (a gnome sitting inside) the random oracle forgetting the query.
  First, we identify a bisimulation relation \<open>?X\<close> between the different states of @{term oracle'} for the second phase of the game.
Clearly, if we plug in the appropriate function \<open>?f\<close>, then we get @{term game\<^sub>2}:
Using the lemmas about @{term negligible} and Eberl's library for asymptotic reasoning~\<^cite>\<open>"Eberl2015"\<close>,
