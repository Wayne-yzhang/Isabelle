theory Dijkstra
  imports 
  Graph 
  Dijkstra_Misc 
  Collections.Refine_Dflt_ICF
  Weight
begin

subsection "Graph's for Dijkstra's Algorithm"
  locale weighted_graph = valid_graph G
    for G :: "('V,'W::weight) graph"

subsection "Specification of Correct Result"
  context weighted_graph
  begin
    definition is_shortest_path_map :: "'V \<Rightarrow> ('V \<rightharpoonup> ('V,'W) path) \<Rightarrow> bool" 
      where
      "is_shortest_path_map v0 res \<equiv> \<forall>v\<in>V. (case res v of
        None \<Rightarrow> \<not>(\<exists>p. is_path v0 p v) |
        Some p \<Rightarrow> is_path v0 p v 
                  \<and> (\<forall>p'. is_path v0 p' v \<longrightarrow> path_weight p \<le> path_weight p')
      )"
  end

  fun path_weight' where
    "path_weight' None = top" |
    "path_weight' (Some p) = Num (path_weight p)"

subsection "Dijkstra's Algorithm"
  type_synonym ('V,'W) state = "('V set) \<times> ('V \<rightharpoonup> ('V,'W) path)"

  locale Dijkstra = weighted_graph G 
    for G :: "('V,'W::weight) graph"+
    fixes v0 :: 'V
    assumes finite[simp,intro!]: "finite V" "finite E"
    assumes v0_in_V[simp, intro!]: "v0\<in>V"
    assumes nonneg_weights[simp, intro]: "(v,w,v')\<in>edges G \<Longrightarrow> 0\<le>w"
  begin

  lemma path_nonneg_weight: "is_path v p v' \<Longrightarrow> 0 \<le> path_weight p"
    by (induct rule: is_path.induct) auto

  definition "dinvar \<sigma> \<equiv> let (wl,res)=\<sigma> in
    wl \<subseteq> V \<and>
    (\<forall>v\<in>V. \<forall>p. res v = Some p \<longrightarrow> is_path v0 p v \<and> int_vertices p \<subseteq> V-wl) \<and>
    (\<forall>v\<in>V-wl. \<forall>p. is_path v0 p v 
       \<longrightarrow> path_weight' (res v) \<le> path_weight' (Some p)) \<and>
    (\<forall>v\<in>wl. \<forall>p. is_path v0 p v \<and> int_vertices p \<subseteq> V-wl
       \<longrightarrow> path_weight' (res v) \<le> path_weight' (Some p)
    )
    "

  lemma invar_imp_correct: "dinvar ({},res) \<Longrightarrow> is_shortest_path_map v0 res"
    unfolding dinvar_def is_shortest_path_map_def
    by (auto simp: infty_unbox split: option.split)

  definition dinit :: "('V,'W) state nres" where
    "dinit \<equiv> SPEC ( \<lambda>(wl,res) . 
        wl=V \<and> res v0 = Some [] \<and> (\<forall>v\<in>V-{v0}. res v = None))"

  lemma dinit_invar: "dinit \<le> SPEC dinvar"
    unfolding dinit_def
    apply (intro refine_vcg)
    apply (force simp: dinvar_def split: option.split)
    done


  definition pop_min :: "('V,'W) state \<Rightarrow> ('V \<times> ('V,'W) state) nres" where
    "pop_min \<sigma> \<equiv> do {
      let (wl,res)=\<sigma>;
      ASSERT (wl\<noteq>{}); 
      v \<leftarrow> RES (least_map (path_weight' \<circ> res) wl);
      RETURN (v,(wl-{v},res))
    }"


  inductive update_spec :: "'V \<Rightarrow> ('V,'W) state \<Rightarrow> ('V,'W) state \<Rightarrow> bool"
    where
    "\<lbrakk> \<forall>v'\<in>V. 
      res' v' \<in> least_map path_weight' (
        { res v' } \<union> { Some (p@[(v,w,v')]) | p w. res v = Some p \<and> (v,w,v')\<in>E }
      )
     \<rbrakk> \<Longrightarrow> update_spec v (wl,res) (wl,res')"

  definition update_pre :: "'V \<Rightarrow> ('V,'W) state \<Rightarrow> bool" where
    "update_pre v \<sigma> \<equiv> let (wl,res)=\<sigma> in v\<in>V 
      \<and> (\<forall>v'\<in>V-wl. v'\<noteq>v \<longrightarrow> (\<forall>p. is_path v0 p v' 
          \<longrightarrow> path_weight' (res v') \<le> path_weight' (Some p)))
      \<and> (\<forall>v'\<in>V. \<forall>p. res v' = Some p \<longrightarrow> is_path v0 p v')"

  definition update :: "'V \<Rightarrow> ('V,'W) state \<Rightarrow> ('V,'W) state nres" where 
    "update v \<sigma> \<equiv> do {ASSERT (update_pre v \<sigma>); SPEC (update_spec v \<sigma>)}"

  definition dijkstra where
    "dijkstra \<equiv> do {
       \<sigma>0\<leftarrow>dinit; 
       (_,res) \<leftarrow> WHILE\<^sub>T\<^bsup>dinvar\<^esup> (\<lambda>(wl,_). wl\<noteq>{}) 
            (\<lambda>\<sigma>. 
              do { (v,\<sigma>') \<leftarrow> pop_min \<sigma>; update v \<sigma>' }
            )
            \<sigma>0;
       RETURN res }
    "


  theorem dijkstra_correct: "dijkstra \<le> SPEC (is_shortest_path_map v0)"
    unfolding dijkstra_def
    unfolding dinit_def
    unfolding pop_min_def update_def [abs_def]
    thm refine_vcg

    apply (refine_rcg
      WHILEIT_rule[where R="inv_image {(x,y). x<y} (card \<circ> fst)"]
      refine_vcg 
    )

    supply [[simproc del: defined_all]]
    apply (simp_all split: prod.split_asm)

  proof -
    fix wl res v
    assume INV: "dinvar (wl,res)"
    and LM: "v\<in>least_map (path_weight' \<circ> res) wl"
    hence "v\<in>V" unfolding dinvar_def by (auto dest: least_map_elemD)
    moreover
    from INV have " \<forall>v'\<in>V - (wl-{v}). v' \<noteq> v \<longrightarrow> 
      (\<forall>p. is_path v0 p v' \<longrightarrow> path_weight' (res v') \<le> Num (path_weight p))"
      by (auto simp: dinvar_def)
    moreover from INV have "\<forall>v'\<in>V. \<forall>p. res v'=Some p \<longrightarrow> is_path v0 p v'"
      by (auto simp: dinvar_def)
    ultimately show "update_pre v (wl-{v},res)" by (auto simp: update_pre_def)
  next
    fix res
    assume "dinvar ({}, res)"
    thus "is_shortest_path_map v0 res"
      by (rule invar_imp_correct)
  next
    show "wf (inv_image {(x, y). x < y} (card \<circ> fst))" 
      by (blast intro: wf_less)
  next
    fix wl res v \<sigma>''
    assume 
      LM: "v\<in>least_map (path_weight' \<circ> res) wl" and 
      UD: "update_spec v (wl-{v},res) \<sigma>''" and
      INV: "dinvar (wl,res)" 

    from LM have "v\<in>wl" by (auto dest: least_map_elemD)
    moreover from UD have "fst \<sigma>'' = wl-{v}" by (auto elim: update_spec.cases)
    moreover from INV have "finite wl" 
      unfolding dinvar_def by (auto dest: finite_subset)
    ultimately show "card (fst \<sigma>'') < card wl" 
      apply simp
      by (metis card_gt_0_iff diff_Suc_less empty_iff)
  next
    fix a and res :: "'V \<rightharpoonup> ('V,'W) path"
    assume "a = V \<and> res v0 = Some [] \<and> (\<forall>v\<in>V-{v0}. res v = None)"
    thus "dinvar (V,res)"
      by (force simp: dinvar_def split: option.split)
  next
    fix wl res
    assume INV: "dinvar (wl,res)"
    hence  
      WL_SUBSET: "wl \<subseteq> V" and
      PATH_VALID: "\<forall>v\<in>V. \<forall>p. res v = Some p 
        \<longrightarrow> is_path v0 p v \<and> int_vertices p \<subseteq> V - wl" and
      NWL_MIN: "\<forall>v\<in>V - wl. \<forall>p. is_path v0 p v 
        \<longrightarrow> path_weight' (res v) \<le> Num (path_weight p)" and
      WL_MIN: "\<forall>v\<in>wl. \<forall>p. is_path v0 p v \<and> int_vertices p \<subseteq> V - wl 
        \<longrightarrow> path_weight' (res v) \<le> Num (path_weight p)"
      unfolding dinvar_def by auto

    fix v \<sigma>''
    assume V_LEAST: "v\<in>least_map (path_weight' o res) wl" 
      and "update_spec v (wl-{v},res) \<sigma>''"
    then obtain res' where
      [simp]: "\<sigma>''=(wl-{v},res')"
      and CONSIDERED_NEW_PATHS: "\<forall>v'\<in>V. res' v' \<in> least_map path_weight' 
        (insert (res v') 
              ({ Some (p@[(v,w,v')]) | p w. res v = Some p \<and> (v,w,v')\<in>E }))"
      by (auto elim!: update_spec.cases)
      
    from V_LEAST have V_MEM: "v\<in>wl" by (blast intro: least_map_elemD)

    show "dinvar \<sigma>''"
      apply (unfold dinvar_def, simp)
      apply (intro conjI)
    proof -
      from WL_SUBSET show "wl-{v} \<subseteq> V" by auto

      show "\<forall>va\<in>V. \<forall>p. res' va = Some p 
        \<longrightarrow> is_path v0 p va \<and> int_vertices p \<subseteq> V - (wl - {v})"
      proof (intro ballI conjI impI allI)
        fix v' p
        assume V'_MEM: "v'\<in>V" and [simp]: "res' v' = Some p"
        with CONSIDERED_NEW_PATHS have "res' v' \<in> (insert (res v') 
          ({ Some (p@[(v,w,v')]) | p w. res v = Some p \<and> (v,w,v')\<in>E }))"
          by (rule_tac least_map_elemD) blast
        moreover {
          assume [symmetric,simp]: "res' v' = res v'"
          from V'_MEM PATH_VALID have 
            "is_path v0 p v'" 
            "int_vertices p \<subseteq> V - (wl-{v})"
            by force+
        } moreover {
          fix pv w
          assume "res' v' = Some (pv@[(v,w,v')])" 
            and [simp]: "res v = Some pv" 
            and EDGE: "(v,w,v')\<in>E"
          hence [simp]: "p = pv@[(v,w,v')]" by simp
          
          from bspec[OF PATH_VALID rev_subsetD[OF V_MEM WL_SUBSET]] have 
            PATHV: "is_path v0 pv v" and IVV: "int_vertices pv \<subseteq> V - wl" by auto
          hence 
            "is_path v0 p v'" 
            "int_vertices p \<subseteq> V - (wl-{v})"
            by (auto simp: EDGE V'_MEM)
        } 
        ultimately show 
          "is_path v0 p v'" 
          "int_vertices p \<subseteq> V - (wl-{v})"
          by blast+
      qed

