theory Tau_Sinks
imports
  Coupled_Simulation
begin


context lts_tau
begin

definition tau_sink ::
where


lemma tau_sink_maximal:
  shows
  using assms steps_loop step_weak_step_tau tau_tau unfolding tau_sink_def by metis+

lemma sink_has_no_word_transitions: 
  assumes 
proof - 
    by (metis assms(1,3) list.set_intros(1) lts_tau.tau_def steps_loop tau_sink_def)
qed


lemma sink_coupled_simulates_all_states:
  assumes
  shows 
  by (simp add: assms coupledsim_refl coupledsim_step)

theorem coupledsim_weaksim_equiv_on_sink_expansion:
  assumes
  shows
  using assms 
  using coupled_simulation_weak_simulation weak_sim_tau_step weaksim_greatest by auto

  
lemma sink_contrasimulates_all_states:
fixes A :: " 'a list"
  assumes 
  shows 
proof (cases A)
  case Nil
  show ?thesis using assms(2) contrasim_tau_step by auto 
next
  case Cons
    using assms(1) sink_has_no_word_transitions by fastforce
  show ?thesis using assms(2) contrasim_tau_step by auto 
qed

lemma sink_trace_includes_all_states:
  assumes 
  shows 
  by (metis assms contrasim_tau_step lts_tau.contrasim_implies_trace_incl) 

lemma trace_incl_with_sink_is_contrasim:
  assumes
  shows
 unfolding contrasimulation_def
proof clarify
  fix p q p' A
    using assms(3) unfolding trace_inclusion_def by blast
    using assms(1) tau_tau word_tau_concat by blast
    using assms(2) by auto
qed

theorem contrasim_trace_incl_equiv_on_sink_expansion_R:
  assumes
  shows 
proof
next
qed

theorem contrasim_trace_incl_equiv_on_sink_expansion:
  assumes
  shows
  using assms weak_trace_inlcusion_greatest
    contrasim_tau_step contrasim_trace_incl_equiv_on_sink_expansion_R contrasim_implies_trace_incl
  by (metis (no_types, lifting))

end


lemma simulation_tau_sink_1:
  fixes
    step sink R \<tau>
  defines
  assumes
  shows
proof -
  show ?thesis unfolding lts_tau.weak_simulation_def
  proof safe
    fix p q p' a
      using assms(2) unfolding step2_def by auto
      using lts_tau.step_tau_refl[of \<tau> step2 q] by auto
  next
    fix p q p' a
      unfolding step2_def by blast
      using `step2 p a p'` unfolding step2_def .
    proof safe
        using lts.steps.refl[of step2 q ?tau] assms(1) by (meson lts_tau.tau_tau)
    next
      then obtain q' where q'_def:
        using assms(3) `R p q` unfolding lts_tau.weak_simulation_def by blast
        using lts_impl_steps[of step _ _ _ step2] step_impl_step2 by blast
        by blast
    qed
  qed
qed
  
lemma simulation_tau_sink_2:
  fixes
    step sink R \<tau>
  defines
  assumes
  shows
proof -
  show ?thesis
    unfolding lts_tau.weak_simulation_def
  proof safe
    fix p q p' a
    assume
    hence False using assms(2) by blast
  next
    fix p q p' a
      using assms(2)[of a p] assms(2)[of a p'] by auto
    then obtain q' where q'_def:
      using assms(3) `R p q` unfolding lts_tau.weak_simulation_def by blast
      then obtain q'' where q''_def:
        using q'_def(2,3) assms(1) step2_def lts_tau.step_tau_refl[of \<tau>]
          lts_tau.tau_tau[of \<tau>] by metis
        using assms(2) unfolding step2_def by (metis lts.steps.cases)
      proof
        obtain pq1 where pq1_def:
          using q''_def(2) `\<not> ?tau a` by blast
        proof (induct rule: lts.steps.induct[OF `?steps step2 q ?tau pq1`])
          case (1 p af)
          then show ?case using lts.steps.refl[of step p af] by blast
        next
          case (2 p af q1 a q)
          ultimately show ?case using 2(4) by (meson lts.step)
        qed
        thus
          using pq1_def(2) lts.steps.refl[of step q'' ?tau] by blast
      qed
        using q''_def(1) q'_def(1) by auto
    next
        using q'_def(2) not_sink_q' unfolding step2_def
      proof (safe)
        assume i:
        proof (induct rule: lts.steps.induct[OF i(3)])
          case (1 p af)
          then show ?case using lts.steps.refl[of _ p af] by auto
        next
          case (2 p af q1 a q)
          ultimately show ?case using `af a` lts.step[of step p af q1 a q] by blast
        qed
      qed
      have outer_goal_c:
        using q'_def(3)
      proof safe
        fix pq1 pq2
        assume subassms:
          using subassms(4) assms(2) not_sink_q' lts.steps_loop
          unfolding step2_def by (metis (mono_tags, lifting))
          using subassms(4) not_sink_q' unfolding step2_def
        proof (induct rule:lts.steps.induct[OF subassms(4)])
          case (1 p af) show ?case using lts.steps.refl by assumption
        next
          case (2 p af q1 a q)
          thus ?case using `step q1 a q` 2(4) lts.step[of step p af q1 a q] by blast
        qed
          using `pq2 \<noteq> sink` subassms(3) unfolding step2_def by blast
          using subassms(4) unfolding step2_def
        proof (induct rule:lts.steps.induct[OF subassms(2)])
          case (1 p af) show ?case using lts.steps.refl by assumption
        next
          case (2 p af q1 a q)
          thus ?case using `step q1 a q` 2(4) lts.step[of step p af q1 a q] by blast
        qed
        thus
          using goal_b goal_c by auto
      qed
        using outer_goal_a outer_goal_b by auto
    qed
  qed
qed

lemma simulation_sink_invariant:
  fixes
    step sink R \<tau>
  defines
  assumes
proof (rule)
    unfolding lts_tau.weak_simulation_def step2_def using assms(2)
    by (meson lts.steps.simps)
    using lts_tau.weaksim_greatest[of step2 \<tau>] unfolding R_def by blast
  have R_contains_inv_tau_closure:
    unfolding R_def using lts_tau.weak_sim_tau_step by fastforce
    by meson
  hence closed_R:
    using weak_sim_R sink_sim_min lts_tau.weak_sim_union_cl by blast
    using weak_sim_R sink_sim_min lts_tau.weak_sim_union_cl[of step2 \<tau>] by blast
    using  simulation_tau_sink_2[of step sink \<tau> R] assms(2) closed_R
    unfolding step2_def by blast
    using Rpq weak_sim_R by blast
next
  proof clarify
    fix R
    assume
      using simulation_tau_sink_1[of step sink \<tau> R] assms(2) unfolding step2_def by auto
      using `R p q` unfolding step2_def by blast
  qed
qed


lemma trace_inclusion_sink_invariant:
  fixes
    step sink R \<tau>
  defines
  assumes
  shows
proof - 
  {
    fix A
    proof(clarify, induct A rule: rev_induct)
      case Nil
        using lts_tau.step_tau_refl by fastforce
      thus ?case
        by (metis Nil.prems(2) lts_tau.tau_tau lts_tau.weak_step_seq.simps(1)) 
    next
      case (snoc a A)
      then obtain p01 where 
        using snoc by (metis lts_tau.rev_seq_split) 
      then obtain p02 where p02_def: 
        using snoc.hyps[of p p01] snoc.prems(1) not_in_set by auto
        using p01_def2 lts_tau.step_tau_concat lts_tau.tau_tau
        by (smt (verit, del_insts))
      then obtain p03 p04 where 
        using snoc.prems(1) lts_tau.tau_def 
        by (metis last_in_set snoc_eq_iff_butlast)
      proof (induct rule: lts.steps.induct[OF `lts.steps step2 p02 ?tau  p03`])
        case (1 p A)
        thus ?case by (simp add: lts.refl)
      next
        case (2 p A q1 a q)
        thus ?case using 2 lts.step step2_def by metis
      qed 
        by (metis lts.step lts_tau.step_tau_refl lts_tau.tau_tau) 
        using lts_tau.rev_seq_step_concat p02_def(1) by fastforce 
      thus ?case using tau2 by auto
    qed
  }
    by fastforce

  proof
    fix A
    proof(clarify, induct A rule: list.induct)
      case Nil
        by (simp add: lts_tau.weak_step_seq.simps(1) lts_tau.tau_tau)
        using lts_impl_steps step2_def lts_tau.tau_tau  by force 
      thus ?case by (simp add: lts_tau.weak_step_seq.simps(1) lts_tau.tau_tau) 
    next
      case (Cons x xs)
        by (metis (mono_tags, lifting) lts_tau.weak_step_seq.simps(2))
        using Cons.prems(1) p1_def lts_tau.tau_def by (metis list.set_intros(1))
        using lts_impl_steps step2_def
        by (smt (verit, best))
        using p02_weak lts_impl_steps step2_def by (smt (verit, best))
        using tau1 strong step2_def Cons.prems(1) lts_tau.tau_def
        by (metis list.set_intros(1))  
        using IH lts_tau.weak_step_seq_def[of step2 \<tau>] by auto
    qed
  qed
  show ?thesis
  proof (rule)
      by blast
      unfolding lts_tau.trace_inclusion_def
    proof clarify
      fix p q p' A
      assume subassms: 
        using weak_sim_R 
        unfolding lts_tau.trace_inclusion_def by simp
        using step2_to_step step_to_step2
        by auto
      thus "\<exists>q'. ?weak_seq q A q'"
        by (simp add: subassms)
    qed
      using Rpq by auto
  next 
      by blast
      unfolding lts_tau.trace_inclusion_def
    proof clarify
      fix p q p' A
      assume subassms: 
        using step2_to_step step_to_step2
        by (metis (full_types) lts_tau.trace_inclusion_def weak_sim_R)
    qed
  qed
qed

end
