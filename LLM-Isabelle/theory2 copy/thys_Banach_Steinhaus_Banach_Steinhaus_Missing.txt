theory Banach_Steinhaus_Missing
  imports
    "HOL-Analysis.Bounded_Linear_Function"
    "HOL-Analysis.Line_Segment"

begin

bundle notation_norm begin
notation norm ("\<parallel>_\<parallel>")
end

bundle no_notation_norm begin
no_notation norm ("\<parallel>_\<parallel>")
end

unbundle notation_norm

bundle notation_blinfun_apply begin
notation blinfun_apply (infixr "*\<^sub>v" 70)
end

bundle no_notation_blinfun_apply begin
no_notation blinfun_apply (infixr "*\<^sub>v" 70)
end

unbundle notation_blinfun_apply

lemma bdd_above_plus:
proof-
  thus ?thesis unfolding bdd_above_def by blast
qed

definition pointwise_max:: "('a \<Rightarrow> 'b::ord) \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'b)" where

lemma max_Sup_absorb_left:


proof-
  proof-
      by blast
  qed
  proof-
      by blast
      for e::real
    ultimately show ?thesis
  qed
    using y_f_X by (metis (mono_tags) cSup_least calculation empty_is_image)  
  ultimately show ?thesis unfolding pointwise_max_def by simp
qed

lemma max_Sup_absorb_right:
proof-
    using  assms by (simp add: max_Sup_absorb_left)     
    unfolding pointwise_max_def  by auto
  ultimately show ?thesis by simp
qed

lemma max_Sup:
  case True thus ?thesis by (simp add: assms(1) assms(2) assms(3) max_Sup_absorb_left)
next
  case False 
  have f1: "\<not> 0 \<le> Sup (f ` X) + - 1 * Sup (g ` X)"
    using False by linarith
  hence "Sup (Banach_Steinhaus_Missing.pointwise_max f g ` X) = Sup (g ` X)"
    by (simp add: assms(1) assms(2) assms(3) max_Sup_absorb_right)
  thus ?thesis
    using f1 by linarith
qed


lemma identity_telescopic:
proof-
    by (simp add: add.commute)
    by simp 
    using tendsto_add_const_iff by metis 
    by simp
    by (simp add: sum_Suc_diff)
    by blast
    using f1 by simp
    by (simp add: add.commute)
    using Topological_Spaces.LIMSEQ_offset[where f = "(\<lambda> N. sum (\<lambda> k. x (Suc k) - x k) {n..N})" 
        and a = "l - x n" and k = n] by blast
    by simp
  thus ?thesis by blast
qed

lemma bound_Cauchy_to_lim:
proof-
    case True
      by auto
  next
    case False
      by auto
      by auto
      by (simp add: sum_norm_le)
      by (simp add: assms(2) sum_norm_le)
      by blast
  qed
    using tendsto_norm by blast
    using norm_1 Lim_bounded by blast
    by auto
    by (simp add: divide_inverse_commute)    
qed

lemma onorm_open_ball:
  includes notation_norm
  case True
    by auto
    by (metis (full_types) blinfun.zero_right)
    by (simp add: blinfun_eqI zero_blinfun.rep_eq)      
    by simp    
next
  case False
    by simp
    by simp
    by blast
    by auto
    unfolding y_def by auto
    by auto
    by blast
    by blast
    unfolding bdd_above_def apply auto
    by (metis norm_blinfun)
    by (metis (mono_tags, lifting) Collect_empty_eq_bot bot_empty_eq empty_iff norm_zero 
        zero_less_one)   
  proof-
    proof-
      obtain r :: "('a \<Rightarrow>\<^sub>L 'b) \<Rightarrow> real" where
        "\<And>f x. 0 \<le> r f \<and> (bounded_linear f \<longrightarrow> \<parallel>f *\<^sub>v x\<parallel> \<le> \<parallel>x\<parallel> * r f)"
        using bounded_linear.nonneg_bounded by moura
        by simp          
      hence "(\<exists>r. \<parallel>f\<parallel> * \<parallel>a r\<parallel> \<le> r) \<or> (\<exists>r. \<parallel>a r\<parallel> < 1 \<longrightarrow> \<parallel>f *\<^sub>v a r\<parallel> \<le> r)"
        by (meson less_eq_real_def mult_le_cancel_left2) 
      thus ?thesis using dual_order.trans norm_blinfun by blast
    qed
      by metis
    thus ?thesis by auto 
  qed
    by (smt Collect_empty_eq cSup_upper mem_Collect_eq nonnegative norm_1_bounded norm_1_non_empty)      
    by simp
    by simp
    case True
      by (simp add: True)
      by blast        
      using calculation norm_less_1_non_empty by fastforce                        
      by blast
      by simp
      by (simp add: True blinfun_eqI)        
      using Sup1 by blast
    ultimately show ?thesis by simp
  next
    case False
    proof-
        by blast
        by auto
      proof-
              abs_of_nonneg add_diff_cancel_left' add_eq_if cancel_comm_monoid_add_class.diff_cancel
              diff_ge_0_iff_ge eq_iff_diff_eq_0 inverse_1 inverse_le_iff_le nat.distinct(1) of_nat_0
              of_nat_Suc of_nat_le_0_iff zero_less_abs_iff zero_neq_one)
          by (simp add: blinfun.scaleR_right)            
          by blast
          by (simp add: linordered_field_class.inverse_le_1_iff)                
        thus ?thesis using y'_1 by blast 
      qed
        using Limits.LIMSEQ_inverse_real_of_nat_add_minus by simp
        using Limits.tendsto_scaleR by blast
        by simp
        using y'_def by simp
        by simp
      thus ?thesis by blast
    qed
      by (metis (lifting) cSup_least norm_1_non_empty)
      case True thus ?thesis by (simp add: Sup_non_neg) 
    next
      case False
        by blast
        by blast
        by simp
        by simp
        by (simp add: blinfun.scaleR_right)          
        by blast
        by simp
        by simp
        by (simp add: cSup_upper norm_1_bounded)
      ultimately show ?thesis by linarith 
    qed
      by (smt cSup_least norm_less_1_non_empty) 
      by (simp add: full_SetCompr_eq)
      for y
    proof-
        case True  thus ?thesis by simp 
      next
        case False
          by blast
          by simp
          by simp
          by (simp add: blinfun.scaleR_right)            
          by blast
        thus ?thesis by blast
      qed
    qed
      for y
      case True thus ?thesis by auto 
    next
      case False
        by simp
        by simp
        by auto
        by simp 
      thus ?thesis by auto 
    qed
      by blast
      by simp
    have "\<And>r s. \<not> (r::real) \<le> s \<or> sup r s = s"
      by (metis (lifting) sup.absorb_iff1 sup_commute)
        cSup_union_distrib max.absorb_iff1 sup_commute norm_1_bounded norm_1_non_empty
      by (metis (no_types, lifting) )
      by simp          
      using Sup_non_neg by linarith
      by auto           
      using f1 f2 by linarith
    thus ?thesis apply transfer by (simp add: onorm_def) 
  qed      
qed

lemma onorm_r:
  includes notation_norm
proof-
    using onorm_open_ball by blast
    unfolding ball_def by auto
    by simp
  proof-
      by auto
      by blast
      by linarith
      by auto
          inverse_inverse_eq pos_le_divideR_eq positive_imp_inverse_positive) 
      by blast
      by simp        
      by (simp add: bounded_linear_image blinfun.bounded_linear_right bounded_imp_bdd_above 
          bounded_norm_comp) 
      using y_norm_f by blast
    ultimately show ?thesis
  qed
  proof-
    proof-
        by auto
    qed
      by simp        
      by (simp add: bounded_linear_image blinfun.bounded_linear_right bounded_imp_bdd_above 
          bounded_norm_comp) 
      by (smt divide_strict_right_mono nonzero_mult_div_cancel_left)  
  qed
    by auto
    by (simp add: blinfun.scaleR_right)    
    by (smt assms ball_scale nonzero_mult_div_cancel_left right_inverse_eq scale_zero_right)
    by simp
    using Sup.SUP_image by auto
    using f_x1 by (simp add: comp_assoc) 
    using norm_scaleR f_x1 by auto 
    apply (rule cSup_eq_non_empty) apply simp using s2 apply auto using s3 by auto
    using onorm_f by auto
    by blast    
qed

definition pointwise_convergent_to :: 

lemma linear_limit_linear:
proof
  show "F (x + y) = F x + F y" for x y
  proof-
    have "\<forall>a. F a = lim (\<lambda>n. f n a)"
    moreover have "\<forall>f b c g. (lim (\<lambda>n. g n + f n) = (b::'b) + c \<or> \<not> f \<longlonglongrightarrow> c) \<or> \<not> g \<longlonglongrightarrow> b"
      by (metis (no_types) limI tendsto_add)
    moreover have "\<And>a. (\<lambda>n. f n a) \<longlonglongrightarrow> F a"
      using assms(2) pointwise_convergent_to_def by force
    ultimately have 
      by metis
      by auto
      by simp
      using lim_sum by simp
    ultimately show ?thesis
      by (metis limI) 
  qed
  show "F (r *\<^sub>R x) = r *\<^sub>R F x" for r and x
  proof-
      by (simp add: Real_Vector_Spaces.linear_def real_vector.linear_scale)
      by simp
      by (metis assms(2) convergentI pointwise_convergent_to_def)
      by (simp add: bounded_linear_scaleR_right)
      by (metis (mono_tags) isCont_tendsto_compose limI)
    ultimately show ?thesis
      by (metis limI) 
  qed
qed


lemma non_Cauchy_unbounded:
proof-
  proof(induction k)
    case 0
      by simp
      by simp
      by simp
      by simp
      by (metis sum.union_disjoint) 
      by (simp add: assms(1) sum_nonneg)
      by linarith      
      unfolding S_def by blast
      using ereal_less_eq(5) by fastforce    
    thus ?case
      by (simp add: zero_ereal_def)  
  next
    case (Suc k)
      by blast
      by blast
      by blast
      by simp
      by simp
      using Set_Interval.ivl_disj_un
      by simp
      by (metis sum.union_disjoint)
      by simp
      by simp
      by simp
      by (simp add: semiring_normalization_rules(3))
      by linarith
      by auto
      unfolding S_def by blast
    ultimately show ?case by blast
  qed
    by (meson assms(2) ereal_le_le ex_less_of_nat_mult less_le_not_le)
    using Sup_le_iff Sup_subset_mono dual_order.strict_trans1 leD less_PInf_Ex_of_nat subsetI 
    by metis
    by blast
    by (meson incseq_Suc_iff)
    using incseq_ereal by (simp add: atLeast0AtMost lessThan_Suc_atMost) 
    using LIMSEQ_SUP by auto
  thus ?thesis using Sup PInfty_neq_ereal by auto 
qed

lemma sum_Cauchy_positive:
proof (unfold Cauchy_altdef2, rule, rule)
  fix e::real
  proof(rule classical)
      by blast
      by fastforce
      by blast
      using Lim_PInfty by simp
      using ereal_less_eq(3) by blast        
  qed
    if "m > n" for m n
    apply (simp add: that atLeast0AtMost) using sum_up_index_split 
    by (smt less_imp_add_positive that)
    by blast
    by auto
        less_irrefl_nat linorder_neqE_nat zero_less_diff)      
    by (metis abs_minus_commute nat_le_linear)
    by (simp add: dist_real_def)      
qed

lemma convergent_series_Cauchy:
