theory Countermodel
  imports Hintikka Usemantics ProverLemmas
begin


abbreviation (input)

abbreviation

abbreviation

  case).\<close>
lemma terms_ne [simp]: \<open>terms S \<noteq> {}\<close>
text \<open>If a term is in the set of terms, it is either the default term or a subterm of some formula
  in the set.\<close>
lemma terms_cases: \<open>t \<in> terms S \<Longrightarrow> t = Fun 0 [] \<or> (\<exists>p \<in> S. t \<in> set (subtermFm p))\<close>
text \<open>The set of terms is downwards closed under the subterm function.\<close>
lemma terms_downwards_closed: \<open>t \<in> terms S \<Longrightarrow> set (subtermTm t) \<subseteq> terms S\<close>
  moreover have \<open>\<forall>t \<in> set ts. t \<in> set ts\<close>
  moreover have \<open>\<forall>t \<in> set ts. t \<in> terms S\<close>
    assume *: \<open>t \<in> set ts\<close>
    then show \<open>t \<in> terms S\<close>
    proof (cases \<open>terms S = {Fun 0 []}\<close>)
      moreover obtain p where p: \<open>p \<in> S\<close> \<open>Fun n ts \<in> set (subtermFm p)\<close>
      then have \<open>set ts \<subseteq> set (subtermFm p)\<close>
      ultimately show \<open>t \<in> terms S\<close>
  ultimately have \<open>\<forall>t \<in> set ts. set (subtermTm t) \<subseteq> terms S\<close>
  moreover note \<open>Fun n ts \<in> terms S\<close>
text \<open>If terms are actually in a set of formulas, interpreting the environment over these formulas
allows for a Herbrand interpretation.\<close>
    \<open>t \<in> terms S \<Longrightarrow> semantics_term (E S) (F S) t = t\<close>
    \<open>list_all (\<lambda>t. t \<in> terms S) ts \<Longrightarrow> semantics_list (E S) (F S) ts = ts\<close>
  moreover have \<open>\<forall>t' \<in> set ts'. t' \<in> set (subtermTm (Fun i ts'))\<close>
  ultimately have \<open>list_all (\<lambda>t. t \<in> terms S) ts'\<close>
text \<open>Our alternate interpretation of environments is well-formed for the terms function.\<close>
  \<open>is_env (terms S) (E S)\<close>
  show \<open>E S n \<in> terms S\<close>
    by (cases \<open>Var n \<in> terms S\<close>) (simp_all add: some_in_eq)
text \<open>Our alternate function interpretation is well-formed for the terms function.\<close>
  \<open>is_fdenot (terms S) (F S)\<close>
  assume \<open>list_all (\<lambda>x. x \<in> terms S) l\<close>
  then show \<open>F S i l \<in> terms S\<close>
    by (cases \<open>\<forall>n. Var n \<in> terms S\<close>) (simp_all add: some_in_eq)
  \<open>M S \<equiv> usemantics (terms S) (E S) (F S) (G S)\<close>
text \<open>If S is a Hintikka set, then we can construct a countermodel for any formula using our
  bounded semantics and a Herbrand interpretation.\<close>
  assumes \<open>Hintikka S\<close>
  shows \<open>(p \<in> S \<longrightarrow> \<not> M S p) \<and> (Neg p \<in> S \<longrightarrow> M S p)\<close>
proof (induct p rule: wf_induct [where r=\<open>measure size\<close>])
  assume wf: \<open>\<forall>q. (q, x) \<in> measure size \<longrightarrow>
    (q \<in> S \<longrightarrow> \<not> M S q) \<and> (Neg q \<in> S \<longrightarrow> M S q)\<close>
  show \<open>(x \<in> S \<longrightarrow> \<not> M S x) \<and> (Neg x \<in> S \<longrightarrow> M S x)\<close>
      assume \<open>x \<in> S\<close>
      then have \<open>Neg (Pre n ts) \<notin> S\<close>
      moreover have \<open>list_all (\<lambda>t. t \<in> terms S) ts\<close>
        using \<open>x \<in> S\<close> Pre subterm_Pre_refl unfolding terms_def list_all_def by force
      ultimately show \<open>\<not> M S x\<close>
      assume \<open>Neg x \<in> S\<close>
      then have \<open>G S n ts\<close>
      moreover have \<open>list_all (\<lambda>t. t \<in> terms S) ts\<close>
        using \<open>Neg x \<in> S\<close> Pre subterm_Pre_refl unfolding terms_def list_all_def by force
      ultimately show \<open>M S x\<close>
      assume \<open>x \<in> S\<close>
      then have \<open>Neg p \<in> S\<close> \<open>q \<in> S\<close>
      then show \<open>\<not> M S x\<close>
      assume \<open>Neg x \<in> S\<close>
      then have \<open>p \<in> S \<or> Neg q \<in> S\<close>
      then show \<open>M S x\<close>
      assume \<open>x \<in> S\<close>
      then have \<open>p \<in> S\<close> \<open>q \<in> S\<close>
      then show \<open>\<not> M S x\<close>
      assume \<open>Neg x \<in> S\<close>
      then have \<open>Neg p \<in> S \<or> Neg q \<in> S\<close>
      then show \<open>M S x\<close>
      assume \<open>x \<in> S\<close>
      then have \<open>p \<in> S \<or> q \<in> S\<close>
      then show \<open>\<not> M S x\<close>
      assume \<open>Neg x \<in> S\<close>
      then have \<open>Neg p \<in> S\<close> \<open>Neg q \<in> S\<close>
      then show \<open>M S x\<close>
      assume \<open>x \<in> S\<close>
      then have \<open>\<forall>t \<in> terms S. sub 0 t p \<in> S\<close>
      then have \<open>\<forall>t \<in> terms S. \<not> M S (sub 0 t p)\<close>
      moreover have \<open>\<forall>t \<in> terms S. semantics_term (E S) (F S) t = t\<close>
      ultimately have \<open>\<forall>t \<in> terms S. \<not> usemantics (terms S) (SeCaV.shift (E S) 0 t) (F S) (G S) p\<close>
      then show \<open>\<not> M S x\<close>
      assume \<open>Neg x \<in> S\<close>
      then obtain t where \<open>t \<in> terms S\<close> \<open>Neg (sub 0 t p) \<in> S\<close>
      then have \<open>M S (sub 0 t p)\<close>
      moreover have \<open>semantics_term (E S) (F S) t = t\<close>
        using \<open>t \<in> terms S\<close> usemantics_E(1) terms_downwards_closed unfolding list_all_def by blast
      ultimately show \<open>M S x\<close>
        using Exi \<open>t \<in> terms S\<close> by auto
      assume \<open>x \<in> S\<close>
      then obtain t where \<open>t \<in> terms S\<close> \<open>sub 0 t p \<in> S\<close>
      then have \<open>\<not> M S (sub 0 t p)\<close>
      moreover have \<open>semantics_term (E S) (F S) t = t\<close>
        using \<open>t \<in> terms S\<close> usemantics_E(1) terms_downwards_closed unfolding list_all_def by blast
      ultimately show \<open>\<not> M S x\<close>
        using Uni \<open>t \<in> terms S\<close> by auto
      assume \<open>Neg x \<in> S\<close>
      then have \<open>\<forall>t \<in> terms S. Neg (sub 0 t p) \<in> S\<close>
      then have \<open>\<forall>t \<in> terms S. M S (sub 0 t p)\<close>
      moreover have \<open>\<forall>t \<in> terms S. semantics_term (E S) (F S) t = t\<close>
      ultimately have \<open>\<forall>t \<in> terms S. \<not> usemantics (terms S) (SeCaV.shift (E S) 0 t) (F S) (G S) (Neg p)\<close>
      then show \<open>M S x\<close>
      assume \<open>x \<in> S\<close>
      then show \<open>\<not> M S x\<close>
      assume \<open>Neg x \<in> S\<close>
      then have \<open>p \<in> S\<close>
      then show \<open>M S x\<close>
