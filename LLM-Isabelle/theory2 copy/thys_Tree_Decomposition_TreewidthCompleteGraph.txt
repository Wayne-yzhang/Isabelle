theory TreewidthCompleteGraph
imports TreeDecomposition begin

  (a clique) has treewidth @{term "(n::nat)-1"}.\<close>
    text \<open>Let @{term s} be a bag of maximal size.\<close>
      using max_bag_card_in_bag_cards \<open>V \<noteq> {}\<close> by fastforce
    text \<open>The treewidth cannot be larger than @{term "card V - 1"}, so due to our assumption
      @{term "width \<noteq> card V - 1" } it must be smaller, hence @{term "card (bag s) < card V"}.\<close>
      using \<open>V \<noteq> {}\<close> empty_tree_empty_V le_eq_less_or_eq max_bag_card_upper_bound_V by presburger
    text \<open>There exists a bag containing @{term v}.  We consider the path from @{term s} to
      @{term t} and find that somewhere along this path there exists a bag containing
      @{term "insert v (bag s)"}, which is a contradiction because such a bag would be too big.\<close>
        text \<open>Bags can never drop vertices because every vertex has a neighbor in @{term G} which
          has not yet been visited.\<close>
            using bag_no_drop Cons.prems(1,4) \<open>v \<notin> bag s\<close> assms bags_in_V v(1) by blast
        text \<open>Bags can never gain vertices because we started with a bag of maximal size.\<close>
            using Max_ge \<open>s' \<in> V\<^bsub>T\<^esub>\<close> bag_cards_finite by blast
        ultimately have "bag s' = bag s" using \<open>s' \<in> V\<^bsub>T\<^esub>\<close> bag_finite card_seteq by blast
          using Cons.hyps Cons.prems(1,2) \<open>s' \<in> V\<^bsub>T\<^esub>\<close> t s' st_path \<open>xs \<noteq> []\<close>
