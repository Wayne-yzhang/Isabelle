theory Sepref_Tool
imports Sepref_Translate Sepref_Definition Sepref_Combinator_Setup Sepref_Intf_Util
begin




lemma CONS_init: 
  assumes "hn_refine \<Gamma> c \<Gamma>' R a"
  assumes "\<Gamma>' \<Longrightarrow>\<^sub>t \<Gamma>c'"
  assumes "\<And>a c. hn_ctxt R a c \<Longrightarrow>\<^sub>t hn_ctxt Rc a c"
  shows "hn_refine \<Gamma> c \<Gamma>c' Rc a"
  apply (rule hn_refine_cons)
  apply (rule entt_refl)
  apply (rule assms[unfolded hn_ctxt_def])+
  done

lemma ID_init: "\<lbrakk>ID a a' TYPE('T); hn_refine \<Gamma> c \<Gamma>' R a'\<rbrakk> 
  \<Longrightarrow> hn_refine \<Gamma> c \<Gamma>' R a" by simp

lemma TRANS_init: "\<lbrakk> hn_refine \<Gamma> c \<Gamma>' R a; CNV c c' \<rbrakk> 
  \<Longrightarrow> hn_refine \<Gamma> c' \<Gamma>' R a"
  by simp

lemma infer_post_triv: "P \<Longrightarrow>\<^sub>t P" by (rule entt_refl)


setup Sepref.setup



lemma return_bind_eq_let: "do { x\<leftarrow>return v; f x } = do { let x=v; f x }" by simp
lemmas [sepref_opt_simps] = return_bind_eq_let bind_return bind_bind id_def

lemmas [sepref_opt_simps] = Autoref_Tagging.APP_def


lemma case_prod_return_opt[sepref_opt_simps]:
  "case_prod (\<lambda>a b. return (f a b)) p = return (case_prod f p)"
  by (simp split: prod.split)

lemma case_option_return_opt[sepref_opt_simps]:
  "case_option (return fn) (\<lambda>s. return (fs s)) v = return (case_option fn fs v)"
  by (simp split: option.split)

lemma case_list_return[sepref_opt_simps]:
  "case_list (return fn) (\<lambda>x xs. return (fc x xs)) l = return (case_list fn fc l)"
  by (simp split: list.split)

lemma if_return[sepref_opt_simps]:
  "If b (return t) (return e) = return (If b t e)" by simp

lemma case_prod_opt2[sepref_opt_simps2]:
  "(\<lambda>x. return (case x of (a,b) \<Rightarrow> f a b)) 
  = (\<lambda>(a,b). return (f a b))"
  by auto





















