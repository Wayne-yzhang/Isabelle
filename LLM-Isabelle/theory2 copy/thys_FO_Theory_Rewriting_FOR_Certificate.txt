theory FOR_Certificate
  imports Rewriting
begin



definition map_ftrs where
  "map_ftrs f = case_ftrs (Fwd \<circ> f) (Bwd \<circ> f)"




definition GSteps where "GSteps trss = GTrancl (ARoot trss)"






  "R1Fin r = R1Diff R1Terms (R1Inf r)"
  "R2Eq = R2Diag R1Terms"
  "R2Reflc r = R2Union r R2Eq"
  "R2Step trss = R2GTT_Rel (ARoot trss) PAny ESingle"
  "R2StepEq trss = R2Reflc (R2Step trss)"
  "R2Steps trss = R2GTT_Rel (GSteps trss) PAny EStrictParallel"
  "R2StepsEq trss = R2GTT_Rel (GSteps trss) PAny EParallel"
  "R2StepsNF trss = R2Inter (R2StepsEq trss) (R2Prod R1Terms (R1NF trss))"
  "R2ParStep trss = R2GTT_Rel (ARoot trss) PAny EParallel"
  "R2RootStep trss = R2GTT_Rel (ARoot trss) PRoot ESingle"
  "R2RootStepEq trss = R2Reflc (R2RootStep trss)"
  "R2RootSteps trss = R2GTT_Rel (ATrancl (ARoot trss)) PRoot ESingle"
  "R2RootStepsEq trss = R2Reflc (R2RootSteps trss)"
  "R2NonRootStep trss = R2GTT_Rel (ARoot trss) PNonRoot ESingle"
  "R2NonRootStepEq trss = R2Reflc (R2NonRootStep trss)"
  "R2NonRootSteps trss = R2GTT_Rel (GSteps trss) PNonRoot EStrictParallel"
  "R2NonRootStepsEq trss = R2GTT_Rel (GSteps trss) PNonRoot EParallel"
  "R2Meet trss = R2GTT_Rel (GComp (GInv (GSteps trss)) (GSteps trss)) PAny EParallel"
  "R2Join trss = R2GTT_Rel (GComp (GSteps trss) (GInv (GSteps trss))) PAny EParallel"




  "FTrue \<equiv> FAnd []"
  "FFalse \<equiv> FOr []"
  "FRestrict f trss \<equiv> map_formula (map_ftrs (\<lambda>n. if n \<ge> length trss then 0 else trss ! n)) f"



datatype ('f, 'v, 't) many_sorted_sig
  = Many_Sorted_Sig (ms_functions: "('f \<times> 't list \<times> 't) list") (ms_variables: "('v \<times> 't) list")

datatype ('f, 'v, 't) problem
  = Problem (p_signature: "('f, 'v, 't) many_sorted_sig")
            (p_trss: "('f, 'v) trs list")
            (p_formula: "ftrs formula")





datatype claim = Empty | Nonempty

datatype info = Size nat nat nat

datatype 'trs certificate
  = Certificate "(nat \<times> 'trs inference \<times> 'trs formula \<times> info list) list" claim nat



definition no_normal_forms_cert :: "ftrs certificate" where
  "no_normal_forms_cert = Certificate
  [ (0, (IRR2 (R2Step [Fwd 0]) 1 0),
        (FRR2 (R2Step [Fwd 0]) 1 0), [])
  , (1, (IExists 0),
        (FExists (FRR2 (R2Step [Fwd 0]) 1 0)), [])
  , (2, (INot 1),
        (FNot (FExists (FRR2 (R2Step [Fwd 0]) 1 0))), [])
  , (3, (IExists 2),
        (FExists (FNot (FExists (FRR2 (R2Step [Fwd 0]) 1 0)))), [])
  , (4, (INot 3),
        (FNot (FExists (FNot (FExists (FRR2 (R2Step [Fwd 0]) 1 0))))), [])
  , (5, (INNFPlus 4),
        (FForall (FExists (FRR2 (R2Step [Fwd 0]) 1 0))), [])
  ] Nonempty 5"

definition no_normal_forms_problem :: "(string, string, unit) problem" where
  "no_normal_forms_problem = Problem
    (Many_Sorted_Sig [(''f'',[()],()), (''a'',[],())] [(''x'',())])
    [{(Fun ''f'' [Var ''x''],Fun ''a'' [])}]
    (FForall (FExists (FRR2 (R2Step [Fwd 0]) 1 0)))"

end